###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         04/Feb/2022  12:58:44
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Drivers\module_err_logHandle.c
#    Command line                 =
#        -f C:\Users\610126~1\AppData\Local\Temp\EWD97B.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Drivers\module_err_logHandle.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale                       =  C
#    List file                    =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\module_err_logHandle.lst
#    Object file                  =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\module_err_logHandle.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Drivers\module_err_logHandle.c
      1          /**
      2          ********************************************************************************************************************************
      3          * @file    module_err_logHandle.c 
      4          * @author  Pamela Lee
      5          * @version V1.0
      6          * @date    28-OCT-2020
      7          * @brief   Kernal module for error or log handling.
      8          * @details All module/s can report their Error or log by either software interrupt(in urgent message) or by structured_memory(for normal data log), 
      9          *          this module will response according to the type of the message, which may either store it in the EEprom as error/data log or just 
     10          *          increase as the relatived counter/s.
     11          *     parameters:-
     12          *          ErrorModule ID(SENDER_MODULE_ID):  Module ID for error occur                    
     13          *          ErrorMesage Type(irqType_u8):      0xE0 = AutoAck-TimeOut, 
     14          *                                             0xE1 = Heap-Memory allocation Error, 
     15          *                                             0xE2 = Module execution exceed time limit error,
     16          *                                             0xE3 = IRQ response execution exceed time limit error,
     17          *                                             0xE4 = Flash Error 
     18          *                                             0xEF = for debug tetsing 
     19          *          Further Detials(irqDatXX):         All the details will send through the various irqDatxx as data, may need to decode in different way (see the particular routine for details)
     20          ********************************************************************************************************************************
     21          */
     22          
     23          /* Includes --------------------------------------------------------------------------------------------------------------------*/
     24          #include "module_err_logHandle.h"

   \                                 In section .bss, align 4
   \   static __absolute Ram_Buf * Err_logHandlingStructMem_u32
   \                     Err_logHandlingStructMem_u32:
   \        0x0                      DS8 4
     25          
     26          //#include "driver_usart2.h"
     27          
     28          /* Content ---------------------------------------------------------------------------------------------------------------------*/
     29          /* Auto acknowledgement handle declaration */
     30          extern ProcessInfo processInfoTable[];
     31          
     32          void AssignModuleMemErrLogHandle(void);
     33          

   \                                 In section .bss, align 4
     34          Err_logHandling_Control* err_logHandling_Control;
   \                     err_logHandling_Control:
   \        0x0                      DS8 4
     35          
     36          #define Err_logTimePeriod 5000                        //Err_log Handling waiting period

   \                                 In section .bss, align 8
     37          uint64_t Err_log_WaitTime; 
   \                     Err_log_WaitTime:
   \        0x0                      DS8 8

   \                                 In section .bss, align 8
     38          uint64_t testDat = 0;                           
   \                     testDat:
   \        0x0                      DS8 8
     39          
     40          enum {
     41            MEMORY_INIT_MODULE,
     42            INIT_MODULE,
     43            RUN_MODULE,
     44            // additional states to be added here as necessary.
     45            IRQ_MODULE = DEFAULT_IRQ_STATE,
     46            KILL_MODULE = KILL_APP
     47          };
     48          

   \                                 In section .text, align 2, keep-with-next
     49          uint8_t moduleErrorLog_u32(uint8_t drv_id_u8, uint8_t prev_state_u8, uint8_t next_state_u8, uint8_t irq_id_u8) {
   \                     moduleErrorLog_u32: (+1)
   \        0x0   0xB5FB             PUSH     {R0,R1,R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0017             MOVS     R7,R2
     50            uint8_t return_state_u8 = MEMORY_INIT_MODULE;
   \        0x6   0x2600             MOVS     R6,#+0
     51            switch (next_state_u8) {
   \        0x8   0x0038             MOVS     R0,R7
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD008             BEQ      ??moduleErrorLog_u32_0
   \       0x10   0x2801             CMP      R0,#+1
   \       0x12   0xD00A             BEQ      ??moduleErrorLog_u32_1
   \       0x14   0x2802             CMP      R0,#+2
   \       0x16   0xD015             BEQ      ??moduleErrorLog_u32_2
   \       0x18   0x28C8             CMP      R0,#+200
   \       0x1A   0xD02B             BEQ      ??moduleErrorLog_u32_3
   \       0x1C   0x28FF             CMP      R0,#+255
   \       0x1E   0xD033             BEQ      ??moduleErrorLog_u32_4
   \       0x20   0xE045             B        ??moduleErrorLog_u32_5
     52            case MEMORY_INIT_MODULE:
     53              {
     54                AssignModuleMemErrLogHandle(); // Assign structured memory
   \                     ??moduleErrorLog_u32_0: (+1)
   \       0x22   0x....'....        BL       AssignModuleMemErrLogHandle
     55                return_state_u8 = INIT_MODULE;
   \       0x26   0x2001             MOVS     R0,#+1
     56                break;
   \       0x28   0xE042             B        ??moduleErrorLog_u32_6
     57              }
     58            case INIT_MODULE: 
     59              {
     60                //AssignModuleMemErrLogHandle(); // Assign structured memory
     61                ////Err_logHandlingStructMem_u32 = StructMem_CreateInstance(MODULE_ERR_LOGHANDLE, sizeof(Err_logHandling_Control), ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a structured memory
     62                ////err_logHandling_Control = (Err_logHandling_Control*)(*Err_logHandlingStructMem_u32).p_ramBuf_u8;
     63                //      (*err_logHandling_Control)
     64                Err_log_WaitTime = getSysCount() + Err_logTimePeriod;                        //store time tick value  
   \                     ??moduleErrorLog_u32_1: (+1)
   \       0x2A   0x....'....        BL       getSysCount
   \       0x2E   0x0002             MOVS     R2,R0
   \       0x30   0x000B             MOVS     R3,R1
   \       0x32   0x....             LDR      R0,??DataTable1  ;; 0x1388
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x1880             ADDS     R0,R0,R2
   \       0x38   0x4159             ADCS     R1,R1,R3
   \       0x3A   0x....             LDR      R2,??DataTable1_1
   \       0x3C   0xC203             STM      R2!,{R0,R1}
   \       0x3E   0x3A08             SUBS     R2,R2,#+8
     65                return_state_u8 = RUN_MODULE;
   \       0x40   0x2002             MOVS     R0,#+2
     66                break;
   \       0x42   0xE035             B        ??moduleErrorLog_u32_6
     67              }
     68            case RUN_MODULE: 
     69              {                                                  //        
     70                if (getSysCount() >= Err_log_WaitTime) 
   \                     ??moduleErrorLog_u32_2: (+1)
   \       0x44   0x....'....        BL       getSysCount
   \       0x48   0x0002             MOVS     R2,R0
   \       0x4A   0x000B             MOVS     R3,R1
   \       0x4C   0x....             LDR      R5,??DataTable1_1
   \       0x4E   0xCD03             LDM      R5!,{R0,R1}
   \       0x50   0x3D08             SUBS     R5,R5,#+8
   \       0x52   0x428B             CMP      R3,R1
   \       0x54   0xD30C             BCC      ??moduleErrorLog_u32_7
   \       0x56   0xD801             BHI      ??moduleErrorLog_u32_8
   \       0x58   0x4282             CMP      R2,R0
   \       0x5A   0xD309             BCC      ??moduleErrorLog_u32_7
     71                {
     72                  
     73                  Err_log_WaitTime = getSysCount() + Err_logTimePeriod;                        //store time tick value  
   \                     ??moduleErrorLog_u32_8: (+1)
   \       0x5C   0x....'....        BL       getSysCount
   \       0x60   0x0002             MOVS     R2,R0
   \       0x62   0x000B             MOVS     R3,R1
   \       0x64   0x....             LDR      R0,??DataTable1  ;; 0x1388
   \       0x66   0x2100             MOVS     R1,#+0
   \       0x68   0x1880             ADDS     R0,R0,R2
   \       0x6A   0x4159             ADCS     R1,R1,R3
   \       0x6C   0xC503             STM      R5!,{R0,R1}
   \       0x6E   0x3D08             SUBS     R5,R5,#+8
     74                }
     75                return_state_u8 = RUN_MODULE;
   \                     ??moduleErrorLog_u32_7: (+1)
   \       0x70   0x2002             MOVS     R0,#+2
     76                break;
   \       0x72   0xE01D             B        ??moduleErrorLog_u32_6
     77              }
     78            case IRQ_MODULE: 
     79              {
     80                testDat++;
   \                     ??moduleErrorLog_u32_3: (+1)
   \       0x74   0x....             LDR      R3,??DataTable1_2
   \       0x76   0xCB03             LDM      R3!,{R0,R1}
   \       0x78   0x3B08             SUBS     R3,R3,#+8
   \       0x7A   0x2200             MOVS     R2,#+0
   \       0x7C   0x1C40             ADDS     R0,R0,#+1
   \       0x7E   0x4151             ADCS     R1,R1,R2
   \       0x80   0xC303             STM      R3!,{R0,R1}
   \       0x82   0x3B08             SUBS     R3,R3,#+8
     81                return_state_u8 = RUN_MODULE;
   \       0x84   0x2002             MOVS     R0,#+2
     82                break;
   \       0x86   0xE013             B        ??moduleErrorLog_u32_6
     83              }
     84            case KILL_MODULE: 
     85              {
     86                // The USART2 driver module must only be executed once.
     87                // Setting processStatus_u8 to PROCESS_STATUS_KILLED prevents the scheduler main loop from calling this module again.
     88                uint8_t table_index_u8 = getProcessInfoIndex(drv_id_u8);
   \                     ??moduleErrorLog_u32_4: (+1)
   \       0x88   0x0020             MOVS     R0,R4
   \       0x8A   0xB2C0             UXTB     R0,R0
   \       0x8C   0x....'....        BL       getProcessInfoIndex
   \       0x90   0x0001             MOVS     R1,R0
     89                if (table_index_u8 != INDEX_NOT_FOUND) {
   \       0x92   0x0008             MOVS     R0,R1
   \       0x94   0xB2C0             UXTB     R0,R0
   \       0x96   0x28FF             CMP      R0,#+255
   \       0x98   0xD007             BEQ      ??moduleErrorLog_u32_9
     90                  processInfoTable[table_index_u8].Sched_DrvData.processStatus_u8 = PROCESS_STATUS_KILLED;
   \       0x9A   0x20FF             MOVS     R0,#+255
   \       0x9C   0x....             LDR      R2,??DataTable1_3
   \       0x9E   0x000B             MOVS     R3,R1
   \       0xA0   0xB2DB             UXTB     R3,R3
   \       0xA2   0x2516             MOVS     R5,#+22
   \       0xA4   0x436B             MULS     R3,R5,R3
   \       0xA6   0x18D2             ADDS     R2,R2,R3
   \       0xA8   0x7290             STRB     R0,[R2, #+10]
     91                }
     92                return_state_u8 = KILL_MODULE;
   \                     ??moduleErrorLog_u32_9: (+1)
   \       0xAA   0x20FF             MOVS     R0,#+255
     93                break;
   \       0xAC   0xE000             B        ??moduleErrorLog_u32_6
     94              }
     95            default: 
     96              {
     97                return_state_u8 = KILL_MODULE;
   \                     ??moduleErrorLog_u32_5: (+1)
   \       0xAE   0x20FF             MOVS     R0,#+255
     98                break;
     99              }
    100            }
    101            return return_state_u8;
   \                     ??moduleErrorLog_u32_6: (+1)
   \       0xB0   0xB2C0             UXTB     R0,R0
   \       0xB2   0xBDFE             POP      {R1-R7,PC}       ;; return
    102          }
    103          

   \                                 In section .text, align 2, keep-with-next
    104          void AssignModuleMemErrLogHandle(void)
    105          {
   \                     AssignModuleMemErrLogHandle: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    106            Err_logHandlingStructMem_u32 =  StructMem_CreateInstance(MODULE_ERR_LOGHANDLE, sizeof(Err_logHandling_Control), ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);
   \        0x2   0x....             LDR      R4,??DataTable1_4
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x2202             MOVS     R2,#+2
   \        0xC   0x2110             MOVS     R1,#+16
   \        0xE   0x200F             MOVS     R0,#+15
   \       0x10   0x....'....        BL       StructMem_CreateInstance
   \       0x14   0x6020             STR      R0,[R4, #+0]
    107            (*Err_logHandlingStructMem_u32).p_ramBuf_u8 = (uint8_t *)&err_logHandling_Control ;    //map the ADC1 memory into the structured memory
   \       0x16   0x....             LDR      R0,??DataTable1_5
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6008             STR      R0,[R1, #+0]
    108            uint8_t Drv_Index = getProcessInfoIndex(MODULE_ERR_LOGHANDLE);
   \       0x1C   0x200F             MOVS     R0,#+15
   \       0x1E   0x....'....        BL       getProcessInfoIndex
   \       0x22   0x0005             MOVS     R5,R0
    109            processInfoTable[Drv_Index].Sched_DrvData.p_masterSharedMem_u32 = Err_logHandlingStructMem_u32; 
   \       0x24   0x....             LDR      R0,??DataTable1_3
   \       0x26   0x0029             MOVS     R1,R5
   \       0x28   0xB2C9             UXTB     R1,R1
   \       0x2A   0x2216             MOVS     R2,#+22
   \       0x2C   0x4351             MULS     R1,R2,R1
   \       0x2E   0x1840             ADDS     R0,R0,R1
   \       0x30   0x0001             MOVS     R1,R0
   \       0x32   0x310B             ADDS     R1,R1,#+11
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x....'....        BL       __aeabi_uwrite4
    110            
    111            //Err_logHandlingStructMem_u32 = StructMem_CreateInstance(MODULE_ERR_LOGHANDLE, sizeof(Err_logHandling_Control), ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a structured memory
    112            //err_logHandling_Control = (Err_logHandling_Control*)(*Err_logHandlingStructMem_u32).p_ramBuf_u8;
    113          }
   \       0x3A   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x0000'1388        DC32     0x1388

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \        0x0   0x....'....        DC32     Err_log_WaitTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \        0x0   0x....'....        DC32     testDat

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \        0x0   0x....'....        DC32     processInfoTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \        0x0   0x....'....        DC32     Err_logHandlingStructMem_u32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \        0x0   0x....'....        DC32     err_logHandling_Control

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   AssignModuleMemErrLogHandle
        16   -> StructMem_CreateInstance
        16   -> getProcessInfoIndex
        16 __aeabi_uwrite4
      32   moduleErrorLog_u32
        32   -> AssignModuleMemErrLogHandle
        32   -> getProcessInfoIndex
        32   -> getSysCount


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
      60  AssignModuleMemErrLogHandle
       4  Err_logHandlingStructMem_u32
       8  Err_log_WaitTime
       4  err_logHandling_Control
     180  moduleErrorLog_u32
       8  testDat

 
  24 bytes in section .bss
 264 bytes in section .text
 
 264 bytes of CODE memory
  24 bytes of DATA memory

Errors: none
Warnings: none

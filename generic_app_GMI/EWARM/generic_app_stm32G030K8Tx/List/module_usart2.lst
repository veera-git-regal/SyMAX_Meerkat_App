###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         09/Feb/2022  16:09:35
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Drivers\module_usart2.c
#    Command line                 =
#        -f C:\Users\610126~1\AppData\Local\Temp\EWD284.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Drivers\module_usart2.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale                       =  C
#    List file                    =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\module_usart2.lst
#    Object file                  =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\module_usart2.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Drivers\module_usart2.c
      1          /**
      2          ********************************************************************************************************************************
      3          * @file    module_usart2.c 
      4          * @author  Pamela Lee
      5          * @brief   Main driver module for USART2 Communication.
      6          * @details This module initializes the USART2 port and attaches the pre-selected fixed memory allocation to the module.
      7          To Transmitt data in the RUN_MODULE case: put data into seqMemTX_u32, and call this function:
      8          *             USART_ITConfig(USART2, USART_IT_TXE, ENABLE);
      9          ********************************************************************************************************************************
     10          */
     11          
     12          /* Includes --------------------------------------------------------------------------------------------------------------------*/
     13          #include "module_usart2.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_USART_EnableIT_RXNE_RXFNE(USART_TypeDef *)
   \                     LL_USART_EnableIT_RXNE_RXFNE: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x2220             MOVS     R2,#+32
   \        0x4   0x430A             ORRS     R2,R2,R1
   \        0x6   0x6002             STR      R2,[R0, #+0]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_USART_DisableIT_RXNE_RXFNE(USART_TypeDef *)
   \                     LL_USART_DisableIT_RXNE_RXFNE: (+1)
   \        0x0   0x6801             LDR      R1,[R0, #+0]
   \        0x2   0x2220             MOVS     R2,#+32
   \        0x4   0x4391             BICS     R1,R1,R2
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_GPIO_TogglePin(GPIO_TypeDef *, uint32_t)
   \                     LL_GPIO_TogglePin: (+1)
   \        0x0   0x6942             LDR      R2,[R0, #+20]
   \        0x2   0x404A             EORS     R2,R2,R1
   \        0x4   0x6142             STR      R2,[R0, #+20]
   \        0x6   0x4770             BX       LR               ;; return
     14          
     15          #include "driver_usart2.h"

   \                                 In section .bss, align 4
   \   static __absolute Ring_Buf * usart2InternalSeqMem_u32
   \                     usart2InternalSeqMem_u32:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \   static __absolute Ring_Buf * usart2SeqMemRX_transparentMode_u32
   \                     usart2SeqMemRX_transparentMode_u32:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \   static __absolute Ring_Buf * usart2SeqMemRX_u32
   \                     usart2SeqMemRX_u32:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \   static __absolute Ring_Buf * usart2SeqMemTX_u32
   \                     usart2SeqMemTX_u32:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \   static __absolute Ram_Buf * usart2StructMem_u32
   \                     usart2StructMem_u32:
   \        0x0                      DS8 4
     16          #include "module_motor_com.h"
     17          #define LED_ONBOARD_Pin LL_GPIO_PIN_6 //SPA REVIEW.
                         ^
Warning[Pa181]: incompatible redefinition of macro "LED_ONBOARD_Pin" (declared
          at line 129 of
          "C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit
          _test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMous
          e\Drivers\hardware_config.h")
     18          
     19          /* Content ---------------------------------------------------------------------------------------------------------------------*/
     20          /* Uarts handle declaration */
     21          extern void Delay(__IO uint32_t nTime);
     22          
     23          extern Ram_Buf sharedMemArray[STRUCT_MEM_ARRAY_SIZE];
     24          extern ProcessInfo processInfoTable[];
     25          
     26          //extern Ram_Buf *usart2StructMem_u32;
     27          extern Ram_Buf_Handle usart2StructMem_u32;
     28          //Usart2_Control* usart2_Module_Control;
     29          
     30          #define ENABLE_RXCMD_USART2_FIXED_LEN 1
     31          #if ENABLE_RXCMD_USART2_FIXED_LEN >= 1
     32          // This is a one-shot buffer, that is written to and read from in single calls.
     33          // - it does not currently need to be tracked for current index because of this.
     34          // - REVIEW: does RX_FLASHUPDATECMD_LENGTH need to be this big?
     35          // -- Made it this big so 'write packets' could have as much data as possible.
     36          #define FIXED_RXCMD_USART2_MAX_LENGTH  TX_RX_BUF_SIZE // Inclusive (this value is accepted). REVIEW: Size, left high for flash reads 

   \                                 In section .bss, align 1
     37          unsigned char fixedRxCMD_Usart2_Length = 0;
   \                     fixedRxCMD_Usart2_Length:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
     38          unsigned char fixedRxCMD_Usart2[FIXED_RXCMD_USART2_MAX_LENGTH];
   \                     fixedRxCMD_Usart2:
   \        0x0                      DS8 80

   \                                 In section .data, align 4
     39          unsigned char* RxCMD_Usart2 = fixedRxCMD_Usart2;
   \                     RxCMD_Usart2:
   \        0x0   0x....'....        DC32 fixedRxCMD_Usart2
     40          #else // if ENABLE_RXCMD_USART2_FIXED_LEN <= 0
     41          unsigned char* RxCMD_Usart2;
     42          #endif // if ENABLE_RXCMD_USART2_FIXED_LEN <= 0

   \                                 In section .bss, align 2
     43          int16_t Actual_Measured_Speed;
   \                     Actual_Measured_Speed:
   \        0x0                      DS8 2
     44          extern uint8_t usart2CaptureLen;
     45          extern uint8_t UniProtocolState;
     46          extern __IO uint8_t indexTx;
     47          
     48          extern Usart2_Control usart2Control;
     49          
     50          // Function prototypes
     51          void assign_UART2_ModuleMem(uint8_t);
     52          void parseMessage_BulkMonitoring(unsigned int);
     53          void parseMessage_DriveFlashData(unsigned int data_length);
     54          void parseMessage_EEPROMData(unsigned int);
     55          
     56          enum {
     57            MEMORY_INIT_MODULE,
     58            INIT_MODULE,
     59            RUN_MODULE,
     60            // additional states to be added here as necessary.
     61            IRQ_MODULE = DEFAULT_IRQ_STATE,
     62            KILL_MODULE = KILL_APP
     63          };
     64          
     65          #define UNIVERSAL_PROTOCOL_HEADER_LENGTH 7
     66          #define MESSAGE_LENGTH_UP_BULK_MONITORING (14 + UNIVERSAL_PROTOCOL_HEADER_LENGTH)
     67          
     68          // TODO: Move all these extern function declarations to a separate file once we finalize the motor system.
     69          //
     70          extern void Modbus_UpdateStoredStatus(uint8_t status);
     71          extern void Modbus_UpdateStoredFaults(uint16_t faults);
     72          extern void Modbus_UpdateStoredBusVoltage(uint16_t bus_voltage);
     73          //
     74          extern void Modbus_UpdateStoredDirection(uint8_t direction);
     75          extern void Modbus_UpdateStoredMeasuredSpeed(int16_t measured_speed);
     76          extern void Modbus_UpdateStoredTorque(int16_t torque);
     77          //
     78          extern void Modbus_UpdateStoredPower(int16_t power);
     79          extern void Modbus_UpdateStoredTemperature(int16_t temperature);
     80          //
     81          extern void Modbus_PassEEPROMData(uint8_t* data_address_pu8, uint16_t length_u16);
     82          extern void Modbus_PassDriveFlashData(uint8_t *data_address_pu8, uint16_t data_length);
     83          
     84          #define UNIVERSAL_PROTOCOL_DATA_START_INDEX 5

   \                                 In section .bss, align 1
     85          volatile uint8_t test_counter_bulk_monitoring = 0;
   \                     test_counter_bulk_monitoring:
   \        0x0                      DS8 1

   \                                 In section .bss, align 2
     86          int16_t Motor_Avg_Speed_s16;
   \                     Motor_Avg_Speed_s16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 1
     87          uint8_t Motor_Avg_Counter_u8;
   \                     Motor_Avg_Counter_u8:
   \        0x0                      DS8 1
     88          
     89          

   \                                 In section .text, align 2, keep-with-next
     90          uint8_t moduleUsart2_u32(uint8_t drv_id_u8, uint8_t prev_state_u8, uint8_t next_state_u8, uint8_t irq_id_u8) {
   \                     moduleUsart2_u32: (+1)
   \        0x0   0xB5FF             PUSH     {R0-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
     91            uint8_t return_state_u8 = MEMORY_INIT_MODULE;
   \        0x4   0x2700             MOVS     R7,#+0
   \        0x6   0x0038             MOVS     R0,R7
   \        0x8   0x4669             MOV      R1,SP
   \        0xA   0x7148             STRB     R0,[R1, #+5]
     92            switch (next_state_u8) {
   \        0xC   0xA809             ADD      R0,SP,#+36
   \        0xE   0x7800             LDRB     R0,[R0, #+0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD007             BEQ      ??moduleUsart2_u32_0
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD00B             BEQ      ??moduleUsart2_u32_1
   \       0x18   0x2802             CMP      R0,#+2
   \       0x1A   0xD010             BEQ      ??moduleUsart2_u32_2
   \       0x1C   0x28FF             CMP      R0,#+255
   \       0x1E   0xD100             BNE      .+4
   \       0x20   0xE11B             B        ??moduleUsart2_u32_3
   \       0x22   0xE12D             B        ??moduleUsart2_u32_4
     93            case MEMORY_INIT_MODULE:
     94              {
     95                assign_UART2_ModuleMem(drv_id_u8); // Assign structured memory
   \                     ??moduleUsart2_u32_0: (+1)
   \       0x24   0x4668             MOV      R0,SP
   \       0x26   0x7F00             LDRB     R0,[R0, #+28]
   \       0x28   0x....'....        BL       assign_UART2_ModuleMem
     96                return_state_u8 = INIT_MODULE;
   \       0x2C   0x2001             MOVS     R0,#+1
     97                break;
   \       0x2E   0xE128             B        ??moduleUsart2_u32_5
     98              }
     99            case INIT_MODULE: 
    100              {
    101                // Initialize UART
    102                
    103                usart2_Init(); // USART init after memory allocation since USART needs buffers during init
   \                     ??moduleUsart2_u32_1: (+1)
   \       0x30   0x....'....        BL       usart2_Init
    104                //assign_UART2_ModuleMem();
    105                
    106                // Find the structured memory for the UART2 driver module, by searching for the UART2 onwer id.
    107                /* Ram_Buf_Handle this_ram_buf_u32;
    108                for (uint8_t struct_mem_index_u8 = 0; struct_mem_index_u8 < TOTAL_NUM_OF_STRUCT_MEM_INSTANCES;
    109                struct_mem_index_u8++) {
    110                this_ram_buf_u32 = &sharedMemArray[struct_mem_index_u8];
    111                if (RamBuf_GetOwner(this_ram_buf_u32) == drv_id_u8) {
    112                usart2StructMem_u32 = &sharedMemArray[struct_mem_index_u8];
    113              }
    114              }
    115                
    116                // Attach the structured memory to the process's master shared memory.
    117                uint8_t table_index_u8 = getProcessInfoIndex(drv_id_u8);
    118                if (table_index_u8 != INDEX_NOT_FOUND) {
    119                processInfoTable[table_index_u8].Sched_DrvData.irqState_u8 = DEFAULT_IRQ_STATE;
    120                processInfoTable[table_index_u8].Sched_DrvData.p_masterSharedMem_u32 =
    121                usart2StructMem_u32;
    122              }
    123                
    124                //Get structured memory for ADC1 data
    125                usart2Control = (Usart2_Control*)((*(processInfoTable[table_index_u8].Sched_DrvData.p_masterSharedMem_u32)).p_ramBuf_u8);*/
    126                usart2CaptureLen = UniHeaderlen;                                 //pam bug without this
   \       0x34   0x2007             MOVS     R0,#+7
   \       0x36   0x....             LDR      R1,??DataTable1
   \       0x38   0x7008             STRB     R0,[R1, #+0]
    127                return_state_u8 = RUN_MODULE;
   \       0x3A   0x2002             MOVS     R0,#+2
    128                break;
   \       0x3C   0xE121             B        ??moduleUsart2_u32_5
    129              }
    130            case RUN_MODULE: 
    131              {
    132                if(RingBuf_GetUsedNumOfElements((usart2Control).seqMem_InternalPipe_u32) >= usart2CaptureLen )
   \                     ??moduleUsart2_u32_2: (+1)
   \       0x3E   0x....             LDR      R4,??DataTable2
   \       0x40   0x68E0             LDR      R0,[R4, #+12]
   \       0x42   0x....'....        BL       RingBuf_GetUsedNumOfElements
   \       0x46   0x....             LDR      R1,??DataTable1
   \       0x48   0x7809             LDRB     R1,[R1, #+0]
   \       0x4A   0xB2C0             UXTB     R0,R0
   \       0x4C   0x4288             CMP      R0,R1
   \       0x4E   0xD30D             BCC      ??moduleUsart2_u32_6
    133                {
    134                  LL_USART_DisableIT_RXNE(USART2); // disable interrupts so new data doesn't come in while we are editing receive buffer
   \       0x50   0x....             LDR      R5,??DataTable2_1  ;; 0x40004400
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0x....'....        BL       LL_USART_DisableIT_RXNE_RXFNE
    135                  // Idle line detection: Only interpret messages when transmission is complete
    136                  // - This Idle Line Patches a bug with lost data due to interpretation of incomplete packets.
    137                  // -- TODO: When this is disabled, firmware infrequently crashes (main loop no longer executes) when interpreting incomplete packets.
    138                  // --- locate the source of the crash and patch, as this likely could still cause problems.
    139                  uint32_t idle_line = Usart2IdlePatch_RxIsIdle(); // LL_USART_IsActiveFlag_IDLE(USART2) (Emulation Note: this is polled) 
   \       0x58   0x....'....        BL       Usart2IdlePatch_RxIsIdle
   \       0x5C   0x0006             MOVS     R6,R0
    140                  if (idle_line) {
   \       0x5E   0x2E00             CMP      R6,#+0
   \       0x60   0xD001             BEQ      ??moduleUsart2_u32_7
    141                    protocolHeaderfetch();
   \       0x62   0x....'....        BL       protocolHeaderfetch
    142                    // LL_USART_ClearFlag_IDLE(USART2); // Clear the idle line flag.
    143                  }
    144                  LL_USART_EnableIT_RXNE(USART2); // re-enable the receive interrupt after parsing the received data
   \                     ??moduleUsart2_u32_7: (+1)
   \       0x66   0x0028             MOVS     R0,R5
   \       0x68   0x....'....        BL       LL_USART_EnableIT_RXNE_RXFNE
    145                }
    146                uint8_t TxLen = UniHeaderlen;
   \                     ??moduleUsart2_u32_6: (+1)
   \       0x6C   0x2507             MOVS     R5,#+7
   \       0x6E   0x0028             MOVS     R0,R5
   \       0x70   0x4669             MOV      R1,SP
   \       0x72   0x7108             STRB     R0,[R1, #+4]
    147                //if((RingBuf_GetUsedNumOfElements((Ring_Buf_Handle)((*(usart2Control).seqMemTX_u32).p_ringBuf_u8)) >= TxLen) && !indexTx)
    148                if((RingBuf_GetUsedNumOfElements((usart2Control).seqMemTX_u32) >= TxLen) && !indexTx)
   \       0x74   0x68A0             LDR      R0,[R4, #+8]
   \       0x76   0x....'....        BL       RingBuf_GetUsedNumOfElements
   \       0x7A   0x4669             MOV      R1,SP
   \       0x7C   0x7909             LDRB     R1,[R1, #+4]
   \       0x7E   0x4288             CMP      R0,R1
   \       0x80   0xD305             BCC      ??moduleUsart2_u32_8
   \       0x82   0x....             LDR      R0,??DataTable2_2
   \       0x84   0x7800             LDRB     R0,[R0, #+0]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD101             BNE      ??moduleUsart2_u32_8
    149                {
    150                  TxProcess();
   \       0x8A   0x....'....        BL       TxProcess
    151                }
    152                /********* for MVP only Pam ******************************************/
    153                
    154                unsigned int DataLen2 = (unsigned int)UniHeaderlen;
   \                     ??moduleUsart2_u32_8: (+1)
   \       0x8E   0x9500             STR      R5,[SP, #+0]
    155                //if(RingBuf_GetUsedNumOfElements((Ring_Buf_Handle)((*(usart2Control).seqMemRX_u32).p_ringBuf_u8)) >= DataLen2 )
    156                if(RingBuf_GetUsedNumOfElements((usart2Control).seqMemRX_u32) >= DataLen2 )
   \       0x90   0x6860             LDR      R0,[R4, #+4]
   \       0x92   0x....'....        BL       RingBuf_GetUsedNumOfElements
   \       0x96   0xB2C0             UXTB     R0,R0
   \       0x98   0x9900             LDR      R1,[SP, #+0]
   \       0x9A   0x4288             CMP      R0,R1
   \       0x9C   0xD200             BCS      .+4
   \       0x9E   0xE0DA             B        ??moduleUsart2_u32_9
    157                {        
    158                  
    159          #if ENABLE_RXCMD_USART2_FIXED_LEN >= 1
    160                  // No need to check length here, this buffer must be at least longer than the header.
    161          #else // if ENABLE_RXCMD_USART2_FIXED_LEN <= 0
    162                  RxCMD_Usart2 = (unsigned char*) realloc(RxCMD_Usart2,DataLen2);     
    163          #endif // if ENABLE_RXCMD_USART2_FIXED_LEN <= 0
    164                  RingBuf_Observe((usart2Control).seqMemRX_u32, RxCMD_Usart2, 0, &DataLen2);  
   \       0xA0   0x....             LDR      R5,??DataTable2_3
   \       0xA2   0x466B             MOV      R3,SP
   \       0xA4   0x2200             MOVS     R2,#+0
   \       0xA6   0x6829             LDR      R1,[R5, #+0]
   \       0xA8   0x6860             LDR      R0,[R4, #+4]
   \       0xAA   0x....'....        BL       RingBuf_Observe
    165                  
    166                  //calculate the total number of frame
    167                  DataLen2 = ((unsigned int)RxCMD_Usart2[1] & 0x3F) + (unsigned int)UniHeaderlen;
   \       0xAE   0x6828             LDR      R0,[R5, #+0]
   \       0xB0   0x7840             LDRB     R0,[R0, #+1]
   \       0xB2   0x0680             LSLS     R0,R0,#+26       ;; ZeroExtS R0,R0,#+26,#+26
   \       0xB4   0x0E80             LSRS     R0,R0,#+26
   \       0xB6   0x1DC0             ADDS     R0,R0,#+7
   \       0xB8   0x9000             STR      R0,[SP, #+0]
    168                  
    169          #if ENABLE_RXCMD_USART2_FIXED_LEN >= 1
    170                  // Check for possible buffer overflow
    171                  if (DataLen2 <= FIXED_RXCMD_USART2_MAX_LENGTH) { // Normal Case: Read message into buffer
   \       0xBA   0x9800             LDR      R0,[SP, #+0]
   \       0xBC   0x2851             CMP      R0,#+81
   \       0xBE   0xD22A             BCS      ??moduleUsart2_u32_10
    172                    RingBuf_ReadBlock((usart2Control).seqMemRX_u32, RxCMD_Usart2, &DataLen2); //extract the whole frame into the buffer
   \       0xC0   0x466A             MOV      R2,SP
   \       0xC2   0x6829             LDR      R1,[R5, #+0]
   \       0xC4   0x6860             LDR      R0,[R4, #+4]
   \       0xC6   0x....'....        BL       RingBuf_ReadBlock
    173                  } else { // Overflow 
    174                    // Read All Data (Clear the Buffer)
    175                    while (DataLen2 > 0) {
    176                      if (DataLen2 > FIXED_RXCMD_USART2_MAX_LENGTH) {
    177                        // REVIEW: Replace with RingBuf_ClearContents? Much less processing
    178                        unsigned int read_length = FIXED_RXCMD_USART2_MAX_LENGTH;
    179                        RingBuf_ReadBlock((usart2Control).seqMemRX_u32, RxCMD_Usart2, &read_length); //extract the whole frame
    180                        // RingBuf_ReadBlock((*usart2Control).seqMemTX_u32, headerFramebuf, &read_length);             //copy the complete frame into buffer
    181                        DataLen2 -= FIXED_RXCMD_USART2_MAX_LENGTH;
    182                      } else {
    183                        RingBuf_ReadBlock((usart2Control).seqMemRX_u32, RxCMD_Usart2, &DataLen2); //extract the whole frame
    184                        // RingBuf_ReadBlock((*usart2Control).seqMemTX_u32, headerFramebuf, &DataLen2);             //copy the complete frame into buffer
    185                        DataLen2 = 0;
    186                      }
    187                    }
    188                    // Exit Gracefully, so that we don't interpret the corrupted message
    189                    return_state_u8 = RUN_MODULE;
    190                    return return_state_u8;
    191                  }
    192          #else // if ENABLE_RXCMD_USART2_FIXED_LEN <= 0
    193                  RxCMD_Usart2 = (unsigned char*) realloc(RxCMD_Usart2,DataLen2);     //allocate the right frame size of memory for buffer
    194                  RingBuf_ReadBlock((usart2Control).seqMemRX_u32, RxCMD_Usart2, &DataLen2); //extract the whole frame
    195          #endif // if ENABLE_RXCMD_USART2_FIXED_LEN <= 0
    196                  
    197                  
    198                  switch(RxCMD_Usart2[2])
   \       0xCA   0x6828             LDR      R0,[R5, #+0]
   \       0xCC   0x7880             LDRB     R0,[R0, #+2]
   \       0xCE   0x2807             CMP      R0,#+7
   \       0xD0   0xD100             BNE      .+4
   \       0xD2   0xE0BD             B        ??moduleUsart2_u32_11
   \       0xD4   0x2840             CMP      R0,#+64
   \       0xD6   0xD039             BEQ      ??moduleUsart2_u32_12
   \       0xD8   0x2841             CMP      R0,#+65
   \       0xDA   0xD040             BEQ      ??moduleUsart2_u32_13
   \       0xDC   0x2842             CMP      R0,#+66
   \       0xDE   0xD04F             BEQ      ??moduleUsart2_u32_14
   \       0xE0   0x284D             CMP      R0,#+77
   \       0xE2   0xD056             BEQ      ??moduleUsart2_u32_15
   \       0xE4   0x284E             CMP      R0,#+78
   \       0xE6   0xD058             BEQ      ??moduleUsart2_u32_16
   \       0xE8   0x284F             CMP      R0,#+79
   \       0xEA   0xD064             BEQ      ??moduleUsart2_u32_17
   \       0xEC   0x2860             CMP      R0,#+96
   \       0xEE   0xD07B             BEQ      ??moduleUsart2_u32_18
   \       0xF0   0x2861             CMP      R0,#+97
   \       0xF2   0xD100             BNE      .+4
   \       0xF4   0xE08A             B        ??moduleUsart2_u32_19
   \       0xF6   0x286F             CMP      R0,#+111
   \       0xF8   0xD100             BNE      .+4
   \       0xFA   0xE090             B        ??moduleUsart2_u32_20
   \       0xFC   0x2879             CMP      R0,#+121
   \       0xFE   0xD100             BNE      .+4
   \      0x100   0xE09E             B        ??moduleUsart2_u32_21
   \      0x102   0x2880             CMP      R0,#+128
   \      0x104   0xD100             BNE      .+4
   \      0x106   0xE09F             B        ??moduleUsart2_u32_22
   \      0x108   0x28B0             CMP      R0,#+176
   \      0x10A   0xD100             BNE      .+4
   \      0x10C   0xE0A1             B        ??moduleUsart2_u32_23
   \      0x10E   0x28B1             CMP      R0,#+177
   \      0x110   0xD100             BNE      .+4
   \      0x112   0xE09F             B        ??moduleUsart2_u32_24
   \      0x114   0xE09F             B        ??moduleUsart2_u32_25
   \                     ??moduleUsart2_u32_10: (+1)
   \      0x116   0x9800             LDR      R0,[SP, #+0]
   \      0x118   0x2800             CMP      R0,#+0
   \      0x11A   0xD014             BEQ      ??moduleUsart2_u32_26
   \      0x11C   0x9800             LDR      R0,[SP, #+0]
   \      0x11E   0x2851             CMP      R0,#+81
   \      0x120   0xD30A             BCC      ??moduleUsart2_u32_27
   \      0x122   0x2050             MOVS     R0,#+80
   \      0x124   0x9003             STR      R0,[SP, #+12]
   \      0x126   0xAA03             ADD      R2,SP,#+12
   \      0x128   0x6829             LDR      R1,[R5, #+0]
   \      0x12A   0x6860             LDR      R0,[R4, #+4]
   \      0x12C   0x....'....        BL       RingBuf_ReadBlock
   \      0x130   0x9800             LDR      R0,[SP, #+0]
   \      0x132   0x3850             SUBS     R0,R0,#+80
   \      0x134   0x9000             STR      R0,[SP, #+0]
   \      0x136   0xE7EE             B        ??moduleUsart2_u32_10
   \                     ??moduleUsart2_u32_27: (+1)
   \      0x138   0x466A             MOV      R2,SP
   \      0x13A   0x6829             LDR      R1,[R5, #+0]
   \      0x13C   0x6860             LDR      R0,[R4, #+4]
   \      0x13E   0x....'....        BL       RingBuf_ReadBlock
   \      0x142   0x9700             STR      R7,[SP, #+0]
   \      0x144   0xE7E7             B        ??moduleUsart2_u32_10
   \                     ??moduleUsart2_u32_26: (+1)
   \      0x146   0x2002             MOVS     R0,#+2
   \      0x148   0xB2C0             UXTB     R0,R0
   \      0x14A   0xE09B             B        ??moduleUsart2_u32_28
    199                  {
    200                    
    201                  case BUS_VOLTS_CMD:       //  0x40 // Read bus volts
    202                    {
    203                      uint16_t bus_volts_u16 = RxCMD_Usart2[6]; 
   \                     ??moduleUsart2_u32_12: (+1)
   \      0x14C   0x6828             LDR      R0,[R5, #+0]
   \      0x14E   0x7980             LDRB     R0,[R0, #+6]
    204                      bus_volts_u16 += (uint16_t) RxCMD_Usart2[5] << 8;
   \      0x150   0xB280             UXTH     R0,R0
   \      0x152   0x6829             LDR      R1,[R5, #+0]
   \      0x154   0x7949             LDRB     R1,[R1, #+5]
   \      0x156   0x0209             LSLS     R1,R1,#+8
   \      0x158   0x1840             ADDS     R0,R0,R1
    205                      (usart2Control).busVolts_u16 = bus_volts_u16;
   \      0x15A   0x8220             STRH     R0,[R4, #+16]
    206                      break;
   \      0x15C   0xE07B             B        ??moduleUsart2_u32_9
    207                    }
    208                  case MOTOR_STATUS_CMD:    //  0x41 // Motor status
    209                    {
    210                      uint16_t Mot_Status = RxCMD_Usart2[6]; 
   \                     ??moduleUsart2_u32_13: (+1)
   \      0x15E   0x6828             LDR      R0,[R5, #+0]
   \      0x160   0x7980             LDRB     R0,[R0, #+6]
    211                      Mot_Status += (uint16_t) RxCMD_Usart2[5] << 8;
   \      0x162   0xB280             UXTH     R0,R0
   \      0x164   0x6829             LDR      R1,[R5, #+0]
   \      0x166   0x7949             LDRB     R1,[R1, #+5]
   \      0x168   0x0209             LSLS     R1,R1,#+8
   \      0x16A   0x1845             ADDS     R5,R0,R1
    212                      (usart2Control).motorStatus_u16 = Mot_Status;
   \      0x16C   0x8425             STRH     R5,[R4, #+32]
    213                      if(Mot_Status != 0)
   \      0x16E   0x0028             MOVS     R0,R5
   \      0x170   0xB280             UXTH     R0,R0
   \      0x172   0x2800             CMP      R0,#+0
   \      0x174   0xD003             BEQ      ??moduleUsart2_u32_29
    214                      {
    215                        LL_GPIO_TogglePin(GPIOC, LED_ONBOARD_Pin); //on board LED output // SPA Reveiw. This function should not be part of module.
   \      0x176   0x2140             MOVS     R1,#+64
   \      0x178   0x....             LDR      R0,??DataTable2_4  ;; 0x50000800
   \      0x17A   0x....'....        BL       LL_GPIO_TogglePin
    216                      }
    217                      break;
   \                     ??moduleUsart2_u32_29: (+1)
   \      0x17E   0xE06A             B        ??moduleUsart2_u32_9
    218                    }
    219                  case MOTOR_DIR_CMD :      //  0x42 // Motor direction
    220                    {
    221                      int16_t motor_dir_s16 = RxCMD_Usart2[6]; 
   \                     ??moduleUsart2_u32_14: (+1)
   \      0x180   0x6828             LDR      R0,[R5, #+0]
   \      0x182   0x7980             LDRB     R0,[R0, #+6]
    222                      motor_dir_s16 += (int16_t) RxCMD_Usart2[5] << 8;
   \      0x184   0xB200             SXTH     R0,R0
   \      0x186   0x6829             LDR      R1,[R5, #+0]
   \      0x188   0x7949             LDRB     R1,[R1, #+5]
   \      0x18A   0x0209             LSLS     R1,R1,#+8
   \      0x18C   0x1840             ADDS     R0,R0,R1
    223                      (usart2Control).motorDir_s16 = motor_dir_s16;
   \      0x18E   0x8260             STRH     R0,[R4, #+18]
    224                      break;
   \      0x190   0xE061             B        ??moduleUsart2_u32_9
    225                    }
    226                  case BULK_MONITORING_CMD: // 0x4D
    227                    {
    228                      parseMessage_BulkMonitoring(DataLen2);
   \                     ??moduleUsart2_u32_15: (+1)
   \      0x192   0x9800             LDR      R0,[SP, #+0]
   \      0x194   0x....'....        BL       parseMessage_BulkMonitoring
    229                      break;
   \      0x198   0xE05D             B        ??moduleUsart2_u32_9
    230                    }
    231                  case HEART_BEAT_CMD:      //  0x4E // Heart beat
    232                    { //this would basically send a packet (with a time delay info (to be specified later)) to motor-side and will be used as a heartbeat
    233                      unsigned char HeartBeatTx[] = {0x55, 0x02, 0x4E, 0x00, 0x00, 0x0F, 0xA0, 0xCC, 0xCC};
   \                     ??moduleUsart2_u32_16: (+1)
   \      0x19A   0xA804             ADD      R0,SP,#+16
   \      0x19C   0x....             LDR      R1,??DataTable2_5
   \      0x19E   0xC92C             LDM      R1!,{R2,R3,R5}
   \      0x1A0   0xC02C             STM      R0!,{R2,R3,R5}
   \      0x1A2   0x390C             SUBS     R1,R1,#+12
   \      0x1A4   0x380C             SUBS     R0,R0,#+12
    234                      unsigned int HeartBeatLen = sizeof(HeartBeatTx);         
   \      0x1A6   0x2009             MOVS     R0,#+9
   \      0x1A8   0x9002             STR      R0,[SP, #+8]
    235                      RingBuf_WriteBlock((usart2Control).seqMemTX_u32, HeartBeatTx, &HeartBeatLen);
   \      0x1AA   0xAA02             ADD      R2,SP,#+8
   \      0x1AC   0xA904             ADD      R1,SP,#+16
   \      0x1AE   0x68A0             LDR      R0,[R4, #+8]
   \      0x1B0   0x....'....        BL       RingBuf_WriteBlock
    236                      
    237                      // TODO: (RPa) please add the necessary sequence on the app-side if not receiving any valid packet from the motor-side
    238                      // to complete the loop of HeartBeat
    239                      break;
   \      0x1B4   0xE04F             B        ??moduleUsart2_u32_9
    240                    }
    241                  case ELECTRICAL_INFO_CMD: //  0x4F // Motor volts, phase current & power
    242                    {
    243                      int16_t motor_volts_s16 = RxCMD_Usart2[6]; 
   \                     ??moduleUsart2_u32_17: (+1)
   \      0x1B6   0x6828             LDR      R0,[R5, #+0]
   \      0x1B8   0x7980             LDRB     R0,[R0, #+6]
    244                      motor_volts_s16 += (int16_t) RxCMD_Usart2[5] << 8;
   \      0x1BA   0xB200             SXTH     R0,R0
   \      0x1BC   0x6829             LDR      R1,[R5, #+0]
   \      0x1BE   0x7949             LDRB     R1,[R1, #+5]
   \      0x1C0   0x0209             LSLS     R1,R1,#+8
   \      0x1C2   0x1840             ADDS     R0,R0,R1
    245                      (usart2Control).motorVolts_s16 = motor_volts_s16;
   \      0x1C4   0x82A0             STRH     R0,[R4, #+20]
    246                      
    247                      int16_t motor_phase_amps_s16 = RxCMD_Usart2[8]; 
   \      0x1C6   0x6829             LDR      R1,[R5, #+0]
   \      0x1C8   0x7A09             LDRB     R1,[R1, #+8]
    248                      motor_phase_amps_s16 += (int16_t) RxCMD_Usart2[7] << 8;
   \      0x1CA   0xB209             SXTH     R1,R1
   \      0x1CC   0x682A             LDR      R2,[R5, #+0]
   \      0x1CE   0x79D2             LDRB     R2,[R2, #+7]
   \      0x1D0   0x0212             LSLS     R2,R2,#+8
   \      0x1D2   0x1889             ADDS     R1,R1,R2
    249                      (usart2Control).motorPhaseCurrent_s16 = motor_phase_amps_s16;
   \      0x1D4   0x82E1             STRH     R1,[R4, #+22]
    250                      
    251                      int16_t motor_output_power_s16 = RxCMD_Usart2[10]; 
   \      0x1D6   0x682A             LDR      R2,[R5, #+0]
   \      0x1D8   0x7A92             LDRB     R2,[R2, #+10]
    252                      motor_output_power_s16 += (int16_t) RxCMD_Usart2[9] << 8;
   \      0x1DA   0xB212             SXTH     R2,R2
   \      0x1DC   0x682B             LDR      R3,[R5, #+0]
   \      0x1DE   0x7A5B             LDRB     R3,[R3, #+9]
   \      0x1E0   0x021B             LSLS     R3,R3,#+8
   \      0x1E2   0x18D2             ADDS     R2,R2,R3
    253                      (usart2Control).motorOutputPower_s16 = motor_output_power_s16;
   \      0x1E4   0x8322             STRH     R2,[R4, #+24]
    254                      
    255                      break;
   \      0x1E6   0xE036             B        ??moduleUsart2_u32_9
    256                    }
    257                  case MEASURED_SPEED_CMD:  //  0x60 // Measured speed
    258                    {
    259                      int16_t Mea_speed = RxCMD_Usart2[6];
   \                     ??moduleUsart2_u32_18: (+1)
   \      0x1E8   0x6828             LDR      R0,[R5, #+0]
   \      0x1EA   0x7980             LDRB     R0,[R0, #+6]
    260                      Mea_speed += (int16_t) RxCMD_Usart2[5] << 8;
   \      0x1EC   0xB200             SXTH     R0,R0
   \      0x1EE   0x6829             LDR      R1,[R5, #+0]
   \      0x1F0   0x7949             LDRB     R1,[R1, #+5]
   \      0x1F2   0x0209             LSLS     R1,R1,#+8
   \      0x1F4   0x1845             ADDS     R5,R0,R1
    261                      Mea_speed=abs(Mea_speed);
   \      0x1F6   0x0028             MOVS     R0,R5
   \      0x1F8   0xB200             SXTH     R0,R0
   \      0x1FA   0x....'....        BL       abs
   \      0x1FE   0x0006             MOVS     R6,R0
    262                      (usart2Control).motorSpeed_s16 = Mea_speed;              
   \      0x200   0x83E6             STRH     R6,[R4, #+30]
    263                      Modbus_UpdateStoredMeasuredSpeed(Mea_speed);
   \      0x202   0x0030             MOVS     R0,R6
   \      0x204   0xB200             SXTH     R0,R0
   \      0x206   0x....'....        BL       Modbus_UpdateStoredMeasuredSpeed
    264                     /* Motor_Avg_Speed_s16+=Mea_speed;
    265                      Motor_Avg_Counter_u8++;
    266                      if(Motor_Avg_Counter_u8>=2){
    267                        Actual_Measured_Speed=Motor_Avg_Speed_s16/Motor_Avg_Counter_u8;
    268                        Modbus_UpdateStoredMeasuredSpeed(Actual_Measured_Speed);
    269                        Motor_Avg_Counter_u8=0;
    270                        Motor_Avg_Speed_s16=0;
    271                      }*/
    272                      
    273                      break;
   \      0x20A   0xE024             B        ??moduleUsart2_u32_9
    274                    }
    275                  case MEASURED_TORQUE_CMD: //  0x61 // Measured Torque
    276                    {
    277                      int16_t motor_torque_s16 = RxCMD_Usart2[6]; 
   \                     ??moduleUsart2_u32_19: (+1)
   \      0x20C   0x6828             LDR      R0,[R5, #+0]
   \      0x20E   0x7980             LDRB     R0,[R0, #+6]
    278                      motor_torque_s16 += (int16_t) RxCMD_Usart2[5] << 8;
   \      0x210   0xB200             SXTH     R0,R0
   \      0x212   0x6829             LDR      R1,[R5, #+0]
   \      0x214   0x7949             LDRB     R1,[R1, #+5]
   \      0x216   0x0209             LSLS     R1,R1,#+8
   \      0x218   0x1840             ADDS     R0,R0,R1
    279                      (usart2Control).motorOutputTorque_s16 = motor_torque_s16;
   \      0x21A   0x8360             STRH     R0,[R4, #+26]
    280                      break;
   \      0x21C   0xE01B             B        ??moduleUsart2_u32_9
    281                    }
    282                  case THERMO_MECHANICAL_INFO_CMD:  // 0x6F // Measured torque & temperature
    283                    {
    284                      int16_t motor_torque_s16 = RxCMD_Usart2[6]; 
   \                     ??moduleUsart2_u32_20: (+1)
   \      0x21E   0x6828             LDR      R0,[R5, #+0]
   \      0x220   0x7980             LDRB     R0,[R0, #+6]
    285                      motor_torque_s16 += (int16_t) RxCMD_Usart2[5] << 8;
   \      0x222   0xB200             SXTH     R0,R0
   \      0x224   0x6829             LDR      R1,[R5, #+0]
   \      0x226   0x7949             LDRB     R1,[R1, #+5]
   \      0x228   0x0209             LSLS     R1,R1,#+8
   \      0x22A   0x1840             ADDS     R0,R0,R1
    286                      (usart2Control).motorOutputTorque_s16 = motor_torque_s16;
   \      0x22C   0x8360             STRH     R0,[R4, #+26]
    287                      
    288                      int16_t module_temperature_s16 = RxCMD_Usart2[8]; 
   \      0x22E   0x6829             LDR      R1,[R5, #+0]
   \      0x230   0x7A09             LDRB     R1,[R1, #+8]
    289                      module_temperature_s16 += (int16_t) RxCMD_Usart2[7] << 8;
   \      0x232   0xB209             SXTH     R1,R1
   \      0x234   0x682A             LDR      R2,[R5, #+0]
   \      0x236   0x79D2             LDRB     R2,[R2, #+7]
   \      0x238   0x0212             LSLS     R2,R2,#+8
   \      0x23A   0x1889             ADDS     R1,R1,R2
    290                      (usart2Control).moduleTemperature_s16 = module_temperature_s16;
   \      0x23C   0x83A1             STRH     R1,[R4, #+28]
    291                      
    292                      break;
   \      0x23E   0xE00A             B        ??moduleUsart2_u32_9
    293                    }
    294          		case DRIVE_FLASH_READ_CMD: // 0x79
    295                    {
    296                      parseMessage_DriveFlashData(DataLen2);
   \                     ??moduleUsart2_u32_21: (+1)
   \      0x240   0x9800             LDR      R0,[SP, #+0]
   \      0x242   0x....'....        BL       parseMessage_DriveFlashData
    297                      break;
   \      0x246   0xE006             B        ??moduleUsart2_u32_9
    298                    }
    299          		case EEPROM_READ_DATA_CMD: // 0x80
    300                    {
    301                      parseMessage_EEPROMData(DataLen2);
   \                     ??moduleUsart2_u32_22: (+1)
   \      0x248   0x9800             LDR      R0,[SP, #+0]
   \      0x24A   0x....'....        BL       parseMessage_EEPROMData
    302                      break;
   \      0x24E   0xE002             B        ??moduleUsart2_u32_9
    303                    }
    304                  case SINGLE_REG_READ_CMD: //  0x07 // Read single regiser
    305                    {
    306                      break;
   \                     ??moduleUsart2_u32_11: (+1)
   \      0x250   0xE001             B        ??moduleUsart2_u32_9
    307                    }
    308                    //case REG_STATUS_CMD:      //  0x72 // Read register status
    309                  case MULT_DATA_REQ1_CMD:  //  0xB0 // Read multiple commands 1
    310                    {
    311                      break;
   \                     ??moduleUsart2_u32_23: (+1)
   \      0x252   0xE000             B        ??moduleUsart2_u32_9
    312                    }
    313                  case MULT_DATA_REQ2_CMD:  //  0xB1 // Read multiple commands 2
    314                    {
    315                      break;
   \                     ??moduleUsart2_u32_24: (+1)
   \      0x254   0xE7FF             B        ??moduleUsart2_u32_9
    316                    }
    317                    
    318                    /*case 0x60:
    319                    {
    320                    int16_t Mea_speed = RxCMD_Usart2[6];
    321                    Mea_speed += (int16_t) RxCMD_Usart2[5] << 8;
    322                    (*usart2Control).motorSpeed_s16 = Mea_speed;     
    323                    break;
    324                  }
    325                  case 0x41:
    326                    {
    327                    uint16_t Mot_Status = RxCMD_Usart2[6]; 
    328                    Mot_Status += (uint16_t) RxCMD_Usart2[5] << 8;
    329                    (*usart2Control).motorStatus_u16 = Mot_Status;
    330                    if(Mot_Status != 0)
    331                    {
    332                    LL_GPIO_TogglePin(GPIOC, LED_ONBOARD_Pin); //on board LED output // SPA Reveiw. This function should not be part of module.
    333                  }
    334                    break;
    335                  }*/
    336                    
    337                  default:
    338                    break;
    339                  }
    340                }
    341          #if ENABLE_RXCMD_USART2_FIXED_LEN <= 0
    342                RxCMD_Usart2 = (unsigned char*) realloc(RxCMD_Usart2,1);   
    343          #endif // ENABLE_RXCMD_USART2_FIXED_LEN <= 0
    344                
    345                return_state_u8 = RUN_MODULE;
   \                     ??moduleUsart2_u32_25: (+1)
   \                     ??moduleUsart2_u32_9: (+1)
   \      0x256   0x2002             MOVS     R0,#+2
    346                break;
   \      0x258   0xE013             B        ??moduleUsart2_u32_5
    347              }
    348            case KILL_MODULE: 
    349              {
    350                // The USART2 driver module must only be executed once.
    351                // Setting processStatus_u8 to PROCESS_STATUS_KILLED prevents the scheduler main loop from calling this module again.
    352                uint8_t table_index_u8 = getProcessInfoIndex(drv_id_u8);
   \                     ??moduleUsart2_u32_3: (+1)
   \      0x25A   0x4668             MOV      R0,SP
   \      0x25C   0x7F00             LDRB     R0,[R0, #+28]
   \      0x25E   0x....'....        BL       getProcessInfoIndex
   \      0x262   0x0001             MOVS     R1,R0
    353                if (table_index_u8 != INDEX_NOT_FOUND) {
   \      0x264   0x0008             MOVS     R0,R1
   \      0x266   0xB2C0             UXTB     R0,R0
   \      0x268   0x28FF             CMP      R0,#+255
   \      0x26A   0xD007             BEQ      ??moduleUsart2_u32_30
    354                  processInfoTable[table_index_u8].Sched_DrvData.processStatus_u8 = PROCESS_STATUS_KILLED;
   \      0x26C   0x20FF             MOVS     R0,#+255
   \      0x26E   0x....             LDR      R2,??DataTable5
   \      0x270   0x000B             MOVS     R3,R1
   \      0x272   0xB2DB             UXTB     R3,R3
   \      0x274   0x2416             MOVS     R4,#+22
   \      0x276   0x4363             MULS     R3,R4,R3
   \      0x278   0x18D2             ADDS     R2,R2,R3
   \      0x27A   0x7290             STRB     R0,[R2, #+10]
    355                }
    356                return_state_u8 = KILL_MODULE;
   \                     ??moduleUsart2_u32_30: (+1)
   \      0x27C   0x20FF             MOVS     R0,#+255
    357                break;
   \      0x27E   0xE000             B        ??moduleUsart2_u32_5
    358              }
    359            default: 
    360              {
    361                return_state_u8 = KILL_MODULE;
   \                     ??moduleUsart2_u32_4: (+1)
   \      0x280   0x20FF             MOVS     R0,#+255
    362                break;
    363              }
    364            }
    365            return return_state_u8;
   \                     ??moduleUsart2_u32_5: (+1)
   \      0x282   0xB2C0             UXTB     R0,R0
   \                     ??moduleUsart2_u32_28: (+1)
   \      0x284   0xB00B             ADD      SP,SP,#+44
   \      0x286   0xBDF0             POP      {R4-R7,PC}       ;; return
    366          }
    367          
    368          /**
    369          ********************************************************************************************************************************
    370          * @brief   Assign structured/sequential memory
    371          * @details Assign structured/sequential memory for USAR2 module
    372          * @param   None 
    373          * @return  None
    374          ********************************************************************************************************************************
    375          */

   \                                 In section .text, align 2, keep-with-next
    376          void assign_UART2_ModuleMem(uint8_t drv_id_u8){  
   \                     assign_UART2_ModuleMem: (+1)
   \        0x0   0xB5F1             PUSH     {R0,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
    377            //System call create a buffer for this driver need to be bigger than 1 complete frame 
    378            usart2InternalSeqMem_u32 = SeqMem_CreateInstance(MODULE_USART2, TX_RX_BUF_SIZE, ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x2202             MOVS     R2,#+2
   \        0xC   0x2150             MOVS     R1,#+80
   \        0xE   0x2003             MOVS     R0,#+3
   \       0x10   0x....'....        BL       SeqMem_CreateInstance
   \       0x14   0x....             LDR      R1,??DataTable5_1
   \       0x16   0x6008             STR      R0,[R1, #+0]
    379            //System call create a buffer for final packet receiver buffer 
    380            usart2SeqMemRX_transparentMode_u32 = SeqMem_CreateInstance(MODULE_USART2, TX_RX_BUF_SIZE, ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0x2300             MOVS     R3,#+0
   \       0x1E   0x2202             MOVS     R2,#+2
   \       0x20   0x2150             MOVS     R1,#+80
   \       0x22   0x2003             MOVS     R0,#+3
   \       0x24   0x....'....        BL       SeqMem_CreateInstance
   \       0x28   0x....             LDR      R1,??DataTable5_2
   \       0x2A   0x6008             STR      R0,[R1, #+0]
    381            //System call create a buffer for final packet receiver buffer 
    382            usart2SeqMemRX_u32 = SeqMem_CreateInstance(MODULE_USART2, TX_RX_BUF_SIZE, ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);
   \       0x2C   0x....             LDR      R7,??DataTable5_3
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x9000             STR      R0,[SP, #+0]
   \       0x32   0x2300             MOVS     R3,#+0
   \       0x34   0x2202             MOVS     R2,#+2
   \       0x36   0x2150             MOVS     R1,#+80
   \       0x38   0x2003             MOVS     R0,#+3
   \       0x3A   0x....'....        BL       SeqMem_CreateInstance
   \       0x3E   0x6038             STR      R0,[R7, #+0]
    383            //System call create a buffer for Tx data
    384            usart2SeqMemTX_u32 = SeqMem_CreateInstance(MODULE_USART2, TX_RX_BUF_SIZE, ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);      
   \       0x40   0x....             LDR      R6,??DataTable5_4
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x9000             STR      R0,[SP, #+0]
   \       0x46   0x2300             MOVS     R3,#+0
   \       0x48   0x2202             MOVS     R2,#+2
   \       0x4A   0x2150             MOVS     R1,#+80
   \       0x4C   0x2003             MOVS     R0,#+3
   \       0x4E   0x....'....        BL       SeqMem_CreateInstance
   \       0x52   0x6030             STR      R0,[R6, #+0]
    385            
    386            usart2StructMem_u32 =  StructMem_CreateInstance(MODULE_USART2, sizeof(Usart2_Control), ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);//System call create a structured memory for this driver [should map it back to this driver local struct]
   \       0x54   0x....             LDR      R5,??DataTable5_5
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x9000             STR      R0,[SP, #+0]
   \       0x5A   0x2300             MOVS     R3,#+0
   \       0x5C   0x2202             MOVS     R2,#+2
   \       0x5E   0x2124             MOVS     R1,#+36
   \       0x60   0x2003             MOVS     R0,#+3
   \       0x62   0x....'....        BL       StructMem_CreateInstance
   \       0x66   0x6028             STR      R0,[R5, #+0]
    387            (*usart2StructMem_u32).p_ramBuf_u8 = (uint8_t *)&usart2Control ;    // Map the usart2Control memory into the structured memory
   \       0x68   0x....             LDR      R4,??DataTable2
   \       0x6A   0x6828             LDR      R0,[R5, #+0]
   \       0x6C   0x6004             STR      R4,[R0, #+0]
    388            uint8_t usart2_index_u8 = getProcessInfoIndex(MODULE_USART2);
   \       0x6E   0x2003             MOVS     R0,#+3
   \       0x70   0x....'....        BL       getProcessInfoIndex
   \       0x74   0x4669             MOV      R1,SP
   \       0x76   0x7008             STRB     R0,[R1, #+0]
    389            processInfoTable[usart2_index_u8].Sched_DrvData.irqState_u8 = DEFAULT_IRQ_STATE;
   \       0x78   0x....             LDR      R0,??DataTable5
   \       0x7A   0x21C8             MOVS     R1,#+200
   \       0x7C   0x466A             MOV      R2,SP
   \       0x7E   0x7812             LDRB     R2,[R2, #+0]
   \       0x80   0x2316             MOVS     R3,#+22
   \       0x82   0x435A             MULS     R2,R3,R2
   \       0x84   0x1882             ADDS     R2,R0,R2
   \       0x86   0x7251             STRB     R1,[R2, #+9]
    390            processInfoTable[usart2_index_u8].Sched_DrvData.p_masterSharedMem_u32 = (Ram_Buf_Handle)usart2StructMem_u32;
   \       0x88   0x4669             MOV      R1,SP
   \       0x8A   0x7809             LDRB     R1,[R1, #+0]
   \       0x8C   0x2216             MOVS     R2,#+22
   \       0x8E   0x4351             MULS     R1,R2,R1
   \       0x90   0x1840             ADDS     R0,R0,R1
   \       0x92   0x0001             MOVS     R1,R0
   \       0x94   0x310B             ADDS     R1,R1,#+11
   \       0x96   0x6828             LDR      R0,[R5, #+0]
   \       0x98   0x....'....        BL       __aeabi_uwrite4
    391            
    392            usart2Control.seqMemRX_transparentMode_u32 = usart2SeqMemRX_transparentMode_u32;
   \       0x9C   0x....             LDR      R0,??DataTable5_2
   \       0x9E   0x6800             LDR      R0,[R0, #+0]
   \       0xA0   0x6020             STR      R0,[R4, #+0]
    393            usart2Control.seqMemTX_u32 = usart2SeqMemTX_u32;
   \       0xA2   0x6830             LDR      R0,[R6, #+0]
   \       0xA4   0x60A0             STR      R0,[R4, #+8]
    394            usart2Control.seqMemRX_u32 = usart2SeqMemRX_u32;
   \       0xA6   0x6838             LDR      R0,[R7, #+0]
   \       0xA8   0x6060             STR      R0,[R4, #+4]
    395            usart2Control.seqMem_InternalPipe_u32 = usart2InternalSeqMem_u32;
   \       0xAA   0x....             LDR      R0,??DataTable5_1
   \       0xAC   0x6800             LDR      R0,[R0, #+0]
   \       0xAE   0x60E0             STR      R0,[R4, #+12]
    396            usart2Control.errorCode_u8 = 0;
   \       0xB0   0x2000             MOVS     R0,#+0
   \       0xB2   0x0001             MOVS     R1,R0
   \       0xB4   0x2223             MOVS     R2,#+35
   \       0xB6   0x54A1             STRB     R1,[R4, R2]
    397            usart2Control.UsartMode_u8 = 0;
   \       0xB8   0x2122             MOVS     R1,#+34
   \       0xBA   0x5460             STRB     R0,[R4, R1]
    398          }
   \       0xBC   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    399          

   \                                 In section .text, align 2, keep-with-next
    400          void parseMessage_BulkMonitoring(unsigned int data_length) { 
   \                     parseMessage_BulkMonitoring: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x0007             MOVS     R7,R0
    401            if (data_length < MESSAGE_LENGTH_UP_BULK_MONITORING) {
   \        0x6   0x2F15             CMP      R7,#+21
   \        0x8   0xD200             BCS      .+4
   \        0xA   0xE0D6             B        ??parseMessage_BulkMonitoring_0
    402              return;
    403            } else {
    404              test_counter_bulk_monitoring += 1;
   \                     ??parseMessage_BulkMonitoring_1: (+1)
   \        0xC   0x....             LDR      R0,??DataTable5_6
   \        0xE   0x7801             LDRB     R1,[R0, #+0]
   \       0x10   0x1C49             ADDS     R1,R1,#+1
   \       0x12   0x7001             STRB     R1,[R0, #+0]
    405              // Received message will be of the following format.
    406              // uint8_t message[] = {0x55, 14, 0x4D, 0x00, 0x00, 
    407              //                      0xff, 0xff, 0xff, 0xff, 0xff, // status_u8, faults_u16, bus_voltage_u16
    408              //                      0xff, 0xff, 0xff, 0xff, 0xff, // direction_u8, speed_i16, torque_i16
    409              //                      0xff, 0xff, 0xff, 0xff, // power_i16, temperature_i16
    410              //                      0xCC, 0xCC};// Just send 0x5AA5 to App-side and get a response
    411              
    412              uint8_t index = UNIVERSAL_PROTOCOL_DATA_START_INDEX;
   \       0x14   0x2505             MOVS     R5,#+5
    413              // 
    414              uint8_t status = RxCMD_Usart2[index++];
   \       0x16   0x....             LDR      R4,??DataTable5_7
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x0029             MOVS     R1,R5
   \       0x1C   0xB2C9             UXTB     R1,R1
   \       0x1E   0x5C40             LDRB     R0,[R0, R1]
   \       0x20   0x4669             MOV      R1,SP
   \       0x22   0x7048             STRB     R0,[R1, #+1]
   \       0x24   0x1C6D             ADDS     R5,R5,#+1
    415              uint16_t faults = RxCMD_Usart2[index++] << 8;
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x0029             MOVS     R1,R5
   \       0x2A   0xB2C9             UXTB     R1,R1
   \       0x2C   0x5C40             LDRB     R0,[R0, R1]
   \       0x2E   0x0200             LSLS     R0,R0,#+8
   \       0x30   0x1C6D             ADDS     R5,R5,#+1
    416              faults += RxCMD_Usart2[index++];
   \       0x32   0x6821             LDR      R1,[R4, #+0]
   \       0x34   0x002A             MOVS     R2,R5
   \       0x36   0xB2D2             UXTB     R2,R2
   \       0x38   0x5C89             LDRB     R1,[R1, R2]
   \       0x3A   0x1840             ADDS     R0,R0,R1
   \       0x3C   0x4669             MOV      R1,SP
   \       0x3E   0x8188             STRH     R0,[R1, #+12]
   \       0x40   0x1C6D             ADDS     R5,R5,#+1
    417              uint16_t regal_mc_status_u16 = (uint16_t) RxCMD_Usart2[index++];
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x0029             MOVS     R1,R5
   \       0x46   0xB2C9             UXTB     R1,R1
   \       0x48   0x5C40             LDRB     R0,[R0, R1]
   \       0x4A   0x4669             MOV      R1,SP
   \       0x4C   0x8148             STRH     R0,[R1, #+10]
   \       0x4E   0x1C6D             ADDS     R5,R5,#+1
    418              
    419              uint16_t bus_voltage = RxCMD_Usart2[index++] << 8;
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x0029             MOVS     R1,R5
   \       0x54   0xB2C9             UXTB     R1,R1
   \       0x56   0x5C40             LDRB     R0,[R0, R1]
   \       0x58   0x0200             LSLS     R0,R0,#+8
   \       0x5A   0x1C6D             ADDS     R5,R5,#+1
    420              bus_voltage += RxCMD_Usart2[index++];
   \       0x5C   0x6821             LDR      R1,[R4, #+0]
   \       0x5E   0x002A             MOVS     R2,R5
   \       0x60   0xB2D2             UXTB     R2,R2
   \       0x62   0x5C89             LDRB     R1,[R1, R2]
   \       0x64   0x1840             ADDS     R0,R0,R1
   \       0x66   0x4669             MOV      R1,SP
   \       0x68   0x8108             STRH     R0,[R1, #+8]
   \       0x6A   0x1C6D             ADDS     R5,R5,#+1
    421              //
    422              uint8_t direction = RxCMD_Usart2[index++];
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x0029             MOVS     R1,R5
   \       0x70   0xB2C9             UXTB     R1,R1
   \       0x72   0x5C40             LDRB     R0,[R0, R1]
   \       0x74   0x4669             MOV      R1,SP
   \       0x76   0x7008             STRB     R0,[R1, #+0]
   \       0x78   0x1C6D             ADDS     R5,R5,#+1
    423              
    424              int16_t measured_speed = RxCMD_Usart2[index++] << 8;
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x0029             MOVS     R1,R5
   \       0x7E   0xB2C9             UXTB     R1,R1
   \       0x80   0x5C40             LDRB     R0,[R0, R1]
   \       0x82   0x0200             LSLS     R0,R0,#+8
   \       0x84   0x1C6D             ADDS     R5,R5,#+1
    425              measured_speed += RxCMD_Usart2[index++];
   \       0x86   0x6821             LDR      R1,[R4, #+0]
   \       0x88   0x002A             MOVS     R2,R5
   \       0x8A   0xB2D2             UXTB     R2,R2
   \       0x8C   0x5C89             LDRB     R1,[R1, R2]
   \       0x8E   0x1840             ADDS     R0,R0,R1
   \       0x90   0x4669             MOV      R1,SP
   \       0x92   0x8048             STRH     R0,[R1, #+2]
   \       0x94   0x1C6D             ADDS     R5,R5,#+1
    426              measured_speed=abs(measured_speed);
   \       0x96   0x9800             LDR      R0,[SP, #+0]
   \       0x98   0x1400             ASRS     R0,R0,#+16
   \       0x9A   0x....'....        BL       abs
   \       0x9E   0x0006             MOVS     R6,R0
    427              // Measured Torque
    428              int16_t torque = RxCMD_Usart2[index++] << 8;
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x0029             MOVS     R1,R5
   \       0xA4   0xB2C9             UXTB     R1,R1
   \       0xA6   0x5C40             LDRB     R0,[R0, R1]
   \       0xA8   0x0201             LSLS     R1,R0,#+8
   \       0xAA   0x1C6D             ADDS     R5,R5,#+1
   \       0xAC   0x0028             MOVS     R0,R5
    429              torque += RxCMD_Usart2[index++];
   \       0xAE   0x6822             LDR      R2,[R4, #+0]
   \       0xB0   0x0003             MOVS     R3,R0
   \       0xB2   0xB2DB             UXTB     R3,R3
   \       0xB4   0x5CD2             LDRB     R2,[R2, R3]
   \       0xB6   0x1889             ADDS     R1,R1,R2
   \       0xB8   0x466A             MOV      R2,SP
   \       0xBA   0x80D1             STRH     R1,[R2, #+6]
   \       0xBC   0x1C40             ADDS     R0,R0,#+1
    430              //
    431              int16_t power = RxCMD_Usart2[index++] << 8;
   \       0xBE   0x6821             LDR      R1,[R4, #+0]
   \       0xC0   0x0002             MOVS     R2,R0
   \       0xC2   0xB2D2             UXTB     R2,R2
   \       0xC4   0x5C89             LDRB     R1,[R1, R2]
   \       0xC6   0x0209             LSLS     R1,R1,#+8
   \       0xC8   0x1C40             ADDS     R0,R0,#+1
    432              power += RxCMD_Usart2[index++];
   \       0xCA   0x6822             LDR      R2,[R4, #+0]
   \       0xCC   0x0003             MOVS     R3,R0
   \       0xCE   0xB2DB             UXTB     R3,R3
   \       0xD0   0x5CD2             LDRB     R2,[R2, R3]
   \       0xD2   0x1889             ADDS     R1,R1,R2
   \       0xD4   0x466A             MOV      R2,SP
   \       0xD6   0x8091             STRH     R1,[R2, #+4]
   \       0xD8   0x1C40             ADDS     R0,R0,#+1
    433              
    434              int16_t temperature = RxCMD_Usart2[index++] << 8;
   \       0xDA   0x6821             LDR      R1,[R4, #+0]
   \       0xDC   0x0002             MOVS     R2,R0
   \       0xDE   0xB2D2             UXTB     R2,R2
   \       0xE0   0x5C89             LDRB     R1,[R1, R2]
   \       0xE2   0x0209             LSLS     R1,R1,#+8
   \       0xE4   0x1C40             ADDS     R0,R0,#+1
    435              temperature += RxCMD_Usart2[index++]; 
   \       0xE6   0x6822             LDR      R2,[R4, #+0]
   \       0xE8   0x0003             MOVS     R3,R0
   \       0xEA   0xB2DB             UXTB     R3,R3
   \       0xEC   0x5CD2             LDRB     R2,[R2, R3]
   \       0xEE   0x1889             ADDS     R1,R1,R2
   \       0xF0   0x466A             MOV      R2,SP
   \       0xF2   0x8051             STRH     R1,[R2, #+2]
   \       0xF4   0x1C40             ADDS     R0,R0,#+1
    436              
    437               // Measured phase peak current Ia
    438                  int16_t ia_s16 = RxCMD_Usart2[index++] << 8;
   \       0xF6   0x6821             LDR      R1,[R4, #+0]
   \       0xF8   0x0002             MOVS     R2,R0
   \       0xFA   0xB2D2             UXTB     R2,R2
   \       0xFC   0x5C89             LDRB     R1,[R1, R2]
   \       0xFE   0x0209             LSLS     R1,R1,#+8
   \      0x100   0x1C40             ADDS     R0,R0,#+1
    439                  ia_s16 += RxCMD_Usart2[index++];
   \      0x102   0x6822             LDR      R2,[R4, #+0]
   \      0x104   0x0003             MOVS     R3,R0
   \      0x106   0xB2DB             UXTB     R3,R3
   \      0x108   0x5CD2             LDRB     R2,[R2, R3]
   \      0x10A   0x1889             ADDS     R1,R1,R2
   \      0x10C   0x466A             MOV      R2,SP
   \      0x10E   0x8251             STRH     R1,[R2, #+18]
   \      0x110   0x1C40             ADDS     R0,R0,#+1
    440                  // Measured phase peak current Ib
    441                  int16_t ib_s16 = RxCMD_Usart2[index++] << 8;
   \      0x112   0x6821             LDR      R1,[R4, #+0]
   \      0x114   0x0002             MOVS     R2,R0
   \      0x116   0xB2D2             UXTB     R2,R2
   \      0x118   0x5C89             LDRB     R1,[R1, R2]
   \      0x11A   0x0209             LSLS     R1,R1,#+8
   \      0x11C   0x1C40             ADDS     R0,R0,#+1
    442                  ib_s16 += RxCMD_Usart2[index++];
   \      0x11E   0x6822             LDR      R2,[R4, #+0]
   \      0x120   0x0003             MOVS     R3,R0
   \      0x122   0xB2DB             UXTB     R3,R3
   \      0x124   0x5CD2             LDRB     R2,[R2, R3]
   \      0x126   0x1889             ADDS     R1,R1,R2
   \      0x128   0x466A             MOV      R2,SP
   \      0x12A   0x8211             STRH     R1,[R2, #+16]
   \      0x12C   0x1C40             ADDS     R0,R0,#+1
    443          
    444                  // Phase currents Ia and Ib
    445                  int16_t current_ia_s16 = RxCMD_Usart2[index++] << 8;
   \      0x12E   0x6821             LDR      R1,[R4, #+0]
   \      0x130   0x0002             MOVS     R2,R0
   \      0x132   0xB2D2             UXTB     R2,R2
   \      0x134   0x5C89             LDRB     R1,[R1, R2]
   \      0x136   0x0209             LSLS     R1,R1,#+8
   \      0x138   0x1C40             ADDS     R0,R0,#+1
    446                  current_ia_s16 += RxCMD_Usart2[index++];
   \      0x13A   0x6822             LDR      R2,[R4, #+0]
   \      0x13C   0x0003             MOVS     R3,R0
   \      0x13E   0xB2DB             UXTB     R3,R3
   \      0x140   0x5CD2             LDRB     R2,[R2, R3]
   \      0x142   0x188D             ADDS     R5,R1,R2
   \      0x144   0x1C40             ADDS     R0,R0,#+1
    447                  int16_t current_ib_s16 = RxCMD_Usart2[index++] << 8;
   \      0x146   0x6821             LDR      R1,[R4, #+0]
   \      0x148   0x0002             MOVS     R2,R0
   \      0x14A   0xB2D2             UXTB     R2,R2
   \      0x14C   0x5C89             LDRB     R1,[R1, R2]
   \      0x14E   0x0209             LSLS     R1,R1,#+8
   \      0x150   0x1C40             ADDS     R0,R0,#+1
    448                  current_ib_s16 += RxCMD_Usart2[index++];
   \      0x152   0x6822             LDR      R2,[R4, #+0]
   \      0x154   0x0003             MOVS     R3,R0
   \      0x156   0xB2DB             UXTB     R3,R3
   \      0x158   0x5CD2             LDRB     R2,[R2, R3]
   \      0x15A   0x188C             ADDS     R4,R1,R2
   \      0x15C   0x1C40             ADDS     R0,R0,#+1
   \      0x15E   0x4669             MOV      R1,SP
   \      0x160   0x7388             STRB     R0,[R1, #+14]
    449          
    450          
    451              
    452              // Send Data to Motor Parameter Table (used by modbus)
    453              // - TODO: Motor State Stuff should go in it's own module, so that both Universal Protocol, Bluetooth, and Modbus can use it
    454              Modbus_UpdateStoredStatus(status);
   \      0x162   0x4668             MOV      R0,SP
   \      0x164   0x7840             LDRB     R0,[R0, #+1]
   \      0x166   0x....'....        BL       Modbus_UpdateStoredStatus
    455              Modbus_UpdateStoredFaults(faults);
   \      0x16A   0x4668             MOV      R0,SP
   \      0x16C   0x8980             LDRH     R0,[R0, #+12]
   \      0x16E   0x....'....        BL       Modbus_UpdateStoredFaults
    456               Modbus_UpdateStoredRegalMCStatus(regal_mc_status_u16);
                      ^
Warning[Pe223]: function "Modbus_UpdateStoredRegalMCStatus" declared implicitly
   \      0x172   0x4668             MOV      R0,SP
   \      0x174   0x8940             LDRH     R0,[R0, #+10]
   \      0x176   0x....'....        BL       Modbus_UpdateStoredRegalMCStatus
    457              Modbus_UpdateStoredBusVoltage(bus_voltage);
   \      0x17A   0x4668             MOV      R0,SP
   \      0x17C   0x8900             LDRH     R0,[R0, #+8]
   \      0x17E   0x....'....        BL       Modbus_UpdateStoredBusVoltage
    458              //
    459              Modbus_UpdateStoredDirection(direction);
   \      0x182   0x4668             MOV      R0,SP
   \      0x184   0x7800             LDRB     R0,[R0, #+0]
   \      0x186   0x....'....        BL       Modbus_UpdateStoredDirection
    460              Modbus_UpdateStoredMeasuredSpeed(measured_speed);
   \      0x18A   0x0030             MOVS     R0,R6
   \      0x18C   0xB200             SXTH     R0,R0
   \      0x18E   0x....'....        BL       Modbus_UpdateStoredMeasuredSpeed
    461              Modbus_UpdateStoredTorque(torque);
   \      0x192   0x9801             LDR      R0,[SP, #+4]
   \      0x194   0x1400             ASRS     R0,R0,#+16
   \      0x196   0x....'....        BL       Modbus_UpdateStoredTorque
    462              //
    463              Modbus_UpdateStoredPower(power);
   \      0x19A   0x9801             LDR      R0,[SP, #+4]
   \      0x19C   0xB200             SXTH     R0,R0
   \      0x19E   0x....'....        BL       Modbus_UpdateStoredPower
    464              Modbus_UpdateStoredTemperature(temperature);
   \      0x1A2   0x9800             LDR      R0,[SP, #+0]
   \      0x1A4   0x1400             ASRS     R0,R0,#+16
   \      0x1A6   0x....'....        BL       Modbus_UpdateStoredTemperature
    465              
    466              Modbus_UpdateStoredPhaseCurrentIa(current_ia_s16);
                     ^
Warning[Pe223]: function "Modbus_UpdateStoredPhaseCurrentIa" declared
          implicitly
   \      0x1AA   0x0028             MOVS     R0,R5
   \      0x1AC   0xB200             SXTH     R0,R0
   \      0x1AE   0x....'....        BL       Modbus_UpdateStoredPhaseCurrentIa
    467              Modbus_UpdateStoredPhaseCurrentIb(current_ib_s16);
                     ^
Warning[Pe223]: function "Modbus_UpdateStoredPhaseCurrentIb" declared
          implicitly
   \      0x1B2   0x0020             MOVS     R0,R4
   \      0x1B4   0xB200             SXTH     R0,R0
   \      0x1B6   0x....'....        BL       Modbus_UpdateStoredPhaseCurrentIb
    468              
    469            }
    470          }
   \                     ??parseMessage_BulkMonitoring_0: (+1)
   \      0x1BA   0xB005             ADD      SP,SP,#+20
   \      0x1BC   0xBDF0             POP      {R4-R7,PC}       ;; return
    471          

   \                                 In section .text, align 2, keep-with-next
    472          void parseMessage_DriveFlashData(unsigned int data_length) {     
   \                     parseMessage_DriveFlashData: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    473              uint8_t index_u8 = UNIVERSAL_PROTOCOL_DATA_START_INDEX;
   \        0x4   0x2505             MOVS     R5,#+5
    474              uint8_t *data_address_pu8 = &(RxCMD_Usart2[index_u8]);
   \        0x6   0x....             LDR      R0,??DataTable5_7
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x0029             MOVS     R1,R5
   \        0xC   0xB2C9             UXTB     R1,R1
   \        0xE   0x1846             ADDS     R6,R0,R1
    475              
    476              // Send Data to Modbus Module to process Modbus response
    477          	Modbus_PassDriveFlashData(data_address_pu8, data_length);
   \       0x10   0x0021             MOVS     R1,R4
   \       0x12   0xB289             UXTH     R1,R1
   \       0x14   0x0030             MOVS     R0,R6
   \       0x16   0x....'....        BL       Modbus_PassDriveFlashData
    478          } 
   \       0x1A   0xBD70             POP      {R4-R6,PC}       ;; return
    479          

   \                                 In section .text, align 2, keep-with-next
    480          void parseMessage_EEPROMData(unsigned int data_length) {     
   \                     parseMessage_EEPROMData: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    481              uint8_t index_u8 = UNIVERSAL_PROTOCOL_DATA_START_INDEX;
   \        0x4   0x2505             MOVS     R5,#+5
    482              uint8_t *data_address_pu8 = &(RxCMD_Usart2[index_u8]);
   \        0x6   0x....             LDR      R0,??DataTable5_7
   \        0x8   0x6800             LDR      R0,[R0, #+0]
   \        0xA   0x0029             MOVS     R1,R5
   \        0xC   0xB2C9             UXTB     R1,R1
   \        0xE   0x1846             ADDS     R6,R0,R1
    483              
    484              // Send Data to Modbus Module to process Modbus response
    485          	Modbus_PassEEPROMData(data_address_pu8, data_length);
   \       0x10   0x0021             MOVS     R1,R4
   \       0x12   0xB289             UXTH     R1,R1
   \       0x14   0x0030             MOVS     R0,R6
   \       0x16   0x....'....        BL       Modbus_PassEEPROMData
    486          }
   \       0x1A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \        0x0   0x....'....        DC32     usart2CaptureLen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     usart2Control

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x4000'4400        DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     indexTx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x....'....        DC32     RxCMD_Usart2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x5000'0800        DC32     0x50000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     processInfoTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x....'....        DC32     usart2InternalSeqMem_u32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x....'....        DC32     usart2SeqMemRX_transparentMode_u32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x....'....        DC32     usart2SeqMemRX_u32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0x....'....        DC32     usart2SeqMemTX_u32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \        0x0   0x....'....        DC32     usart2StructMem_u32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \        0x0   0x....'....        DC32     test_counter_bulk_monitoring

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \        0x0   0x....'....        DC32     RxCMD_Usart2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x55 0x02          DC8 85, 2, 78, 0, 0, 15, 160, 204, 204

   \              0x4E 0x00    

   \              0x00 0x0F    

   \              0xA0 0xCC    

   \              0xCC
   \        0x9                      DS8 3

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   LL_GPIO_TogglePin
       0   LL_USART_DisableIT_RXNE_RXFNE
       0   LL_USART_EnableIT_RXNE_RXFNE
      32   assign_UART2_ModuleMem
        32   -> SeqMem_CreateInstance
        32   -> StructMem_CreateInstance
        32   -> getProcessInfoIndex
        32 __aeabi_uwrite4
      64   moduleUsart2_u32
        64   -> LL_GPIO_TogglePin
        64   -> LL_USART_DisableIT_RXNE_RXFNE
        64   -> LL_USART_EnableIT_RXNE_RXFNE
        64   -> Modbus_UpdateStoredMeasuredSpeed
        64   -> RingBuf_GetUsedNumOfElements
        64   -> RingBuf_Observe
        64   -> RingBuf_ReadBlock
        64   -> RingBuf_WriteBlock
        64   -> TxProcess
        64   -> Usart2IdlePatch_RxIsIdle
        64   -> abs
        64   -> assign_UART2_ModuleMem
        64   -> getProcessInfoIndex
        64   -> parseMessage_BulkMonitoring
        64   -> parseMessage_DriveFlashData
        64   -> parseMessage_EEPROMData
        64   -> protocolHeaderfetch
        64   -> usart2_Init
      40   parseMessage_BulkMonitoring
        40   -> Modbus_UpdateStoredBusVoltage
        40   -> Modbus_UpdateStoredDirection
        40   -> Modbus_UpdateStoredFaults
        40   -> Modbus_UpdateStoredMeasuredSpeed
        40   -> Modbus_UpdateStoredPhaseCurrentIa
        40   -> Modbus_UpdateStoredPhaseCurrentIb
        40   -> Modbus_UpdateStoredPower
        40   -> Modbus_UpdateStoredRegalMCStatus
        40   -> Modbus_UpdateStoredStatus
        40   -> Modbus_UpdateStoredTemperature
        40   -> Modbus_UpdateStoredTorque
        40   -> abs
      16   parseMessage_DriveFlashData
        16   -> Modbus_PassDriveFlashData
      16   parseMessage_EEPROMData
        16   -> Modbus_PassEEPROMData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
      12  ?_0
       2  Actual_Measured_Speed
       8  LL_GPIO_TogglePin
      10  LL_USART_DisableIT_RXNE_RXFNE
      10  LL_USART_EnableIT_RXNE_RXFNE
       1  Motor_Avg_Counter_u8
       2  Motor_Avg_Speed_s16
       4  RxCMD_Usart2
     190  assign_UART2_ModuleMem
      80  fixedRxCMD_Usart2
       1  fixedRxCMD_Usart2_Length
     648  moduleUsart2_u32
     446  parseMessage_BulkMonitoring
      28  parseMessage_DriveFlashData
      28  parseMessage_EEPROMData
       1  test_counter_bulk_monitoring
       4  usart2InternalSeqMem_u32
       4  usart2SeqMemRX_transparentMode_u32
       4  usart2SeqMemRX_u32
       4  usart2SeqMemTX_u32
       4  usart2StructMem_u32

 
   107 bytes in section .bss
     4 bytes in section .data
    12 bytes in section .rodata
 1'428 bytes in section .text
 
 1'428 bytes of CODE  memory
    12 bytes of CONST memory
   111 bytes of DATA  memory

Errors: none
Warnings: 4

###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         04/Feb/2022  12:58:56
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_tim.c
#    Command line      =
#        -f C:\Users\610126~1\AppData\Local\Temp\EW9B1.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_tim.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\stm32g0xx_hal_tim.lst
#    Object file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\stm32g0xx_hal_tim.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32g0xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Timer (TIM) peripheral:
      8            *           + TIM Time Base Initialization
      9            *           + TIM Time Base Start
     10            *           + TIM Time Base Start Interruption
     11            *           + TIM Time Base Start DMA
     12            *           + TIM Output Compare/PWM Initialization
     13            *           + TIM Output Compare/PWM Channel Configuration
     14            *           + TIM Output Compare/PWM  Start
     15            *           + TIM Output Compare/PWM  Start Interruption
     16            *           + TIM Output Compare/PWM Start DMA
     17            *           + TIM Input Capture Initialization
     18            *           + TIM Input Capture Channel Configuration
     19            *           + TIM Input Capture Start
     20            *           + TIM Input Capture Start Interruption
     21            *           + TIM Input Capture Start DMA
     22            *           + TIM One Pulse Initialization
     23            *           + TIM One Pulse Channel Configuration
     24            *           + TIM One Pulse Start
     25            *           + TIM Encoder Interface Initialization
     26            *           + TIM Encoder Interface Start
     27            *           + TIM Encoder Interface Start Interruption
     28            *           + TIM Encoder Interface Start DMA
     29            *           + Commutation Event configuration with Interruption and DMA
     30            *           + TIM OCRef clear configuration
     31            *           + TIM External Clock configuration
     32            @verbatim
     33            ==============================================================================
     34                                ##### TIMER Generic features #####
     35            ==============================================================================
     36            [..] The Timer features include:
     37                 (#) 16-bit up, down, up/down auto-reload counter.
     38                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the
     39                     counter clock frequency either by any factor between 1 and 65536.
     40                 (#) Up to 4 independent channels for:
     41                     (++) Input Capture
     42                     (++) Output Compare
     43                     (++) PWM generation (Edge and Center-aligned Mode)
     44                     (++) One-pulse mode output
     45                 (#) Synchronization circuit to control the timer with external signals and to interconnect
     46                      several timers together.
     47                 (#) Supports incremental encoder for positioning purposes
     48          
     49                      ##### How to use this driver #####
     50            ==============================================================================
     51              [..]
     52               (#) Initialize the TIM low level resources by implementing the following functions
     53                   depending on the selected feature:
     54                     (++) Time Base : HAL_TIM_Base_MspInit()
     55                     (++) Input Capture : HAL_TIM_IC_MspInit()
     56                     (++) Output Compare : HAL_TIM_OC_MspInit()
     57                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     58                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     59                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     60          
     61               (#) Initialize the TIM low level resources :
     62                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     63                  (##) TIM pins configuration
     64                      (+++) Enable the clock for the TIM GPIOs using the following function:
     65                       __HAL_RCC_GPIOx_CLK_ENABLE();
     66                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     67          
     68               (#) The external Clock can be configured, if needed (the default clock is the
     69                   internal clock from the APBx), using the following function:
     70                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     71                   any start function.
     72          
     73               (#) Configure the TIM in the desired functioning mode using one of the
     74                 Initialization function of this driver:
     75                 (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     76                 (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an
     77                      Output Compare signal.
     78                 (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a
     79                      PWM signal.
     80                 (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an
     81                      external signal.
     82                 (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer
     83                      in One Pulse Mode.
     84                 (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     85          
     86               (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
     87                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     88                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     89                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     90                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     91                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     92                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     93          
     94               (#) The DMA Burst is managed with the two following functions:
     95                   HAL_TIM_DMABurst_WriteStart()
     96                   HAL_TIM_DMABurst_ReadStart()
     97          
     98              *** Callback registration ***
     99            =============================================
    100          
    101            [..]
    102            The compilation define  USE_HAL_TIM_REGISTER_CALLBACKS when set to 1
    103            allows the user to configure dynamically the driver callbacks.
    104          
    105            [..]
    106            Use Function @ref HAL_TIM_RegisterCallback() to register a callback.
    107            @ref HAL_TIM_RegisterCallback() takes as parameters the HAL peripheral handle,
    108            the Callback ID and a pointer to the user callback function.
    109          
    110            [..]
    111            Use function @ref HAL_TIM_UnRegisterCallback() to reset a callback to the default
    112            weak function.
    113            @ref HAL_TIM_UnRegisterCallback takes as parameters the HAL peripheral handle,
    114            and the Callback ID.
    115          
    116            [..]
    117            These functions allow to register/unregister following callbacks:
    118              (+) Base_MspInitCallback              : TIM Base Msp Init Callback.
    119              (+) Base_MspDeInitCallback            : TIM Base Msp DeInit Callback.
    120              (+) IC_MspInitCallback                : TIM IC Msp Init Callback.
    121              (+) IC_MspDeInitCallback              : TIM IC Msp DeInit Callback.
    122              (+) OC_MspInitCallback                : TIM OC Msp Init Callback.
    123              (+) OC_MspDeInitCallback              : TIM OC Msp DeInit Callback.
    124              (+) PWM_MspInitCallback               : TIM PWM Msp Init Callback.
    125              (+) PWM_MspDeInitCallback             : TIM PWM Msp DeInit Callback.
    126              (+) OnePulse_MspInitCallback          : TIM One Pulse Msp Init Callback.
    127              (+) OnePulse_MspDeInitCallback        : TIM One Pulse Msp DeInit Callback.
    128              (+) Encoder_MspInitCallback           : TIM Encoder Msp Init Callback.
    129              (+) Encoder_MspDeInitCallback         : TIM Encoder Msp DeInit Callback.
    130              (+) HallSensor_MspInitCallback        : TIM Hall Sensor Msp Init Callback.
    131              (+) HallSensor_MspDeInitCallback      : TIM Hall Sensor Msp DeInit Callback.
    132              (+) PeriodElapsedCallback             : TIM Period Elapsed Callback.
    133              (+) PeriodElapsedHalfCpltCallback     : TIM Period Elapsed half complete Callback.
    134              (+) TriggerCallback                   : TIM Trigger Callback.
    135              (+) TriggerHalfCpltCallback           : TIM Trigger half complete Callback.
    136              (+) IC_CaptureCallback                : TIM Input Capture Callback.
    137              (+) IC_CaptureHalfCpltCallback        : TIM Input Capture half complete Callback.
    138              (+) OC_DelayElapsedCallback           : TIM Output Compare Delay Elapsed Callback.
    139              (+) PWM_PulseFinishedCallback         : TIM PWM Pulse Finished Callback.
    140              (+) PWM_PulseFinishedHalfCpltCallback : TIM PWM Pulse Finished half complete Callback.
    141              (+) ErrorCallback                     : TIM Error Callback.
    142              (+) CommutationCallback               : TIM Commutation Callback.
    143              (+) CommutationHalfCpltCallback       : TIM Commutation half complete Callback.
    144              (+) BreakCallback                     : TIM Break Callback.
    145              (+) Break2Callback                    : TIM Break2 Callback.
    146          
    147            [..]
    148          By default, after the Init and when the state is HAL_TIM_STATE_RESET
    149          all interrupt callbacks are set to the corresponding weak functions:
    150            examples @ref HAL_TIM_TriggerCallback(), @ref HAL_TIM_ErrorCallback().
    151          
    152            [..]
    153            Exception done for MspInit and MspDeInit functions that are reset to the legacy weak
    154            functionalities in the Init / DeInit only when these callbacks are null
    155            (not registered beforehand). If not, MspInit or MspDeInit are not null, the Init / DeInit
    156              keep and use the user MspInit / MspDeInit callbacks(registered beforehand)
    157          
    158            [..]
    159              Callbacks can be registered / unregistered in HAL_TIM_STATE_READY state only.
    160              Exception done MspInit / MspDeInit that can be registered / unregistered
    161              in HAL_TIM_STATE_READY or HAL_TIM_STATE_RESET state,
    162              thus registered(user) MspInit / DeInit callbacks can be used during the Init / DeInit.
    163            In that case first register the MspInit/MspDeInit user callbacks
    164                using @ref HAL_TIM_RegisterCallback() before calling DeInit or Init function.
    165          
    166            [..]
    167                When The compilation define USE_HAL_TIM_REGISTER_CALLBACKS is set to 0 or
    168                not defined, the callback registration feature is not available and all callbacks
    169                are set to the corresponding weak functions.
    170          
    171            @endverbatim
    172            ******************************************************************************
    173            * @attention
    174            *
    175            * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics.
    176            * All rights reserved.</center></h2>
    177            *
    178            * This software component is licensed by ST under BSD 3-Clause license,
    179            * the "License"; You may not use this file except in compliance with the
    180            * License. You may obtain a copy of the License at:
    181            *                        opensource.org/licenses/BSD-3-Clause
    182            *
    183            ******************************************************************************
    184            */
    185          
    186          /* Includes ------------------------------------------------------------------*/
    187          #include "stm32g0xx_hal.h"
    188          
    189          /** @addtogroup STM32G0xx_HAL_Driver
    190            * @{
    191            */
    192          
    193          /** @defgroup TIM TIM
    194            * @brief TIM HAL module driver
    195            * @{
    196            */
    197          
    198          #ifdef HAL_TIM_MODULE_ENABLED
    199          
    200          /* Private typedef -----------------------------------------------------------*/
    201          /* Private define ------------------------------------------------------------*/
    202          /** @addtogroup TIM_Private_Constants
    203            * @{
    204            */
    205          #define TIMx_OR1_OCREF_CLR 0x00000001U
    206          /**
    207            * @}
    208            */
    209          
    210          /* Private macro -------------------------------------------------------------*/
    211          /* Private variables ---------------------------------------------------------*/
    212          /* Private function prototypes -----------------------------------------------*/
    213          /** @addtogroup TIM_Private_Functions
    214            * @{
    215            */
    216          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    217          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    218          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    219          static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    220          static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    221          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    222          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    223                                        uint32_t TIM_ICFilter);
    224          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    225          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    226                                        uint32_t TIM_ICFilter);
    227          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    228                                        uint32_t TIM_ICFilter);
    229          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource);
    230          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    231          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma);
    232          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    233          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma);
    234          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    235                                                            TIM_SlaveConfigTypeDef *sSlaveConfig);
    236          /**
    237            * @}
    238            */
    239          /* Exported functions --------------------------------------------------------*/
    240          
    241          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    242            * @{
    243            */
    244          
    245          /** @defgroup TIM_Exported_Functions_Group1 TIM Time Base functions
    246            *  @brief    Time Base functions
    247            *
    248          @verbatim
    249            ==============================================================================
    250                        ##### Time Base functions #####
    251            ==============================================================================
    252            [..]
    253              This section provides functions allowing to:
    254              (+) Initialize and configure the TIM base.
    255              (+) De-initialize the TIM base.
    256              (+) Start the Time Base.
    257              (+) Stop the Time Base.
    258              (+) Start the Time Base and enable interrupt.
    259              (+) Stop the Time Base and disable interrupt.
    260              (+) Start the Time Base and enable DMA transfer.
    261              (+) Stop the Time Base and disable DMA transfer.
    262          
    263          @endverbatim
    264            * @{
    265            */
    266          /**
    267            * @brief  Initializes the TIM Time base Unit according to the specified
    268            *         parameters in the TIM_HandleTypeDef and initialize the associated handle.
    269            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    270            *         requires a timer reset to avoid unexpected direction
    271            *         due to DIR bit readonly in center aligned mode.
    272            *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
    273            * @param  htim TIM Base handle
    274            * @retval HAL status
    275            */

   \                                 In section .text, align 2, keep-with-next
    276          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    277          {
   \                     HAL_TIM_Base_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    278            /* Check the TIM handle allocation */
    279            if (htim == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE      ??HAL_TIM_Base_Init_0
    280            {
    281              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE014             B        ??HAL_TIM_Base_Init_1
    282            }
    283          
    284            /* Check the parameters */
    285            assert_param(IS_TIM_INSTANCE(htim->Instance));
    286            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    287            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    288            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    289          
    290            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Base_Init_0: (+1)
   \        0xC   0x203D             MOVS     R0,#+61
   \        0xE   0x5C20             LDRB     R0,[R4, R0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE      ??HAL_TIM_Base_Init_2
    291            {
    292              /* Allocate lock resource and initialize it */
    293              htim->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x213C             MOVS     R1,#+60
   \       0x18   0x5460             STRB     R0,[R4, R1]
    294          
    295          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    296              /* Reset interrupt callbacks to legacy weak callbacks */
    297              TIM_ResetCallback(htim);
    298          
    299              if (htim->Base_MspInitCallback == NULL)
    300              {
    301                htim->Base_MspInitCallback = HAL_TIM_Base_MspInit;
    302              }
    303              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    304              htim->Base_MspInitCallback(htim);
    305          #else
    306              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    307              HAL_TIM_Base_MspInit(htim);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x....'....        BL       HAL_TIM_Base_MspInit
    308          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    309            }
    310          
    311            /* Set the TIM state */
    312            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Init_2: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0x213D             MOVS     R1,#+61
   \       0x24   0x5460             STRB     R0,[R4, R1]
    313          
    314            /* Set the Time Base configuration */
    315            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x26   0x1D21             ADDS     R1,R4,#+4
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x....'....        BL       TIM_Base_SetConfig
    316          
    317            /* Initialize the TIM state*/
    318            htim->State = HAL_TIM_STATE_READY;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x213D             MOVS     R1,#+61
   \       0x32   0x5460             STRB     R0,[R4, R1]
    319          
    320            return HAL_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Init_1: (+1)
   \       0x36   0xBD10             POP      {R4,PC}          ;; return
    321          }
    322          
    323          /**
    324            * @brief  DeInitializes the TIM Base peripheral
    325            * @param  htim TIM Base handle
    326            * @retval HAL status
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    329          {
   \                     HAL_TIM_Base_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    330            /* Check the parameters */
    331            assert_param(IS_TIM_INSTANCE(htim->Instance));
    332          
    333            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x213D             MOVS     R1,#+61
   \        0x8   0x5460             STRB     R0,[R4, R1]
    334          
    335            /* Disable the TIM Peripheral Clock */
    336            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable8  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD10B             BNE      ??HAL_TIM_Base_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0x....             LDR      R1,??DataTable9  ;; 0x444
   \       0x1C   0x4001             ANDS     R1,R1,R0
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD105             BNE      ??HAL_TIM_Base_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x4388             BICS     R0,R0,R1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
    337          
    338          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    339            if (htim->Base_MspDeInitCallback == NULL)
    340            {
    341              htim->Base_MspDeInitCallback = HAL_TIM_Base_MspDeInit;
    342            }
    343            /* DeInit the low level hardware */
    344            htim->Base_MspDeInitCallback(htim);
    345          #else
    346            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    347            HAL_TIM_Base_MspDeInit(htim);
   \                     ??HAL_TIM_Base_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x....'....        BL       HAL_TIM_Base_MspDeInit
    348          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    349          
    350            /* Change TIM state */
    351            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x0001             MOVS     R1,R0
   \       0x38   0x223D             MOVS     R2,#+61
   \       0x3A   0x54A1             STRB     R1,[R4, R2]
    352          
    353            /* Release Lock */
    354            __HAL_UNLOCK(htim);
   \       0x3C   0x213C             MOVS     R1,#+60
   \       0x3E   0x5460             STRB     R0,[R4, R1]
    355          
    356            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}          ;; return
    357          }
    358          
    359          /**
    360            * @brief  Initializes the TIM Base MSP.
    361            * @param  htim TIM Base handle
    362            * @retval None
    363            */

   \                                 In section .text, align 2
    364          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    365          {
    366            /* Prevent unused argument(s) compilation warning */
    367            UNUSED(htim);
    368          
    369            /* NOTE : This function should not be modified, when the callback is needed,
    370                      the HAL_TIM_Base_MspInit could be implemented in the user file
    371             */
    372          }
   \                     HAL_TIM_Base_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    373          
    374          /**
    375            * @brief  DeInitializes TIM Base MSP.
    376            * @param  htim TIM Base handle
    377            * @retval None
    378            */

   \                                 In section .text, align 2
    379          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    380          {
    381            /* Prevent unused argument(s) compilation warning */
    382            UNUSED(htim);
    383          
    384            /* NOTE : This function should not be modified, when the callback is needed,
    385                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    386             */
    387          }
   \                     HAL_TIM_Base_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    388          
    389          
    390          /**
    391            * @brief  Starts the TIM Base generation.
    392            * @param  htim TIM Base handle
    393            * @retval HAL status
    394            */

   \                                 In section .text, align 2, keep-with-next
    395          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    396          {
   \                     HAL_TIM_Base_Start: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
    397            uint32_t tmpsmcr;
    398          
    399            /* Check the parameters */
    400            assert_param(IS_TIM_INSTANCE(htim->Instance));
    401          
    402            /* Set the TIM state */
    403            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x223D             MOVS     R2,#+61
   \        0x8   0x5488             STRB     R0,[R1, R2]
    404          
    405            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    406            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \        0xA   0x6808             LDR      R0,[R1, #+0]
   \        0xC   0x6880             LDR      R0,[R0, #+8]
   \        0xE   0x....             LDR      R2,??DataTable9_1  ;; 0x10007
   \       0x10   0x4002             ANDS     R2,R2,R0
    407            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x12   0x2A06             CMP      R2,#+6
   \       0x14   0xD009             BEQ      ??HAL_TIM_Base_Start_0
   \       0x16   0x2080             MOVS     R0,#+128
   \       0x18   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x1A   0x4282             CMP      R2,R0
   \       0x1C   0xD005             BEQ      ??HAL_TIM_Base_Start_0
    408            {
    409              __HAL_TIM_ENABLE(htim);
   \       0x1E   0x6808             LDR      R0,[R1, #+0]
   \       0x20   0x6800             LDR      R0,[R0, #+0]
   \       0x22   0x2301             MOVS     R3,#+1
   \       0x24   0x4303             ORRS     R3,R3,R0
   \       0x26   0x6808             LDR      R0,[R1, #+0]
   \       0x28   0x6003             STR      R3,[R0, #+0]
    410            }
    411          
    412            /* Change the TIM state*/
    413            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Start_0: (+1)
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0x233D             MOVS     R3,#+61
   \       0x2E   0x54C8             STRB     R0,[R1, R3]
    414          
    415            /* Return function status */
    416            return HAL_OK;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xBD00             POP      {PC}             ;; return
    417          }
    418          
    419          /**
    420            * @brief  Stops the TIM Base generation.
    421            * @param  htim TIM Base handle
    422            * @retval HAL status
    423            */

   \                                 In section .text, align 2, keep-with-next
    424          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    425          {
   \                     HAL_TIM_Base_Stop: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
    426            /* Check the parameters */
    427            assert_param(IS_TIM_INSTANCE(htim->Instance));
    428          
    429            /* Set the TIM state */
    430            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x223D             MOVS     R2,#+61
   \        0x8   0x5488             STRB     R0,[R1, R2]
    431          
    432            /* Disable the Peripheral */
    433            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6808             LDR      R0,[R1, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R2,??DataTable8  ;; 0x1111
   \       0x10   0x4002             ANDS     R2,R2,R0
   \       0x12   0x2A00             CMP      R2,#+0
   \       0x14   0xD10B             BNE      ??HAL_TIM_Base_Stop_0
   \       0x16   0x6808             LDR      R0,[R1, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0x....             LDR      R2,??DataTable9  ;; 0x444
   \       0x1C   0x4002             ANDS     R2,R2,R0
   \       0x1E   0x2A00             CMP      R2,#+0
   \       0x20   0xD105             BNE      ??HAL_TIM_Base_Stop_0
   \       0x22   0x6808             LDR      R0,[R1, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x2201             MOVS     R2,#+1
   \       0x28   0x4390             BICS     R0,R0,R2
   \       0x2A   0x680A             LDR      R2,[R1, #+0]
   \       0x2C   0x6010             STR      R0,[R2, #+0]
    434          
    435            /* Change the TIM state*/
    436            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_0: (+1)
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x223D             MOVS     R2,#+61
   \       0x32   0x5488             STRB     R0,[R1, R2]
    437          
    438            /* Return function status */
    439            return HAL_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD00             POP      {PC}             ;; return
    440          }
    441          
    442          /**
    443            * @brief  Starts the TIM Base generation in interrupt mode.
    444            * @param  htim TIM Base handle
    445            * @retval HAL status
    446            */

   \                                 In section .text, align 2, keep-with-next
    447          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    448          {
   \                     HAL_TIM_Base_Start_IT: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
    449            uint32_t tmpsmcr;
    450          
    451            /* Check the parameters */
    452            assert_param(IS_TIM_INSTANCE(htim->Instance));
    453          
    454            /* Enable the TIM Update interrupt */
    455            __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x68D2             LDR      R2,[R2, #+12]
   \        0xA   0x4302             ORRS     R2,R2,R0
   \        0xC   0x680B             LDR      R3,[R1, #+0]
   \        0xE   0x60DA             STR      R2,[R3, #+12]
    456          
    457            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    458            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x10   0x680A             LDR      R2,[R1, #+0]
   \       0x12   0x6893             LDR      R3,[R2, #+8]
   \       0x14   0x....             LDR      R2,??DataTable9_1  ;; 0x10007
   \       0x16   0x401A             ANDS     R2,R2,R3
    459            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x18   0x2A06             CMP      R2,#+6
   \       0x1A   0xD008             BEQ      ??HAL_TIM_Base_Start_IT_0
   \       0x1C   0x2380             MOVS     R3,#+128
   \       0x1E   0x025B             LSLS     R3,R3,#+9        ;; #+65536
   \       0x20   0x429A             CMP      R2,R3
   \       0x22   0xD004             BEQ      ??HAL_TIM_Base_Start_IT_0
    460            {
    461              __HAL_TIM_ENABLE(htim);
   \       0x24   0x680B             LDR      R3,[R1, #+0]
   \       0x26   0x681B             LDR      R3,[R3, #+0]
   \       0x28   0x4318             ORRS     R0,R0,R3
   \       0x2A   0x680B             LDR      R3,[R1, #+0]
   \       0x2C   0x6018             STR      R0,[R3, #+0]
    462            }
    463          
    464            /* Return function status */
    465            return HAL_OK;
   \                     ??HAL_TIM_Base_Start_IT_0: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBD00             POP      {PC}             ;; return
    466          }
    467          
    468          /**
    469            * @brief  Stops the TIM Base generation in interrupt mode.
    470            * @param  htim TIM Base handle
    471            * @retval HAL status
    472            */

   \                                 In section .text, align 2, keep-with-next
    473          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    474          {
   \                     HAL_TIM_Base_Stop_IT: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
    475            /* Check the parameters */
    476            assert_param(IS_TIM_INSTANCE(htim->Instance));
    477            /* Disable the TIM Update interrupt */
    478            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
   \        0x4   0x6808             LDR      R0,[R1, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0x4390             BICS     R0,R0,R2
   \        0xC   0x680A             LDR      R2,[R1, #+0]
   \        0xE   0x60D0             STR      R0,[R2, #+12]
    479          
    480            /* Disable the Peripheral */
    481            __HAL_TIM_DISABLE(htim);
   \       0x10   0x6808             LDR      R0,[R1, #+0]
   \       0x12   0x6A00             LDR      R0,[R0, #+32]
   \       0x14   0x....             LDR      R2,??DataTable8  ;; 0x1111
   \       0x16   0x4002             ANDS     R2,R2,R0
   \       0x18   0x2A00             CMP      R2,#+0
   \       0x1A   0xD10B             BNE      ??HAL_TIM_Base_Stop_IT_0
   \       0x1C   0x6808             LDR      R0,[R1, #+0]
   \       0x1E   0x6A00             LDR      R0,[R0, #+32]
   \       0x20   0x....             LDR      R2,??DataTable9  ;; 0x444
   \       0x22   0x4002             ANDS     R2,R2,R0
   \       0x24   0x2A00             CMP      R2,#+0
   \       0x26   0xD105             BNE      ??HAL_TIM_Base_Stop_IT_0
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x2201             MOVS     R2,#+1
   \       0x2E   0x4390             BICS     R0,R0,R2
   \       0x30   0x680A             LDR      R2,[R1, #+0]
   \       0x32   0x6010             STR      R0,[R2, #+0]
    482          
    483            /* Return function status */
    484            return HAL_OK;
   \                     ??HAL_TIM_Base_Stop_IT_0: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD00             POP      {PC}             ;; return
    485          }
    486          
    487          /**
    488            * @brief  Starts the TIM Base generation in DMA mode.
    489            * @param  htim TIM Base handle
    490            * @param  pData The source Buffer address.
    491            * @param  Length The length of data to be transferred from memory to peripheral.
    492            * @retval HAL status
    493            */

   \                                 In section .text, align 2, keep-with-next
    494          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    495          {
   \                     HAL_TIM_Base_Start_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0015             MOVS     R5,R2
    496            uint32_t tmpsmcr;
    497          
    498            /* Check the parameters */
    499            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    500          
    501            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0x8   0x203D             MOVS     R0,#+61
   \        0xA   0x5C20             LDRB     R0,[R4, R0]
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD101             BNE      ??HAL_TIM_Base_Start_DMA_0
    502            {
    503              return HAL_BUSY;
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE03C             B        ??HAL_TIM_Base_Start_DMA_1
    504            }
    505            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_Base_Start_DMA_0: (+1)
   \       0x14   0x203D             MOVS     R0,#+61
   \       0x16   0x5C20             LDRB     R0,[R4, R0]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD10A             BNE      ??HAL_TIM_Base_Start_DMA_2
    506            {
    507              if ((pData == NULL) && (Length > 0U))
   \       0x1C   0x2E00             CMP      R6,#+0
   \       0x1E   0xD105             BNE      ??HAL_TIM_Base_Start_DMA_3
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0xB280             UXTH     R0,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD001             BEQ      ??HAL_TIM_Base_Start_DMA_3
    508              {
    509                return HAL_ERROR;
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE030             B        ??HAL_TIM_Base_Start_DMA_1
    510              }
    511              else
    512              {
    513                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Base_Start_DMA_3: (+1)
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0x213D             MOVS     R1,#+61
   \       0x30   0x5460             STRB     R0,[R4, R1]
    514              }
    515            }
    516            else
    517            {
    518              /* nothing to do */
    519            }
    520          
    521            /* Set the DMA Period elapsed callbacks */
    522            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_Base_Start_DMA_2: (+1)
   \       0x32   0x....             LDR      R0,??DataTable10
   \       0x34   0x6A21             LDR      R1,[R4, #+32]
   \       0x36   0x62C8             STR      R0,[R1, #+44]
    523            htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   \       0x38   0x....             LDR      R0,??DataTable10_1
   \       0x3A   0x6A21             LDR      R1,[R4, #+32]
   \       0x3C   0x6308             STR      R0,[R1, #+48]
    524          
    525            /* Set the DMA error callback */
    526            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \       0x3E   0x....             LDR      R0,??DataTable10_2
   \       0x40   0x6A21             LDR      R1,[R4, #+32]
   \       0x42   0x6348             STR      R0,[R1, #+52]
    527          
    528            /* Enable the DMA channel */
    529            if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length) != HAL_OK)
   \       0x44   0x002B             MOVS     R3,R5
   \       0x46   0xB29B             UXTH     R3,R3
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x0002             MOVS     R2,R0
   \       0x4C   0x322C             ADDS     R2,R2,#+44
   \       0x4E   0x0031             MOVS     R1,R6
   \       0x50   0x6A20             LDR      R0,[R4, #+32]
   \       0x52   0x....'....        BL       HAL_DMA_Start_IT
   \       0x56   0x2800             CMP      R0,#+0
   \       0x58   0xD001             BEQ      ??HAL_TIM_Base_Start_DMA_4
    530            {
    531              return HAL_ERROR;
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0xE017             B        ??HAL_TIM_Base_Start_DMA_1
    532            }
    533          
    534            /* Enable the TIM Update DMA request */
    535            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
   \                     ??HAL_TIM_Base_Start_DMA_4: (+1)
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x68C0             LDR      R0,[R0, #+12]
   \       0x62   0x2180             MOVS     R1,#+128
   \       0x64   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x66   0x4301             ORRS     R1,R1,R0
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x60C1             STR      R1,[R0, #+12]
    536          
    537            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    538            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x6880             LDR      R0,[R0, #+8]
   \       0x70   0x....             LDR      R1,??DataTable9_1  ;; 0x10007
   \       0x72   0x4001             ANDS     R1,R1,R0
    539            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x74   0x2906             CMP      R1,#+6
   \       0x76   0xD009             BEQ      ??HAL_TIM_Base_Start_DMA_5
   \       0x78   0x2080             MOVS     R0,#+128
   \       0x7A   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x7C   0x4281             CMP      R1,R0
   \       0x7E   0xD005             BEQ      ??HAL_TIM_Base_Start_DMA_5
    540            {
    541              __HAL_TIM_ENABLE(htim);
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6800             LDR      R0,[R0, #+0]
   \       0x84   0x2201             MOVS     R2,#+1
   \       0x86   0x4302             ORRS     R2,R2,R0
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6002             STR      R2,[R0, #+0]
    542            }
    543          
    544            /* Return function status */
    545            return HAL_OK;
   \                     ??HAL_TIM_Base_Start_DMA_5: (+1)
   \       0x8C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Base_Start_DMA_1: (+1)
   \       0x8E   0xBD70             POP      {R4-R6,PC}       ;; return
    546          }
    547          
    548          /**
    549            * @brief  Stops the TIM Base generation in DMA mode.
    550            * @param  htim TIM Base handle
    551            * @retval HAL status
    552            */

   \                                 In section .text, align 2, keep-with-next
    553          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    554          {
   \                     HAL_TIM_Base_Stop_DMA: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    555            /* Check the parameters */
    556            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    557          
    558            /* Disable the TIM Update DMA request */
    559            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0x....             LDR      R1,??DataTable11  ;; 0xfffffeff
   \        0xA   0x4001             ANDS     R1,R1,R0
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    560          
    561            (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   \       0x10   0x6A20             LDR      R0,[R4, #+32]
   \       0x12   0x....'....        BL       HAL_DMA_Abort_IT
    562          
    563            /* Disable the Peripheral */
    564            __HAL_TIM_DISABLE(htim);
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0x....             LDR      R1,??DataTable8  ;; 0x1111
   \       0x1C   0x4001             ANDS     R1,R1,R0
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD10B             BNE      ??HAL_TIM_Base_Stop_DMA_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6A00             LDR      R0,[R0, #+32]
   \       0x26   0x....             LDR      R1,??DataTable9  ;; 0x444
   \       0x28   0x4001             ANDS     R1,R1,R0
   \       0x2A   0x2900             CMP      R1,#+0
   \       0x2C   0xD105             BNE      ??HAL_TIM_Base_Stop_DMA_0
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0x2101             MOVS     R1,#+1
   \       0x34   0x4388             BICS     R0,R0,R1
   \       0x36   0x6821             LDR      R1,[R4, #+0]
   \       0x38   0x6008             STR      R0,[R1, #+0]
    565          
    566            /* Change the htim state */
    567            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Base_Stop_DMA_0: (+1)
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0x213D             MOVS     R1,#+61
   \       0x3E   0x5460             STRB     R0,[R4, R1]
    568          
    569            /* Return function status */
    570            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}          ;; return
    571          }
    572          
    573          /**
    574            * @}
    575            */
    576          
    577          /** @defgroup TIM_Exported_Functions_Group2 TIM Output Compare functions
    578            *  @brief    TIM Output Compare functions
    579            *
    580          @verbatim
    581            ==============================================================================
    582                            ##### TIM Output Compare functions #####
    583            ==============================================================================
    584            [..]
    585              This section provides functions allowing to:
    586              (+) Initialize and configure the TIM Output Compare.
    587              (+) De-initialize the TIM Output Compare.
    588              (+) Start the TIM Output Compare.
    589              (+) Stop the TIM Output Compare.
    590              (+) Start the TIM Output Compare and enable interrupt.
    591              (+) Stop the TIM Output Compare and disable interrupt.
    592              (+) Start the TIM Output Compare and enable DMA transfer.
    593              (+) Stop the TIM Output Compare and disable DMA transfer.
    594          
    595          @endverbatim
    596            * @{
    597            */
    598          /**
    599            * @brief  Initializes the TIM Output Compare according to the specified
    600            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
    601            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    602            *         requires a timer reset to avoid unexpected direction
    603            *         due to DIR bit readonly in center aligned mode.
    604            *         Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
    605            * @param  htim TIM Output Compare handle
    606            * @retval HAL status
    607            */

   \                                 In section .text, align 2, keep-with-next
    608          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef *htim)
    609          {
   \                     HAL_TIM_OC_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    610            /* Check the TIM handle allocation */
    611            if (htim == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE      ??HAL_TIM_OC_Init_0
    612            {
    613              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE014             B        ??HAL_TIM_OC_Init_1
    614            }
    615          
    616            /* Check the parameters */
    617            assert_param(IS_TIM_INSTANCE(htim->Instance));
    618            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    619            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    620            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    621          
    622            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OC_Init_0: (+1)
   \        0xC   0x203D             MOVS     R0,#+61
   \        0xE   0x5C20             LDRB     R0,[R4, R0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE      ??HAL_TIM_OC_Init_2
    623            {
    624              /* Allocate lock resource and initialize it */
    625              htim->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x213C             MOVS     R1,#+60
   \       0x18   0x5460             STRB     R0,[R4, R1]
    626          
    627          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    628              /* Reset interrupt callbacks to legacy weak callbacks */
    629              TIM_ResetCallback(htim);
    630          
    631              if (htim->OC_MspInitCallback == NULL)
    632              {
    633                htim->OC_MspInitCallback = HAL_TIM_OC_MspInit;
    634              }
    635              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    636              htim->OC_MspInitCallback(htim);
    637          #else
    638              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    639              HAL_TIM_OC_MspInit(htim);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x....'....        BL       HAL_TIM_OC_MspInit
    640          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    641            }
    642          
    643            /* Set the TIM state */
    644            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Init_2: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0x213D             MOVS     R1,#+61
   \       0x24   0x5460             STRB     R0,[R4, R1]
    645          
    646            /* Init the base time for the Output Compare */
    647            TIM_Base_SetConfig(htim->Instance,  &htim->Init);
   \       0x26   0x1D21             ADDS     R1,R4,#+4
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x....'....        BL       TIM_Base_SetConfig
    648          
    649            /* Initialize the TIM state*/
    650            htim->State = HAL_TIM_STATE_READY;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x213D             MOVS     R1,#+61
   \       0x32   0x5460             STRB     R0,[R4, R1]
    651          
    652            return HAL_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Init_1: (+1)
   \       0x36   0xBD10             POP      {R4,PC}          ;; return
    653          }
    654          
    655          /**
    656            * @brief  DeInitializes the TIM peripheral
    657            * @param  htim TIM Output Compare handle
    658            * @retval HAL status
    659            */

   \                                 In section .text, align 2, keep-with-next
    660          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    661          {
   \                     HAL_TIM_OC_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    662            /* Check the parameters */
    663            assert_param(IS_TIM_INSTANCE(htim->Instance));
    664          
    665            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x213D             MOVS     R1,#+61
   \        0x8   0x5460             STRB     R0,[R4, R1]
    666          
    667            /* Disable the TIM Peripheral Clock */
    668            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable8  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD10B             BNE      ??HAL_TIM_OC_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0x....             LDR      R1,??DataTable9  ;; 0x444
   \       0x1C   0x4001             ANDS     R1,R1,R0
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD105             BNE      ??HAL_TIM_OC_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x4388             BICS     R0,R0,R1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
    669          
    670          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    671            if (htim->OC_MspDeInitCallback == NULL)
    672            {
    673              htim->OC_MspDeInitCallback = HAL_TIM_OC_MspDeInit;
    674            }
    675            /* DeInit the low level hardware */
    676            htim->OC_MspDeInitCallback(htim);
    677          #else
    678            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    679            HAL_TIM_OC_MspDeInit(htim);
   \                     ??HAL_TIM_OC_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x....'....        BL       HAL_TIM_OC_MspDeInit
    680          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    681          
    682            /* Change TIM state */
    683            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x0001             MOVS     R1,R0
   \       0x38   0x223D             MOVS     R2,#+61
   \       0x3A   0x54A1             STRB     R1,[R4, R2]
    684          
    685            /* Release Lock */
    686            __HAL_UNLOCK(htim);
   \       0x3C   0x213C             MOVS     R1,#+60
   \       0x3E   0x5460             STRB     R0,[R4, R1]
    687          
    688            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}          ;; return
    689          }
    690          
    691          /**
    692            * @brief  Initializes the TIM Output Compare MSP.
    693            * @param  htim TIM Output Compare handle
    694            * @retval None
    695            */

   \                                 In section .text, align 2
    696          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    697          {
    698            /* Prevent unused argument(s) compilation warning */
    699            UNUSED(htim);
    700          
    701            /* NOTE : This function should not be modified, when the callback is needed,
    702                      the HAL_TIM_OC_MspInit could be implemented in the user file
    703             */
    704          }
   \                     HAL_TIM_OC_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    705          
    706          /**
    707            * @brief  DeInitializes TIM Output Compare MSP.
    708            * @param  htim TIM Output Compare handle
    709            * @retval None
    710            */

   \                                 In section .text, align 2
    711          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    712          {
    713            /* Prevent unused argument(s) compilation warning */
    714            UNUSED(htim);
    715          
    716            /* NOTE : This function should not be modified, when the callback is needed,
    717                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    718             */
    719          }
   \                     HAL_TIM_OC_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    720          
    721          /**
    722            * @brief  Starts the TIM Output Compare signal generation.
    723            * @param  htim TIM Output Compare handle
    724            * @param  Channel TIM Channel to be enabled
    725            *          This parameter can be one of the following values:
    726            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    727            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    728            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    729            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    730            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
    731            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
    732            * @retval HAL status
    733            */

   \                                 In section .text, align 2, keep-with-next
    734          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    735          {
   \                     HAL_TIM_OC_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    736            uint32_t tmpsmcr;
    737          
    738            /* Check the parameters */
    739            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    740          
    741            /* Enable the Output compare channel */
    742            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxChannelCmd
    743          
    744            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x....             LDR      R1,??DataTable12  ;; 0x40012c00
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD007             BEQ      ??HAL_TIM_OC_Start_0
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x....             LDR      R1,??DataTable12_1  ;; 0x40014400
   \       0x1C   0x4288             CMP      R0,R1
   \       0x1E   0xD003             BEQ      ??HAL_TIM_OC_Start_0
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x....             LDR      R1,??DataTable12_2  ;; 0x40014800
   \       0x24   0x4288             CMP      R0,R1
   \       0x26   0xD101             BNE      ??HAL_TIM_OC_Start_1
   \                     ??HAL_TIM_OC_Start_0: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE000             B        ??HAL_TIM_OC_Start_2
   \                     ??HAL_TIM_OC_Start_1: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_2: (+1)
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD006             BEQ      ??HAL_TIM_OC_Start_3
    745            {
    746              /* Enable the main output */
    747              __HAL_TIM_MOE_ENABLE(htim);
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x6C40             LDR      R0,[R0, #+68]
   \       0x38   0x2180             MOVS     R1,#+128
   \       0x3A   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x3C   0x4301             ORRS     R1,R1,R0
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6441             STR      R1,[R0, #+68]
    748            }
    749          
    750            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    751            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIM_OC_Start_3: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x6880             LDR      R0,[R0, #+8]
   \       0x46   0x....             LDR      R1,??DataTable9_1  ;; 0x10007
   \       0x48   0x4001             ANDS     R1,R1,R0
    752            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x4A   0x2906             CMP      R1,#+6
   \       0x4C   0xD009             BEQ      ??HAL_TIM_OC_Start_4
   \       0x4E   0x2080             MOVS     R0,#+128
   \       0x50   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x52   0x4281             CMP      R1,R0
   \       0x54   0xD005             BEQ      ??HAL_TIM_OC_Start_4
    753            {
    754              __HAL_TIM_ENABLE(htim);
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6800             LDR      R0,[R0, #+0]
   \       0x5A   0x2201             MOVS     R2,#+1
   \       0x5C   0x4302             ORRS     R2,R2,R0
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6002             STR      R2,[R0, #+0]
    755            }
    756          
    757            /* Return function status */
    758            return HAL_OK;
   \                     ??HAL_TIM_OC_Start_4: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    759          }
    760          
    761          /**
    762            * @brief  Stops the TIM Output Compare signal generation.
    763            * @param  htim TIM Output Compare handle
    764            * @param  Channel TIM Channel to be disabled
    765            *          This parameter can be one of the following values:
    766            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    767            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    768            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    769            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    770            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
    771            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
    772            * @retval HAL status
    773            */

   \                                 In section .text, align 2, keep-with-next
    774          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    775          {
   \                     HAL_TIM_OC_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    776            /* Check the parameters */
    777            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    778          
    779            /* Disable the Output compare channel */
    780            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxChannelCmd
    781          
    782            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x....             LDR      R1,??DataTable12  ;; 0x40012c00
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD007             BEQ      ??HAL_TIM_OC_Stop_0
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x....             LDR      R1,??DataTable12_1  ;; 0x40014400
   \       0x1C   0x4288             CMP      R0,R1
   \       0x1E   0xD003             BEQ      ??HAL_TIM_OC_Stop_0
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x....             LDR      R1,??DataTable12_2  ;; 0x40014800
   \       0x24   0x4288             CMP      R0,R1
   \       0x26   0xD101             BNE      ??HAL_TIM_OC_Stop_1
   \                     ??HAL_TIM_OC_Stop_0: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE000             B        ??HAL_TIM_OC_Stop_2
   \                     ??HAL_TIM_OC_Stop_1: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Stop_2: (+1)
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD011             BEQ      ??HAL_TIM_OC_Stop_3
    783            {
    784              /* Disable the Main Output */
    785              __HAL_TIM_MOE_DISABLE(htim);
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x6A00             LDR      R0,[R0, #+32]
   \       0x38   0x....             LDR      R1,??DataTable12_3  ;; 0x1111
   \       0x3A   0x4001             ANDS     R1,R1,R0
   \       0x3C   0x2900             CMP      R1,#+0
   \       0x3E   0xD10B             BNE      ??HAL_TIM_OC_Stop_4
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x6A00             LDR      R0,[R0, #+32]
   \       0x44   0x....             LDR      R1,??DataTable12_4  ;; 0x444
   \       0x46   0x4001             ANDS     R1,R1,R0
   \       0x48   0x2900             CMP      R1,#+0
   \       0x4A   0xD105             BNE      ??HAL_TIM_OC_Stop_4
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6C40             LDR      R0,[R0, #+68]
   \       0x50   0x....             LDR      R1,??DataTable12_5  ;; 0xffff7fff
   \       0x52   0x4001             ANDS     R1,R1,R0
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6441             STR      R1,[R0, #+68]
    786            }
    787          
    788            /* Disable the Peripheral */
    789            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_4: (+1)
   \                     ??HAL_TIM_OC_Stop_3: (+1)
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6A00             LDR      R0,[R0, #+32]
   \       0x5C   0x....             LDR      R1,??DataTable12_3  ;; 0x1111
   \       0x5E   0x4001             ANDS     R1,R1,R0
   \       0x60   0x2900             CMP      R1,#+0
   \       0x62   0xD10B             BNE      ??HAL_TIM_OC_Stop_5
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6A00             LDR      R0,[R0, #+32]
   \       0x68   0x....             LDR      R1,??DataTable12_4  ;; 0x444
   \       0x6A   0x4001             ANDS     R1,R1,R0
   \       0x6C   0x2900             CMP      R1,#+0
   \       0x6E   0xD105             BNE      ??HAL_TIM_OC_Stop_5
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6800             LDR      R0,[R0, #+0]
   \       0x74   0x2101             MOVS     R1,#+1
   \       0x76   0x4388             BICS     R0,R0,R1
   \       0x78   0x6821             LDR      R1,[R4, #+0]
   \       0x7A   0x6008             STR      R0,[R1, #+0]
    790          
    791            /* Return function status */
    792            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_5: (+1)
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    793          }
    794          
    795          /**
    796            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    797            * @param  htim TIM Output Compare handle
    798            * @param  Channel TIM Channel to be enabled
    799            *          This parameter can be one of the following values:
    800            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    801            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    802            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    803            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    804            * @retval HAL status
    805            */

   \                                 In section .text, align 2, keep-with-next
    806          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    807          {
   \                     HAL_TIM_OC_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    808            uint32_t tmpsmcr;
    809          
    810            /* Check the parameters */
    811            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    812          
    813            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ      ??HAL_TIM_OC_Start_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00B             BEQ      ??HAL_TIM_OC_Start_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD010             BEQ      ??HAL_TIM_OC_Start_IT_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD015             BEQ      ??HAL_TIM_OC_Start_IT_3
   \       0x18   0xE01B             B        ??HAL_TIM_OC_Start_IT_4
    814            {
    815              case TIM_CHANNEL_1:
    816              {
    817                /* Enable the TIM Capture/Compare 1 interrupt */
    818                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Start_IT_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0x2102             MOVS     R1,#+2
   \       0x20   0x4301             ORRS     R1,R1,R0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x60C1             STR      R1,[R0, #+12]
    819                break;
   \       0x26   0xE014             B        ??HAL_TIM_OC_Start_IT_5
    820              }
    821          
    822              case TIM_CHANNEL_2:
    823              {
    824                /* Enable the TIM Capture/Compare 2 interrupt */
    825                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Start_IT_1: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0x2104             MOVS     R1,#+4
   \       0x2E   0x4301             ORRS     R1,R1,R0
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x60C1             STR      R1,[R0, #+12]
    826                break;
   \       0x34   0xE00D             B        ??HAL_TIM_OC_Start_IT_5
    827              }
    828          
    829              case TIM_CHANNEL_3:
    830              {
    831                /* Enable the TIM Capture/Compare 3 interrupt */
    832                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Start_IT_2: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0x2108             MOVS     R1,#+8
   \       0x3C   0x4301             ORRS     R1,R1,R0
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x60C1             STR      R1,[R0, #+12]
    833                break;
   \       0x42   0xE006             B        ??HAL_TIM_OC_Start_IT_5
    834              }
    835          
    836              case TIM_CHANNEL_4:
    837              {
    838                /* Enable the TIM Capture/Compare 4 interrupt */
    839                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Start_IT_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0x2110             MOVS     R1,#+16
   \       0x4A   0x4301             ORRS     R1,R1,R0
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x60C1             STR      R1,[R0, #+12]
    840                break;
   \       0x50   0xE7FF             B        ??HAL_TIM_OC_Start_IT_5
    841              }
    842          
    843              default:
    844                break;
    845            }
    846          
    847            /* Enable the Output compare channel */
    848            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_IT_4: (+1)
   \                     ??HAL_TIM_OC_Start_IT_5: (+1)
   \       0x52   0x2201             MOVS     R2,#+1
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x....'....        BL       TIM_CCxChannelCmd
    849          
    850            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x....             LDR      R1,??DataTable12  ;; 0x40012c00
   \       0x60   0x4288             CMP      R0,R1
   \       0x62   0xD007             BEQ      ??HAL_TIM_OC_Start_IT_6
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x....             LDR      R1,??DataTable12_1  ;; 0x40014400
   \       0x68   0x4288             CMP      R0,R1
   \       0x6A   0xD003             BEQ      ??HAL_TIM_OC_Start_IT_6
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x....             LDR      R1,??DataTable12_2  ;; 0x40014800
   \       0x70   0x4288             CMP      R0,R1
   \       0x72   0xD101             BNE      ??HAL_TIM_OC_Start_IT_7
   \                     ??HAL_TIM_OC_Start_IT_6: (+1)
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xE000             B        ??HAL_TIM_OC_Start_IT_8
   \                     ??HAL_TIM_OC_Start_IT_7: (+1)
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_IT_8: (+1)
   \       0x7A   0xB2C0             UXTB     R0,R0
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD006             BEQ      ??HAL_TIM_OC_Start_IT_9
    851            {
    852              /* Enable the main output */
    853              __HAL_TIM_MOE_ENABLE(htim);
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6C40             LDR      R0,[R0, #+68]
   \       0x84   0x2180             MOVS     R1,#+128
   \       0x86   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x88   0x4301             ORRS     R1,R1,R0
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x6441             STR      R1,[R0, #+68]
    854            }
    855          
    856            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    857            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIM_OC_Start_IT_9: (+1)
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x6880             LDR      R0,[R0, #+8]
   \       0x92   0x....             LDR      R1,??DataTable13  ;; 0x10007
   \       0x94   0x4001             ANDS     R1,R1,R0
    858            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x96   0x2906             CMP      R1,#+6
   \       0x98   0xD009             BEQ      ??HAL_TIM_OC_Start_IT_10
   \       0x9A   0x2080             MOVS     R0,#+128
   \       0x9C   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x9E   0x4281             CMP      R1,R0
   \       0xA0   0xD005             BEQ      ??HAL_TIM_OC_Start_IT_10
    859            {
    860              __HAL_TIM_ENABLE(htim);
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x6800             LDR      R0,[R0, #+0]
   \       0xA6   0x2201             MOVS     R2,#+1
   \       0xA8   0x4302             ORRS     R2,R2,R0
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x6002             STR      R2,[R0, #+0]
    861            }
    862          
    863            /* Return function status */
    864            return HAL_OK;
   \                     ??HAL_TIM_OC_Start_IT_10: (+1)
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    865          }
    866          
    867          /**
    868            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    869            * @param  htim TIM Output Compare handle
    870            * @param  Channel TIM Channel to be disabled
    871            *          This parameter can be one of the following values:
    872            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    873            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    874            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    875            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    876            * @retval HAL status
    877            */

   \                                 In section .text, align 2, keep-with-next
    878          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    879          {
   \                     HAL_TIM_OC_Stop_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    880            /* Check the parameters */
    881            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    882          
    883            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ      ??HAL_TIM_OC_Stop_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00B             BEQ      ??HAL_TIM_OC_Stop_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD010             BEQ      ??HAL_TIM_OC_Stop_IT_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD015             BEQ      ??HAL_TIM_OC_Stop_IT_3
   \       0x18   0xE01B             B        ??HAL_TIM_OC_Stop_IT_4
    884            {
    885              case TIM_CHANNEL_1:
    886              {
    887                /* Disable the TIM Capture/Compare 1 interrupt */
    888                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_OC_Stop_IT_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0x2102             MOVS     R1,#+2
   \       0x20   0x4388             BICS     R0,R0,R1
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
    889                break;
   \       0x26   0xE014             B        ??HAL_TIM_OC_Stop_IT_5
    890              }
    891          
    892              case TIM_CHANNEL_2:
    893              {
    894                /* Disable the TIM Capture/Compare 2 interrupt */
    895                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_OC_Stop_IT_1: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0x2104             MOVS     R1,#+4
   \       0x2E   0x4388             BICS     R0,R0,R1
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x60C8             STR      R0,[R1, #+12]
    896                break;
   \       0x34   0xE00D             B        ??HAL_TIM_OC_Stop_IT_5
    897              }
    898          
    899              case TIM_CHANNEL_3:
    900              {
    901                /* Disable the TIM Capture/Compare 3 interrupt */
    902                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_OC_Stop_IT_2: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0x2108             MOVS     R1,#+8
   \       0x3C   0x4388             BICS     R0,R0,R1
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x60C8             STR      R0,[R1, #+12]
    903                break;
   \       0x42   0xE006             B        ??HAL_TIM_OC_Stop_IT_5
    904              }
    905          
    906              case TIM_CHANNEL_4:
    907              {
    908                /* Disable the TIM Capture/Compare 4 interrupt */
    909                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_OC_Stop_IT_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0x2110             MOVS     R1,#+16
   \       0x4A   0x4388             BICS     R0,R0,R1
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x60C8             STR      R0,[R1, #+12]
    910                break;
   \       0x50   0xE7FF             B        ??HAL_TIM_OC_Stop_IT_5
    911              }
    912          
    913              default:
    914                break;
    915            }
    916          
    917            /* Disable the Output compare channel */
    918            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_IT_4: (+1)
   \                     ??HAL_TIM_OC_Stop_IT_5: (+1)
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x....'....        BL       TIM_CCxChannelCmd
    919          
    920            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x....             LDR      R1,??DataTable12  ;; 0x40012c00
   \       0x60   0x4288             CMP      R0,R1
   \       0x62   0xD007             BEQ      ??HAL_TIM_OC_Stop_IT_6
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x....             LDR      R1,??DataTable12_1  ;; 0x40014400
   \       0x68   0x4288             CMP      R0,R1
   \       0x6A   0xD003             BEQ      ??HAL_TIM_OC_Stop_IT_6
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x....             LDR      R1,??DataTable12_2  ;; 0x40014800
   \       0x70   0x4288             CMP      R0,R1
   \       0x72   0xD101             BNE      ??HAL_TIM_OC_Stop_IT_7
   \                     ??HAL_TIM_OC_Stop_IT_6: (+1)
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xE000             B        ??HAL_TIM_OC_Stop_IT_8
   \                     ??HAL_TIM_OC_Stop_IT_7: (+1)
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Stop_IT_8: (+1)
   \       0x7A   0xB2C0             UXTB     R0,R0
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD011             BEQ      ??HAL_TIM_OC_Stop_IT_9
    921            {
    922              /* Disable the Main Output */
    923              __HAL_TIM_MOE_DISABLE(htim);
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6A00             LDR      R0,[R0, #+32]
   \       0x84   0x....             LDR      R1,??DataTable12_3  ;; 0x1111
   \       0x86   0x4001             ANDS     R1,R1,R0
   \       0x88   0x2900             CMP      R1,#+0
   \       0x8A   0xD10B             BNE      ??HAL_TIM_OC_Stop_IT_10
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6A00             LDR      R0,[R0, #+32]
   \       0x90   0x....             LDR      R1,??DataTable12_4  ;; 0x444
   \       0x92   0x4001             ANDS     R1,R1,R0
   \       0x94   0x2900             CMP      R1,#+0
   \       0x96   0xD105             BNE      ??HAL_TIM_OC_Stop_IT_10
   \       0x98   0x6820             LDR      R0,[R4, #+0]
   \       0x9A   0x6C40             LDR      R0,[R0, #+68]
   \       0x9C   0x....             LDR      R1,??DataTable12_5  ;; 0xffff7fff
   \       0x9E   0x4001             ANDS     R1,R1,R0
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x6441             STR      R1,[R0, #+68]
    924            }
    925          
    926            /* Disable the Peripheral */
    927            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_IT_10: (+1)
   \                     ??HAL_TIM_OC_Stop_IT_9: (+1)
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x6A00             LDR      R0,[R0, #+32]
   \       0xA8   0x....             LDR      R1,??DataTable12_3  ;; 0x1111
   \       0xAA   0x4001             ANDS     R1,R1,R0
   \       0xAC   0x2900             CMP      R1,#+0
   \       0xAE   0xD10B             BNE      ??HAL_TIM_OC_Stop_IT_11
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x6A00             LDR      R0,[R0, #+32]
   \       0xB4   0x....             LDR      R1,??DataTable12_4  ;; 0x444
   \       0xB6   0x4001             ANDS     R1,R1,R0
   \       0xB8   0x2900             CMP      R1,#+0
   \       0xBA   0xD105             BNE      ??HAL_TIM_OC_Stop_IT_11
   \       0xBC   0x6820             LDR      R0,[R4, #+0]
   \       0xBE   0x6800             LDR      R0,[R0, #+0]
   \       0xC0   0x2101             MOVS     R1,#+1
   \       0xC2   0x4388             BICS     R0,R0,R1
   \       0xC4   0x6821             LDR      R1,[R4, #+0]
   \       0xC6   0x6008             STR      R0,[R1, #+0]
    928          
    929            /* Return function status */
    930            return HAL_OK;
   \                     ??HAL_TIM_OC_Stop_IT_11: (+1)
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    931          }
    932          
    933          /**
    934            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    935            * @param  htim TIM Output Compare handle
    936            * @param  Channel TIM Channel to be enabled
    937            *          This parameter can be one of the following values:
    938            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    939            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    940            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    941            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    942            * @param  pData The source Buffer address.
    943            * @param  Length The length of data to be transferred from memory to TIM peripheral
    944            * @retval HAL status
    945            */

   \                                 In section .text, align 2, keep-with-next
    946          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    947          {
   \                     HAL_TIM_OC_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001D             MOVS     R5,R3
    948            uint32_t tmpsmcr;
    949          
    950            /* Check the parameters */
    951            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    952          
    953            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xA   0x203D             MOVS     R0,#+61
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE      ??HAL_TIM_OC_Start_DMA_0
    954            {
    955              return HAL_BUSY;
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE0BF             B        ??HAL_TIM_OC_Start_DMA_1
    956            }
    957            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_OC_Start_DMA_0: (+1)
   \       0x16   0x203D             MOVS     R0,#+61
   \       0x18   0x5C20             LDRB     R0,[R4, R0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD10A             BNE      ??HAL_TIM_OC_Start_DMA_2
    958            {
    959              if ((pData == NULL) && (Length > 0U))
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD105             BNE      ??HAL_TIM_OC_Start_DMA_3
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0xB280             UXTH     R0,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ      ??HAL_TIM_OC_Start_DMA_3
    960              {
    961                return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE0B3             B        ??HAL_TIM_OC_Start_DMA_1
    962              }
    963              else
    964              {
    965                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OC_Start_DMA_3: (+1)
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0x213D             MOVS     R1,#+61
   \       0x32   0x5460             STRB     R0,[R4, R1]
    966              }
    967            }
    968            else
    969            {
    970              /* nothing to do */
    971            }
    972          
    973            switch (Channel)
   \                     ??HAL_TIM_OC_Start_DMA_2: (+1)
   \       0x34   0x0038             MOVS     R0,R7
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD006             BEQ      ??HAL_TIM_OC_Start_DMA_4
   \       0x3A   0x2804             CMP      R0,#+4
   \       0x3C   0xD022             BEQ      ??HAL_TIM_OC_Start_DMA_5
   \       0x3E   0x2808             CMP      R0,#+8
   \       0x40   0xD03E             BEQ      ??HAL_TIM_OC_Start_DMA_6
   \       0x42   0x280C             CMP      R0,#+12
   \       0x44   0xD05A             BEQ      ??HAL_TIM_OC_Start_DMA_7
   \       0x46   0xE077             B        ??HAL_TIM_OC_Start_DMA_8
    974            {
    975              case TIM_CHANNEL_1:
    976              {
    977                /* Set the DMA compare callbacks */
    978                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_4: (+1)
   \       0x48   0x....             LDR      R0,??DataTable15
   \       0x4A   0x6A61             LDR      R1,[R4, #+36]
   \       0x4C   0x62C8             STR      R0,[R1, #+44]
    979                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x4E   0x....             LDR      R0,??DataTable15_1
   \       0x50   0x6A61             LDR      R1,[R4, #+36]
   \       0x52   0x6308             STR      R0,[R1, #+48]
    980          
    981                /* Set the DMA error callback */
    982                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x54   0x....             LDR      R0,??DataTable15_2
   \       0x56   0x6A61             LDR      R1,[R4, #+36]
   \       0x58   0x6348             STR      R0,[R1, #+52]
    983          
    984                /* Enable the DMA channel */
    985                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   \       0x5A   0x002B             MOVS     R3,R5
   \       0x5C   0xB29B             UXTH     R3,R3
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x0002             MOVS     R2,R0
   \       0x62   0x3234             ADDS     R2,R2,#+52
   \       0x64   0x0031             MOVS     R1,R6
   \       0x66   0x6A60             LDR      R0,[R4, #+36]
   \       0x68   0x....'....        BL       HAL_DMA_Start_IT
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD001             BEQ      ??HAL_TIM_OC_Start_DMA_9
    986                {
    987                  return HAL_ERROR;
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xE090             B        ??HAL_TIM_OC_Start_DMA_1
    988                }
    989          
    990                /* Enable the TIM Capture/Compare 1 DMA request */
    991                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Start_DMA_9: (+1)
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x68C0             LDR      R0,[R0, #+12]
   \       0x78   0x2180             MOVS     R1,#+128
   \       0x7A   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x7C   0x4301             ORRS     R1,R1,R0
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0x60C1             STR      R1,[R0, #+12]
    992                break;
   \       0x82   0xE059             B        ??HAL_TIM_OC_Start_DMA_10
    993              }
    994          
    995              case TIM_CHANNEL_2:
    996              {
    997                /* Set the DMA compare callbacks */
    998                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_5: (+1)
   \       0x84   0x....             LDR      R0,??DataTable15
   \       0x86   0x6AA1             LDR      R1,[R4, #+40]
   \       0x88   0x62C8             STR      R0,[R1, #+44]
    999                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x8A   0x....             LDR      R0,??DataTable15_1
   \       0x8C   0x6AA1             LDR      R1,[R4, #+40]
   \       0x8E   0x6308             STR      R0,[R1, #+48]
   1000          
   1001                /* Set the DMA error callback */
   1002                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0x90   0x....             LDR      R0,??DataTable15_2
   \       0x92   0x6AA1             LDR      R1,[R4, #+40]
   \       0x94   0x6348             STR      R0,[R1, #+52]
   1003          
   1004                /* Enable the DMA channel */
   1005                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   \       0x96   0x002B             MOVS     R3,R5
   \       0x98   0xB29B             UXTH     R3,R3
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x0002             MOVS     R2,R0
   \       0x9E   0x3238             ADDS     R2,R2,#+56
   \       0xA0   0x0031             MOVS     R1,R6
   \       0xA2   0x6AA0             LDR      R0,[R4, #+40]
   \       0xA4   0x....'....        BL       HAL_DMA_Start_IT
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD001             BEQ      ??HAL_TIM_OC_Start_DMA_11
   1006                {
   1007                  return HAL_ERROR;
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0xE072             B        ??HAL_TIM_OC_Start_DMA_1
   1008                }
   1009          
   1010                /* Enable the TIM Capture/Compare 2 DMA request */
   1011                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Start_DMA_11: (+1)
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x68C0             LDR      R0,[R0, #+12]
   \       0xB4   0x2180             MOVS     R1,#+128
   \       0xB6   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \       0xB8   0x4301             ORRS     R1,R1,R0
   \       0xBA   0x6820             LDR      R0,[R4, #+0]
   \       0xBC   0x60C1             STR      R1,[R0, #+12]
   1012                break;
   \       0xBE   0xE03B             B        ??HAL_TIM_OC_Start_DMA_10
   1013              }
   1014          
   1015              case TIM_CHANNEL_3:
   1016              {
   1017                /* Set the DMA compare callbacks */
   1018                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_6: (+1)
   \       0xC0   0x....             LDR      R0,??DataTable15
   \       0xC2   0x6AE1             LDR      R1,[R4, #+44]
   \       0xC4   0x62C8             STR      R0,[R1, #+44]
   1019                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xC6   0x....             LDR      R0,??DataTable15_1
   \       0xC8   0x6AE1             LDR      R1,[R4, #+44]
   \       0xCA   0x6308             STR      R0,[R1, #+48]
   1020          
   1021                /* Set the DMA error callback */
   1022                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \       0xCC   0x....             LDR      R0,??DataTable15_2
   \       0xCE   0x6AE1             LDR      R1,[R4, #+44]
   \       0xD0   0x6348             STR      R0,[R1, #+52]
   1023          
   1024                /* Enable the DMA channel */
   1025                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   \       0xD2   0x002B             MOVS     R3,R5
   \       0xD4   0xB29B             UXTH     R3,R3
   \       0xD6   0x6820             LDR      R0,[R4, #+0]
   \       0xD8   0x0002             MOVS     R2,R0
   \       0xDA   0x323C             ADDS     R2,R2,#+60
   \       0xDC   0x0031             MOVS     R1,R6
   \       0xDE   0x6AE0             LDR      R0,[R4, #+44]
   \       0xE0   0x....'....        BL       HAL_DMA_Start_IT
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD001             BEQ      ??HAL_TIM_OC_Start_DMA_12
   1026                {
   1027                  return HAL_ERROR;
   \       0xE8   0x2001             MOVS     R0,#+1
   \       0xEA   0xE054             B        ??HAL_TIM_OC_Start_DMA_1
   1028                }
   1029                /* Enable the TIM Capture/Compare 3 DMA request */
   1030                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Start_DMA_12: (+1)
   \       0xEC   0x6820             LDR      R0,[R4, #+0]
   \       0xEE   0x68C0             LDR      R0,[R0, #+12]
   \       0xF0   0x2180             MOVS     R1,#+128
   \       0xF2   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0xF4   0x4301             ORRS     R1,R1,R0
   \       0xF6   0x6820             LDR      R0,[R4, #+0]
   \       0xF8   0x60C1             STR      R1,[R0, #+12]
   1031                break;
   \       0xFA   0xE01D             B        ??HAL_TIM_OC_Start_DMA_10
   1032              }
   1033          
   1034              case TIM_CHANNEL_4:
   1035              {
   1036                /* Set the DMA compare callbacks */
   1037                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_OC_Start_DMA_7: (+1)
   \       0xFC   0x....             LDR      R0,??DataTable15
   \       0xFE   0x6B21             LDR      R1,[R4, #+48]
   \      0x100   0x62C8             STR      R0,[R1, #+44]
   1038                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \      0x102   0x....             LDR      R0,??DataTable15_1
   \      0x104   0x6B21             LDR      R1,[R4, #+48]
   \      0x106   0x6308             STR      R0,[R1, #+48]
   1039          
   1040                /* Set the DMA error callback */
   1041                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \      0x108   0x....             LDR      R0,??DataTable15_2
   \      0x10A   0x6B21             LDR      R1,[R4, #+48]
   \      0x10C   0x6348             STR      R0,[R1, #+52]
   1042          
   1043                /* Enable the DMA channel */
   1044                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
   \      0x10E   0x002B             MOVS     R3,R5
   \      0x110   0xB29B             UXTH     R3,R3
   \      0x112   0x6820             LDR      R0,[R4, #+0]
   \      0x114   0x0002             MOVS     R2,R0
   \      0x116   0x3240             ADDS     R2,R2,#+64
   \      0x118   0x0031             MOVS     R1,R6
   \      0x11A   0x6B20             LDR      R0,[R4, #+48]
   \      0x11C   0x....'....        BL       HAL_DMA_Start_IT
   \      0x120   0x2800             CMP      R0,#+0
   \      0x122   0xD001             BEQ      ??HAL_TIM_OC_Start_DMA_13
   1045                {
   1046                  return HAL_ERROR;
   \      0x124   0x2001             MOVS     R0,#+1
   \      0x126   0xE036             B        ??HAL_TIM_OC_Start_DMA_1
   1047                }
   1048                /* Enable the TIM Capture/Compare 4 DMA request */
   1049                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Start_DMA_13: (+1)
   \      0x128   0x6820             LDR      R0,[R4, #+0]
   \      0x12A   0x68C0             LDR      R0,[R0, #+12]
   \      0x12C   0x2180             MOVS     R1,#+128
   \      0x12E   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \      0x130   0x4301             ORRS     R1,R1,R0
   \      0x132   0x6820             LDR      R0,[R4, #+0]
   \      0x134   0x60C1             STR      R1,[R0, #+12]
   1050                break;
   \      0x136   0xE7FF             B        ??HAL_TIM_OC_Start_DMA_10
   1051              }
   1052          
   1053              default:
   1054                break;
   1055            }
   1056          
   1057            /* Enable the Output compare channel */
   1058            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_OC_Start_DMA_8: (+1)
   \                     ??HAL_TIM_OC_Start_DMA_10: (+1)
   \      0x138   0x2201             MOVS     R2,#+1
   \      0x13A   0x0039             MOVS     R1,R7
   \      0x13C   0x6820             LDR      R0,[R4, #+0]
   \      0x13E   0x....'....        BL       TIM_CCxChannelCmd
   1059          
   1060            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \      0x142   0x6820             LDR      R0,[R4, #+0]
   \      0x144   0x....             LDR      R1,??DataTable16  ;; 0x40012c00
   \      0x146   0x4288             CMP      R0,R1
   \      0x148   0xD007             BEQ      ??HAL_TIM_OC_Start_DMA_14
   \      0x14A   0x6820             LDR      R0,[R4, #+0]
   \      0x14C   0x....             LDR      R1,??DataTable16_1  ;; 0x40014400
   \      0x14E   0x4288             CMP      R0,R1
   \      0x150   0xD003             BEQ      ??HAL_TIM_OC_Start_DMA_14
   \      0x152   0x6820             LDR      R0,[R4, #+0]
   \      0x154   0x....             LDR      R1,??DataTable16_2  ;; 0x40014800
   \      0x156   0x4288             CMP      R0,R1
   \      0x158   0xD101             BNE      ??HAL_TIM_OC_Start_DMA_15
   \                     ??HAL_TIM_OC_Start_DMA_14: (+1)
   \      0x15A   0x2001             MOVS     R0,#+1
   \      0x15C   0xE000             B        ??HAL_TIM_OC_Start_DMA_16
   \                     ??HAL_TIM_OC_Start_DMA_15: (+1)
   \      0x15E   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_DMA_16: (+1)
   \      0x160   0xB2C0             UXTB     R0,R0
   \      0x162   0x2800             CMP      R0,#+0
   \      0x164   0xD006             BEQ      ??HAL_TIM_OC_Start_DMA_17
   1061            {
   1062              /* Enable the main output */
   1063              __HAL_TIM_MOE_ENABLE(htim);
   \      0x166   0x6820             LDR      R0,[R4, #+0]
   \      0x168   0x6C40             LDR      R0,[R0, #+68]
   \      0x16A   0x2180             MOVS     R1,#+128
   \      0x16C   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \      0x16E   0x4301             ORRS     R1,R1,R0
   \      0x170   0x6820             LDR      R0,[R4, #+0]
   \      0x172   0x6441             STR      R1,[R0, #+68]
   1064            }
   1065          
   1066            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1067            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIM_OC_Start_DMA_17: (+1)
   \      0x174   0x6820             LDR      R0,[R4, #+0]
   \      0x176   0x6880             LDR      R0,[R0, #+8]
   \      0x178   0x....             LDR      R1,??DataTable13  ;; 0x10007
   \      0x17A   0x4001             ANDS     R1,R1,R0
   1068            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \      0x17C   0x2906             CMP      R1,#+6
   \      0x17E   0xD009             BEQ      ??HAL_TIM_OC_Start_DMA_18
   \      0x180   0x2080             MOVS     R0,#+128
   \      0x182   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \      0x184   0x4281             CMP      R1,R0
   \      0x186   0xD005             BEQ      ??HAL_TIM_OC_Start_DMA_18
   1069            {
   1070              __HAL_TIM_ENABLE(htim);
   \      0x188   0x6820             LDR      R0,[R4, #+0]
   \      0x18A   0x6800             LDR      R0,[R0, #+0]
   \      0x18C   0x2201             MOVS     R2,#+1
   \      0x18E   0x4302             ORRS     R2,R2,R0
   \      0x190   0x6820             LDR      R0,[R4, #+0]
   \      0x192   0x6002             STR      R2,[R0, #+0]
   1071            }
   1072          
   1073            /* Return function status */
   1074            return HAL_OK;
   \                     ??HAL_TIM_OC_Start_DMA_18: (+1)
   \      0x194   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Start_DMA_1: (+1)
   \      0x196   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1075          }
   1076          
   1077          /**
   1078            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
   1079            * @param  htim TIM Output Compare handle
   1080            * @param  Channel TIM Channel to be disabled
   1081            *          This parameter can be one of the following values:
   1082            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1083            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1084            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1085            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1086            * @retval HAL status
   1087            */

   \                                 In section .text, align 2, keep-with-next
   1088          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1089          {
   \                     HAL_TIM_OC_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1090            /* Check the parameters */
   1091            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1092          
   1093            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ      ??HAL_TIM_OC_Stop_DMA_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00E             BEQ      ??HAL_TIM_OC_Stop_DMA_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD016             BEQ      ??HAL_TIM_OC_Stop_DMA_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD01E             BEQ      ??HAL_TIM_OC_Stop_DMA_3
   \       0x18   0xE027             B        ??HAL_TIM_OC_Stop_DMA_4
   1094            {
   1095              case TIM_CHANNEL_1:
   1096              {
   1097                /* Disable the TIM Capture/Compare 1 DMA request */
   1098                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_OC_Stop_DMA_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0x....             LDR      R1,??DataTable17  ;; 0xfffffdff
   \       0x20   0x4001             ANDS     R1,R1,R0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x60C1             STR      R1,[R0, #+12]
   1099                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x26   0x6A60             LDR      R0,[R4, #+36]
   \       0x28   0x....'....        BL       HAL_DMA_Abort_IT
   1100                break;
   \       0x2C   0xE01D             B        ??HAL_TIM_OC_Stop_DMA_5
   1101              }
   1102          
   1103              case TIM_CHANNEL_2:
   1104              {
   1105                /* Disable the TIM Capture/Compare 2 DMA request */
   1106                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_OC_Stop_DMA_1: (+1)
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x68C0             LDR      R0,[R0, #+12]
   \       0x32   0x....             LDR      R1,??DataTable17_1  ;; 0xfffffbff
   \       0x34   0x4001             ANDS     R1,R1,R0
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x60C1             STR      R1,[R0, #+12]
   1107                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x3A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x3C   0x....'....        BL       HAL_DMA_Abort_IT
   1108                break;
   \       0x40   0xE013             B        ??HAL_TIM_OC_Stop_DMA_5
   1109              }
   1110          
   1111              case TIM_CHANNEL_3:
   1112              {
   1113                /* Disable the TIM Capture/Compare 3 DMA request */
   1114                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_OC_Stop_DMA_2: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x68C0             LDR      R0,[R0, #+12]
   \       0x46   0x....             LDR      R1,??DataTable17_2  ;; 0xfffff7ff
   \       0x48   0x4001             ANDS     R1,R1,R0
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x60C1             STR      R1,[R0, #+12]
   1115                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \       0x4E   0x6AE0             LDR      R0,[R4, #+44]
   \       0x50   0x....'....        BL       HAL_DMA_Abort_IT
   1116                break;
   \       0x54   0xE009             B        ??HAL_TIM_OC_Stop_DMA_5
   1117              }
   1118          
   1119              case TIM_CHANNEL_4:
   1120              {
   1121                /* Disable the TIM Capture/Compare 4 interrupt */
   1122                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_OC_Stop_DMA_3: (+1)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x68C0             LDR      R0,[R0, #+12]
   \       0x5A   0x....             LDR      R1,??DataTable17_3  ;; 0xffffefff
   \       0x5C   0x4001             ANDS     R1,R1,R0
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x60C1             STR      R1,[R0, #+12]
   1123                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \       0x62   0x6B20             LDR      R0,[R4, #+48]
   \       0x64   0x....'....        BL       HAL_DMA_Abort_IT
   1124                break;
   \       0x68   0xE7FF             B        ??HAL_TIM_OC_Stop_DMA_5
   1125              }
   1126          
   1127              default:
   1128                break;
   1129            }
   1130          
   1131            /* Disable the Output compare channel */
   1132            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_OC_Stop_DMA_4: (+1)
   \                     ??HAL_TIM_OC_Stop_DMA_5: (+1)
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0x0029             MOVS     R1,R5
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x....'....        BL       TIM_CCxChannelCmd
   1133          
   1134            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x....             LDR      R1,??DataTable16  ;; 0x40012c00
   \       0x78   0x4288             CMP      R0,R1
   \       0x7A   0xD007             BEQ      ??HAL_TIM_OC_Stop_DMA_6
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x....             LDR      R1,??DataTable16_1  ;; 0x40014400
   \       0x80   0x4288             CMP      R0,R1
   \       0x82   0xD003             BEQ      ??HAL_TIM_OC_Stop_DMA_6
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x....             LDR      R1,??DataTable16_2  ;; 0x40014800
   \       0x88   0x4288             CMP      R0,R1
   \       0x8A   0xD101             BNE      ??HAL_TIM_OC_Stop_DMA_7
   \                     ??HAL_TIM_OC_Stop_DMA_6: (+1)
   \       0x8C   0x2001             MOVS     R0,#+1
   \       0x8E   0xE000             B        ??HAL_TIM_OC_Stop_DMA_8
   \                     ??HAL_TIM_OC_Stop_DMA_7: (+1)
   \       0x90   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_Stop_DMA_8: (+1)
   \       0x92   0xB2C0             UXTB     R0,R0
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD011             BEQ      ??HAL_TIM_OC_Stop_DMA_9
   1135            {
   1136              /* Disable the Main Output */
   1137              __HAL_TIM_MOE_DISABLE(htim);
   \       0x98   0x6820             LDR      R0,[R4, #+0]
   \       0x9A   0x6A00             LDR      R0,[R0, #+32]
   \       0x9C   0x....             LDR      R1,??DataTable18  ;; 0x1111
   \       0x9E   0x4001             ANDS     R1,R1,R0
   \       0xA0   0x2900             CMP      R1,#+0
   \       0xA2   0xD10B             BNE      ??HAL_TIM_OC_Stop_DMA_10
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x6A00             LDR      R0,[R0, #+32]
   \       0xA8   0x....             LDR      R1,??DataTable18_1  ;; 0x444
   \       0xAA   0x4001             ANDS     R1,R1,R0
   \       0xAC   0x2900             CMP      R1,#+0
   \       0xAE   0xD105             BNE      ??HAL_TIM_OC_Stop_DMA_10
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x6C40             LDR      R0,[R0, #+68]
   \       0xB4   0x....             LDR      R1,??DataTable18_2  ;; 0xffff7fff
   \       0xB6   0x4001             ANDS     R1,R1,R0
   \       0xB8   0x6820             LDR      R0,[R4, #+0]
   \       0xBA   0x6441             STR      R1,[R0, #+68]
   1138            }
   1139          
   1140            /* Disable the Peripheral */
   1141            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OC_Stop_DMA_10: (+1)
   \                     ??HAL_TIM_OC_Stop_DMA_9: (+1)
   \       0xBC   0x6820             LDR      R0,[R4, #+0]
   \       0xBE   0x6A00             LDR      R0,[R0, #+32]
   \       0xC0   0x....             LDR      R1,??DataTable18  ;; 0x1111
   \       0xC2   0x4001             ANDS     R1,R1,R0
   \       0xC4   0x2900             CMP      R1,#+0
   \       0xC6   0xD10B             BNE      ??HAL_TIM_OC_Stop_DMA_11
   \       0xC8   0x6820             LDR      R0,[R4, #+0]
   \       0xCA   0x6A00             LDR      R0,[R0, #+32]
   \       0xCC   0x....             LDR      R1,??DataTable18_1  ;; 0x444
   \       0xCE   0x4001             ANDS     R1,R1,R0
   \       0xD0   0x2900             CMP      R1,#+0
   \       0xD2   0xD105             BNE      ??HAL_TIM_OC_Stop_DMA_11
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x6800             LDR      R0,[R0, #+0]
   \       0xD8   0x2101             MOVS     R1,#+1
   \       0xDA   0x4388             BICS     R0,R0,R1
   \       0xDC   0x6821             LDR      R1,[R4, #+0]
   \       0xDE   0x6008             STR      R0,[R1, #+0]
   1142          
   1143            /* Change the htim state */
   1144            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_Stop_DMA_11: (+1)
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0x213D             MOVS     R1,#+61
   \       0xE4   0x5460             STRB     R0,[R4, R1]
   1145          
   1146            /* Return function status */
   1147            return HAL_OK;
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1148          }
   1149          
   1150          /**
   1151            * @}
   1152            */
   1153          
   1154          /** @defgroup TIM_Exported_Functions_Group3 TIM PWM functions
   1155            *  @brief    TIM PWM functions
   1156            *
   1157          @verbatim
   1158            ==============================================================================
   1159                                    ##### TIM PWM functions #####
   1160            ==============================================================================
   1161            [..]
   1162              This section provides functions allowing to:
   1163              (+) Initialize and configure the TIM PWM.
   1164              (+) De-initialize the TIM PWM.
   1165              (+) Start the TIM PWM.
   1166              (+) Stop the TIM PWM.
   1167              (+) Start the TIM PWM and enable interrupt.
   1168              (+) Stop the TIM PWM and disable interrupt.
   1169              (+) Start the TIM PWM and enable DMA transfer.
   1170              (+) Stop the TIM PWM and disable DMA transfer.
   1171          
   1172          @endverbatim
   1173            * @{
   1174            */
   1175          /**
   1176            * @brief  Initializes the TIM PWM Time Base according to the specified
   1177            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1178            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1179            *         requires a timer reset to avoid unexpected direction
   1180            *         due to DIR bit readonly in center aligned mode.
   1181            *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
   1182            * @param  htim TIM PWM handle
   1183            * @retval HAL status
   1184            */

   \                                 In section .text, align 2, keep-with-next
   1185          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
   1186          {
   \                     HAL_TIM_PWM_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1187            /* Check the TIM handle allocation */
   1188            if (htim == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE      ??HAL_TIM_PWM_Init_0
   1189            {
   1190              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE014             B        ??HAL_TIM_PWM_Init_1
   1191            }
   1192          
   1193            /* Check the parameters */
   1194            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1195            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1196            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1197            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1198          
   1199            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_PWM_Init_0: (+1)
   \        0xC   0x203D             MOVS     R0,#+61
   \        0xE   0x5C20             LDRB     R0,[R4, R0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE      ??HAL_TIM_PWM_Init_2
   1200            {
   1201              /* Allocate lock resource and initialize it */
   1202              htim->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x213C             MOVS     R1,#+60
   \       0x18   0x5460             STRB     R0,[R4, R1]
   1203          
   1204          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1205              /* Reset interrupt callbacks to legacy weak callbacks */
   1206              TIM_ResetCallback(htim);
   1207          
   1208              if (htim->PWM_MspInitCallback == NULL)
   1209              {
   1210                htim->PWM_MspInitCallback = HAL_TIM_PWM_MspInit;
   1211              }
   1212              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1213              htim->PWM_MspInitCallback(htim);
   1214          #else
   1215              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1216              HAL_TIM_PWM_MspInit(htim);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x....'....        BL       HAL_TIM_PWM_MspInit
   1217          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1218            }
   1219          
   1220            /* Set the TIM state */
   1221            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Init_2: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0x213D             MOVS     R1,#+61
   \       0x24   0x5460             STRB     R0,[R4, R1]
   1222          
   1223            /* Init the base time for the PWM */
   1224            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x26   0x1D21             ADDS     R1,R4,#+4
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x....'....        BL       TIM_Base_SetConfig
   1225          
   1226            /* Initialize the TIM state*/
   1227            htim->State = HAL_TIM_STATE_READY;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x213D             MOVS     R1,#+61
   \       0x32   0x5460             STRB     R0,[R4, R1]
   1228          
   1229            return HAL_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Init_1: (+1)
   \       0x36   0xBD10             POP      {R4,PC}          ;; return
   1230          }
   1231          
   1232          /**
   1233            * @brief  DeInitializes the TIM peripheral
   1234            * @param  htim TIM PWM handle
   1235            * @retval HAL status
   1236            */

   \                                 In section .text, align 2, keep-with-next
   1237          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1238          {
   \                     HAL_TIM_PWM_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1239            /* Check the parameters */
   1240            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1241          
   1242            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x213D             MOVS     R1,#+61
   \        0x8   0x5460             STRB     R0,[R4, R1]
   1243          
   1244            /* Disable the TIM Peripheral Clock */
   1245            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable18  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD10B             BNE      ??HAL_TIM_PWM_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0x....             LDR      R1,??DataTable18_1  ;; 0x444
   \       0x1C   0x4001             ANDS     R1,R1,R0
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD105             BNE      ??HAL_TIM_PWM_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x4388             BICS     R0,R0,R1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   1246          
   1247          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1248            if (htim->PWM_MspDeInitCallback == NULL)
   1249            {
   1250              htim->PWM_MspDeInitCallback = HAL_TIM_PWM_MspDeInit;
   1251            }
   1252            /* DeInit the low level hardware */
   1253            htim->PWM_MspDeInitCallback(htim);
   1254          #else
   1255            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1256            HAL_TIM_PWM_MspDeInit(htim);
   \                     ??HAL_TIM_PWM_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x....'....        BL       HAL_TIM_PWM_MspDeInit
   1257          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1258          
   1259            /* Change TIM state */
   1260            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x0001             MOVS     R1,R0
   \       0x38   0x223D             MOVS     R2,#+61
   \       0x3A   0x54A1             STRB     R1,[R4, R2]
   1261          
   1262            /* Release Lock */
   1263            __HAL_UNLOCK(htim);
   \       0x3C   0x213C             MOVS     R1,#+60
   \       0x3E   0x5460             STRB     R0,[R4, R1]
   1264          
   1265            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}          ;; return
   1266          }
   1267          
   1268          /**
   1269            * @brief  Initializes the TIM PWM MSP.
   1270            * @param  htim TIM PWM handle
   1271            * @retval None
   1272            */

   \                                 In section .text, align 2
   1273          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1274          {
   1275            /* Prevent unused argument(s) compilation warning */
   1276            UNUSED(htim);
   1277          
   1278            /* NOTE : This function should not be modified, when the callback is needed,
   1279                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1280             */
   1281          }
   \                     HAL_TIM_PWM_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1282          
   1283          /**
   1284            * @brief  DeInitializes TIM PWM MSP.
   1285            * @param  htim TIM PWM handle
   1286            * @retval None
   1287            */

   \                                 In section .text, align 2
   1288          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1289          {
   1290            /* Prevent unused argument(s) compilation warning */
   1291            UNUSED(htim);
   1292          
   1293            /* NOTE : This function should not be modified, when the callback is needed,
   1294                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1295             */
   1296          }
   \                     HAL_TIM_PWM_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1297          
   1298          /**
   1299            * @brief  Starts the PWM signal generation.
   1300            * @param  htim TIM handle
   1301            * @param  Channel TIM Channels to be enabled
   1302            *          This parameter can be one of the following values:
   1303            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1304            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1305            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1306            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1307            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
   1308            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
   1309            * @retval HAL status
   1310            */

   \                                 In section .text, align 2, keep-with-next
   1311          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1312          {
   \                     HAL_TIM_PWM_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1313            uint32_t tmpsmcr;
   1314          
   1315            /* Check the parameters */
   1316            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1317          
   1318            /* Enable the Capture compare channel */
   1319            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxChannelCmd
   1320          
   1321            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x....             LDR      R1,??DataTable16  ;; 0x40012c00
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD007             BEQ      ??HAL_TIM_PWM_Start_0
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x....             LDR      R1,??DataTable16_1  ;; 0x40014400
   \       0x1C   0x4288             CMP      R0,R1
   \       0x1E   0xD003             BEQ      ??HAL_TIM_PWM_Start_0
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x....             LDR      R1,??DataTable16_2  ;; 0x40014800
   \       0x24   0x4288             CMP      R0,R1
   \       0x26   0xD101             BNE      ??HAL_TIM_PWM_Start_1
   \                     ??HAL_TIM_PWM_Start_0: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE000             B        ??HAL_TIM_PWM_Start_2
   \                     ??HAL_TIM_PWM_Start_1: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_2: (+1)
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD006             BEQ      ??HAL_TIM_PWM_Start_3
   1322            {
   1323              /* Enable the main output */
   1324              __HAL_TIM_MOE_ENABLE(htim);
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x6C40             LDR      R0,[R0, #+68]
   \       0x38   0x2180             MOVS     R1,#+128
   \       0x3A   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x3C   0x4301             ORRS     R1,R1,R0
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6441             STR      R1,[R0, #+68]
   1325            }
   1326          
   1327            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1328            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIM_PWM_Start_3: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x6880             LDR      R0,[R0, #+8]
   \       0x46   0x....             LDR      R1,??DataTable19  ;; 0x10007
   \       0x48   0x4001             ANDS     R1,R1,R0
   1329            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x4A   0x2906             CMP      R1,#+6
   \       0x4C   0xD009             BEQ      ??HAL_TIM_PWM_Start_4
   \       0x4E   0x2080             MOVS     R0,#+128
   \       0x50   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x52   0x4281             CMP      R1,R0
   \       0x54   0xD005             BEQ      ??HAL_TIM_PWM_Start_4
   1330            {
   1331              __HAL_TIM_ENABLE(htim);
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6800             LDR      R0,[R0, #+0]
   \       0x5A   0x2201             MOVS     R2,#+1
   \       0x5C   0x4302             ORRS     R2,R2,R0
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6002             STR      R2,[R0, #+0]
   1332            }
   1333          
   1334            /* Return function status */
   1335            return HAL_OK;
   \                     ??HAL_TIM_PWM_Start_4: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1336          }
   1337          
   1338          /**
   1339            * @brief  Stops the PWM signal generation.
   1340            * @param  htim TIM PWM handle
   1341            * @param  Channel TIM Channels to be disabled
   1342            *          This parameter can be one of the following values:
   1343            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1344            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1345            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1346            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1347            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
   1348            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
   1349            * @retval HAL status
   1350            */

   \                                 In section .text, align 2, keep-with-next
   1351          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1352          {
   \                     HAL_TIM_PWM_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1353            /* Check the parameters */
   1354            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1355          
   1356            /* Disable the Capture compare channel */
   1357            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxChannelCmd
   1358          
   1359            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x....             LDR      R1,??DataTable19_1  ;; 0x40012c00
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD007             BEQ      ??HAL_TIM_PWM_Stop_0
   \       0x18   0x6820             LDR      R0,[R4, #+0]
   \       0x1A   0x....             LDR      R1,??DataTable19_2  ;; 0x40014400
   \       0x1C   0x4288             CMP      R0,R1
   \       0x1E   0xD003             BEQ      ??HAL_TIM_PWM_Stop_0
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x....             LDR      R1,??DataTable19_3  ;; 0x40014800
   \       0x24   0x4288             CMP      R0,R1
   \       0x26   0xD101             BNE      ??HAL_TIM_PWM_Stop_1
   \                     ??HAL_TIM_PWM_Stop_0: (+1)
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE000             B        ??HAL_TIM_PWM_Stop_2
   \                     ??HAL_TIM_PWM_Stop_1: (+1)
   \       0x2C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Stop_2: (+1)
   \       0x2E   0xB2C0             UXTB     R0,R0
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD011             BEQ      ??HAL_TIM_PWM_Stop_3
   1360            {
   1361              /* Disable the Main Output */
   1362              __HAL_TIM_MOE_DISABLE(htim);
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x6A00             LDR      R0,[R0, #+32]
   \       0x38   0x....             LDR      R1,??DataTable18  ;; 0x1111
   \       0x3A   0x4001             ANDS     R1,R1,R0
   \       0x3C   0x2900             CMP      R1,#+0
   \       0x3E   0xD10B             BNE      ??HAL_TIM_PWM_Stop_4
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x6A00             LDR      R0,[R0, #+32]
   \       0x44   0x....             LDR      R1,??DataTable18_1  ;; 0x444
   \       0x46   0x4001             ANDS     R1,R1,R0
   \       0x48   0x2900             CMP      R1,#+0
   \       0x4A   0xD105             BNE      ??HAL_TIM_PWM_Stop_4
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6C40             LDR      R0,[R0, #+68]
   \       0x50   0x....             LDR      R1,??DataTable18_2  ;; 0xffff7fff
   \       0x52   0x4001             ANDS     R1,R1,R0
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x6441             STR      R1,[R0, #+68]
   1363            }
   1364          
   1365            /* Disable the Peripheral */
   1366            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_4: (+1)
   \                     ??HAL_TIM_PWM_Stop_3: (+1)
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x6A00             LDR      R0,[R0, #+32]
   \       0x5C   0x....             LDR      R1,??DataTable18  ;; 0x1111
   \       0x5E   0x4001             ANDS     R1,R1,R0
   \       0x60   0x2900             CMP      R1,#+0
   \       0x62   0xD10B             BNE      ??HAL_TIM_PWM_Stop_5
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6A00             LDR      R0,[R0, #+32]
   \       0x68   0x....             LDR      R1,??DataTable18_1  ;; 0x444
   \       0x6A   0x4001             ANDS     R1,R1,R0
   \       0x6C   0x2900             CMP      R1,#+0
   \       0x6E   0xD105             BNE      ??HAL_TIM_PWM_Stop_5
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6800             LDR      R0,[R0, #+0]
   \       0x74   0x2101             MOVS     R1,#+1
   \       0x76   0x4388             BICS     R0,R0,R1
   \       0x78   0x6821             LDR      R1,[R4, #+0]
   \       0x7A   0x6008             STR      R0,[R1, #+0]
   1367          
   1368            /* Change the htim state */
   1369            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_5: (+1)
   \       0x7C   0x2001             MOVS     R0,#+1
   \       0x7E   0x213D             MOVS     R1,#+61
   \       0x80   0x5460             STRB     R0,[R4, R1]
   1370          
   1371            /* Return function status */
   1372            return HAL_OK;
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1373          }
   1374          
   1375          /**
   1376            * @brief  Starts the PWM signal generation in interrupt mode.
   1377            * @param  htim TIM PWM handle
   1378            * @param  Channel TIM Channel to be enabled
   1379            *          This parameter can be one of the following values:
   1380            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1381            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1382            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1383            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1384            * @retval HAL status
   1385            */

   \                                 In section .text, align 2, keep-with-next
   1386          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1387          {
   \                     HAL_TIM_PWM_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1388            uint32_t tmpsmcr;
   1389            /* Check the parameters */
   1390            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1391          
   1392            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ      ??HAL_TIM_PWM_Start_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00B             BEQ      ??HAL_TIM_PWM_Start_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD010             BEQ      ??HAL_TIM_PWM_Start_IT_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD015             BEQ      ??HAL_TIM_PWM_Start_IT_3
   \       0x18   0xE01B             B        ??HAL_TIM_PWM_Start_IT_4
   1393            {
   1394              case TIM_CHANNEL_1:
   1395              {
   1396                /* Enable the TIM Capture/Compare 1 interrupt */
   1397                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Start_IT_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0x2102             MOVS     R1,#+2
   \       0x20   0x4301             ORRS     R1,R1,R0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x60C1             STR      R1,[R0, #+12]
   1398                break;
   \       0x26   0xE014             B        ??HAL_TIM_PWM_Start_IT_5
   1399              }
   1400          
   1401              case TIM_CHANNEL_2:
   1402              {
   1403                /* Enable the TIM Capture/Compare 2 interrupt */
   1404                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Start_IT_1: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0x2104             MOVS     R1,#+4
   \       0x2E   0x4301             ORRS     R1,R1,R0
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x60C1             STR      R1,[R0, #+12]
   1405                break;
   \       0x34   0xE00D             B        ??HAL_TIM_PWM_Start_IT_5
   1406              }
   1407          
   1408              case TIM_CHANNEL_3:
   1409              {
   1410                /* Enable the TIM Capture/Compare 3 interrupt */
   1411                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Start_IT_2: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0x2108             MOVS     R1,#+8
   \       0x3C   0x4301             ORRS     R1,R1,R0
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x60C1             STR      R1,[R0, #+12]
   1412                break;
   \       0x42   0xE006             B        ??HAL_TIM_PWM_Start_IT_5
   1413              }
   1414          
   1415              case TIM_CHANNEL_4:
   1416              {
   1417                /* Enable the TIM Capture/Compare 4 interrupt */
   1418                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Start_IT_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0x2110             MOVS     R1,#+16
   \       0x4A   0x4301             ORRS     R1,R1,R0
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x60C1             STR      R1,[R0, #+12]
   1419                break;
   \       0x50   0xE7FF             B        ??HAL_TIM_PWM_Start_IT_5
   1420              }
   1421          
   1422              default:
   1423                break;
   1424            }
   1425          
   1426            /* Enable the Capture compare channel */
   1427            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_IT_4: (+1)
   \                     ??HAL_TIM_PWM_Start_IT_5: (+1)
   \       0x52   0x2201             MOVS     R2,#+1
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x....'....        BL       TIM_CCxChannelCmd
   1428          
   1429            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x....             LDR      R1,??DataTable19_1  ;; 0x40012c00
   \       0x60   0x4288             CMP      R0,R1
   \       0x62   0xD007             BEQ      ??HAL_TIM_PWM_Start_IT_6
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x....             LDR      R1,??DataTable19_2  ;; 0x40014400
   \       0x68   0x4288             CMP      R0,R1
   \       0x6A   0xD003             BEQ      ??HAL_TIM_PWM_Start_IT_6
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x....             LDR      R1,??DataTable19_3  ;; 0x40014800
   \       0x70   0x4288             CMP      R0,R1
   \       0x72   0xD101             BNE      ??HAL_TIM_PWM_Start_IT_7
   \                     ??HAL_TIM_PWM_Start_IT_6: (+1)
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xE000             B        ??HAL_TIM_PWM_Start_IT_8
   \                     ??HAL_TIM_PWM_Start_IT_7: (+1)
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_IT_8: (+1)
   \       0x7A   0xB2C0             UXTB     R0,R0
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD006             BEQ      ??HAL_TIM_PWM_Start_IT_9
   1430            {
   1431              /* Enable the main output */
   1432              __HAL_TIM_MOE_ENABLE(htim);
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6C40             LDR      R0,[R0, #+68]
   \       0x84   0x2180             MOVS     R1,#+128
   \       0x86   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x88   0x4301             ORRS     R1,R1,R0
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x6441             STR      R1,[R0, #+68]
   1433            }
   1434          
   1435            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1436            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIM_PWM_Start_IT_9: (+1)
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x6880             LDR      R0,[R0, #+8]
   \       0x92   0x....             LDR      R1,??DataTable19  ;; 0x10007
   \       0x94   0x4001             ANDS     R1,R1,R0
   1437            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x96   0x2906             CMP      R1,#+6
   \       0x98   0xD009             BEQ      ??HAL_TIM_PWM_Start_IT_10
   \       0x9A   0x2080             MOVS     R0,#+128
   \       0x9C   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x9E   0x4281             CMP      R1,R0
   \       0xA0   0xD005             BEQ      ??HAL_TIM_PWM_Start_IT_10
   1438            {
   1439              __HAL_TIM_ENABLE(htim);
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x6800             LDR      R0,[R0, #+0]
   \       0xA6   0x2201             MOVS     R2,#+1
   \       0xA8   0x4302             ORRS     R2,R2,R0
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x6002             STR      R2,[R0, #+0]
   1440            }
   1441          
   1442            /* Return function status */
   1443            return HAL_OK;
   \                     ??HAL_TIM_PWM_Start_IT_10: (+1)
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1444          }
   1445          
   1446          /**
   1447            * @brief  Stops the PWM signal generation in interrupt mode.
   1448            * @param  htim TIM PWM handle
   1449            * @param  Channel TIM Channels to be disabled
   1450            *          This parameter can be one of the following values:
   1451            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1452            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1453            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1454            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1455            * @retval HAL status
   1456            */

   \                                 In section .text, align 2, keep-with-next
   1457          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1458          {
   \                     HAL_TIM_PWM_Stop_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1459            /* Check the parameters */
   1460            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1461          
   1462            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ      ??HAL_TIM_PWM_Stop_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00B             BEQ      ??HAL_TIM_PWM_Stop_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD010             BEQ      ??HAL_TIM_PWM_Stop_IT_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD015             BEQ      ??HAL_TIM_PWM_Stop_IT_3
   \       0x18   0xE01B             B        ??HAL_TIM_PWM_Stop_IT_4
   1463            {
   1464              case TIM_CHANNEL_1:
   1465              {
   1466                /* Disable the TIM Capture/Compare 1 interrupt */
   1467                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_PWM_Stop_IT_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0x2102             MOVS     R1,#+2
   \       0x20   0x4388             BICS     R0,R0,R1
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
   1468                break;
   \       0x26   0xE014             B        ??HAL_TIM_PWM_Stop_IT_5
   1469              }
   1470          
   1471              case TIM_CHANNEL_2:
   1472              {
   1473                /* Disable the TIM Capture/Compare 2 interrupt */
   1474                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_PWM_Stop_IT_1: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0x2104             MOVS     R1,#+4
   \       0x2E   0x4388             BICS     R0,R0,R1
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x60C8             STR      R0,[R1, #+12]
   1475                break;
   \       0x34   0xE00D             B        ??HAL_TIM_PWM_Stop_IT_5
   1476              }
   1477          
   1478              case TIM_CHANNEL_3:
   1479              {
   1480                /* Disable the TIM Capture/Compare 3 interrupt */
   1481                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_PWM_Stop_IT_2: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0x2108             MOVS     R1,#+8
   \       0x3C   0x4388             BICS     R0,R0,R1
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x60C8             STR      R0,[R1, #+12]
   1482                break;
   \       0x42   0xE006             B        ??HAL_TIM_PWM_Stop_IT_5
   1483              }
   1484          
   1485              case TIM_CHANNEL_4:
   1486              {
   1487                /* Disable the TIM Capture/Compare 4 interrupt */
   1488                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_PWM_Stop_IT_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0x2110             MOVS     R1,#+16
   \       0x4A   0x4388             BICS     R0,R0,R1
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x60C8             STR      R0,[R1, #+12]
   1489                break;
   \       0x50   0xE7FF             B        ??HAL_TIM_PWM_Stop_IT_5
   1490              }
   1491          
   1492              default:
   1493                break;
   1494            }
   1495          
   1496            /* Disable the Capture compare channel */
   1497            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_IT_4: (+1)
   \                     ??HAL_TIM_PWM_Stop_IT_5: (+1)
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x....'....        BL       TIM_CCxChannelCmd
   1498          
   1499            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x....             LDR      R1,??DataTable19_1  ;; 0x40012c00
   \       0x60   0x4288             CMP      R0,R1
   \       0x62   0xD007             BEQ      ??HAL_TIM_PWM_Stop_IT_6
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x....             LDR      R1,??DataTable19_2  ;; 0x40014400
   \       0x68   0x4288             CMP      R0,R1
   \       0x6A   0xD003             BEQ      ??HAL_TIM_PWM_Stop_IT_6
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x....             LDR      R1,??DataTable19_3  ;; 0x40014800
   \       0x70   0x4288             CMP      R0,R1
   \       0x72   0xD101             BNE      ??HAL_TIM_PWM_Stop_IT_7
   \                     ??HAL_TIM_PWM_Stop_IT_6: (+1)
   \       0x74   0x2001             MOVS     R0,#+1
   \       0x76   0xE000             B        ??HAL_TIM_PWM_Stop_IT_8
   \                     ??HAL_TIM_PWM_Stop_IT_7: (+1)
   \       0x78   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Stop_IT_8: (+1)
   \       0x7A   0xB2C0             UXTB     R0,R0
   \       0x7C   0x2800             CMP      R0,#+0
   \       0x7E   0xD011             BEQ      ??HAL_TIM_PWM_Stop_IT_9
   1500            {
   1501              /* Disable the Main Output */
   1502              __HAL_TIM_MOE_DISABLE(htim);
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6A00             LDR      R0,[R0, #+32]
   \       0x84   0x....             LDR      R1,??DataTable20  ;; 0x1111
   \       0x86   0x4001             ANDS     R1,R1,R0
   \       0x88   0x2900             CMP      R1,#+0
   \       0x8A   0xD10B             BNE      ??HAL_TIM_PWM_Stop_IT_10
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6A00             LDR      R0,[R0, #+32]
   \       0x90   0x....             LDR      R1,??DataTable21  ;; 0x444
   \       0x92   0x4001             ANDS     R1,R1,R0
   \       0x94   0x2900             CMP      R1,#+0
   \       0x96   0xD105             BNE      ??HAL_TIM_PWM_Stop_IT_10
   \       0x98   0x6820             LDR      R0,[R4, #+0]
   \       0x9A   0x6C40             LDR      R0,[R0, #+68]
   \       0x9C   0x....             LDR      R1,??DataTable20_1  ;; 0xffff7fff
   \       0x9E   0x4001             ANDS     R1,R1,R0
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x6441             STR      R1,[R0, #+68]
   1503            }
   1504          
   1505            /* Disable the Peripheral */
   1506            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_IT_10: (+1)
   \                     ??HAL_TIM_PWM_Stop_IT_9: (+1)
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x6A00             LDR      R0,[R0, #+32]
   \       0xA8   0x....             LDR      R1,??DataTable20  ;; 0x1111
   \       0xAA   0x4001             ANDS     R1,R1,R0
   \       0xAC   0x2900             CMP      R1,#+0
   \       0xAE   0xD10B             BNE      ??HAL_TIM_PWM_Stop_IT_11
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x6A00             LDR      R0,[R0, #+32]
   \       0xB4   0x....             LDR      R1,??DataTable21  ;; 0x444
   \       0xB6   0x4001             ANDS     R1,R1,R0
   \       0xB8   0x2900             CMP      R1,#+0
   \       0xBA   0xD105             BNE      ??HAL_TIM_PWM_Stop_IT_11
   \       0xBC   0x6820             LDR      R0,[R4, #+0]
   \       0xBE   0x6800             LDR      R0,[R0, #+0]
   \       0xC0   0x2101             MOVS     R1,#+1
   \       0xC2   0x4388             BICS     R0,R0,R1
   \       0xC4   0x6821             LDR      R1,[R4, #+0]
   \       0xC6   0x6008             STR      R0,[R1, #+0]
   1507          
   1508            /* Return function status */
   1509            return HAL_OK;
   \                     ??HAL_TIM_PWM_Stop_IT_11: (+1)
   \       0xC8   0x2000             MOVS     R0,#+0
   \       0xCA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1510          }
   1511          
   1512          /**
   1513            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1514            * @param  htim TIM PWM handle
   1515            * @param  Channel TIM Channels to be enabled
   1516            *          This parameter can be one of the following values:
   1517            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1518            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1519            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1520            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1521            * @param  pData The source Buffer address.
   1522            * @param  Length The length of data to be transferred from memory to TIM peripheral
   1523            * @retval HAL status
   1524            */

   \                                 In section .text, align 2, keep-with-next
   1525          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1526          {
   \                     HAL_TIM_PWM_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001D             MOVS     R5,R3
   1527            uint32_t tmpsmcr;
   1528          
   1529            /* Check the parameters */
   1530            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1531          
   1532            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xA   0x203D             MOVS     R0,#+61
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE      ??HAL_TIM_PWM_Start_DMA_0
   1533            {
   1534              return HAL_BUSY;
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE0BF             B        ??HAL_TIM_PWM_Start_DMA_1
   1535            }
   1536            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_PWM_Start_DMA_0: (+1)
   \       0x16   0x203D             MOVS     R0,#+61
   \       0x18   0x5C20             LDRB     R0,[R4, R0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD10A             BNE      ??HAL_TIM_PWM_Start_DMA_2
   1537            {
   1538              if ((pData == NULL) && (Length > 0U))
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD105             BNE      ??HAL_TIM_PWM_Start_DMA_3
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0xB280             UXTH     R0,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ      ??HAL_TIM_PWM_Start_DMA_3
   1539              {
   1540                return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE0B3             B        ??HAL_TIM_PWM_Start_DMA_1
   1541              }
   1542              else
   1543              {
   1544                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_PWM_Start_DMA_3: (+1)
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0x213D             MOVS     R1,#+61
   \       0x32   0x5460             STRB     R0,[R4, R1]
   1545              }
   1546            }
   1547            else
   1548            {
   1549              /* nothing to do */
   1550            }
   1551          
   1552            switch (Channel)
   \                     ??HAL_TIM_PWM_Start_DMA_2: (+1)
   \       0x34   0x0038             MOVS     R0,R7
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD006             BEQ      ??HAL_TIM_PWM_Start_DMA_4
   \       0x3A   0x2804             CMP      R0,#+4
   \       0x3C   0xD022             BEQ      ??HAL_TIM_PWM_Start_DMA_5
   \       0x3E   0x2808             CMP      R0,#+8
   \       0x40   0xD03E             BEQ      ??HAL_TIM_PWM_Start_DMA_6
   \       0x42   0x280C             CMP      R0,#+12
   \       0x44   0xD05A             BEQ      ??HAL_TIM_PWM_Start_DMA_7
   \       0x46   0xE077             B        ??HAL_TIM_PWM_Start_DMA_8
   1553            {
   1554              case TIM_CHANNEL_1:
   1555              {
   1556                /* Set the DMA compare callbacks */
   1557                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_4: (+1)
   \       0x48   0x....             LDR      R0,??DataTable22
   \       0x4A   0x6A61             LDR      R1,[R4, #+36]
   \       0x4C   0x62C8             STR      R0,[R1, #+44]
   1558                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x4E   0x....             LDR      R0,??DataTable22_1
   \       0x50   0x6A61             LDR      R1,[R4, #+36]
   \       0x52   0x6308             STR      R0,[R1, #+48]
   1559          
   1560                /* Set the DMA error callback */
   1561                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x54   0x....             LDR      R0,??DataTable22_2
   \       0x56   0x6A61             LDR      R1,[R4, #+36]
   \       0x58   0x6348             STR      R0,[R1, #+52]
   1562          
   1563                /* Enable the DMA channel */
   1564                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   \       0x5A   0x002B             MOVS     R3,R5
   \       0x5C   0xB29B             UXTH     R3,R3
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x0002             MOVS     R2,R0
   \       0x62   0x3234             ADDS     R2,R2,#+52
   \       0x64   0x0031             MOVS     R1,R6
   \       0x66   0x6A60             LDR      R0,[R4, #+36]
   \       0x68   0x....'....        BL       HAL_DMA_Start_IT
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD001             BEQ      ??HAL_TIM_PWM_Start_DMA_9
   1565                {
   1566                  return HAL_ERROR;
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xE090             B        ??HAL_TIM_PWM_Start_DMA_1
   1567                }
   1568          
   1569                /* Enable the TIM Capture/Compare 1 DMA request */
   1570                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Start_DMA_9: (+1)
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x68C0             LDR      R0,[R0, #+12]
   \       0x78   0x2180             MOVS     R1,#+128
   \       0x7A   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x7C   0x4301             ORRS     R1,R1,R0
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0x60C1             STR      R1,[R0, #+12]
   1571                break;
   \       0x82   0xE059             B        ??HAL_TIM_PWM_Start_DMA_10
   1572              }
   1573          
   1574              case TIM_CHANNEL_2:
   1575              {
   1576                /* Set the DMA compare callbacks */
   1577                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_5: (+1)
   \       0x84   0x....             LDR      R0,??DataTable22
   \       0x86   0x6AA1             LDR      R1,[R4, #+40]
   \       0x88   0x62C8             STR      R0,[R1, #+44]
   1578                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x8A   0x....             LDR      R0,??DataTable22_1
   \       0x8C   0x6AA1             LDR      R1,[R4, #+40]
   \       0x8E   0x6308             STR      R0,[R1, #+48]
   1579          
   1580                /* Set the DMA error callback */
   1581                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0x90   0x....             LDR      R0,??DataTable22_2
   \       0x92   0x6AA1             LDR      R1,[R4, #+40]
   \       0x94   0x6348             STR      R0,[R1, #+52]
   1582          
   1583                /* Enable the DMA channel */
   1584                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   \       0x96   0x002B             MOVS     R3,R5
   \       0x98   0xB29B             UXTH     R3,R3
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x0002             MOVS     R2,R0
   \       0x9E   0x3238             ADDS     R2,R2,#+56
   \       0xA0   0x0031             MOVS     R1,R6
   \       0xA2   0x6AA0             LDR      R0,[R4, #+40]
   \       0xA4   0x....'....        BL       HAL_DMA_Start_IT
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD001             BEQ      ??HAL_TIM_PWM_Start_DMA_11
   1585                {
   1586                  return HAL_ERROR;
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0xE072             B        ??HAL_TIM_PWM_Start_DMA_1
   1587                }
   1588                /* Enable the TIM Capture/Compare 2 DMA request */
   1589                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Start_DMA_11: (+1)
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x68C0             LDR      R0,[R0, #+12]
   \       0xB4   0x2180             MOVS     R1,#+128
   \       0xB6   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \       0xB8   0x4301             ORRS     R1,R1,R0
   \       0xBA   0x6820             LDR      R0,[R4, #+0]
   \       0xBC   0x60C1             STR      R1,[R0, #+12]
   1590                break;
   \       0xBE   0xE03B             B        ??HAL_TIM_PWM_Start_DMA_10
   1591              }
   1592          
   1593              case TIM_CHANNEL_3:
   1594              {
   1595                /* Set the DMA compare callbacks */
   1596                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_6: (+1)
   \       0xC0   0x....             LDR      R0,??DataTable22
   \       0xC2   0x6AE1             LDR      R1,[R4, #+44]
   \       0xC4   0x62C8             STR      R0,[R1, #+44]
   1597                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xC6   0x....             LDR      R0,??DataTable22_1
   \       0xC8   0x6AE1             LDR      R1,[R4, #+44]
   \       0xCA   0x6308             STR      R0,[R1, #+48]
   1598          
   1599                /* Set the DMA error callback */
   1600                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \       0xCC   0x....             LDR      R0,??DataTable22_2
   \       0xCE   0x6AE1             LDR      R1,[R4, #+44]
   \       0xD0   0x6348             STR      R0,[R1, #+52]
   1601          
   1602                /* Enable the DMA channel */
   1603                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   \       0xD2   0x002B             MOVS     R3,R5
   \       0xD4   0xB29B             UXTH     R3,R3
   \       0xD6   0x6820             LDR      R0,[R4, #+0]
   \       0xD8   0x0002             MOVS     R2,R0
   \       0xDA   0x323C             ADDS     R2,R2,#+60
   \       0xDC   0x0031             MOVS     R1,R6
   \       0xDE   0x6AE0             LDR      R0,[R4, #+44]
   \       0xE0   0x....'....        BL       HAL_DMA_Start_IT
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD001             BEQ      ??HAL_TIM_PWM_Start_DMA_12
   1604                {
   1605                  return HAL_ERROR;
   \       0xE8   0x2001             MOVS     R0,#+1
   \       0xEA   0xE054             B        ??HAL_TIM_PWM_Start_DMA_1
   1606                }
   1607                /* Enable the TIM Output Capture/Compare 3 request */
   1608                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Start_DMA_12: (+1)
   \       0xEC   0x6820             LDR      R0,[R4, #+0]
   \       0xEE   0x68C0             LDR      R0,[R0, #+12]
   \       0xF0   0x2180             MOVS     R1,#+128
   \       0xF2   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0xF4   0x4301             ORRS     R1,R1,R0
   \       0xF6   0x6820             LDR      R0,[R4, #+0]
   \       0xF8   0x60C1             STR      R1,[R0, #+12]
   1609                break;
   \       0xFA   0xE01D             B        ??HAL_TIM_PWM_Start_DMA_10
   1610              }
   1611          
   1612              case TIM_CHANNEL_4:
   1613              {
   1614                /* Set the DMA compare callbacks */
   1615                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_PWM_Start_DMA_7: (+1)
   \       0xFC   0x....             LDR      R0,??DataTable22
   \       0xFE   0x6B21             LDR      R1,[R4, #+48]
   \      0x100   0x62C8             STR      R0,[R1, #+44]
   1616                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \      0x102   0x....             LDR      R0,??DataTable22_1
   \      0x104   0x6B21             LDR      R1,[R4, #+48]
   \      0x106   0x6308             STR      R0,[R1, #+48]
   1617          
   1618                /* Set the DMA error callback */
   1619                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \      0x108   0x....             LDR      R0,??DataTable22_2
   \      0x10A   0x6B21             LDR      R1,[R4, #+48]
   \      0x10C   0x6348             STR      R0,[R1, #+52]
   1620          
   1621                /* Enable the DMA channel */
   1622                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length) != HAL_OK)
   \      0x10E   0x002B             MOVS     R3,R5
   \      0x110   0xB29B             UXTH     R3,R3
   \      0x112   0x6820             LDR      R0,[R4, #+0]
   \      0x114   0x0002             MOVS     R2,R0
   \      0x116   0x3240             ADDS     R2,R2,#+64
   \      0x118   0x0031             MOVS     R1,R6
   \      0x11A   0x6B20             LDR      R0,[R4, #+48]
   \      0x11C   0x....'....        BL       HAL_DMA_Start_IT
   \      0x120   0x2800             CMP      R0,#+0
   \      0x122   0xD001             BEQ      ??HAL_TIM_PWM_Start_DMA_13
   1623                {
   1624                  return HAL_ERROR;
   \      0x124   0x2001             MOVS     R0,#+1
   \      0x126   0xE036             B        ??HAL_TIM_PWM_Start_DMA_1
   1625                }
   1626                /* Enable the TIM Capture/Compare 4 DMA request */
   1627                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Start_DMA_13: (+1)
   \      0x128   0x6820             LDR      R0,[R4, #+0]
   \      0x12A   0x68C0             LDR      R0,[R0, #+12]
   \      0x12C   0x2180             MOVS     R1,#+128
   \      0x12E   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \      0x130   0x4301             ORRS     R1,R1,R0
   \      0x132   0x6820             LDR      R0,[R4, #+0]
   \      0x134   0x60C1             STR      R1,[R0, #+12]
   1628                break;
   \      0x136   0xE7FF             B        ??HAL_TIM_PWM_Start_DMA_10
   1629              }
   1630          
   1631              default:
   1632                break;
   1633            }
   1634          
   1635            /* Enable the Capture compare channel */
   1636            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_PWM_Start_DMA_8: (+1)
   \                     ??HAL_TIM_PWM_Start_DMA_10: (+1)
   \      0x138   0x2201             MOVS     R2,#+1
   \      0x13A   0x0039             MOVS     R1,R7
   \      0x13C   0x6820             LDR      R0,[R4, #+0]
   \      0x13E   0x....'....        BL       TIM_CCxChannelCmd
   1637          
   1638            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \      0x142   0x6820             LDR      R0,[R4, #+0]
   \      0x144   0x....             LDR      R1,??DataTable24  ;; 0x40012c00
   \      0x146   0x4288             CMP      R0,R1
   \      0x148   0xD007             BEQ      ??HAL_TIM_PWM_Start_DMA_14
   \      0x14A   0x6820             LDR      R0,[R4, #+0]
   \      0x14C   0x....             LDR      R1,??DataTable25  ;; 0x40014400
   \      0x14E   0x4288             CMP      R0,R1
   \      0x150   0xD003             BEQ      ??HAL_TIM_PWM_Start_DMA_14
   \      0x152   0x6820             LDR      R0,[R4, #+0]
   \      0x154   0x....             LDR      R1,??DataTable25_1  ;; 0x40014800
   \      0x156   0x4288             CMP      R0,R1
   \      0x158   0xD101             BNE      ??HAL_TIM_PWM_Start_DMA_15
   \                     ??HAL_TIM_PWM_Start_DMA_14: (+1)
   \      0x15A   0x2001             MOVS     R0,#+1
   \      0x15C   0xE000             B        ??HAL_TIM_PWM_Start_DMA_16
   \                     ??HAL_TIM_PWM_Start_DMA_15: (+1)
   \      0x15E   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_16: (+1)
   \      0x160   0xB2C0             UXTB     R0,R0
   \      0x162   0x2800             CMP      R0,#+0
   \      0x164   0xD006             BEQ      ??HAL_TIM_PWM_Start_DMA_17
   1639            {
   1640              /* Enable the main output */
   1641              __HAL_TIM_MOE_ENABLE(htim);
   \      0x166   0x6820             LDR      R0,[R4, #+0]
   \      0x168   0x6C40             LDR      R0,[R0, #+68]
   \      0x16A   0x2180             MOVS     R1,#+128
   \      0x16C   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \      0x16E   0x4301             ORRS     R1,R1,R0
   \      0x170   0x6820             LDR      R0,[R4, #+0]
   \      0x172   0x6441             STR      R1,[R0, #+68]
   1642            }
   1643          
   1644            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1645            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \                     ??HAL_TIM_PWM_Start_DMA_17: (+1)
   \      0x174   0x6820             LDR      R0,[R4, #+0]
   \      0x176   0x6880             LDR      R0,[R0, #+8]
   \      0x178   0x....             LDR      R1,??DataTable25_2  ;; 0x10007
   \      0x17A   0x4001             ANDS     R1,R1,R0
   1646            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \      0x17C   0x2906             CMP      R1,#+6
   \      0x17E   0xD009             BEQ      ??HAL_TIM_PWM_Start_DMA_18
   \      0x180   0x2080             MOVS     R0,#+128
   \      0x182   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \      0x184   0x4281             CMP      R1,R0
   \      0x186   0xD005             BEQ      ??HAL_TIM_PWM_Start_DMA_18
   1647            {
   1648              __HAL_TIM_ENABLE(htim);
   \      0x188   0x6820             LDR      R0,[R4, #+0]
   \      0x18A   0x6800             LDR      R0,[R0, #+0]
   \      0x18C   0x2201             MOVS     R2,#+1
   \      0x18E   0x4302             ORRS     R2,R2,R0
   \      0x190   0x6820             LDR      R0,[R4, #+0]
   \      0x192   0x6002             STR      R2,[R0, #+0]
   1649            }
   1650          
   1651            /* Return function status */
   1652            return HAL_OK;
   \                     ??HAL_TIM_PWM_Start_DMA_18: (+1)
   \      0x194   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Start_DMA_1: (+1)
   \      0x196   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1653          }
   1654          
   1655          /**
   1656            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1657            * @param  htim TIM PWM handle
   1658            * @param  Channel TIM Channels to be disabled
   1659            *          This parameter can be one of the following values:
   1660            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1661            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1662            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1663            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1664            * @retval HAL status
   1665            */

   \                                 In section .text, align 2, keep-with-next
   1666          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1667          {
   \                     HAL_TIM_PWM_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1668            /* Check the parameters */
   1669            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1670          
   1671            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ      ??HAL_TIM_PWM_Stop_DMA_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00E             BEQ      ??HAL_TIM_PWM_Stop_DMA_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD016             BEQ      ??HAL_TIM_PWM_Stop_DMA_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD01E             BEQ      ??HAL_TIM_PWM_Stop_DMA_3
   \       0x18   0xE027             B        ??HAL_TIM_PWM_Stop_DMA_4
   1672            {
   1673              case TIM_CHANNEL_1:
   1674              {
   1675                /* Disable the TIM Capture/Compare 1 DMA request */
   1676                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_PWM_Stop_DMA_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0x....             LDR      R1,??DataTable25_3  ;; 0xfffffdff
   \       0x20   0x4001             ANDS     R1,R1,R0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x60C1             STR      R1,[R0, #+12]
   1677                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x26   0x6A60             LDR      R0,[R4, #+36]
   \       0x28   0x....'....        BL       HAL_DMA_Abort_IT
   1678                break;
   \       0x2C   0xE01D             B        ??HAL_TIM_PWM_Stop_DMA_5
   1679              }
   1680          
   1681              case TIM_CHANNEL_2:
   1682              {
   1683                /* Disable the TIM Capture/Compare 2 DMA request */
   1684                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_PWM_Stop_DMA_1: (+1)
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x68C0             LDR      R0,[R0, #+12]
   \       0x32   0x....             LDR      R1,??DataTable26  ;; 0xfffffbff
   \       0x34   0x4001             ANDS     R1,R1,R0
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x60C1             STR      R1,[R0, #+12]
   1685                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x3A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x3C   0x....'....        BL       HAL_DMA_Abort_IT
   1686                break;
   \       0x40   0xE013             B        ??HAL_TIM_PWM_Stop_DMA_5
   1687              }
   1688          
   1689              case TIM_CHANNEL_3:
   1690              {
   1691                /* Disable the TIM Capture/Compare 3 DMA request */
   1692                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_PWM_Stop_DMA_2: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x68C0             LDR      R0,[R0, #+12]
   \       0x46   0x....             LDR      R1,??DataTable26_1  ;; 0xfffff7ff
   \       0x48   0x4001             ANDS     R1,R1,R0
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x60C1             STR      R1,[R0, #+12]
   1693                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \       0x4E   0x6AE0             LDR      R0,[R4, #+44]
   \       0x50   0x....'....        BL       HAL_DMA_Abort_IT
   1694                break;
   \       0x54   0xE009             B        ??HAL_TIM_PWM_Stop_DMA_5
   1695              }
   1696          
   1697              case TIM_CHANNEL_4:
   1698              {
   1699                /* Disable the TIM Capture/Compare 4 interrupt */
   1700                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_PWM_Stop_DMA_3: (+1)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x68C0             LDR      R0,[R0, #+12]
   \       0x5A   0x....             LDR      R1,??DataTable26_2  ;; 0xffffefff
   \       0x5C   0x4001             ANDS     R1,R1,R0
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x60C1             STR      R1,[R0, #+12]
   1701                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \       0x62   0x6B20             LDR      R0,[R4, #+48]
   \       0x64   0x....'....        BL       HAL_DMA_Abort_IT
   1702                break;
   \       0x68   0xE7FF             B        ??HAL_TIM_PWM_Stop_DMA_5
   1703              }
   1704          
   1705              default:
   1706                break;
   1707            }
   1708          
   1709            /* Disable the Capture compare channel */
   1710            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_PWM_Stop_DMA_4: (+1)
   \                     ??HAL_TIM_PWM_Stop_DMA_5: (+1)
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0x0029             MOVS     R1,R5
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x....'....        BL       TIM_CCxChannelCmd
   1711          
   1712            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x....             LDR      R1,??DataTable24  ;; 0x40012c00
   \       0x78   0x4288             CMP      R0,R1
   \       0x7A   0xD007             BEQ      ??HAL_TIM_PWM_Stop_DMA_6
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x....             LDR      R1,??DataTable25  ;; 0x40014400
   \       0x80   0x4288             CMP      R0,R1
   \       0x82   0xD003             BEQ      ??HAL_TIM_PWM_Stop_DMA_6
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x....             LDR      R1,??DataTable25_1  ;; 0x40014800
   \       0x88   0x4288             CMP      R0,R1
   \       0x8A   0xD101             BNE      ??HAL_TIM_PWM_Stop_DMA_7
   \                     ??HAL_TIM_PWM_Stop_DMA_6: (+1)
   \       0x8C   0x2001             MOVS     R0,#+1
   \       0x8E   0xE000             B        ??HAL_TIM_PWM_Stop_DMA_8
   \                     ??HAL_TIM_PWM_Stop_DMA_7: (+1)
   \       0x90   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_Stop_DMA_8: (+1)
   \       0x92   0xB2C0             UXTB     R0,R0
   \       0x94   0x2800             CMP      R0,#+0
   \       0x96   0xD011             BEQ      ??HAL_TIM_PWM_Stop_DMA_9
   1713            {
   1714              /* Disable the Main Output */
   1715              __HAL_TIM_MOE_DISABLE(htim);
   \       0x98   0x6820             LDR      R0,[R4, #+0]
   \       0x9A   0x6A00             LDR      R0,[R0, #+32]
   \       0x9C   0x....             LDR      R1,??DataTable26_3  ;; 0x1111
   \       0x9E   0x4001             ANDS     R1,R1,R0
   \       0xA0   0x2900             CMP      R1,#+0
   \       0xA2   0xD10B             BNE      ??HAL_TIM_PWM_Stop_DMA_10
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x6A00             LDR      R0,[R0, #+32]
   \       0xA8   0x....             LDR      R1,??DataTable21  ;; 0x444
   \       0xAA   0x4001             ANDS     R1,R1,R0
   \       0xAC   0x2900             CMP      R1,#+0
   \       0xAE   0xD105             BNE      ??HAL_TIM_PWM_Stop_DMA_10
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x6C40             LDR      R0,[R0, #+68]
   \       0xB4   0x....             LDR      R1,??DataTable26_4  ;; 0xffff7fff
   \       0xB6   0x4001             ANDS     R1,R1,R0
   \       0xB8   0x6820             LDR      R0,[R4, #+0]
   \       0xBA   0x6441             STR      R1,[R0, #+68]
   1716            }
   1717          
   1718            /* Disable the Peripheral */
   1719            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_PWM_Stop_DMA_10: (+1)
   \                     ??HAL_TIM_PWM_Stop_DMA_9: (+1)
   \       0xBC   0x6820             LDR      R0,[R4, #+0]
   \       0xBE   0x6A00             LDR      R0,[R0, #+32]
   \       0xC0   0x....             LDR      R1,??DataTable26_3  ;; 0x1111
   \       0xC2   0x4001             ANDS     R1,R1,R0
   \       0xC4   0x2900             CMP      R1,#+0
   \       0xC6   0xD10B             BNE      ??HAL_TIM_PWM_Stop_DMA_11
   \       0xC8   0x6820             LDR      R0,[R4, #+0]
   \       0xCA   0x6A00             LDR      R0,[R0, #+32]
   \       0xCC   0x....             LDR      R1,??DataTable21  ;; 0x444
   \       0xCE   0x4001             ANDS     R1,R1,R0
   \       0xD0   0x2900             CMP      R1,#+0
   \       0xD2   0xD105             BNE      ??HAL_TIM_PWM_Stop_DMA_11
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x6800             LDR      R0,[R0, #+0]
   \       0xD8   0x2101             MOVS     R1,#+1
   \       0xDA   0x4388             BICS     R0,R0,R1
   \       0xDC   0x6821             LDR      R1,[R4, #+0]
   \       0xDE   0x6008             STR      R0,[R1, #+0]
   1720          
   1721            /* Change the htim state */
   1722            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_Stop_DMA_11: (+1)
   \       0xE0   0x2001             MOVS     R0,#+1
   \       0xE2   0x213D             MOVS     R1,#+61
   \       0xE4   0x5460             STRB     R0,[R4, R1]
   1723          
   1724            /* Return function status */
   1725            return HAL_OK;
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1726          }
   1727          
   1728          /**
   1729            * @}
   1730            */
   1731          
   1732          /** @defgroup TIM_Exported_Functions_Group4 TIM Input Capture functions
   1733            *  @brief    TIM Input Capture functions
   1734            *
   1735          @verbatim
   1736            ==============================================================================
   1737                        ##### TIM Input Capture functions #####
   1738            ==============================================================================
   1739           [..]
   1740             This section provides functions allowing to:
   1741             (+) Initialize and configure the TIM Input Capture.
   1742             (+) De-initialize the TIM Input Capture.
   1743             (+) Start the TIM Input Capture.
   1744             (+) Stop the TIM Input Capture.
   1745             (+) Start the TIM Input Capture and enable interrupt.
   1746             (+) Stop the TIM Input Capture and disable interrupt.
   1747             (+) Start the TIM Input Capture and enable DMA transfer.
   1748             (+) Stop the TIM Input Capture and disable DMA transfer.
   1749          
   1750          @endverbatim
   1751            * @{
   1752            */
   1753          /**
   1754            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1755            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   1756            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1757            *         requires a timer reset to avoid unexpected direction
   1758            *         due to DIR bit readonly in center aligned mode.
   1759            *         Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()
   1760            * @param  htim TIM Input Capture handle
   1761            * @retval HAL status
   1762            */

   \                                 In section .text, align 2, keep-with-next
   1763          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1764          {
   \                     HAL_TIM_IC_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1765            /* Check the TIM handle allocation */
   1766            if (htim == NULL)
   \        0x4   0x2C00             CMP      R4,#+0
   \        0x6   0xD101             BNE      ??HAL_TIM_IC_Init_0
   1767            {
   1768              return HAL_ERROR;
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0xE014             B        ??HAL_TIM_IC_Init_1
   1769            }
   1770          
   1771            /* Check the parameters */
   1772            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1773            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1774            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1775            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1776          
   1777            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_IC_Init_0: (+1)
   \        0xC   0x203D             MOVS     R0,#+61
   \        0xE   0x5C20             LDRB     R0,[R4, R0]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD105             BNE      ??HAL_TIM_IC_Init_2
   1778            {
   1779              /* Allocate lock resource and initialize it */
   1780              htim->Lock = HAL_UNLOCKED;
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x213C             MOVS     R1,#+60
   \       0x18   0x5460             STRB     R0,[R4, R1]
   1781          
   1782          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1783              /* Reset interrupt callbacks to legacy weak callbacks */
   1784              TIM_ResetCallback(htim);
   1785          
   1786              if (htim->IC_MspInitCallback == NULL)
   1787              {
   1788                htim->IC_MspInitCallback = HAL_TIM_IC_MspInit;
   1789              }
   1790              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   1791              htim->IC_MspInitCallback(htim);
   1792          #else
   1793              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1794              HAL_TIM_IC_MspInit(htim);
   \       0x1A   0x0020             MOVS     R0,R4
   \       0x1C   0x....'....        BL       HAL_TIM_IC_MspInit
   1795          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1796            }
   1797          
   1798            /* Set the TIM state */
   1799            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Init_2: (+1)
   \       0x20   0x2002             MOVS     R0,#+2
   \       0x22   0x213D             MOVS     R1,#+61
   \       0x24   0x5460             STRB     R0,[R4, R1]
   1800          
   1801            /* Init the base time for the input capture */
   1802            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x26   0x1D21             ADDS     R1,R4,#+4
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x....'....        BL       TIM_Base_SetConfig
   1803          
   1804            /* Initialize the TIM state*/
   1805            htim->State = HAL_TIM_STATE_READY;
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0x213D             MOVS     R1,#+61
   \       0x32   0x5460             STRB     R0,[R4, R1]
   1806          
   1807            return HAL_OK;
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Init_1: (+1)
   \       0x36   0xBD10             POP      {R4,PC}          ;; return
   1808          }
   1809          
   1810          /**
   1811            * @brief  DeInitializes the TIM peripheral
   1812            * @param  htim TIM Input Capture handle
   1813            * @retval HAL status
   1814            */

   \                                 In section .text, align 2, keep-with-next
   1815          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1816          {
   \                     HAL_TIM_IC_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1817            /* Check the parameters */
   1818            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1819          
   1820            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x213D             MOVS     R1,#+61
   \        0x8   0x5460             STRB     R0,[R4, R1]
   1821          
   1822            /* Disable the TIM Peripheral Clock */
   1823            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable26_3  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD10B             BNE      ??HAL_TIM_IC_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0x....             LDR      R1,??DataTable26_5  ;; 0x444
   \       0x1C   0x4001             ANDS     R1,R1,R0
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD105             BNE      ??HAL_TIM_IC_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x4388             BICS     R0,R0,R1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   1824          
   1825          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   1826            if (htim->IC_MspDeInitCallback == NULL)
   1827            {
   1828              htim->IC_MspDeInitCallback = HAL_TIM_IC_MspDeInit;
   1829            }
   1830            /* DeInit the low level hardware */
   1831            htim->IC_MspDeInitCallback(htim);
   1832          #else
   1833            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1834            HAL_TIM_IC_MspDeInit(htim);
   \                     ??HAL_TIM_IC_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x....'....        BL       HAL_TIM_IC_MspDeInit
   1835          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   1836          
   1837            /* Change TIM state */
   1838            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x0001             MOVS     R1,R0
   \       0x38   0x223D             MOVS     R2,#+61
   \       0x3A   0x54A1             STRB     R1,[R4, R2]
   1839          
   1840            /* Release Lock */
   1841            __HAL_UNLOCK(htim);
   \       0x3C   0x213C             MOVS     R1,#+60
   \       0x3E   0x5460             STRB     R0,[R4, R1]
   1842          
   1843            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}          ;; return
   1844          }
   1845          
   1846          /**
   1847            * @brief  Initializes the TIM Input Capture MSP.
   1848            * @param  htim TIM Input Capture handle
   1849            * @retval None
   1850            */

   \                                 In section .text, align 2
   1851          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1852          {
   1853            /* Prevent unused argument(s) compilation warning */
   1854            UNUSED(htim);
   1855          
   1856            /* NOTE : This function should not be modified, when the callback is needed,
   1857                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1858             */
   1859          }
   \                     HAL_TIM_IC_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1860          
   1861          /**
   1862            * @brief  DeInitializes TIM Input Capture MSP.
   1863            * @param  htim TIM handle
   1864            * @retval None
   1865            */

   \                                 In section .text, align 2
   1866          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1867          {
   1868            /* Prevent unused argument(s) compilation warning */
   1869            UNUSED(htim);
   1870          
   1871            /* NOTE : This function should not be modified, when the callback is needed,
   1872                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1873             */
   1874          }
   \                     HAL_TIM_IC_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1875          
   1876          /**
   1877            * @brief  Starts the TIM Input Capture measurement.
   1878            * @param  htim TIM Input Capture handle
   1879            * @param  Channel TIM Channels to be enabled
   1880            *          This parameter can be one of the following values:
   1881            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1882            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1883            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1884            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1885            * @retval HAL status
   1886            */

   \                                 In section .text, align 2, keep-with-next
   1887          HAL_StatusTypeDef HAL_TIM_IC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1888          {
   \                     HAL_TIM_IC_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1889            uint32_t tmpsmcr;
   1890          
   1891            /* Check the parameters */
   1892            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1893          
   1894            /* Enable the Input Capture channel */
   1895            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxChannelCmd
   1896          
   1897            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1898            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6880             LDR      R0,[R0, #+8]
   \       0x14   0x....             LDR      R1,??DataTable25_2  ;; 0x10007
   \       0x16   0x4001             ANDS     R1,R1,R0
   1899            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x18   0x2906             CMP      R1,#+6
   \       0x1A   0xD009             BEQ      ??HAL_TIM_IC_Start_0
   \       0x1C   0x2080             MOVS     R0,#+128
   \       0x1E   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x20   0x4281             CMP      R1,R0
   \       0x22   0xD005             BEQ      ??HAL_TIM_IC_Start_0
   1900            {
   1901              __HAL_TIM_ENABLE(htim);
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0x2201             MOVS     R2,#+1
   \       0x2A   0x4302             ORRS     R2,R2,R0
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6002             STR      R2,[R0, #+0]
   1902            }
   1903          
   1904            /* Return function status */
   1905            return HAL_OK;
   \                     ??HAL_TIM_IC_Start_0: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1906          }
   1907          
   1908          /**
   1909            * @brief  Stops the TIM Input Capture measurement.
   1910            * @param  htim TIM Input Capture handle
   1911            * @param  Channel TIM Channels to be disabled
   1912            *          This parameter can be one of the following values:
   1913            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1914            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1915            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1916            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1917            * @retval HAL status
   1918            */

   \                                 In section .text, align 2, keep-with-next
   1919          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1920          {
   \                     HAL_TIM_IC_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1921            /* Check the parameters */
   1922            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1923          
   1924            /* Disable the Input Capture channel */
   1925            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxChannelCmd
   1926          
   1927            /* Disable the Peripheral */
   1928            __HAL_TIM_DISABLE(htim);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6A00             LDR      R0,[R0, #+32]
   \       0x14   0x....             LDR      R1,??DataTable26_3  ;; 0x1111
   \       0x16   0x4001             ANDS     R1,R1,R0
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD10B             BNE      ??HAL_TIM_IC_Stop_0
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x6A00             LDR      R0,[R0, #+32]
   \       0x20   0x....             LDR      R1,??DataTable26_5  ;; 0x444
   \       0x22   0x4001             ANDS     R1,R1,R0
   \       0x24   0x2900             CMP      R1,#+0
   \       0x26   0xD105             BNE      ??HAL_TIM_IC_Stop_0
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x4388             BICS     R0,R0,R1
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x6008             STR      R0,[R1, #+0]
   1929          
   1930            /* Return function status */
   1931            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_0: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1932          }
   1933          
   1934          /**
   1935            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1936            * @param  htim TIM Input Capture handle
   1937            * @param  Channel TIM Channels to be enabled
   1938            *          This parameter can be one of the following values:
   1939            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1940            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1941            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1942            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1943            * @retval HAL status
   1944            */

   \                                 In section .text, align 2, keep-with-next
   1945          HAL_StatusTypeDef HAL_TIM_IC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1946          {
   \                     HAL_TIM_IC_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1947            uint32_t tmpsmcr;
   1948          
   1949            /* Check the parameters */
   1950            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1951          
   1952            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ      ??HAL_TIM_IC_Start_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00B             BEQ      ??HAL_TIM_IC_Start_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD010             BEQ      ??HAL_TIM_IC_Start_IT_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD015             BEQ      ??HAL_TIM_IC_Start_IT_3
   \       0x18   0xE01B             B        ??HAL_TIM_IC_Start_IT_4
   1953            {
   1954              case TIM_CHANNEL_1:
   1955              {
   1956                /* Enable the TIM Capture/Compare 1 interrupt */
   1957                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Start_IT_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0x2102             MOVS     R1,#+2
   \       0x20   0x4301             ORRS     R1,R1,R0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x60C1             STR      R1,[R0, #+12]
   1958                break;
   \       0x26   0xE014             B        ??HAL_TIM_IC_Start_IT_5
   1959              }
   1960          
   1961              case TIM_CHANNEL_2:
   1962              {
   1963                /* Enable the TIM Capture/Compare 2 interrupt */
   1964                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Start_IT_1: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0x2104             MOVS     R1,#+4
   \       0x2E   0x4301             ORRS     R1,R1,R0
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x60C1             STR      R1,[R0, #+12]
   1965                break;
   \       0x34   0xE00D             B        ??HAL_TIM_IC_Start_IT_5
   1966              }
   1967          
   1968              case TIM_CHANNEL_3:
   1969              {
   1970                /* Enable the TIM Capture/Compare 3 interrupt */
   1971                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Start_IT_2: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0x2108             MOVS     R1,#+8
   \       0x3C   0x4301             ORRS     R1,R1,R0
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x60C1             STR      R1,[R0, #+12]
   1972                break;
   \       0x42   0xE006             B        ??HAL_TIM_IC_Start_IT_5
   1973              }
   1974          
   1975              case TIM_CHANNEL_4:
   1976              {
   1977                /* Enable the TIM Capture/Compare 4 interrupt */
   1978                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Start_IT_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0x2110             MOVS     R1,#+16
   \       0x4A   0x4301             ORRS     R1,R1,R0
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x60C1             STR      R1,[R0, #+12]
   1979                break;
   \       0x50   0xE7FF             B        ??HAL_TIM_IC_Start_IT_5
   1980              }
   1981          
   1982              default:
   1983                break;
   1984            }
   1985            /* Enable the Input Capture channel */
   1986            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_IT_4: (+1)
   \                     ??HAL_TIM_IC_Start_IT_5: (+1)
   \       0x52   0x2201             MOVS     R2,#+1
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x....'....        BL       TIM_CCxChannelCmd
   1987          
   1988            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1989            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6880             LDR      R0,[R0, #+8]
   \       0x60   0x....             LDR      R1,??DataTable25_2  ;; 0x10007
   \       0x62   0x4001             ANDS     R1,R1,R0
   1990            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x64   0x2906             CMP      R1,#+6
   \       0x66   0xD009             BEQ      ??HAL_TIM_IC_Start_IT_6
   \       0x68   0x2080             MOVS     R0,#+128
   \       0x6A   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x6C   0x4281             CMP      R1,R0
   \       0x6E   0xD005             BEQ      ??HAL_TIM_IC_Start_IT_6
   1991            {
   1992              __HAL_TIM_ENABLE(htim);
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6800             LDR      R0,[R0, #+0]
   \       0x74   0x2201             MOVS     R2,#+1
   \       0x76   0x4302             ORRS     R2,R2,R0
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x6002             STR      R2,[R0, #+0]
   1993            }
   1994          
   1995            /* Return function status */
   1996            return HAL_OK;
   \                     ??HAL_TIM_IC_Start_IT_6: (+1)
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1997          }
   1998          
   1999          /**
   2000            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   2001            * @param  htim TIM Input Capture handle
   2002            * @param  Channel TIM Channels to be disabled
   2003            *          This parameter can be one of the following values:
   2004            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2005            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2006            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2007            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2008            * @retval HAL status
   2009            */

   \                                 In section .text, align 2, keep-with-next
   2010          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2011          {
   \                     HAL_TIM_IC_Stop_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2012            /* Check the parameters */
   2013            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2014          
   2015            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ      ??HAL_TIM_IC_Stop_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00B             BEQ      ??HAL_TIM_IC_Stop_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD010             BEQ      ??HAL_TIM_IC_Stop_IT_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD015             BEQ      ??HAL_TIM_IC_Stop_IT_3
   \       0x18   0xE01B             B        ??HAL_TIM_IC_Stop_IT_4
   2016            {
   2017              case TIM_CHANNEL_1:
   2018              {
   2019                /* Disable the TIM Capture/Compare 1 interrupt */
   2020                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIM_IC_Stop_IT_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0x2102             MOVS     R1,#+2
   \       0x20   0x4388             BICS     R0,R0,R1
   \       0x22   0x6821             LDR      R1,[R4, #+0]
   \       0x24   0x60C8             STR      R0,[R1, #+12]
   2021                break;
   \       0x26   0xE014             B        ??HAL_TIM_IC_Stop_IT_5
   2022              }
   2023          
   2024              case TIM_CHANNEL_2:
   2025              {
   2026                /* Disable the TIM Capture/Compare 2 interrupt */
   2027                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIM_IC_Stop_IT_1: (+1)
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x68C0             LDR      R0,[R0, #+12]
   \       0x2C   0x2104             MOVS     R1,#+4
   \       0x2E   0x4388             BICS     R0,R0,R1
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x60C8             STR      R0,[R1, #+12]
   2028                break;
   \       0x34   0xE00D             B        ??HAL_TIM_IC_Stop_IT_5
   2029              }
   2030          
   2031              case TIM_CHANNEL_3:
   2032              {
   2033                /* Disable the TIM Capture/Compare 3 interrupt */
   2034                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIM_IC_Stop_IT_2: (+1)
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0x2108             MOVS     R1,#+8
   \       0x3C   0x4388             BICS     R0,R0,R1
   \       0x3E   0x6821             LDR      R1,[R4, #+0]
   \       0x40   0x60C8             STR      R0,[R1, #+12]
   2035                break;
   \       0x42   0xE006             B        ??HAL_TIM_IC_Stop_IT_5
   2036              }
   2037          
   2038              case TIM_CHANNEL_4:
   2039              {
   2040                /* Disable the TIM Capture/Compare 4 interrupt */
   2041                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   \                     ??HAL_TIM_IC_Stop_IT_3: (+1)
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0x2110             MOVS     R1,#+16
   \       0x4A   0x4388             BICS     R0,R0,R1
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x60C8             STR      R0,[R1, #+12]
   2042                break;
   \       0x50   0xE7FF             B        ??HAL_TIM_IC_Stop_IT_5
   2043              }
   2044          
   2045              default:
   2046                break;
   2047            }
   2048          
   2049            /* Disable the Input Capture channel */
   2050            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_IT_4: (+1)
   \                     ??HAL_TIM_IC_Stop_IT_5: (+1)
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x....'....        BL       TIM_CCxChannelCmd
   2051          
   2052            /* Disable the Peripheral */
   2053            __HAL_TIM_DISABLE(htim);
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6A00             LDR      R0,[R0, #+32]
   \       0x60   0x....             LDR      R1,??DataTable26_3  ;; 0x1111
   \       0x62   0x4001             ANDS     R1,R1,R0
   \       0x64   0x2900             CMP      R1,#+0
   \       0x66   0xD10B             BNE      ??HAL_TIM_IC_Stop_IT_6
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x6A00             LDR      R0,[R0, #+32]
   \       0x6C   0x....             LDR      R1,??DataTable26_5  ;; 0x444
   \       0x6E   0x4001             ANDS     R1,R1,R0
   \       0x70   0x2900             CMP      R1,#+0
   \       0x72   0xD105             BNE      ??HAL_TIM_IC_Stop_IT_6
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x6800             LDR      R0,[R0, #+0]
   \       0x78   0x2101             MOVS     R1,#+1
   \       0x7A   0x4388             BICS     R0,R0,R1
   \       0x7C   0x6821             LDR      R1,[R4, #+0]
   \       0x7E   0x6008             STR      R0,[R1, #+0]
   2054          
   2055            /* Return function status */
   2056            return HAL_OK;
   \                     ??HAL_TIM_IC_Stop_IT_6: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2057          }
   2058          
   2059          /**
   2060            * @brief  Starts the TIM Input Capture measurement in DMA mode.
   2061            * @param  htim TIM Input Capture handle
   2062            * @param  Channel TIM Channels to be enabled
   2063            *          This parameter can be one of the following values:
   2064            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2065            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2066            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2067            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2068            * @param  pData The destination Buffer address.
   2069            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2070            * @retval HAL status
   2071            */

   \                                 In section .text, align 2, keep-with-next
   2072          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   2073          {
   \                     HAL_TIM_IC_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001D             MOVS     R5,R3
   2074            uint32_t tmpsmcr;
   2075          
   2076            /* Check the parameters */
   2077            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2078            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2079          
   2080            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xA   0x203D             MOVS     R0,#+61
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE      ??HAL_TIM_IC_Start_DMA_0
   2081            {
   2082              return HAL_BUSY;
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE0A6             B        ??HAL_TIM_IC_Start_DMA_1
   2083            }
   2084            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_IC_Start_DMA_0: (+1)
   \       0x16   0x203D             MOVS     R0,#+61
   \       0x18   0x5C20             LDRB     R0,[R4, R0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD10A             BNE      ??HAL_TIM_IC_Start_DMA_2
   2085            {
   2086              if ((pData == NULL) && (Length > 0U))
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD105             BNE      ??HAL_TIM_IC_Start_DMA_3
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0xB280             UXTH     R0,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ      ??HAL_TIM_IC_Start_DMA_3
   2087              {
   2088                return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE09A             B        ??HAL_TIM_IC_Start_DMA_1
   2089              }
   2090              else
   2091              {
   2092                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_IC_Start_DMA_3: (+1)
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0x213D             MOVS     R1,#+61
   \       0x32   0x5460             STRB     R0,[R4, R1]
   2093              }
   2094            }
   2095            else
   2096            {
   2097              /* nothing to do */
   2098            }
   2099          
   2100            switch (Channel)
   \                     ??HAL_TIM_IC_Start_DMA_2: (+1)
   \       0x34   0x0038             MOVS     R0,R7
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD006             BEQ      ??HAL_TIM_IC_Start_DMA_4
   \       0x3A   0x2804             CMP      R0,#+4
   \       0x3C   0xD022             BEQ      ??HAL_TIM_IC_Start_DMA_5
   \       0x3E   0x2808             CMP      R0,#+8
   \       0x40   0xD03E             BEQ      ??HAL_TIM_IC_Start_DMA_6
   \       0x42   0x280C             CMP      R0,#+12
   \       0x44   0xD05A             BEQ      ??HAL_TIM_IC_Start_DMA_7
   \       0x46   0xE077             B        ??HAL_TIM_IC_Start_DMA_8
   2101            {
   2102              case TIM_CHANNEL_1:
   2103              {
   2104                /* Set the DMA capture callbacks */
   2105                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_4: (+1)
   \       0x48   0x....             LDR      R0,??DataTable30
   \       0x4A   0x6A61             LDR      R1,[R4, #+36]
   \       0x4C   0x62C8             STR      R0,[R1, #+44]
   2106                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x4E   0x....             LDR      R0,??DataTable30_1
   \       0x50   0x6A61             LDR      R1,[R4, #+36]
   \       0x52   0x6308             STR      R0,[R1, #+48]
   2107          
   2108                /* Set the DMA error callback */
   2109                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x54   0x....             LDR      R0,??DataTable30_2
   \       0x56   0x6A61             LDR      R1,[R4, #+36]
   \       0x58   0x6348             STR      R0,[R1, #+52]
   2110          
   2111                /* Enable the DMA channel */
   2112                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
   \       0x5A   0x002B             MOVS     R3,R5
   \       0x5C   0xB29B             UXTH     R3,R3
   \       0x5E   0x0032             MOVS     R2,R6
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x0001             MOVS     R1,R0
   \       0x64   0x3134             ADDS     R1,R1,#+52
   \       0x66   0x6A60             LDR      R0,[R4, #+36]
   \       0x68   0x....'....        BL       HAL_DMA_Start_IT
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD001             BEQ      ??HAL_TIM_IC_Start_DMA_9
   2113                {
   2114                  return HAL_ERROR;
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xE077             B        ??HAL_TIM_IC_Start_DMA_1
   2115                }
   2116                /* Enable the TIM Capture/Compare 1 DMA request */
   2117                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Start_DMA_9: (+1)
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x68C0             LDR      R0,[R0, #+12]
   \       0x78   0x2180             MOVS     R1,#+128
   \       0x7A   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x7C   0x4301             ORRS     R1,R1,R0
   \       0x7E   0x6820             LDR      R0,[R4, #+0]
   \       0x80   0x60C1             STR      R1,[R0, #+12]
   2118                break;
   \       0x82   0xE059             B        ??HAL_TIM_IC_Start_DMA_10
   2119              }
   2120          
   2121              case TIM_CHANNEL_2:
   2122              {
   2123                /* Set the DMA capture callbacks */
   2124                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_5: (+1)
   \       0x84   0x....             LDR      R0,??DataTable30
   \       0x86   0x6AA1             LDR      R1,[R4, #+40]
   \       0x88   0x62C8             STR      R0,[R1, #+44]
   2125                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x8A   0x....             LDR      R0,??DataTable30_1
   \       0x8C   0x6AA1             LDR      R1,[R4, #+40]
   \       0x8E   0x6308             STR      R0,[R1, #+48]
   2126          
   2127                /* Set the DMA error callback */
   2128                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0x90   0x....             LDR      R0,??DataTable30_2
   \       0x92   0x6AA1             LDR      R1,[R4, #+40]
   \       0x94   0x6348             STR      R0,[R1, #+52]
   2129          
   2130                /* Enable the DMA channel */
   2131                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length) != HAL_OK)
   \       0x96   0x002B             MOVS     R3,R5
   \       0x98   0xB29B             UXTH     R3,R3
   \       0x9A   0x0032             MOVS     R2,R6
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x0001             MOVS     R1,R0
   \       0xA0   0x3138             ADDS     R1,R1,#+56
   \       0xA2   0x6AA0             LDR      R0,[R4, #+40]
   \       0xA4   0x....'....        BL       HAL_DMA_Start_IT
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD001             BEQ      ??HAL_TIM_IC_Start_DMA_11
   2132                {
   2133                  return HAL_ERROR;
   \       0xAC   0x2001             MOVS     R0,#+1
   \       0xAE   0xE059             B        ??HAL_TIM_IC_Start_DMA_1
   2134                }
   2135                /* Enable the TIM Capture/Compare 2  DMA request */
   2136                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Start_DMA_11: (+1)
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x68C0             LDR      R0,[R0, #+12]
   \       0xB4   0x2180             MOVS     R1,#+128
   \       0xB6   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \       0xB8   0x4301             ORRS     R1,R1,R0
   \       0xBA   0x6820             LDR      R0,[R4, #+0]
   \       0xBC   0x60C1             STR      R1,[R0, #+12]
   2137                break;
   \       0xBE   0xE03B             B        ??HAL_TIM_IC_Start_DMA_10
   2138              }
   2139          
   2140              case TIM_CHANNEL_3:
   2141              {
   2142                /* Set the DMA capture callbacks */
   2143                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_6: (+1)
   \       0xC0   0x....             LDR      R0,??DataTable30
   \       0xC2   0x6AE1             LDR      R1,[R4, #+44]
   \       0xC4   0x62C8             STR      R0,[R1, #+44]
   2144                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xC6   0x....             LDR      R0,??DataTable30_1
   \       0xC8   0x6AE1             LDR      R1,[R4, #+44]
   \       0xCA   0x6308             STR      R0,[R1, #+48]
   2145          
   2146                /* Set the DMA error callback */
   2147                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \       0xCC   0x....             LDR      R0,??DataTable30_2
   \       0xCE   0x6AE1             LDR      R1,[R4, #+44]
   \       0xD0   0x6348             STR      R0,[R1, #+52]
   2148          
   2149                /* Enable the DMA channel */
   2150                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length) != HAL_OK)
   \       0xD2   0x002B             MOVS     R3,R5
   \       0xD4   0xB29B             UXTH     R3,R3
   \       0xD6   0x0032             MOVS     R2,R6
   \       0xD8   0x6820             LDR      R0,[R4, #+0]
   \       0xDA   0x0001             MOVS     R1,R0
   \       0xDC   0x313C             ADDS     R1,R1,#+60
   \       0xDE   0x6AE0             LDR      R0,[R4, #+44]
   \       0xE0   0x....'....        BL       HAL_DMA_Start_IT
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD001             BEQ      ??HAL_TIM_IC_Start_DMA_12
   2151                {
   2152                  return HAL_ERROR;
   \       0xE8   0x2001             MOVS     R0,#+1
   \       0xEA   0xE03B             B        ??HAL_TIM_IC_Start_DMA_1
   2153                }
   2154                /* Enable the TIM Capture/Compare 3  DMA request */
   2155                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Start_DMA_12: (+1)
   \       0xEC   0x6820             LDR      R0,[R4, #+0]
   \       0xEE   0x68C0             LDR      R0,[R0, #+12]
   \       0xF0   0x2180             MOVS     R1,#+128
   \       0xF2   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0xF4   0x4301             ORRS     R1,R1,R0
   \       0xF6   0x6820             LDR      R0,[R4, #+0]
   \       0xF8   0x60C1             STR      R1,[R0, #+12]
   2156                break;
   \       0xFA   0xE01D             B        ??HAL_TIM_IC_Start_DMA_10
   2157              }
   2158          
   2159              case TIM_CHANNEL_4:
   2160              {
   2161                /* Set the DMA capture callbacks */
   2162                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_IC_Start_DMA_7: (+1)
   \       0xFC   0x....             LDR      R0,??DataTable30
   \       0xFE   0x6B21             LDR      R1,[R4, #+48]
   \      0x100   0x62C8             STR      R0,[R1, #+44]
   2163                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \      0x102   0x....             LDR      R0,??DataTable30_1
   \      0x104   0x6B21             LDR      R1,[R4, #+48]
   \      0x106   0x6308             STR      R0,[R1, #+48]
   2164          
   2165                /* Set the DMA error callback */
   2166                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \      0x108   0x....             LDR      R0,??DataTable30_2
   \      0x10A   0x6B21             LDR      R1,[R4, #+48]
   \      0x10C   0x6348             STR      R0,[R1, #+52]
   2167          
   2168                /* Enable the DMA channel */
   2169                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length) != HAL_OK)
   \      0x10E   0x002B             MOVS     R3,R5
   \      0x110   0xB29B             UXTH     R3,R3
   \      0x112   0x0032             MOVS     R2,R6
   \      0x114   0x6820             LDR      R0,[R4, #+0]
   \      0x116   0x0001             MOVS     R1,R0
   \      0x118   0x3140             ADDS     R1,R1,#+64
   \      0x11A   0x6B20             LDR      R0,[R4, #+48]
   \      0x11C   0x....'....        BL       HAL_DMA_Start_IT
   \      0x120   0x2800             CMP      R0,#+0
   \      0x122   0xD001             BEQ      ??HAL_TIM_IC_Start_DMA_13
   2170                {
   2171                  return HAL_ERROR;
   \      0x124   0x2001             MOVS     R0,#+1
   \      0x126   0xE01D             B        ??HAL_TIM_IC_Start_DMA_1
   2172                }
   2173                /* Enable the TIM Capture/Compare 4  DMA request */
   2174                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Start_DMA_13: (+1)
   \      0x128   0x6820             LDR      R0,[R4, #+0]
   \      0x12A   0x68C0             LDR      R0,[R0, #+12]
   \      0x12C   0x2180             MOVS     R1,#+128
   \      0x12E   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \      0x130   0x4301             ORRS     R1,R1,R0
   \      0x132   0x6820             LDR      R0,[R4, #+0]
   \      0x134   0x60C1             STR      R1,[R0, #+12]
   2175                break;
   \      0x136   0xE7FF             B        ??HAL_TIM_IC_Start_DMA_10
   2176              }
   2177          
   2178              default:
   2179                break;
   2180            }
   2181          
   2182            /* Enable the Input Capture channel */
   2183            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_IC_Start_DMA_8: (+1)
   \                     ??HAL_TIM_IC_Start_DMA_10: (+1)
   \      0x138   0x2201             MOVS     R2,#+1
   \      0x13A   0x0039             MOVS     R1,R7
   \      0x13C   0x6820             LDR      R0,[R4, #+0]
   \      0x13E   0x....'....        BL       TIM_CCxChannelCmd
   2184          
   2185            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   2186            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \      0x142   0x6820             LDR      R0,[R4, #+0]
   \      0x144   0x6880             LDR      R0,[R0, #+8]
   \      0x146   0x....             LDR      R1,??DataTable32  ;; 0x10007
   \      0x148   0x4001             ANDS     R1,R1,R0
   2187            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \      0x14A   0x2906             CMP      R1,#+6
   \      0x14C   0xD009             BEQ      ??HAL_TIM_IC_Start_DMA_14
   \      0x14E   0x2080             MOVS     R0,#+128
   \      0x150   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \      0x152   0x4281             CMP      R1,R0
   \      0x154   0xD005             BEQ      ??HAL_TIM_IC_Start_DMA_14
   2188            {
   2189              __HAL_TIM_ENABLE(htim);
   \      0x156   0x6820             LDR      R0,[R4, #+0]
   \      0x158   0x6800             LDR      R0,[R0, #+0]
   \      0x15A   0x2201             MOVS     R2,#+1
   \      0x15C   0x4302             ORRS     R2,R2,R0
   \      0x15E   0x6820             LDR      R0,[R4, #+0]
   \      0x160   0x6002             STR      R2,[R0, #+0]
   2190            }
   2191          
   2192            /* Return function status */
   2193            return HAL_OK;
   \                     ??HAL_TIM_IC_Start_DMA_14: (+1)
   \      0x162   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_Start_DMA_1: (+1)
   \      0x164   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2194          }
   2195          
   2196          /**
   2197            * @brief  Stops the TIM Input Capture measurement in DMA mode.
   2198            * @param  htim TIM Input Capture handle
   2199            * @param  Channel TIM Channels to be disabled
   2200            *          This parameter can be one of the following values:
   2201            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2202            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2203            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2204            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   2205            * @retval HAL status
   2206            */

   \                                 In section .text, align 2, keep-with-next
   2207          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2208          {
   \                     HAL_TIM_IC_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2209            /* Check the parameters */
   2210            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   2211            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2212          
   2213            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD006             BEQ      ??HAL_TIM_IC_Stop_DMA_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00E             BEQ      ??HAL_TIM_IC_Stop_DMA_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD016             BEQ      ??HAL_TIM_IC_Stop_DMA_2
   \       0x14   0x280C             CMP      R0,#+12
   \       0x16   0xD01E             BEQ      ??HAL_TIM_IC_Stop_DMA_3
   \       0x18   0xE027             B        ??HAL_TIM_IC_Stop_DMA_4
   2214            {
   2215              case TIM_CHANNEL_1:
   2216              {
   2217                /* Disable the TIM Capture/Compare 1 DMA request */
   2218                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_IC_Stop_DMA_0: (+1)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x68C0             LDR      R0,[R0, #+12]
   \       0x1E   0x....             LDR      R1,??DataTable32_1  ;; 0xfffffdff
   \       0x20   0x4001             ANDS     R1,R1,R0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x60C1             STR      R1,[R0, #+12]
   2219                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x26   0x6A60             LDR      R0,[R4, #+36]
   \       0x28   0x....'....        BL       HAL_DMA_Abort_IT
   2220                break;
   \       0x2C   0xE01D             B        ??HAL_TIM_IC_Stop_DMA_5
   2221              }
   2222          
   2223              case TIM_CHANNEL_2:
   2224              {
   2225                /* Disable the TIM Capture/Compare 2 DMA request */
   2226                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_IC_Stop_DMA_1: (+1)
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x68C0             LDR      R0,[R0, #+12]
   \       0x32   0x....             LDR      R1,??DataTable32_2  ;; 0xfffffbff
   \       0x34   0x4001             ANDS     R1,R1,R0
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x60C1             STR      R1,[R0, #+12]
   2227                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x3A   0x6AA0             LDR      R0,[R4, #+40]
   \       0x3C   0x....'....        BL       HAL_DMA_Abort_IT
   2228                break;
   \       0x40   0xE013             B        ??HAL_TIM_IC_Stop_DMA_5
   2229              }
   2230          
   2231              case TIM_CHANNEL_3:
   2232              {
   2233                /* Disable the TIM Capture/Compare 3  DMA request */
   2234                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIM_IC_Stop_DMA_2: (+1)
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x68C0             LDR      R0,[R0, #+12]
   \       0x46   0x....             LDR      R1,??DataTable32_3  ;; 0xfffff7ff
   \       0x48   0x4001             ANDS     R1,R1,R0
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x60C1             STR      R1,[R0, #+12]
   2235                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \       0x4E   0x6AE0             LDR      R0,[R4, #+44]
   \       0x50   0x....'....        BL       HAL_DMA_Abort_IT
   2236                break;
   \       0x54   0xE009             B        ??HAL_TIM_IC_Stop_DMA_5
   2237              }
   2238          
   2239              case TIM_CHANNEL_4:
   2240              {
   2241                /* Disable the TIM Capture/Compare 4  DMA request */
   2242                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   \                     ??HAL_TIM_IC_Stop_DMA_3: (+1)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x68C0             LDR      R0,[R0, #+12]
   \       0x5A   0x....             LDR      R1,??DataTable32_4  ;; 0xffffefff
   \       0x5C   0x4001             ANDS     R1,R1,R0
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x60C1             STR      R1,[R0, #+12]
   2243                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \       0x62   0x6B20             LDR      R0,[R4, #+48]
   \       0x64   0x....'....        BL       HAL_DMA_Abort_IT
   2244                break;
   \       0x68   0xE7FF             B        ??HAL_TIM_IC_Stop_DMA_5
   2245              }
   2246          
   2247              default:
   2248                break;
   2249            }
   2250          
   2251            /* Disable the Input Capture channel */
   2252            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_IC_Stop_DMA_4: (+1)
   \                     ??HAL_TIM_IC_Stop_DMA_5: (+1)
   \       0x6A   0x2200             MOVS     R2,#+0
   \       0x6C   0x0029             MOVS     R1,R5
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x....'....        BL       TIM_CCxChannelCmd
   2253          
   2254            /* Disable the Peripheral */
   2255            __HAL_TIM_DISABLE(htim);
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x6A00             LDR      R0,[R0, #+32]
   \       0x78   0x....             LDR      R1,??DataTable32_5  ;; 0x1111
   \       0x7A   0x4001             ANDS     R1,R1,R0
   \       0x7C   0x2900             CMP      R1,#+0
   \       0x7E   0xD10B             BNE      ??HAL_TIM_IC_Stop_DMA_6
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6A00             LDR      R0,[R0, #+32]
   \       0x84   0x....             LDR      R1,??DataTable33  ;; 0x444
   \       0x86   0x4001             ANDS     R1,R1,R0
   \       0x88   0x2900             CMP      R1,#+0
   \       0x8A   0xD105             BNE      ??HAL_TIM_IC_Stop_DMA_6
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6800             LDR      R0,[R0, #+0]
   \       0x90   0x2101             MOVS     R1,#+1
   \       0x92   0x4388             BICS     R0,R0,R1
   \       0x94   0x6821             LDR      R1,[R4, #+0]
   \       0x96   0x6008             STR      R0,[R1, #+0]
   2256          
   2257            /* Change the htim state */
   2258            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_Stop_DMA_6: (+1)
   \       0x98   0x2001             MOVS     R0,#+1
   \       0x9A   0x213D             MOVS     R1,#+61
   \       0x9C   0x5460             STRB     R0,[R4, R1]
   2259          
   2260            /* Return function status */
   2261            return HAL_OK;
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2262          }
   2263          /**
   2264            * @}
   2265            */
   2266          
   2267          /** @defgroup TIM_Exported_Functions_Group5 TIM One Pulse functions
   2268            *  @brief    TIM One Pulse functions
   2269            *
   2270          @verbatim
   2271            ==============================================================================
   2272                                  ##### TIM One Pulse functions #####
   2273            ==============================================================================
   2274            [..]
   2275              This section provides functions allowing to:
   2276              (+) Initialize and configure the TIM One Pulse.
   2277              (+) De-initialize the TIM One Pulse.
   2278              (+) Start the TIM One Pulse.
   2279              (+) Stop the TIM One Pulse.
   2280              (+) Start the TIM One Pulse and enable interrupt.
   2281              (+) Stop the TIM One Pulse and disable interrupt.
   2282              (+) Start the TIM One Pulse and enable DMA transfer.
   2283              (+) Stop the TIM One Pulse and disable DMA transfer.
   2284          
   2285          @endverbatim
   2286            * @{
   2287            */
   2288          /**
   2289            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   2290            *         parameters in the TIM_HandleTypeDef and initializes the associated handle.
   2291            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2292            *         requires a timer reset to avoid unexpected direction
   2293            *         due to DIR bit readonly in center aligned mode.
   2294            *         Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()
   2295            * @param  htim TIM One Pulse handle
   2296            * @param  OnePulseMode Select the One pulse mode.
   2297            *         This parameter can be one of the following values:
   2298            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   2299            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses will be generated.
   2300            * @retval HAL status
   2301            */

   \                                 In section .text, align 2, keep-with-next
   2302          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   2303          {
   \                     HAL_TIM_OnePulse_Init: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2304            /* Check the TIM handle allocation */
   2305            if (htim == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE      ??HAL_TIM_OnePulse_Init_0
   2306            {
   2307              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE01F             B        ??HAL_TIM_OnePulse_Init_1
   2308            }
   2309          
   2310            /* Check the parameters */
   2311            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2312            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2313            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2314            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   2315            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2316          
   2317            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_OnePulse_Init_0: (+1)
   \        0xE   0x203D             MOVS     R0,#+61
   \       0x10   0x5C20             LDRB     R0,[R4, R0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD105             BNE      ??HAL_TIM_OnePulse_Init_2
   2318            {
   2319              /* Allocate lock resource and initialize it */
   2320              htim->Lock = HAL_UNLOCKED;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x213C             MOVS     R1,#+60
   \       0x1A   0x5460             STRB     R0,[R4, R1]
   2321          
   2322          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2323              /* Reset interrupt callbacks to legacy weak callbacks */
   2324              TIM_ResetCallback(htim);
   2325          
   2326              if (htim->OnePulse_MspInitCallback == NULL)
   2327              {
   2328                htim->OnePulse_MspInitCallback = HAL_TIM_OnePulse_MspInit;
   2329              }
   2330              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2331              htim->OnePulse_MspInitCallback(htim);
   2332          #else
   2333              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2334              HAL_TIM_OnePulse_MspInit(htim);
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x....'....        BL       HAL_TIM_OnePulse_MspInit
   2335          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2336            }
   2337          
   2338            /* Set the TIM state */
   2339            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_OnePulse_Init_2: (+1)
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0x213D             MOVS     R1,#+61
   \       0x26   0x5460             STRB     R0,[R4, R1]
   2340          
   2341            /* Configure the Time base in the One Pulse Mode */
   2342            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x28   0x1D21             ADDS     R1,R4,#+4
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x....'....        BL       TIM_Base_SetConfig
   2343          
   2344            /* Reset the OPM Bit */
   2345            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6800             LDR      R0,[R0, #+0]
   \       0x34   0x2108             MOVS     R1,#+8
   \       0x36   0x4388             BICS     R0,R0,R1
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x6008             STR      R0,[R1, #+0]
   2346          
   2347            /* Configure the OPM Mode */
   2348            htim->Instance->CR1 |= OnePulseMode;
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6800             LDR      R0,[R0, #+0]
   \       0x40   0x4328             ORRS     R0,R0,R5
   \       0x42   0x6821             LDR      R1,[R4, #+0]
   \       0x44   0x6008             STR      R0,[R1, #+0]
   2349          
   2350            /* Initialize the TIM state*/
   2351            htim->State = HAL_TIM_STATE_READY;
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0x213D             MOVS     R1,#+61
   \       0x4A   0x5460             STRB     R0,[R4, R1]
   2352          
   2353            return HAL_OK;
   \       0x4C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Init_1: (+1)
   \       0x4E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2354          }
   2355          
   2356          /**
   2357            * @brief  DeInitializes the TIM One Pulse
   2358            * @param  htim TIM One Pulse handle
   2359            * @retval HAL status
   2360            */

   \                                 In section .text, align 2, keep-with-next
   2361          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2362          {
   \                     HAL_TIM_OnePulse_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2363            /* Check the parameters */
   2364            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2365          
   2366            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x213D             MOVS     R1,#+61
   \        0x8   0x5460             STRB     R0,[R4, R1]
   2367          
   2368            /* Disable the TIM Peripheral Clock */
   2369            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable32_5  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD10B             BNE      ??HAL_TIM_OnePulse_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0x....             LDR      R1,??DataTable33  ;; 0x444
   \       0x1C   0x4001             ANDS     R1,R1,R0
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD105             BNE      ??HAL_TIM_OnePulse_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x4388             BICS     R0,R0,R1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   2370          
   2371          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2372            if (htim->OnePulse_MspDeInitCallback == NULL)
   2373            {
   2374              htim->OnePulse_MspDeInitCallback = HAL_TIM_OnePulse_MspDeInit;
   2375            }
   2376            /* DeInit the low level hardware */
   2377            htim->OnePulse_MspDeInitCallback(htim);
   2378          #else
   2379            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2380            HAL_TIM_OnePulse_MspDeInit(htim);
   \                     ??HAL_TIM_OnePulse_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x....'....        BL       HAL_TIM_OnePulse_MspDeInit
   2381          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2382          
   2383            /* Change TIM state */
   2384            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x0001             MOVS     R1,R0
   \       0x38   0x223D             MOVS     R2,#+61
   \       0x3A   0x54A1             STRB     R1,[R4, R2]
   2385          
   2386            /* Release Lock */
   2387            __HAL_UNLOCK(htim);
   \       0x3C   0x213C             MOVS     R1,#+60
   \       0x3E   0x5460             STRB     R0,[R4, R1]
   2388          
   2389            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}          ;; return
   2390          }
   2391          
   2392          /**
   2393            * @brief  Initializes the TIM One Pulse MSP.
   2394            * @param  htim TIM One Pulse handle
   2395            * @retval None
   2396            */

   \                                 In section .text, align 2
   2397          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2398          {
   2399            /* Prevent unused argument(s) compilation warning */
   2400            UNUSED(htim);
   2401          
   2402            /* NOTE : This function should not be modified, when the callback is needed,
   2403                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2404             */
   2405          }
   \                     HAL_TIM_OnePulse_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2406          
   2407          /**
   2408            * @brief  DeInitializes TIM One Pulse MSP.
   2409            * @param  htim TIM One Pulse handle
   2410            * @retval None
   2411            */

   \                                 In section .text, align 2
   2412          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2413          {
   2414            /* Prevent unused argument(s) compilation warning */
   2415            UNUSED(htim);
   2416          
   2417            /* NOTE : This function should not be modified, when the callback is needed,
   2418                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2419             */
   2420          }
   \                     HAL_TIM_OnePulse_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2421          
   2422          /**
   2423            * @brief  Starts the TIM One Pulse signal generation.
   2424            * @param  htim TIM One Pulse handle
   2425            * @param  OutputChannel TIM Channels to be enabled
   2426            *          This parameter can be one of the following values:
   2427            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2428            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2429            * @retval HAL status
   2430            */

   \                                 In section .text, align 2, keep-with-next
   2431          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2432          {
   \                     HAL_TIM_OnePulse_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2433            /* Prevent unused argument(s) compilation warning */
   2434            UNUSED(OutputChannel);
   2435          
   2436            /* Enable the Capture compare and the Input Capture channels
   2437              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2438              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2439              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2440              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2441          
   2442              No need to enable the counter, it's enabled automatically by hardware
   2443              (the counter starts in response to a stimulus and generate a pulse */
   2444          
   2445            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxChannelCmd
   2446            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0x10   0x2201             MOVS     R2,#+1
   \       0x12   0x2104             MOVS     R1,#+4
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x....'....        BL       TIM_CCxChannelCmd
   2447          
   2448            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x....             LDR      R1,??DataTable34  ;; 0x40012c00
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD007             BEQ      ??HAL_TIM_OnePulse_Start_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x....             LDR      R1,??DataTable34_1  ;; 0x40014400
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD003             BEQ      ??HAL_TIM_OnePulse_Start_0
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x....             LDR      R1,??DataTable35  ;; 0x40014800
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xD101             BNE      ??HAL_TIM_OnePulse_Start_1
   \                     ??HAL_TIM_OnePulse_Start_0: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xE000             B        ??HAL_TIM_OnePulse_Start_2
   \                     ??HAL_TIM_OnePulse_Start_1: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Start_2: (+1)
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD006             BEQ      ??HAL_TIM_OnePulse_Start_3
   2449            {
   2450              /* Enable the main output */
   2451              __HAL_TIM_MOE_ENABLE(htim);
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6C40             LDR      R0,[R0, #+68]
   \       0x42   0x2180             MOVS     R1,#+128
   \       0x44   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x46   0x4301             ORRS     R1,R1,R0
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x6441             STR      R1,[R0, #+68]
   2452            }
   2453          
   2454            /* Return function status */
   2455            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_3: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2456          }
   2457          
   2458          /**
   2459            * @brief  Stops the TIM One Pulse signal generation.
   2460            * @param  htim TIM One Pulse handle
   2461            * @param  OutputChannel TIM Channels to be disable
   2462            *          This parameter can be one of the following values:
   2463            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2464            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2465            * @retval HAL status
   2466            */

   \                                 In section .text, align 2, keep-with-next
   2467          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2468          {
   \                     HAL_TIM_OnePulse_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2469            /* Prevent unused argument(s) compilation warning */
   2470            UNUSED(OutputChannel);
   2471          
   2472            /* Disable the Capture compare and the Input Capture channels
   2473            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2474            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2475            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2476            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2477          
   2478            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxChannelCmd
   2479            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x2104             MOVS     R1,#+4
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x....'....        BL       TIM_CCxChannelCmd
   2480          
   2481            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x....             LDR      R1,??DataTable34  ;; 0x40012c00
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD007             BEQ      ??HAL_TIM_OnePulse_Stop_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x....             LDR      R1,??DataTable34_1  ;; 0x40014400
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD003             BEQ      ??HAL_TIM_OnePulse_Stop_0
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x....             LDR      R1,??DataTable35  ;; 0x40014800
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xD101             BNE      ??HAL_TIM_OnePulse_Stop_1
   \                     ??HAL_TIM_OnePulse_Stop_0: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xE000             B        ??HAL_TIM_OnePulse_Stop_2
   \                     ??HAL_TIM_OnePulse_Stop_1: (+1)
   \       0x36   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Stop_2: (+1)
   \       0x38   0xB2C0             UXTB     R0,R0
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD011             BEQ      ??HAL_TIM_OnePulse_Stop_3
   2482            {
   2483              /* Disable the Main Output */
   2484              __HAL_TIM_MOE_DISABLE(htim);
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6A00             LDR      R0,[R0, #+32]
   \       0x42   0x....             LDR      R1,??DataTable32_5  ;; 0x1111
   \       0x44   0x4001             ANDS     R1,R1,R0
   \       0x46   0x2900             CMP      R1,#+0
   \       0x48   0xD10B             BNE      ??HAL_TIM_OnePulse_Stop_4
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6A00             LDR      R0,[R0, #+32]
   \       0x4E   0x....             LDR      R1,??DataTable33  ;; 0x444
   \       0x50   0x4001             ANDS     R1,R1,R0
   \       0x52   0x2900             CMP      R1,#+0
   \       0x54   0xD105             BNE      ??HAL_TIM_OnePulse_Stop_4
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6C40             LDR      R0,[R0, #+68]
   \       0x5A   0x....             LDR      R1,??DataTable35_1  ;; 0xffff7fff
   \       0x5C   0x4001             ANDS     R1,R1,R0
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6441             STR      R1,[R0, #+68]
   2485            }
   2486          
   2487            /* Disable the Peripheral */
   2488            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OnePulse_Stop_4: (+1)
   \                     ??HAL_TIM_OnePulse_Stop_3: (+1)
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x6A00             LDR      R0,[R0, #+32]
   \       0x66   0x....             LDR      R1,??DataTable32_5  ;; 0x1111
   \       0x68   0x4001             ANDS     R1,R1,R0
   \       0x6A   0x2900             CMP      R1,#+0
   \       0x6C   0xD10B             BNE      ??HAL_TIM_OnePulse_Stop_5
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x6A00             LDR      R0,[R0, #+32]
   \       0x72   0x....             LDR      R1,??DataTable33  ;; 0x444
   \       0x74   0x4001             ANDS     R1,R1,R0
   \       0x76   0x2900             CMP      R1,#+0
   \       0x78   0xD105             BNE      ??HAL_TIM_OnePulse_Stop_5
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x6800             LDR      R0,[R0, #+0]
   \       0x7E   0x2101             MOVS     R1,#+1
   \       0x80   0x4388             BICS     R0,R0,R1
   \       0x82   0x6821             LDR      R1,[R4, #+0]
   \       0x84   0x6008             STR      R0,[R1, #+0]
   2489          
   2490            /* Return function status */
   2491            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_5: (+1)
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2492          }
   2493          
   2494          /**
   2495            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2496            * @param  htim TIM One Pulse handle
   2497            * @param  OutputChannel TIM Channels to be enabled
   2498            *          This parameter can be one of the following values:
   2499            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2500            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2501            * @retval HAL status
   2502            */

   \                                 In section .text, align 2, keep-with-next
   2503          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2504          {
   \                     HAL_TIM_OnePulse_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2505            /* Prevent unused argument(s) compilation warning */
   2506            UNUSED(OutputChannel);
   2507          
   2508            /* Enable the Capture compare and the Input Capture channels
   2509              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2510              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2511              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2512              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together
   2513          
   2514              No need to enable the counter, it's enabled automatically by hardware
   2515              (the counter starts in response to a stimulus and generate a pulse */
   2516          
   2517            /* Enable the TIM Capture/Compare 1 interrupt */
   2518            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x68C0             LDR      R0,[R0, #+12]
   \        0xA   0x2102             MOVS     R1,#+2
   \        0xC   0x4301             ORRS     R1,R1,R0
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x60C1             STR      R1,[R0, #+12]
   2519          
   2520            /* Enable the TIM Capture/Compare 2 interrupt */
   2521            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x68C0             LDR      R0,[R0, #+12]
   \       0x16   0x2104             MOVS     R1,#+4
   \       0x18   0x4301             ORRS     R1,R1,R0
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x60C1             STR      R1,[R0, #+12]
   2522          
   2523            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \       0x1E   0x2201             MOVS     R2,#+1
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x....'....        BL       TIM_CCxChannelCmd
   2524            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0x28   0x2201             MOVS     R2,#+1
   \       0x2A   0x2104             MOVS     R1,#+4
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x....'....        BL       TIM_CCxChannelCmd
   2525          
   2526            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x....             LDR      R1,??DataTable34  ;; 0x40012c00
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD007             BEQ      ??HAL_TIM_OnePulse_Start_IT_0
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x....             LDR      R1,??DataTable34_1  ;; 0x40014400
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD003             BEQ      ??HAL_TIM_OnePulse_Start_IT_0
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x....             LDR      R1,??DataTable35  ;; 0x40014800
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xD101             BNE      ??HAL_TIM_OnePulse_Start_IT_1
   \                     ??HAL_TIM_OnePulse_Start_IT_0: (+1)
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xE000             B        ??HAL_TIM_OnePulse_Start_IT_2
   \                     ??HAL_TIM_OnePulse_Start_IT_1: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Start_IT_2: (+1)
   \       0x50   0xB2C0             UXTB     R0,R0
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD006             BEQ      ??HAL_TIM_OnePulse_Start_IT_3
   2527            {
   2528              /* Enable the main output */
   2529              __HAL_TIM_MOE_ENABLE(htim);
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6C40             LDR      R0,[R0, #+68]
   \       0x5A   0x2180             MOVS     R1,#+128
   \       0x5C   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x5E   0x4301             ORRS     R1,R1,R0
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6441             STR      R1,[R0, #+68]
   2530            }
   2531          
   2532            /* Return function status */
   2533            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Start_IT_3: (+1)
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2534          }
   2535          
   2536          /**
   2537            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2538            * @param  htim TIM One Pulse handle
   2539            * @param  OutputChannel TIM Channels to be enabled
   2540            *          This parameter can be one of the following values:
   2541            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2542            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2543            * @retval HAL status
   2544            */

   \                                 In section .text, align 2, keep-with-next
   2545          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2546          {
   \                     HAL_TIM_OnePulse_Stop_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2547            /* Prevent unused argument(s) compilation warning */
   2548            UNUSED(OutputChannel);
   2549          
   2550            /* Disable the TIM Capture/Compare 1 interrupt */
   2551            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x68C0             LDR      R0,[R0, #+12]
   \        0xA   0x2102             MOVS     R1,#+2
   \        0xC   0x4388             BICS     R0,R0,R1
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0x60C8             STR      R0,[R1, #+12]
   2552          
   2553            /* Disable the TIM Capture/Compare 2 interrupt */
   2554            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x68C0             LDR      R0,[R0, #+12]
   \       0x16   0x2104             MOVS     R1,#+4
   \       0x18   0x4388             BICS     R0,R0,R1
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x60C8             STR      R0,[R1, #+12]
   2555          
   2556            /* Disable the Capture compare and the Input Capture channels
   2557            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2558            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2559            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output
   2560            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2561            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x....'....        BL       TIM_CCxChannelCmd
   2562            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x28   0x2200             MOVS     R2,#+0
   \       0x2A   0x2104             MOVS     R1,#+4
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x....'....        BL       TIM_CCxChannelCmd
   2563          
   2564            if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x....             LDR      R1,??DataTable34  ;; 0x40012c00
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD007             BEQ      ??HAL_TIM_OnePulse_Stop_IT_0
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x....             LDR      R1,??DataTable34_1  ;; 0x40014400
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD003             BEQ      ??HAL_TIM_OnePulse_Stop_IT_0
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x....             LDR      R1,??DataTable35  ;; 0x40014800
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xD101             BNE      ??HAL_TIM_OnePulse_Stop_IT_1
   \                     ??HAL_TIM_OnePulse_Stop_IT_0: (+1)
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xE000             B        ??HAL_TIM_OnePulse_Stop_IT_2
   \                     ??HAL_TIM_OnePulse_Stop_IT_1: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OnePulse_Stop_IT_2: (+1)
   \       0x50   0xB2C0             UXTB     R0,R0
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD011             BEQ      ??HAL_TIM_OnePulse_Stop_IT_3
   2565            {
   2566              /* Disable the Main Output */
   2567              __HAL_TIM_MOE_DISABLE(htim);
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6A00             LDR      R0,[R0, #+32]
   \       0x5A   0x....             LDR      R1,??DataTable37  ;; 0x1111
   \       0x5C   0x4001             ANDS     R1,R1,R0
   \       0x5E   0x2900             CMP      R1,#+0
   \       0x60   0xD10B             BNE      ??HAL_TIM_OnePulse_Stop_IT_4
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x6A00             LDR      R0,[R0, #+32]
   \       0x66   0x....             LDR      R1,??DataTable33  ;; 0x444
   \       0x68   0x4001             ANDS     R1,R1,R0
   \       0x6A   0x2900             CMP      R1,#+0
   \       0x6C   0xD105             BNE      ??HAL_TIM_OnePulse_Stop_IT_4
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x6C40             LDR      R0,[R0, #+68]
   \       0x72   0x....             LDR      R1,??DataTable35_1  ;; 0xffff7fff
   \       0x74   0x4001             ANDS     R1,R1,R0
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6441             STR      R1,[R0, #+68]
   2568            }
   2569          
   2570            /* Disable the Peripheral */
   2571            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_OnePulse_Stop_IT_4: (+1)
   \                     ??HAL_TIM_OnePulse_Stop_IT_3: (+1)
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x6A00             LDR      R0,[R0, #+32]
   \       0x7E   0x....             LDR      R1,??DataTable37  ;; 0x1111
   \       0x80   0x4001             ANDS     R1,R1,R0
   \       0x82   0x2900             CMP      R1,#+0
   \       0x84   0xD10B             BNE      ??HAL_TIM_OnePulse_Stop_IT_5
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6A00             LDR      R0,[R0, #+32]
   \       0x8A   0x....             LDR      R1,??DataTable33  ;; 0x444
   \       0x8C   0x4001             ANDS     R1,R1,R0
   \       0x8E   0x2900             CMP      R1,#+0
   \       0x90   0xD105             BNE      ??HAL_TIM_OnePulse_Stop_IT_5
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6800             LDR      R0,[R0, #+0]
   \       0x96   0x2101             MOVS     R1,#+1
   \       0x98   0x4388             BICS     R0,R0,R1
   \       0x9A   0x6821             LDR      R1,[R4, #+0]
   \       0x9C   0x6008             STR      R0,[R1, #+0]
   2572          
   2573            /* Return function status */
   2574            return HAL_OK;
   \                     ??HAL_TIM_OnePulse_Stop_IT_5: (+1)
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2575          }
   2576          
   2577          /**
   2578            * @}
   2579            */
   2580          
   2581          /** @defgroup TIM_Exported_Functions_Group6 TIM Encoder functions
   2582            *  @brief    TIM Encoder functions
   2583            *
   2584          @verbatim
   2585            ==============================================================================
   2586                                    ##### TIM Encoder functions #####
   2587            ==============================================================================
   2588            [..]
   2589              This section provides functions allowing to:
   2590              (+) Initialize and configure the TIM Encoder.
   2591              (+) De-initialize the TIM Encoder.
   2592              (+) Start the TIM Encoder.
   2593              (+) Stop the TIM Encoder.
   2594              (+) Start the TIM Encoder and enable interrupt.
   2595              (+) Stop the TIM Encoder and disable interrupt.
   2596              (+) Start the TIM Encoder and enable DMA transfer.
   2597              (+) Stop the TIM Encoder and disable DMA transfer.
   2598          
   2599          @endverbatim
   2600            * @{
   2601            */
   2602          /**
   2603            * @brief  Initializes the TIM Encoder Interface and initialize the associated handle.
   2604            * @note   Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2605            *         requires a timer reset to avoid unexpected direction
   2606            *         due to DIR bit readonly in center aligned mode.
   2607            *         Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()
   2608            * @note   Encoder mode and External clock mode 2 are not compatible and must not be selected together
   2609            *         Ex: A call for @ref HAL_TIM_Encoder_Init will erase the settings of @ref HAL_TIM_ConfigClockSource
   2610            *         using TIM_CLOCKSOURCE_ETRMODE2 and vice versa
   2611            * @param  htim TIM Encoder Interface handle
   2612            * @param  sConfig TIM Encoder Interface configuration structure
   2613            * @retval HAL status
   2614            */

   \                                 In section .text, align 2, keep-with-next
   2615          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef *sConfig)
   2616          {
   \                     HAL_TIM_Encoder_Init: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2617            uint32_t tmpsmcr;
   2618            uint32_t tmpccmr1;
   2619            uint32_t tmpccer;
   2620          
   2621            /* Check the TIM handle allocation */
   2622            if (htim == NULL)
   \        0x6   0x2C00             CMP      R4,#+0
   \        0x8   0xD101             BNE      ??HAL_TIM_Encoder_Init_0
   2623            {
   2624              return HAL_ERROR;
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0xE047             B        ??HAL_TIM_Encoder_Init_1
   2625            }
   2626          
   2627            /* Check the parameters */
   2628            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2629            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2630            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2631            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2632            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2633            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2634            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2635            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
   2636            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
   2637            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2638            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2639            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2640            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2641          
   2642            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIM_Encoder_Init_0: (+1)
   \        0xE   0x203D             MOVS     R0,#+61
   \       0x10   0x5C20             LDRB     R0,[R4, R0]
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD105             BNE      ??HAL_TIM_Encoder_Init_2
   2643            {
   2644              /* Allocate lock resource and initialize it */
   2645              htim->Lock = HAL_UNLOCKED;
   \       0x16   0x2000             MOVS     R0,#+0
   \       0x18   0x213C             MOVS     R1,#+60
   \       0x1A   0x5460             STRB     R0,[R4, R1]
   2646          
   2647          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2648              /* Reset interrupt callbacks to legacy weak callbacks */
   2649              TIM_ResetCallback(htim);
   2650          
   2651              if (htim->Encoder_MspInitCallback == NULL)
   2652              {
   2653                htim->Encoder_MspInitCallback = HAL_TIM_Encoder_MspInit;
   2654              }
   2655              /* Init the low level hardware : GPIO, CLOCK, NVIC */
   2656              htim->Encoder_MspInitCallback(htim);
   2657          #else
   2658              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2659              HAL_TIM_Encoder_MspInit(htim);
   \       0x1C   0x0020             MOVS     R0,R4
   \       0x1E   0x....'....        BL       HAL_TIM_Encoder_MspInit
   2660          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2661            }
   2662          
   2663            /* Set the TIM state */
   2664            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Init_2: (+1)
   \       0x22   0x2002             MOVS     R0,#+2
   \       0x24   0x213D             MOVS     R1,#+61
   \       0x26   0x5460             STRB     R0,[R4, R1]
   2665          
   2666            /* Reset the SMS and ECE bits */
   2667            htim->Instance->SMCR &= ~(TIM_SMCR_SMS | TIM_SMCR_ECE);
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x6880             LDR      R0,[R0, #+8]
   \       0x2C   0x....             LDR      R1,??DataTable37_1  ;; 0xfffebff8
   \       0x2E   0x4001             ANDS     R1,R1,R0
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6081             STR      R1,[R0, #+8]
   2668          
   2669            /* Configure the Time base in the Encoder Mode */
   2670            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x34   0x1D21             ADDS     R1,R4,#+4
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x....'....        BL       TIM_Base_SetConfig
   2671          
   2672            /* Get the TIMx SMCR register value */
   2673            tmpsmcr = htim->Instance->SMCR;
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6883             LDR      R3,[R0, #+8]
   2674          
   2675            /* Get the TIMx CCMR1 register value */
   2676            tmpccmr1 = htim->Instance->CCMR1;
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x6981             LDR      R1,[R0, #+24]
   2677          
   2678            /* Get the TIMx CCER register value */
   2679            tmpccer = htim->Instance->CCER;
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6A00             LDR      R0,[R0, #+32]
   2680          
   2681            /* Set the encoder Mode */
   2682            tmpsmcr |= sConfig->EncoderMode;
   \       0x48   0x682A             LDR      R2,[R5, #+0]
   \       0x4A   0x431A             ORRS     R2,R2,R3
   2683          
   2684            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2685            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   \       0x4C   0x....             LDR      R3,??DataTable37_2  ;; 0xfffffcfc
   \       0x4E   0x400B             ANDS     R3,R3,R1
   2686            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
   \       0x50   0x68AE             LDR      R6,[R5, #+8]
   \       0x52   0x69A9             LDR      R1,[R5, #+24]
   \       0x54   0x0209             LSLS     R1,R1,#+8
   \       0x56   0x4331             ORRS     R1,R1,R6
   \       0x58   0x4319             ORRS     R1,R1,R3
   2687          
   2688            /* Set the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2689            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   \       0x5A   0x....             LDR      R3,??DataTable37_3  ;; 0xfffff3f3
   \       0x5C   0x400B             ANDS     R3,R3,R1
   2690            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   \       0x5E   0x....             LDR      R1,??DataTable37_4  ;; 0xffff0f0f
   \       0x60   0x4019             ANDS     R1,R1,R3
   2691            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
   \       0x62   0x68EE             LDR      R6,[R5, #+12]
   \       0x64   0x69EB             LDR      R3,[R5, #+28]
   \       0x66   0x021B             LSLS     R3,R3,#+8
   \       0x68   0x4333             ORRS     R3,R3,R6
   \       0x6A   0x430B             ORRS     R3,R3,R1
   2692            tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
   \       0x6C   0x6929             LDR      R1,[R5, #+16]
   \       0x6E   0x010E             LSLS     R6,R1,#+4
   \       0x70   0x6A29             LDR      R1,[R5, #+32]
   \       0x72   0x0309             LSLS     R1,R1,#+12
   \       0x74   0x4331             ORRS     R1,R1,R6
   \       0x76   0x4319             ORRS     R1,R1,R3
   2693          
   2694            /* Set the TI1 and the TI2 Polarities */
   2695            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   \       0x78   0x2322             MOVS     R3,#+34
   \       0x7A   0x4398             BICS     R0,R0,R3
   2696            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   \       0x7C   0x2388             MOVS     R3,#+136
   \       0x7E   0x4398             BICS     R0,R0,R3
   2697            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
   \       0x80   0x686E             LDR      R6,[R5, #+4]
   \       0x82   0x696B             LDR      R3,[R5, #+20]
   \       0x84   0x011B             LSLS     R3,R3,#+4
   \       0x86   0x4333             ORRS     R3,R3,R6
   \       0x88   0x4303             ORRS     R3,R3,R0
   2698          
   2699            /* Write to TIMx SMCR */
   2700            htim->Instance->SMCR = tmpsmcr;
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x6082             STR      R2,[R0, #+8]
   2701          
   2702            /* Write to TIMx CCMR1 */
   2703            htim->Instance->CCMR1 = tmpccmr1;
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x6181             STR      R1,[R0, #+24]
   2704          
   2705            /* Write to TIMx CCER */
   2706            htim->Instance->CCER = tmpccer;
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6203             STR      R3,[R0, #+32]
   2707          
   2708            /* Initialize the TIM state*/
   2709            htim->State = HAL_TIM_STATE_READY;
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0x263D             MOVS     R6,#+61
   \       0x9A   0x55A0             STRB     R0,[R4, R6]
   2710          
   2711            return HAL_OK;
   \       0x9C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Init_1: (+1)
   \       0x9E   0xBD70             POP      {R4-R6,PC}       ;; return
   2712          }
   2713          
   2714          
   2715          /**
   2716            * @brief  DeInitializes the TIM Encoder interface
   2717            * @param  htim TIM Encoder Interface handle
   2718            * @retval HAL status
   2719            */

   \                                 In section .text, align 2, keep-with-next
   2720          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2721          {
   \                     HAL_TIM_Encoder_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2722            /* Check the parameters */
   2723            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2724          
   2725            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x213D             MOVS     R1,#+61
   \        0x8   0x5460             STRB     R0,[R4, R1]
   2726          
   2727            /* Disable the TIM Peripheral Clock */
   2728            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable37  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD10B             BNE      ??HAL_TIM_Encoder_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0x....             LDR      R1,??DataTable37_5  ;; 0x444
   \       0x1C   0x4001             ANDS     R1,R1,R0
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD105             BNE      ??HAL_TIM_Encoder_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x4388             BICS     R0,R0,R1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   2729          
   2730          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2731            if (htim->Encoder_MspDeInitCallback == NULL)
   2732            {
   2733              htim->Encoder_MspDeInitCallback = HAL_TIM_Encoder_MspDeInit;
   2734            }
   2735            /* DeInit the low level hardware */
   2736            htim->Encoder_MspDeInitCallback(htim);
   2737          #else
   2738            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2739            HAL_TIM_Encoder_MspDeInit(htim);
   \                     ??HAL_TIM_Encoder_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x....'....        BL       HAL_TIM_Encoder_MspDeInit
   2740          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2741          
   2742            /* Change TIM state */
   2743            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x0001             MOVS     R1,R0
   \       0x38   0x223D             MOVS     R2,#+61
   \       0x3A   0x54A1             STRB     R1,[R4, R2]
   2744          
   2745            /* Release Lock */
   2746            __HAL_UNLOCK(htim);
   \       0x3C   0x213C             MOVS     R1,#+60
   \       0x3E   0x5460             STRB     R0,[R4, R1]
   2747          
   2748            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}          ;; return
   2749          }
   2750          
   2751          /**
   2752            * @brief  Initializes the TIM Encoder Interface MSP.
   2753            * @param  htim TIM Encoder Interface handle
   2754            * @retval None
   2755            */

   \                                 In section .text, align 2
   2756          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2757          {
   2758            /* Prevent unused argument(s) compilation warning */
   2759            UNUSED(htim);
   2760          
   2761            /* NOTE : This function should not be modified, when the callback is needed,
   2762                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2763             */
   2764          }
   \                     HAL_TIM_Encoder_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2765          
   2766          /**
   2767            * @brief  DeInitializes TIM Encoder Interface MSP.
   2768            * @param  htim TIM Encoder Interface handle
   2769            * @retval None
   2770            */

   \                                 In section .text, align 2
   2771          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2772          {
   2773            /* Prevent unused argument(s) compilation warning */
   2774            UNUSED(htim);
   2775          
   2776            /* NOTE : This function should not be modified, when the callback is needed,
   2777                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2778             */
   2779          }
   \                     HAL_TIM_Encoder_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2780          
   2781          /**
   2782            * @brief  Starts the TIM Encoder Interface.
   2783            * @param  htim TIM Encoder Interface handle
   2784            * @param  Channel TIM Channels to be enabled
   2785            *          This parameter can be one of the following values:
   2786            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2787            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2788            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2789            * @retval HAL status
   2790            */

   \                                 In section .text, align 2, keep-with-next
   2791          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2792          {
   \                     HAL_TIM_Encoder_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2793            /* Check the parameters */
   2794            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2795          
   2796            /* Enable the encoder interface channels */
   2797            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ      ??HAL_TIM_Encoder_Start_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD006             BEQ      ??HAL_TIM_Encoder_Start_1
   \       0x10   0xE00B             B        ??HAL_TIM_Encoder_Start_2
   2798            {
   2799              case TIM_CHANNEL_1:
   2800              {
   2801                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_0: (+1)
   \       0x12   0x2201             MOVS     R2,#+1
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x....'....        BL       TIM_CCxChannelCmd
   2802                break;
   \       0x1C   0xE00F             B        ??HAL_TIM_Encoder_Start_3
   2803              }
   2804          
   2805              case TIM_CHANNEL_2:
   2806              {
   2807                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_1: (+1)
   \       0x1E   0x2201             MOVS     R2,#+1
   \       0x20   0x2104             MOVS     R1,#+4
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x....'....        BL       TIM_CCxChannelCmd
   2808                break;
   \       0x28   0xE009             B        ??HAL_TIM_Encoder_Start_3
   2809              }
   2810          
   2811              default :
   2812              {
   2813                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_2: (+1)
   \       0x2A   0x2201             MOVS     R2,#+1
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x....'....        BL       TIM_CCxChannelCmd
   2814                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0x34   0x2201             MOVS     R2,#+1
   \       0x36   0x2104             MOVS     R1,#+4
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x....'....        BL       TIM_CCxChannelCmd
   2815                break;
   2816              }
   2817            }
   2818            /* Enable the Peripheral */
   2819            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_3: (+1)
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6800             LDR      R0,[R0, #+0]
   \       0x42   0x2101             MOVS     R1,#+1
   \       0x44   0x4301             ORRS     R1,R1,R0
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x6001             STR      R1,[R0, #+0]
   2820          
   2821            /* Return function status */
   2822            return HAL_OK;
   \       0x4A   0x2000             MOVS     R0,#+0
   \       0x4C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2823          }
   2824          
   2825          /**
   2826            * @brief  Stops the TIM Encoder Interface.
   2827            * @param  htim TIM Encoder Interface handle
   2828            * @param  Channel TIM Channels to be disabled
   2829            *          This parameter can be one of the following values:
   2830            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2831            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2832            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2833            * @retval HAL status
   2834            */

   \                                 In section .text, align 2, keep-with-next
   2835          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2836          {
   \                     HAL_TIM_Encoder_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2837            /* Check the parameters */
   2838            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2839          
   2840            /* Disable the Input Capture channels 1 and 2
   2841              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2842            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ      ??HAL_TIM_Encoder_Stop_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD006             BEQ      ??HAL_TIM_Encoder_Stop_1
   \       0x10   0xE00B             B        ??HAL_TIM_Encoder_Stop_2
   2843            {
   2844              case TIM_CHANNEL_1:
   2845              {
   2846                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_0: (+1)
   \       0x12   0x2200             MOVS     R2,#+0
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x....'....        BL       TIM_CCxChannelCmd
   2847                break;
   \       0x1C   0xE00F             B        ??HAL_TIM_Encoder_Stop_3
   2848              }
   2849          
   2850              case TIM_CHANNEL_2:
   2851              {
   2852                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_1: (+1)
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x2104             MOVS     R1,#+4
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x....'....        BL       TIM_CCxChannelCmd
   2853                break;
   \       0x28   0xE009             B        ??HAL_TIM_Encoder_Stop_3
   2854              }
   2855          
   2856              default :
   2857              {
   2858                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_2: (+1)
   \       0x2A   0x2200             MOVS     R2,#+0
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x....'....        BL       TIM_CCxChannelCmd
   2859                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x2104             MOVS     R1,#+4
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x....'....        BL       TIM_CCxChannelCmd
   2860                break;
   2861              }
   2862            }
   2863          
   2864            /* Disable the Peripheral */
   2865            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_3: (+1)
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6A00             LDR      R0,[R0, #+32]
   \       0x42   0x....             LDR      R1,??DataTable37  ;; 0x1111
   \       0x44   0x4001             ANDS     R1,R1,R0
   \       0x46   0x2900             CMP      R1,#+0
   \       0x48   0xD10B             BNE      ??HAL_TIM_Encoder_Stop_4
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6A00             LDR      R0,[R0, #+32]
   \       0x4E   0x....             LDR      R1,??DataTable37_5  ;; 0x444
   \       0x50   0x4001             ANDS     R1,R1,R0
   \       0x52   0x2900             CMP      R1,#+0
   \       0x54   0xD105             BNE      ??HAL_TIM_Encoder_Stop_4
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6800             LDR      R0,[R0, #+0]
   \       0x5A   0x2101             MOVS     R1,#+1
   \       0x5C   0x4388             BICS     R0,R0,R1
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x6008             STR      R0,[R1, #+0]
   2866          
   2867            /* Return function status */
   2868            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Stop_4: (+1)
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2869          }
   2870          
   2871          /**
   2872            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2873            * @param  htim TIM Encoder Interface handle
   2874            * @param  Channel TIM Channels to be enabled
   2875            *          This parameter can be one of the following values:
   2876            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2877            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2878            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2879            * @retval HAL status
   2880            */

   \                                 In section .text, align 2, keep-with-next
   2881          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2882          {
   \                     HAL_TIM_Encoder_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2883            /* Check the parameters */
   2884            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2885          
   2886            /* Enable the encoder interface channels */
   2887            /* Enable the capture compare Interrupts 1 and/or 2 */
   2888            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD002             BEQ      ??HAL_TIM_Encoder_Start_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00C             BEQ      ??HAL_TIM_Encoder_Start_IT_1
   \       0x10   0xE017             B        ??HAL_TIM_Encoder_Start_IT_2
   2889            {
   2890              case TIM_CHANNEL_1:
   2891              {
   2892                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_0: (+1)
   \       0x12   0x2201             MOVS     R2,#+1
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x....'....        BL       TIM_CCxChannelCmd
   2893                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x68C0             LDR      R0,[R0, #+12]
   \       0x20   0x2102             MOVS     R1,#+2
   \       0x22   0x4301             ORRS     R1,R1,R0
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x60C1             STR      R1,[R0, #+12]
   2894                break;
   \       0x28   0xE021             B        ??HAL_TIM_Encoder_Start_IT_3
   2895              }
   2896          
   2897              case TIM_CHANNEL_2:
   2898              {
   2899                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_1: (+1)
   \       0x2A   0x2201             MOVS     R2,#+1
   \       0x2C   0x2104             MOVS     R1,#+4
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x....'....        BL       TIM_CCxChannelCmd
   2900                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x68C0             LDR      R0,[R0, #+12]
   \       0x38   0x2104             MOVS     R1,#+4
   \       0x3A   0x4301             ORRS     R1,R1,R0
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x60C1             STR      R1,[R0, #+12]
   2901                break;
   \       0x40   0xE015             B        ??HAL_TIM_Encoder_Start_IT_3
   2902              }
   2903          
   2904              default :
   2905              {
   2906                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIM_Encoder_Start_IT_2: (+1)
   \       0x42   0x2201             MOVS     R2,#+1
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x....'....        BL       TIM_CCxChannelCmd
   2907                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0x4C   0x2201             MOVS     R2,#+1
   \       0x4E   0x2104             MOVS     R1,#+4
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x....'....        BL       TIM_CCxChannelCmd
   2908                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x68C0             LDR      R0,[R0, #+12]
   \       0x5A   0x2102             MOVS     R1,#+2
   \       0x5C   0x4301             ORRS     R1,R1,R0
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x60C1             STR      R1,[R0, #+12]
   2909                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x68C0             LDR      R0,[R0, #+12]
   \       0x66   0x2104             MOVS     R1,#+4
   \       0x68   0x4301             ORRS     R1,R1,R0
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x60C1             STR      R1,[R0, #+12]
   2910                break;
   2911              }
   2912            }
   2913          
   2914            /* Enable the Peripheral */
   2915            __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_IT_3: (+1)
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x6800             LDR      R0,[R0, #+0]
   \       0x72   0x2101             MOVS     R1,#+1
   \       0x74   0x4301             ORRS     R1,R1,R0
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6001             STR      R1,[R0, #+0]
   2916          
   2917            /* Return function status */
   2918            return HAL_OK;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2919          }
   2920          
   2921          /**
   2922            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2923            * @param  htim TIM Encoder Interface handle
   2924            * @param  Channel TIM Channels to be disabled
   2925            *          This parameter can be one of the following values:
   2926            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2927            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2928            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2929            * @retval HAL status
   2930            */

   \                                 In section .text, align 2, keep-with-next
   2931          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2932          {
   \                     HAL_TIM_Encoder_Stop_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   2933            /* Check the parameters */
   2934            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2935          
   2936            /* Disable the Input Capture channels 1 and 2
   2937              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2938            if (Channel == TIM_CHANNEL_1)
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD10B             BNE      ??HAL_TIM_Encoder_Stop_IT_0
   2939            {
   2940              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       TIM_CCxChannelCmd
   2941          
   2942              /* Disable the capture compare Interrupts 1 */
   2943              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x68C0             LDR      R0,[R0, #+12]
   \       0x18   0x2102             MOVS     R1,#+2
   \       0x1A   0x4388             BICS     R0,R0,R1
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x60C8             STR      R0,[R1, #+12]
   \       0x20   0xE023             B        ??HAL_TIM_Encoder_Stop_IT_1
   2944            }
   2945            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_IT_0: (+1)
   \       0x22   0x2D04             CMP      R5,#+4
   \       0x24   0xD10B             BNE      ??HAL_TIM_Encoder_Stop_IT_2
   2946            {
   2947              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x26   0x2200             MOVS     R2,#+0
   \       0x28   0x2104             MOVS     R1,#+4
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x....'....        BL       TIM_CCxChannelCmd
   2948          
   2949              /* Disable the capture compare Interrupts 2 */
   2950              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x68C0             LDR      R0,[R0, #+12]
   \       0x34   0x2104             MOVS     R1,#+4
   \       0x36   0x4388             BICS     R0,R0,R1
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x60C8             STR      R0,[R1, #+12]
   \       0x3C   0xE015             B        ??HAL_TIM_Encoder_Stop_IT_1
   2951            }
   2952            else
   2953            {
   2954              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_IT_2: (+1)
   \       0x3E   0x2200             MOVS     R2,#+0
   \       0x40   0x2100             MOVS     R1,#+0
   \       0x42   0x6820             LDR      R0,[R4, #+0]
   \       0x44   0x....'....        BL       TIM_CCxChannelCmd
   2955              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x48   0x2200             MOVS     R2,#+0
   \       0x4A   0x2104             MOVS     R1,#+4
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x....'....        BL       TIM_CCxChannelCmd
   2956          
   2957              /* Disable the capture compare Interrupts 1 and 2 */
   2958              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x68C0             LDR      R0,[R0, #+12]
   \       0x56   0x2102             MOVS     R1,#+2
   \       0x58   0x4388             BICS     R0,R0,R1
   \       0x5A   0x6821             LDR      R1,[R4, #+0]
   \       0x5C   0x60C8             STR      R0,[R1, #+12]
   2959              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x68C0             LDR      R0,[R0, #+12]
   \       0x62   0x2104             MOVS     R1,#+4
   \       0x64   0x4388             BICS     R0,R0,R1
   \       0x66   0x6821             LDR      R1,[R4, #+0]
   \       0x68   0x60C8             STR      R0,[R1, #+12]
   2960            }
   2961          
   2962            /* Disable the Peripheral */
   2963            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_IT_1: (+1)
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6A00             LDR      R0,[R0, #+32]
   \       0x6E   0x....             LDR      R1,??DataTable37  ;; 0x1111
   \       0x70   0x4001             ANDS     R1,R1,R0
   \       0x72   0x2900             CMP      R1,#+0
   \       0x74   0xD10B             BNE      ??HAL_TIM_Encoder_Stop_IT_3
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6A00             LDR      R0,[R0, #+32]
   \       0x7A   0x....             LDR      R1,??DataTable37_5  ;; 0x444
   \       0x7C   0x4001             ANDS     R1,R1,R0
   \       0x7E   0x2900             CMP      R1,#+0
   \       0x80   0xD105             BNE      ??HAL_TIM_Encoder_Stop_IT_3
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x6800             LDR      R0,[R0, #+0]
   \       0x86   0x2101             MOVS     R1,#+1
   \       0x88   0x4388             BICS     R0,R0,R1
   \       0x8A   0x6821             LDR      R1,[R4, #+0]
   \       0x8C   0x6008             STR      R0,[R1, #+0]
   2964          
   2965            /* Change the htim state */
   2966            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_IT_3: (+1)
   \       0x8E   0x2001             MOVS     R0,#+1
   \       0x90   0x213D             MOVS     R1,#+61
   \       0x92   0x5460             STRB     R0,[R4, R1]
   2967          
   2968            /* Return function status */
   2969            return HAL_OK;
   \       0x94   0x2000             MOVS     R0,#+0
   \       0x96   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2970          }
   2971          
   2972          /**
   2973            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2974            * @param  htim TIM Encoder Interface handle
   2975            * @param  Channel TIM Channels to be enabled
   2976            *          This parameter can be one of the following values:
   2977            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2978            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2979            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2980            * @param  pData1 The destination Buffer address for IC1.
   2981            * @param  pData2 The destination Buffer address for IC2.
   2982            * @param  Length The length of data to be transferred from TIM peripheral to memory.
   2983            * @retval HAL status
   2984            */

   \                                 In section .text, align 2, keep-with-next
   2985          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1,
   2986                                                      uint32_t *pData2, uint16_t Length)
   2987          {
   \                     HAL_TIM_Encoder_Start_DMA: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2988            /* Check the parameters */
   2989            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2990          
   2991            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0x4   0x203D             MOVS     R0,#+61
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2802             CMP      R0,#+2
   \        0xA   0xD101             BNE      ??HAL_TIM_Encoder_Start_DMA_0
   2992            {
   2993              return HAL_BUSY;
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE0B5             B        ??HAL_TIM_Encoder_Start_DMA_1
   2994            }
   2995            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_Encoder_Start_DMA_0: (+1)
   \       0x10   0x203D             MOVS     R0,#+61
   \       0x12   0x5C20             LDRB     R0,[R4, R0]
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD10E             BNE      ??HAL_TIM_Encoder_Start_DMA_2
   2996            {
   2997              if ((((pData1 == NULL) || (pData2 == NULL))) && (Length > 0U))
   \       0x18   0x9801             LDR      R0,[SP, #+4]
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD002             BEQ      ??HAL_TIM_Encoder_Start_DMA_3
   \       0x1E   0x9802             LDR      R0,[SP, #+8]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD105             BNE      ??HAL_TIM_Encoder_Start_DMA_4
   \                     ??HAL_TIM_Encoder_Start_DMA_3: (+1)
   \       0x24   0x4668             MOV      R0,SP
   \       0x26   0x8C00             LDRH     R0,[R0, #+32]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD001             BEQ      ??HAL_TIM_Encoder_Start_DMA_4
   2998              {
   2999                return HAL_ERROR;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xE0A5             B        ??HAL_TIM_Encoder_Start_DMA_1
   3000              }
   3001              else
   3002              {
   3003                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_Encoder_Start_DMA_4: (+1)
   \       0x30   0x2002             MOVS     R0,#+2
   \       0x32   0x213D             MOVS     R1,#+61
   \       0x34   0x5460             STRB     R0,[R4, R1]
   3004              }
   3005            }
   3006            else
   3007            {
   3008              /* nothing to do */
   3009            }
   3010          
   3011            switch (Channel)
   \                     ??HAL_TIM_Encoder_Start_DMA_2: (+1)
   \       0x36   0x9800             LDR      R0,[SP, #+0]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD004             BEQ      ??HAL_TIM_Encoder_Start_DMA_5
   \       0x3C   0x2804             CMP      R0,#+4
   \       0x3E   0xD02B             BEQ      ??HAL_TIM_Encoder_Start_DMA_6
   \       0x40   0x283C             CMP      R0,#+60
   \       0x42   0xD052             BEQ      ??HAL_TIM_Encoder_Start_DMA_7
   \       0x44   0xE099             B        ??HAL_TIM_Encoder_Start_DMA_8
   3012            {
   3013              case TIM_CHANNEL_1:
   3014              {
   3015                /* Set the DMA capture callbacks */
   3016                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_5: (+1)
   \       0x46   0x....             LDR      R0,??DataTable39
   \       0x48   0x6A61             LDR      R1,[R4, #+36]
   \       0x4A   0x62C8             STR      R0,[R1, #+44]
   3017                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x4C   0x....             LDR      R0,??DataTable39_1
   \       0x4E   0x6A61             LDR      R1,[R4, #+36]
   \       0x50   0x6308             STR      R0,[R1, #+48]
   3018          
   3019                /* Set the DMA error callback */
   3020                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x52   0x....             LDR      R0,??DataTable39_2
   \       0x54   0x6A61             LDR      R1,[R4, #+36]
   \       0x56   0x6348             STR      R0,[R1, #+52]
   3021          
   3022                /* Enable the DMA channel */
   3023                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
   \       0x58   0x4668             MOV      R0,SP
   \       0x5A   0x8C03             LDRH     R3,[R0, #+32]
   \       0x5C   0x9A01             LDR      R2,[SP, #+4]
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x0001             MOVS     R1,R0
   \       0x62   0x3134             ADDS     R1,R1,#+52
   \       0x64   0x6A60             LDR      R0,[R4, #+36]
   \       0x66   0x....'....        BL       HAL_DMA_Start_IT
   \       0x6A   0x2800             CMP      R0,#+0
   \       0x6C   0xD001             BEQ      ??HAL_TIM_Encoder_Start_DMA_9
   3024                {
   3025                  return HAL_ERROR;
   \       0x6E   0x2001             MOVS     R0,#+1
   \       0x70   0xE084             B        ??HAL_TIM_Encoder_Start_DMA_1
   3026                }
   3027                /* Enable the TIM Input Capture DMA request */
   3028                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIM_Encoder_Start_DMA_9: (+1)
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x68C0             LDR      R0,[R0, #+12]
   \       0x76   0x2180             MOVS     R1,#+128
   \       0x78   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x7A   0x4301             ORRS     R1,R1,R0
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x60C1             STR      R1,[R0, #+12]
   3029          
   3030                /* Enable the Peripheral */
   3031                __HAL_TIM_ENABLE(htim);
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6800             LDR      R0,[R0, #+0]
   \       0x84   0x2101             MOVS     R1,#+1
   \       0x86   0x4301             ORRS     R1,R1,R0
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6001             STR      R1,[R0, #+0]
   3032          
   3033                /* Enable the Capture compare channel */
   3034                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \       0x8C   0x2201             MOVS     R2,#+1
   \       0x8E   0x2100             MOVS     R1,#+0
   \       0x90   0x6820             LDR      R0,[R4, #+0]
   \       0x92   0x....'....        BL       TIM_CCxChannelCmd
   3035                break;
   \       0x96   0xE070             B        ??HAL_TIM_Encoder_Start_DMA_10
   3036              }
   3037          
   3038              case TIM_CHANNEL_2:
   3039              {
   3040                /* Set the DMA capture callbacks */
   3041                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_6: (+1)
   \       0x98   0x....             LDR      R0,??DataTable39
   \       0x9A   0x6AA1             LDR      R1,[R4, #+40]
   \       0x9C   0x62C8             STR      R0,[R1, #+44]
   3042                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x9E   0x....             LDR      R0,??DataTable39_1
   \       0xA0   0x6AA1             LDR      R1,[R4, #+40]
   \       0xA2   0x6308             STR      R0,[R1, #+48]
   3043          
   3044                /* Set the DMA error callback */
   3045                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   \       0xA4   0x....             LDR      R0,??DataTable39_2
   \       0xA6   0x6AA1             LDR      R1,[R4, #+40]
   \       0xA8   0x6348             STR      R0,[R1, #+52]
   3046                /* Enable the DMA channel */
   3047                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
   \       0xAA   0x4668             MOV      R0,SP
   \       0xAC   0x8C03             LDRH     R3,[R0, #+32]
   \       0xAE   0x9A02             LDR      R2,[SP, #+8]
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x0001             MOVS     R1,R0
   \       0xB4   0x3138             ADDS     R1,R1,#+56
   \       0xB6   0x6AA0             LDR      R0,[R4, #+40]
   \       0xB8   0x....'....        BL       HAL_DMA_Start_IT
   \       0xBC   0x2800             CMP      R0,#+0
   \       0xBE   0xD001             BEQ      ??HAL_TIM_Encoder_Start_DMA_11
   3048                {
   3049                  return HAL_ERROR;
   \       0xC0   0x2001             MOVS     R0,#+1
   \       0xC2   0xE05B             B        ??HAL_TIM_Encoder_Start_DMA_1
   3050                }
   3051                /* Enable the TIM Input Capture  DMA request */
   3052                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIM_Encoder_Start_DMA_11: (+1)
   \       0xC4   0x6820             LDR      R0,[R4, #+0]
   \       0xC6   0x68C0             LDR      R0,[R0, #+12]
   \       0xC8   0x2180             MOVS     R1,#+128
   \       0xCA   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \       0xCC   0x4301             ORRS     R1,R1,R0
   \       0xCE   0x6820             LDR      R0,[R4, #+0]
   \       0xD0   0x60C1             STR      R1,[R0, #+12]
   3053          
   3054                /* Enable the Peripheral */
   3055                __HAL_TIM_ENABLE(htim);
   \       0xD2   0x6820             LDR      R0,[R4, #+0]
   \       0xD4   0x6800             LDR      R0,[R0, #+0]
   \       0xD6   0x2101             MOVS     R1,#+1
   \       0xD8   0x4301             ORRS     R1,R1,R0
   \       0xDA   0x6820             LDR      R0,[R4, #+0]
   \       0xDC   0x6001             STR      R1,[R0, #+0]
   3056          
   3057                /* Enable the Capture compare channel */
   3058                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \       0xDE   0x2201             MOVS     R2,#+1
   \       0xE0   0x2104             MOVS     R1,#+4
   \       0xE2   0x6820             LDR      R0,[R4, #+0]
   \       0xE4   0x....'....        BL       TIM_CCxChannelCmd
   3059                break;
   \       0xE8   0xE047             B        ??HAL_TIM_Encoder_Start_DMA_10
   3060              }
   3061          
   3062              case TIM_CHANNEL_ALL:
   3063              {
   3064                /* Set the DMA capture callbacks */
   3065                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_7: (+1)
   \       0xEA   0x....             LDR      R7,??DataTable39
   \       0xEC   0x6A60             LDR      R0,[R4, #+36]
   \       0xEE   0x62C7             STR      R7,[R0, #+44]
   3066                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xF0   0x....             LDR      R6,??DataTable39_1
   \       0xF2   0x6A60             LDR      R0,[R4, #+36]
   \       0xF4   0x6306             STR      R6,[R0, #+48]
   3067          
   3068                /* Set the DMA error callback */
   3069                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0xF6   0x....             LDR      R5,??DataTable39_2
   \       0xF8   0x6A60             LDR      R0,[R4, #+36]
   \       0xFA   0x6345             STR      R5,[R0, #+52]
   3070          
   3071                /* Enable the DMA channel */
   3072                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length) != HAL_OK)
   \       0xFC   0x4668             MOV      R0,SP
   \       0xFE   0x8C03             LDRH     R3,[R0, #+32]
   \      0x100   0x9A01             LDR      R2,[SP, #+4]
   \      0x102   0x6820             LDR      R0,[R4, #+0]
   \      0x104   0x0001             MOVS     R1,R0
   \      0x106   0x3134             ADDS     R1,R1,#+52
   \      0x108   0x6A60             LDR      R0,[R4, #+36]
   \      0x10A   0x....'....        BL       HAL_DMA_Start_IT
   \      0x10E   0x2800             CMP      R0,#+0
   \      0x110   0xD001             BEQ      ??HAL_TIM_Encoder_Start_DMA_12
   3073                {
   3074                  return HAL_ERROR;
   \      0x112   0x2001             MOVS     R0,#+1
   \      0x114   0xE032             B        ??HAL_TIM_Encoder_Start_DMA_1
   3075                }
   3076          
   3077                /* Set the DMA capture callbacks */
   3078                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_Encoder_Start_DMA_12: (+1)
   \      0x116   0x6AA0             LDR      R0,[R4, #+40]
   \      0x118   0x62C7             STR      R7,[R0, #+44]
   3079                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \      0x11A   0x6AA0             LDR      R0,[R4, #+40]
   \      0x11C   0x6306             STR      R6,[R0, #+48]
   3080          
   3081                /* Set the DMA error callback */
   3082                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \      0x11E   0x6AA0             LDR      R0,[R4, #+40]
   \      0x120   0x6345             STR      R5,[R0, #+52]
   3083          
   3084                /* Enable the DMA channel */
   3085                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length) != HAL_OK)
   \      0x122   0x4668             MOV      R0,SP
   \      0x124   0x8C03             LDRH     R3,[R0, #+32]
   \      0x126   0x9A02             LDR      R2,[SP, #+8]
   \      0x128   0x6820             LDR      R0,[R4, #+0]
   \      0x12A   0x0001             MOVS     R1,R0
   \      0x12C   0x3138             ADDS     R1,R1,#+56
   \      0x12E   0x6AA0             LDR      R0,[R4, #+40]
   \      0x130   0x....'....        BL       HAL_DMA_Start_IT
   \      0x134   0x2800             CMP      R0,#+0
   \      0x136   0xD001             BEQ      ??HAL_TIM_Encoder_Start_DMA_13
   3086                {
   3087                  return HAL_ERROR;
   \      0x138   0x2001             MOVS     R0,#+1
   \      0x13A   0xE01F             B        ??HAL_TIM_Encoder_Start_DMA_1
   3088                }
   3089                /* Enable the Peripheral */
   3090                __HAL_TIM_ENABLE(htim);
   \                     ??HAL_TIM_Encoder_Start_DMA_13: (+1)
   \      0x13C   0x6820             LDR      R0,[R4, #+0]
   \      0x13E   0x6800             LDR      R0,[R0, #+0]
   \      0x140   0x2101             MOVS     R1,#+1
   \      0x142   0x4301             ORRS     R1,R1,R0
   \      0x144   0x6820             LDR      R0,[R4, #+0]
   \      0x146   0x6001             STR      R1,[R0, #+0]
   3091          
   3092                /* Enable the Capture compare channel */
   3093                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \      0x148   0x2201             MOVS     R2,#+1
   \      0x14A   0x2100             MOVS     R1,#+0
   \      0x14C   0x6820             LDR      R0,[R4, #+0]
   \      0x14E   0x....'....        BL       TIM_CCxChannelCmd
   3094                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   \      0x152   0x2201             MOVS     R2,#+1
   \      0x154   0x2104             MOVS     R1,#+4
   \      0x156   0x6820             LDR      R0,[R4, #+0]
   \      0x158   0x....'....        BL       TIM_CCxChannelCmd
   3095          
   3096                /* Enable the TIM Input Capture  DMA request */
   3097                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \      0x15C   0x6820             LDR      R0,[R4, #+0]
   \      0x15E   0x68C0             LDR      R0,[R0, #+12]
   \      0x160   0x2180             MOVS     R1,#+128
   \      0x162   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \      0x164   0x4301             ORRS     R1,R1,R0
   \      0x166   0x6820             LDR      R0,[R4, #+0]
   \      0x168   0x60C1             STR      R1,[R0, #+12]
   3098                /* Enable the TIM Input Capture  DMA request */
   3099                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \      0x16A   0x6820             LDR      R0,[R4, #+0]
   \      0x16C   0x68C0             LDR      R0,[R0, #+12]
   \      0x16E   0x2180             MOVS     R1,#+128
   \      0x170   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \      0x172   0x4301             ORRS     R1,R1,R0
   \      0x174   0x6820             LDR      R0,[R4, #+0]
   \      0x176   0x60C1             STR      R1,[R0, #+12]
   3100                break;
   \      0x178   0xE7FF             B        ??HAL_TIM_Encoder_Start_DMA_10
   3101              }
   3102          
   3103              default:
   3104                break;
   3105            }
   3106            /* Return function status */
   3107            return HAL_OK;
   \                     ??HAL_TIM_Encoder_Start_DMA_8: (+1)
   \                     ??HAL_TIM_Encoder_Start_DMA_10: (+1)
   \      0x17A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_Encoder_Start_DMA_1: (+1)
   \      0x17C   0xBDFE             POP      {R1-R7,PC}       ;; return
   3108          }
   3109          
   3110          /**
   3111            * @brief  Stops the TIM Encoder Interface in DMA mode.
   3112            * @param  htim TIM Encoder Interface handle
   3113            * @param  Channel TIM Channels to be enabled
   3114            *          This parameter can be one of the following values:
   3115            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3116            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3117            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   3118            * @retval HAL status
   3119            */

   \                                 In section .text, align 2, keep-with-next
   3120          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   3121          {
   \                     HAL_TIM_Encoder_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   3122            /* Check the parameters */
   3123            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   3124          
   3125            /* Disable the Input Capture channels 1 and 2
   3126              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   3127            if (Channel == TIM_CHANNEL_1)
   \        0x6   0x2D00             CMP      R5,#+0
   \        0x8   0xD10E             BNE      ??HAL_TIM_Encoder_Stop_DMA_0
   3128            {
   3129              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x....'....        BL       TIM_CCxChannelCmd
   3130          
   3131              /* Disable the capture compare DMA Request 1 */
   3132              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x68C0             LDR      R0,[R0, #+12]
   \       0x18   0x....             LDR      R1,??DataTable40  ;; 0xfffffdff
   \       0x1A   0x4001             ANDS     R1,R1,R0
   \       0x1C   0x6820             LDR      R0,[R4, #+0]
   \       0x1E   0x60C1             STR      R1,[R0, #+12]
   3133              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x20   0x6A60             LDR      R0,[R4, #+36]
   \       0x22   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x26   0xE02C             B        ??HAL_TIM_Encoder_Stop_DMA_1
   3134            }
   3135            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_Encoder_Stop_DMA_0: (+1)
   \       0x28   0x2D04             CMP      R5,#+4
   \       0x2A   0xD10E             BNE      ??HAL_TIM_Encoder_Stop_DMA_2
   3136            {
   3137              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x2C   0x2200             MOVS     R2,#+0
   \       0x2E   0x2104             MOVS     R1,#+4
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x....'....        BL       TIM_CCxChannelCmd
   3138          
   3139              /* Disable the capture compare DMA Request 2 */
   3140              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x68C0             LDR      R0,[R0, #+12]
   \       0x3A   0x....             LDR      R1,??DataTable40_1  ;; 0xfffffbff
   \       0x3C   0x4001             ANDS     R1,R1,R0
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x60C1             STR      R1,[R0, #+12]
   3141              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x42   0x6AA0             LDR      R0,[R4, #+40]
   \       0x44   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x48   0xE01B             B        ??HAL_TIM_Encoder_Stop_DMA_1
   3142            }
   3143            else
   3144            {
   3145              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \                     ??HAL_TIM_Encoder_Stop_DMA_2: (+1)
   \       0x4A   0x2200             MOVS     R2,#+0
   \       0x4C   0x2100             MOVS     R1,#+0
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x....'....        BL       TIM_CCxChannelCmd
   3146              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   \       0x54   0x2200             MOVS     R2,#+0
   \       0x56   0x2104             MOVS     R1,#+4
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x....'....        BL       TIM_CCxChannelCmd
   3147          
   3148              /* Disable the capture compare DMA Request 1 and 2 */
   3149              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x68C0             LDR      R0,[R0, #+12]
   \       0x62   0x....             LDR      R1,??DataTable40  ;; 0xfffffdff
   \       0x64   0x4001             ANDS     R1,R1,R0
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x60C1             STR      R1,[R0, #+12]
   3150              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x68C0             LDR      R0,[R0, #+12]
   \       0x6E   0x....             LDR      R1,??DataTable40_1  ;; 0xfffffbff
   \       0x70   0x4001             ANDS     R1,R1,R0
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x60C1             STR      R1,[R0, #+12]
   3151              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x76   0x6A60             LDR      R0,[R4, #+36]
   \       0x78   0x....'....        BL       HAL_DMA_Abort_IT
   3152              (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x7C   0x6AA0             LDR      R0,[R4, #+40]
   \       0x7E   0x....'....        BL       HAL_DMA_Abort_IT
   3153            }
   3154          
   3155            /* Disable the Peripheral */
   3156            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIM_Encoder_Stop_DMA_1: (+1)
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x6A00             LDR      R0,[R0, #+32]
   \       0x86   0x....             LDR      R1,??DataTable40_2  ;; 0x1111
   \       0x88   0x4001             ANDS     R1,R1,R0
   \       0x8A   0x2900             CMP      R1,#+0
   \       0x8C   0xD10B             BNE      ??HAL_TIM_Encoder_Stop_DMA_3
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x6A00             LDR      R0,[R0, #+32]
   \       0x92   0x....             LDR      R1,??DataTable40_3  ;; 0x444
   \       0x94   0x4001             ANDS     R1,R1,R0
   \       0x96   0x2900             CMP      R1,#+0
   \       0x98   0xD105             BNE      ??HAL_TIM_Encoder_Stop_DMA_3
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x6800             LDR      R0,[R0, #+0]
   \       0x9E   0x2101             MOVS     R1,#+1
   \       0xA0   0x4388             BICS     R0,R0,R1
   \       0xA2   0x6821             LDR      R1,[R4, #+0]
   \       0xA4   0x6008             STR      R0,[R1, #+0]
   3157          
   3158            /* Change the htim state */
   3159            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_Encoder_Stop_DMA_3: (+1)
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0x213D             MOVS     R1,#+61
   \       0xAA   0x5460             STRB     R0,[R4, R1]
   3160          
   3161            /* Return function status */
   3162            return HAL_OK;
   \       0xAC   0x2000             MOVS     R0,#+0
   \       0xAE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   3163          }
   3164          
   3165          /**
   3166            * @}
   3167            */
   3168          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management
   3169            *  @brief    TIM IRQ handler management
   3170            *
   3171          @verbatim
   3172            ==============================================================================
   3173                                  ##### IRQ handler management #####
   3174            ==============================================================================
   3175            [..]
   3176              This section provides Timer IRQ handler function.
   3177          
   3178          @endverbatim
   3179            * @{
   3180            */
   3181          /**
   3182            * @brief  This function handles TIM interrupts requests.
   3183            * @param  htim TIM  handle
   3184            * @retval None
   3185            */

   \                                 In section .text, align 2, keep-with-next
   3186          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   3187          {
   \                     HAL_TIM_IRQHandler: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   3188            /* Capture compare 1 event */
   3189            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   \        0x4   0x2602             MOVS     R6,#+2
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x6900             LDR      R0,[R0, #+16]
   \        0xA   0x4030             ANDS     R0,R0,R6
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD01C             BEQ      ??HAL_TIM_IRQHandler_0
   3190            {
   3191              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x68C0             LDR      R0,[R0, #+12]
   \       0x14   0x4030             ANDS     R0,R0,R6
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD017             BEQ      ??HAL_TIM_IRQHandler_0
   3192              {
   3193                {
   3194                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0x43C0             MVNS     R0,R0            ;; #-3
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x6108             STR      R0,[R1, #+16]
   3195                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x7720             STRB     R0,[R4, #+28]
   3196          
   3197                  /* Input capture event */
   3198                  if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6980             LDR      R0,[R0, #+24]
   \       0x2A   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \       0x2C   0x0F80             LSRS     R0,R0,#+30
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD003             BEQ      ??HAL_TIM_IRQHandler_1
   3199                  {
   3200          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3201                    htim->IC_CaptureCallback(htim);
   3202          #else
   3203                    HAL_TIM_IC_CaptureCallback(htim);
   \       0x32   0x0020             MOVS     R0,R4
   \       0x34   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   \       0x38   0xE005             B        ??HAL_TIM_IRQHandler_2
   3204          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3205                  }
   3206                  /* Output compare event */
   3207                  else
   3208                  {
   3209          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3210                    htim->OC_DelayElapsedCallback(htim);
   3211                    htim->PWM_PulseFinishedCallback(htim);
   3212          #else
   3213                    HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_1: (+1)
   \       0x3A   0x0020             MOVS     R0,R4
   \       0x3C   0x....'....        BL       HAL_TIM_OC_DelayElapsedCallback
   3214                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x....'....        BL       HAL_TIM_PWM_PulseFinishedCallback
   3215          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3216                  }
   3217                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_2: (+1)
   \       0x46   0x2000             MOVS     R0,#+0
   \       0x48   0x7720             STRB     R0,[R4, #+28]
   3218                }
   3219              }
   3220            }
   3221            /* Capture compare 2 event */
   3222            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   \                     ??HAL_TIM_IRQHandler_0: (+1)
   \       0x4A   0x2504             MOVS     R5,#+4
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6900             LDR      R0,[R0, #+16]
   \       0x50   0x4028             ANDS     R0,R0,R5
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD01C             BEQ      ??HAL_TIM_IRQHandler_3
   3223            {
   3224              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x68C0             LDR      R0,[R0, #+12]
   \       0x5A   0x4028             ANDS     R0,R0,R5
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD017             BEQ      ??HAL_TIM_IRQHandler_3
   3225              {
   3226                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   \       0x60   0x2004             MOVS     R0,#+4
   \       0x62   0x43C0             MVNS     R0,R0            ;; #-5
   \       0x64   0x6821             LDR      R1,[R4, #+0]
   \       0x66   0x6108             STR      R0,[R1, #+16]
   3227                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x68   0x7726             STRB     R6,[R4, #+28]
   3228                /* Input capture event */
   3229                if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6980             LDR      R0,[R0, #+24]
   \       0x6E   0x21C0             MOVS     R1,#+192
   \       0x70   0x0089             LSLS     R1,R1,#+2        ;; #+768
   \       0x72   0x4001             ANDS     R1,R1,R0
   \       0x74   0x2900             CMP      R1,#+0
   \       0x76   0xD003             BEQ      ??HAL_TIM_IRQHandler_4
   3230                {
   3231          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3232                  htim->IC_CaptureCallback(htim);
   3233          #else
   3234                  HAL_TIM_IC_CaptureCallback(htim);
   \       0x78   0x0020             MOVS     R0,R4
   \       0x7A   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   \       0x7E   0xE005             B        ??HAL_TIM_IRQHandler_5
   3235          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3236                }
   3237                /* Output compare event */
   3238                else
   3239                {
   3240          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3241                  htim->OC_DelayElapsedCallback(htim);
   3242                  htim->PWM_PulseFinishedCallback(htim);
   3243          #else
   3244                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_4: (+1)
   \       0x80   0x0020             MOVS     R0,R4
   \       0x82   0x....'....        BL       HAL_TIM_OC_DelayElapsedCallback
   3245                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0x86   0x0020             MOVS     R0,R4
   \       0x88   0x....'....        BL       HAL_TIM_PWM_PulseFinishedCallback
   3246          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3247                }
   3248                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_5: (+1)
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x7720             STRB     R0,[R4, #+28]
   3249              }
   3250            }
   3251            /* Capture compare 3 event */
   3252            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   \                     ??HAL_TIM_IRQHandler_3: (+1)
   \       0x90   0x2608             MOVS     R6,#+8
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6900             LDR      R0,[R0, #+16]
   \       0x96   0x4030             ANDS     R0,R0,R6
   \       0x98   0x2800             CMP      R0,#+0
   \       0x9A   0xD01B             BEQ      ??HAL_TIM_IRQHandler_6
   3253            {
   3254              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
   \       0x9C   0x6820             LDR      R0,[R4, #+0]
   \       0x9E   0x68C0             LDR      R0,[R0, #+12]
   \       0xA0   0x4030             ANDS     R0,R0,R6
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD016             BEQ      ??HAL_TIM_IRQHandler_6
   3255              {
   3256                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   \       0xA6   0x2008             MOVS     R0,#+8
   \       0xA8   0x43C0             MVNS     R0,R0            ;; #-9
   \       0xAA   0x6821             LDR      R1,[R4, #+0]
   \       0xAC   0x6108             STR      R0,[R1, #+16]
   3257                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0xAE   0x7725             STRB     R5,[R4, #+28]
   3258                /* Input capture event */
   3259                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x69C0             LDR      R0,[R0, #+28]
   \       0xB4   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \       0xB6   0x0F80             LSRS     R0,R0,#+30
   \       0xB8   0x2800             CMP      R0,#+0
   \       0xBA   0xD003             BEQ      ??HAL_TIM_IRQHandler_7
   3260                {
   3261          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3262                  htim->IC_CaptureCallback(htim);
   3263          #else
   3264                  HAL_TIM_IC_CaptureCallback(htim);
   \       0xBC   0x0020             MOVS     R0,R4
   \       0xBE   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   \       0xC2   0xE005             B        ??HAL_TIM_IRQHandler_8
   3265          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3266                }
   3267                /* Output compare event */
   3268                else
   3269                {
   3270          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3271                  htim->OC_DelayElapsedCallback(htim);
   3272                  htim->PWM_PulseFinishedCallback(htim);
   3273          #else
   3274                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_7: (+1)
   \       0xC4   0x0020             MOVS     R0,R4
   \       0xC6   0x....'....        BL       HAL_TIM_OC_DelayElapsedCallback
   3275                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \       0xCA   0x0020             MOVS     R0,R4
   \       0xCC   0x....'....        BL       HAL_TIM_PWM_PulseFinishedCallback
   3276          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3277                }
   3278                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_8: (+1)
   \       0xD0   0x2000             MOVS     R0,#+0
   \       0xD2   0x7720             STRB     R0,[R4, #+28]
   3279              }
   3280            }
   3281            /* Capture compare 4 event */
   3282            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   \                     ??HAL_TIM_IRQHandler_6: (+1)
   \       0xD4   0x2010             MOVS     R0,#+16
   \       0xD6   0x6821             LDR      R1,[R4, #+0]
   \       0xD8   0x6909             LDR      R1,[R1, #+16]
   \       0xDA   0x4001             ANDS     R1,R1,R0
   \       0xDC   0x2900             CMP      R1,#+0
   \       0xDE   0xD01C             BEQ      ??HAL_TIM_IRQHandler_9
   3283            {
   3284              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
   \       0xE0   0x6821             LDR      R1,[R4, #+0]
   \       0xE2   0x68C9             LDR      R1,[R1, #+12]
   \       0xE4   0x4008             ANDS     R0,R0,R1
   \       0xE6   0x2800             CMP      R0,#+0
   \       0xE8   0xD017             BEQ      ??HAL_TIM_IRQHandler_9
   3285              {
   3286                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   \       0xEA   0x2010             MOVS     R0,#+16
   \       0xEC   0x43C0             MVNS     R0,R0            ;; #-17
   \       0xEE   0x6821             LDR      R1,[R4, #+0]
   \       0xF0   0x6108             STR      R0,[R1, #+16]
   3287                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0xF2   0x7726             STRB     R6,[R4, #+28]
   3288                /* Input capture event */
   3289                if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
   \       0xF4   0x6820             LDR      R0,[R4, #+0]
   \       0xF6   0x69C0             LDR      R0,[R0, #+28]
   \       0xF8   0x21C0             MOVS     R1,#+192
   \       0xFA   0x0089             LSLS     R1,R1,#+2        ;; #+768
   \       0xFC   0x4001             ANDS     R1,R1,R0
   \       0xFE   0x2900             CMP      R1,#+0
   \      0x100   0xD003             BEQ      ??HAL_TIM_IRQHandler_10
   3290                {
   3291          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3292                  htim->IC_CaptureCallback(htim);
   3293          #else
   3294                  HAL_TIM_IC_CaptureCallback(htim);
   \      0x102   0x0020             MOVS     R0,R4
   \      0x104   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   \      0x108   0xE005             B        ??HAL_TIM_IRQHandler_11
   3295          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3296                }
   3297                /* Output compare event */
   3298                else
   3299                {
   3300          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3301                  htim->OC_DelayElapsedCallback(htim);
   3302                  htim->PWM_PulseFinishedCallback(htim);
   3303          #else
   3304                  HAL_TIM_OC_DelayElapsedCallback(htim);
   \                     ??HAL_TIM_IRQHandler_10: (+1)
   \      0x10A   0x0020             MOVS     R0,R4
   \      0x10C   0x....'....        BL       HAL_TIM_OC_DelayElapsedCallback
   3305                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   \      0x110   0x0020             MOVS     R0,R4
   \      0x112   0x....'....        BL       HAL_TIM_PWM_PulseFinishedCallback
   3306          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3307                }
   3308                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \                     ??HAL_TIM_IRQHandler_11: (+1)
   \      0x116   0x2000             MOVS     R0,#+0
   \      0x118   0x7720             STRB     R0,[R4, #+28]
   3309              }
   3310            }
   3311            /* TIM Update event */
   3312            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   \                     ??HAL_TIM_IRQHandler_9: (+1)
   \      0x11A   0x2001             MOVS     R0,#+1
   \      0x11C   0x6821             LDR      R1,[R4, #+0]
   \      0x11E   0x6909             LDR      R1,[R1, #+16]
   \      0x120   0x4001             ANDS     R1,R1,R0
   \      0x122   0x2900             CMP      R1,#+0
   \      0x124   0xD00B             BEQ      ??HAL_TIM_IRQHandler_12
   3313            {
   3314              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
   \      0x126   0x6821             LDR      R1,[R4, #+0]
   \      0x128   0x68C9             LDR      R1,[R1, #+12]
   \      0x12A   0x4008             ANDS     R0,R0,R1
   \      0x12C   0x2800             CMP      R0,#+0
   \      0x12E   0xD006             BEQ      ??HAL_TIM_IRQHandler_12
   3315              {
   3316                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   \      0x130   0x2001             MOVS     R0,#+1
   \      0x132   0x43C0             MVNS     R0,R0            ;; #-2
   \      0x134   0x6821             LDR      R1,[R4, #+0]
   \      0x136   0x6108             STR      R0,[R1, #+16]
   3317          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3318                htim->PeriodElapsedCallback(htim);
   3319          #else
   3320                HAL_TIM_PeriodElapsedCallback(htim);
   \      0x138   0x0020             MOVS     R0,R4
   \      0x13A   0x....'....        BL       HAL_TIM_PeriodElapsedCallback
   3321          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3322              }
   3323            }
   3324            /* TIM Break input event */
   3325            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   \                     ??HAL_TIM_IRQHandler_12: (+1)
   \      0x13E   0x2580             MOVS     R5,#+128
   \      0x140   0x6820             LDR      R0,[R4, #+0]
   \      0x142   0x6900             LDR      R0,[R0, #+16]
   \      0x144   0x4028             ANDS     R0,R0,R5
   \      0x146   0x2800             CMP      R0,#+0
   \      0x148   0xD00B             BEQ      ??HAL_TIM_IRQHandler_13
   3326            {
   3327              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
   \      0x14A   0x6820             LDR      R0,[R4, #+0]
   \      0x14C   0x68C0             LDR      R0,[R0, #+12]
   \      0x14E   0x4028             ANDS     R0,R0,R5
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD006             BEQ      ??HAL_TIM_IRQHandler_13
   3328              {
   3329                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   \      0x154   0x2080             MOVS     R0,#+128
   \      0x156   0x43C0             MVNS     R0,R0            ;; #-129
   \      0x158   0x6821             LDR      R1,[R4, #+0]
   \      0x15A   0x6108             STR      R0,[R1, #+16]
   3330          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3331                htim->BreakCallback(htim);
   3332          #else
   3333                HAL_TIMEx_BreakCallback(htim);
   \      0x15C   0x0020             MOVS     R0,R4
   \      0x15E   0x....'....        BL       HAL_TIMEx_BreakCallback
   3334          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3335              }
   3336            }
   3337            /* TIM Break2 input event */
   3338            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
   \                     ??HAL_TIM_IRQHandler_13: (+1)
   \      0x162   0x6820             LDR      R0,[R4, #+0]
   \      0x164   0x6900             LDR      R0,[R0, #+16]
   \      0x166   0x05C0             LSLS     R0,R0,#+23
   \      0x168   0xD50A             BPL      ??HAL_TIM_IRQHandler_14
   3339            {
   3340              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
   \      0x16A   0x6820             LDR      R0,[R4, #+0]
   \      0x16C   0x68C0             LDR      R0,[R0, #+12]
   \      0x16E   0x4005             ANDS     R5,R5,R0
   \      0x170   0x2D00             CMP      R5,#+0
   \      0x172   0xD005             BEQ      ??HAL_TIM_IRQHandler_14
   3341              {
   3342                __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
   \      0x174   0x....             LDR      R0,??DataTable42  ;; 0xfffffeff
   \      0x176   0x6821             LDR      R1,[R4, #+0]
   \      0x178   0x6108             STR      R0,[R1, #+16]
   3343          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3344                htim->Break2Callback(htim);
   3345          #else
   3346                HAL_TIMEx_Break2Callback(htim);
   \      0x17A   0x0020             MOVS     R0,R4
   \      0x17C   0x....'....        BL       HAL_TIMEx_Break2Callback
   3347          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3348              }
   3349            }
   3350            /* TIM Trigger detection event */
   3351            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   \                     ??HAL_TIM_IRQHandler_14: (+1)
   \      0x180   0x2040             MOVS     R0,#+64
   \      0x182   0x6821             LDR      R1,[R4, #+0]
   \      0x184   0x6909             LDR      R1,[R1, #+16]
   \      0x186   0x4001             ANDS     R1,R1,R0
   \      0x188   0x2900             CMP      R1,#+0
   \      0x18A   0xD00B             BEQ      ??HAL_TIM_IRQHandler_15
   3352            {
   3353              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
   \      0x18C   0x6821             LDR      R1,[R4, #+0]
   \      0x18E   0x68C9             LDR      R1,[R1, #+12]
   \      0x190   0x4008             ANDS     R0,R0,R1
   \      0x192   0x2800             CMP      R0,#+0
   \      0x194   0xD006             BEQ      ??HAL_TIM_IRQHandler_15
   3354              {
   3355                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   \      0x196   0x2040             MOVS     R0,#+64
   \      0x198   0x43C0             MVNS     R0,R0            ;; #-65
   \      0x19A   0x6821             LDR      R1,[R4, #+0]
   \      0x19C   0x6108             STR      R0,[R1, #+16]
   3356          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3357                htim->TriggerCallback(htim);
   3358          #else
   3359                HAL_TIM_TriggerCallback(htim);
   \      0x19E   0x0020             MOVS     R0,R4
   \      0x1A0   0x....'....        BL       HAL_TIM_TriggerCallback
   3360          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3361              }
   3362            }
   3363            /* TIM commutation event */
   3364            if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   \                     ??HAL_TIM_IRQHandler_15: (+1)
   \      0x1A4   0x2020             MOVS     R0,#+32
   \      0x1A6   0x6821             LDR      R1,[R4, #+0]
   \      0x1A8   0x6909             LDR      R1,[R1, #+16]
   \      0x1AA   0x4001             ANDS     R1,R1,R0
   \      0x1AC   0x2900             CMP      R1,#+0
   \      0x1AE   0xD00B             BEQ      ??HAL_TIM_IRQHandler_16
   3365            {
   3366              if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
   \      0x1B0   0x6821             LDR      R1,[R4, #+0]
   \      0x1B2   0x68C9             LDR      R1,[R1, #+12]
   \      0x1B4   0x4008             ANDS     R0,R0,R1
   \      0x1B6   0x2800             CMP      R0,#+0
   \      0x1B8   0xD006             BEQ      ??HAL_TIM_IRQHandler_16
   3367              {
   3368                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   \      0x1BA   0x2020             MOVS     R0,#+32
   \      0x1BC   0x43C0             MVNS     R0,R0            ;; #-33
   \      0x1BE   0x6821             LDR      R1,[R4, #+0]
   \      0x1C0   0x6108             STR      R0,[R1, #+16]
   3369          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   3370                htim->CommutationCallback(htim);
   3371          #else
   3372                HAL_TIMEx_CommutCallback(htim);
   \      0x1C2   0x0020             MOVS     R0,R4
   \      0x1C4   0x....'....        BL       HAL_TIMEx_CommutCallback
   3373          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   3374              }
   3375            }
   3376          }
   \                     ??HAL_TIM_IRQHandler_16: (+1)
   \      0x1C8   0xBD70             POP      {R4-R6,PC}       ;; return
   3377          
   3378          /**
   3379            * @}
   3380            */
   3381          
   3382          /** @defgroup TIM_Exported_Functions_Group8 TIM Peripheral Control functions
   3383            *  @brief    TIM Peripheral Control functions
   3384            *
   3385          @verbatim
   3386            ==============================================================================
   3387                             ##### Peripheral Control functions #####
   3388            ==============================================================================
   3389           [..]
   3390             This section provides functions allowing to:
   3391                (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
   3392                (+) Configure External Clock source.
   3393                (+) Configure Complementary channels, break features and dead time.
   3394                (+) Configure Master and the Slave synchronization.
   3395                (+) Configure the DMA Burst Mode.
   3396          
   3397          @endverbatim
   3398            * @{
   3399            */
   3400          
   3401          /**
   3402            * @brief  Initializes the TIM Output Compare Channels according to the specified
   3403            *         parameters in the TIM_OC_InitTypeDef.
   3404            * @param  htim TIM Output Compare handle
   3405            * @param  sConfig TIM Output Compare configuration structure
   3406            * @param  Channel TIM Channels to configure
   3407            *          This parameter can be one of the following values:
   3408            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3409            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3410            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3411            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3412            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
   3413            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
   3414            * @retval HAL status
   3415            */

   \                                 In section .text, align 2, keep-with-next
   3416          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim,
   3417                                                     TIM_OC_InitTypeDef *sConfig,
   3418                                                     uint32_t Channel)
   3419          {
   \                     HAL_TIM_OC_ConfigChannel: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0017             MOVS     R7,R2
   3420            /* Check the parameters */
   3421            assert_param(IS_TIM_CHANNELS(Channel));
   3422            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   3423            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3424          
   3425            /* Process Locked */
   3426            __HAL_LOCK(htim);
   \        0x8   0x203C             MOVS     R0,#+60
   \        0xA   0x5C20             LDRB     R0,[R4, R0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE      ??HAL_TIM_OC_ConfigChannel_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE037             B        ??HAL_TIM_OC_ConfigChannel_1
   \                     ??HAL_TIM_OC_ConfigChannel_0: (+1)
   \       0x14   0x2501             MOVS     R5,#+1
   \       0x16   0x203C             MOVS     R0,#+60
   \       0x18   0x5425             STRB     R5,[R4, R0]
   3427          
   3428            htim->State = HAL_TIM_STATE_BUSY;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0x213D             MOVS     R1,#+61
   \       0x1E   0x5460             STRB     R0,[R4, R1]
   3429          
   3430            switch (Channel)
   \       0x20   0x0038             MOVS     R0,R7
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD00A             BEQ      ??HAL_TIM_OC_ConfigChannel_2
   \       0x26   0x2804             CMP      R0,#+4
   \       0x28   0xD00D             BEQ      ??HAL_TIM_OC_ConfigChannel_3
   \       0x2A   0x2808             CMP      R0,#+8
   \       0x2C   0xD010             BEQ      ??HAL_TIM_OC_ConfigChannel_4
   \       0x2E   0x280C             CMP      R0,#+12
   \       0x30   0xD013             BEQ      ??HAL_TIM_OC_ConfigChannel_5
   \       0x32   0x2810             CMP      R0,#+16
   \       0x34   0xD016             BEQ      ??HAL_TIM_OC_ConfigChannel_6
   \       0x36   0x2814             CMP      R0,#+20
   \       0x38   0xD019             BEQ      ??HAL_TIM_OC_ConfigChannel_7
   \       0x3A   0xE01D             B        ??HAL_TIM_OC_ConfigChannel_8
   3431            {
   3432              case TIM_CHANNEL_1:
   3433              {
   3434                /* Check the parameters */
   3435                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3436          
   3437                /* Configure the TIM Channel 1 in Output Compare */
   3438                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_2: (+1)
   \       0x3C   0x0031             MOVS     R1,R6
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x....'....        BL       TIM_OC1_SetConfig
   3439                break;
   \       0x44   0xE018             B        ??HAL_TIM_OC_ConfigChannel_9
   3440              }
   3441          
   3442              case TIM_CHANNEL_2:
   3443              {
   3444                /* Check the parameters */
   3445                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3446          
   3447                /* Configure the TIM Channel 2 in Output Compare */
   3448                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_3: (+1)
   \       0x46   0x0031             MOVS     R1,R6
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x....'....        BL       TIM_OC2_SetConfig
   3449                break;
   \       0x4E   0xE013             B        ??HAL_TIM_OC_ConfigChannel_9
   3450              }
   3451          
   3452              case TIM_CHANNEL_3:
   3453              {
   3454                /* Check the parameters */
   3455                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3456          
   3457                /* Configure the TIM Channel 3 in Output Compare */
   3458                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_4: (+1)
   \       0x50   0x0031             MOVS     R1,R6
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x....'....        BL       TIM_OC3_SetConfig
   3459                break;
   \       0x58   0xE00E             B        ??HAL_TIM_OC_ConfigChannel_9
   3460              }
   3461          
   3462              case TIM_CHANNEL_4:
   3463              {
   3464                /* Check the parameters */
   3465                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3466          
   3467                /* Configure the TIM Channel 4 in Output Compare */
   3468                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_5: (+1)
   \       0x5A   0x0031             MOVS     R1,R6
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x....'....        BL       TIM_OC4_SetConfig
   3469                break;
   \       0x62   0xE009             B        ??HAL_TIM_OC_ConfigChannel_9
   3470              }
   3471          
   3472              case TIM_CHANNEL_5:
   3473              {
   3474                /* Check the parameters */
   3475                assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
   3476          
   3477                /* Configure the TIM Channel 5 in Output Compare */
   3478                TIM_OC5_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_6: (+1)
   \       0x64   0x0031             MOVS     R1,R6
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x....'....        BL       TIM_OC5_SetConfig
   3479                break;
   \       0x6C   0xE004             B        ??HAL_TIM_OC_ConfigChannel_9
   3480              }
   3481          
   3482              case TIM_CHANNEL_6:
   3483              {
   3484                /* Check the parameters */
   3485                assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
   3486          
   3487                /* Configure the TIM Channel 6 in Output Compare */
   3488                TIM_OC6_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_OC_ConfigChannel_7: (+1)
   \       0x6E   0x0031             MOVS     R1,R6
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x....'....        BL       TIM_OC6_SetConfig
   3489                break;
   \       0x76   0xE7FF             B        ??HAL_TIM_OC_ConfigChannel_9
   3490              }
   3491          
   3492              default:
   3493                break;
   3494            }
   3495          
   3496            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OC_ConfigChannel_8: (+1)
   \                     ??HAL_TIM_OC_ConfigChannel_9: (+1)
   \       0x78   0x203D             MOVS     R0,#+61
   \       0x7A   0x5425             STRB     R5,[R4, R0]
   3497          
   3498            __HAL_UNLOCK(htim);
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x213C             MOVS     R1,#+60
   \       0x80   0x5460             STRB     R0,[R4, R1]
   3499          
   3500            return HAL_OK;
   \       0x82   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_OC_ConfigChannel_1: (+1)
   \       0x84   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3501          }
   3502          
   3503          /**
   3504            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3505            *         parameters in the TIM_IC_InitTypeDef.
   3506            * @param  htim TIM IC handle
   3507            * @param  sConfig TIM Input Capture configuration structure
   3508            * @param  Channel TIM Channel to configure
   3509            *          This parameter can be one of the following values:
   3510            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3511            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3512            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3513            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3514            * @retval HAL status
   3515            */

   \                                 In section .text, align 2, keep-with-next
   3516          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef *sConfig, uint32_t Channel)
   3517          {
   \                     HAL_TIM_IC_ConfigChannel: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0017             MOVS     R7,R2
   3518            /* Check the parameters */
   3519            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3520            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3521            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3522            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3523            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3524          
   3525            /* Process Locked */
   3526            __HAL_LOCK(htim);
   \        0x8   0x203C             MOVS     R0,#+60
   \        0xA   0x5C20             LDRB     R0,[R4, R0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE      ??HAL_TIM_IC_ConfigChannel_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE05E             B        ??HAL_TIM_IC_ConfigChannel_1
   \                     ??HAL_TIM_IC_ConfigChannel_0: (+1)
   \       0x14   0x2601             MOVS     R6,#+1
   \       0x16   0x203C             MOVS     R0,#+60
   \       0x18   0x5426             STRB     R6,[R4, R0]
   3527          
   3528            htim->State = HAL_TIM_STATE_BUSY;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0x213D             MOVS     R1,#+61
   \       0x1E   0x5460             STRB     R0,[R4, R1]
   3529          
   3530            if (Channel == TIM_CHANNEL_1)
   \       0x20   0x2F00             CMP      R7,#+0
   \       0x22   0xD112             BNE      ??HAL_TIM_IC_ConfigChannel_2
   3531            {
   3532              /* TI1 Configuration */
   3533              TIM_TI1_SetConfig(htim->Instance,
   3534                                sConfig->ICPolarity,
   3535                                sConfig->ICSelection,
   3536                                sConfig->ICFilter);
   \       0x24   0x68EB             LDR      R3,[R5, #+12]
   \       0x26   0x686A             LDR      R2,[R5, #+4]
   \       0x28   0x6829             LDR      R1,[R5, #+0]
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x....'....        BL       TIM_TI1_SetConfig
   3537          
   3538              /* Reset the IC1PSC Bits */
   3539              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x6980             LDR      R0,[R0, #+24]
   \       0x34   0x210C             MOVS     R1,#+12
   \       0x36   0x4388             BICS     R0,R0,R1
   \       0x38   0x6821             LDR      R1,[R4, #+0]
   \       0x3A   0x6188             STR      R0,[R1, #+24]
   3540          
   3541              /* Set the IC1PSC value */
   3542              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6980             LDR      R0,[R0, #+24]
   \       0x40   0x68A9             LDR      R1,[R5, #+8]
   \       0x42   0x4301             ORRS     R1,R1,R0
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6181             STR      R1,[R0, #+24]
   \       0x48   0xE03D             B        ??HAL_TIM_IC_ConfigChannel_3
   3543            }
   3544            else if (Channel == TIM_CHANNEL_2)
   \                     ??HAL_TIM_IC_ConfigChannel_2: (+1)
   \       0x4A   0x2F04             CMP      R7,#+4
   \       0x4C   0xD113             BNE      ??HAL_TIM_IC_ConfigChannel_4
   3545            {
   3546              /* TI2 Configuration */
   3547              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3548          
   3549              TIM_TI2_SetConfig(htim->Instance,
   3550                                sConfig->ICPolarity,
   3551                                sConfig->ICSelection,
   3552                                sConfig->ICFilter);
   \       0x4E   0x68EB             LDR      R3,[R5, #+12]
   \       0x50   0x686A             LDR      R2,[R5, #+4]
   \       0x52   0x6829             LDR      R1,[R5, #+0]
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x....'....        BL       TIM_TI2_SetConfig
   3553          
   3554              /* Reset the IC2PSC Bits */
   3555              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x6980             LDR      R0,[R0, #+24]
   \       0x5E   0x....             LDR      R1,??DataTable43  ;; 0xfffff3ff
   \       0x60   0x4001             ANDS     R1,R1,R0
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x6181             STR      R1,[R0, #+24]
   3556          
   3557              /* Set the IC2PSC value */
   3558              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x6980             LDR      R0,[R0, #+24]
   \       0x6A   0x68A9             LDR      R1,[R5, #+8]
   \       0x6C   0x0209             LSLS     R1,R1,#+8
   \       0x6E   0x4301             ORRS     R1,R1,R0
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6181             STR      R1,[R0, #+24]
   \       0x74   0xE027             B        ??HAL_TIM_IC_ConfigChannel_3
   3559            }
   3560            else if (Channel == TIM_CHANNEL_3)
   \                     ??HAL_TIM_IC_ConfigChannel_4: (+1)
   \       0x76   0x2F08             CMP      R7,#+8
   \       0x78   0xD112             BNE      ??HAL_TIM_IC_ConfigChannel_5
   3561            {
   3562              /* TI3 Configuration */
   3563              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3564          
   3565              TIM_TI3_SetConfig(htim->Instance,
   3566                                sConfig->ICPolarity,
   3567                                sConfig->ICSelection,
   3568                                sConfig->ICFilter);
   \       0x7A   0x68EB             LDR      R3,[R5, #+12]
   \       0x7C   0x686A             LDR      R2,[R5, #+4]
   \       0x7E   0x6829             LDR      R1,[R5, #+0]
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x....'....        BL       TIM_TI3_SetConfig
   3569          
   3570              /* Reset the IC3PSC Bits */
   3571              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x69C0             LDR      R0,[R0, #+28]
   \       0x8A   0x210C             MOVS     R1,#+12
   \       0x8C   0x4388             BICS     R0,R0,R1
   \       0x8E   0x6821             LDR      R1,[R4, #+0]
   \       0x90   0x61C8             STR      R0,[R1, #+28]
   3572          
   3573              /* Set the IC3PSC value */
   3574              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x69C0             LDR      R0,[R0, #+28]
   \       0x96   0x68A9             LDR      R1,[R5, #+8]
   \       0x98   0x4301             ORRS     R1,R1,R0
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x61C1             STR      R1,[R0, #+28]
   \       0x9E   0xE012             B        ??HAL_TIM_IC_ConfigChannel_3
   3575            }
   3576            else
   3577            {
   3578              /* TI4 Configuration */
   3579              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3580          
   3581              TIM_TI4_SetConfig(htim->Instance,
   3582                                sConfig->ICPolarity,
   3583                                sConfig->ICSelection,
   3584                                sConfig->ICFilter);
   \                     ??HAL_TIM_IC_ConfigChannel_5: (+1)
   \       0xA0   0x68EB             LDR      R3,[R5, #+12]
   \       0xA2   0x686A             LDR      R2,[R5, #+4]
   \       0xA4   0x6829             LDR      R1,[R5, #+0]
   \       0xA6   0x6820             LDR      R0,[R4, #+0]
   \       0xA8   0x....'....        BL       TIM_TI4_SetConfig
   3585          
   3586              /* Reset the IC4PSC Bits */
   3587              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x69C0             LDR      R0,[R0, #+28]
   \       0xB0   0x....             LDR      R1,??DataTable43  ;; 0xfffff3ff
   \       0xB2   0x4001             ANDS     R1,R1,R0
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x61C1             STR      R1,[R0, #+28]
   3588          
   3589              /* Set the IC4PSC value */
   3590              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
   \       0xB8   0x6820             LDR      R0,[R4, #+0]
   \       0xBA   0x69C0             LDR      R0,[R0, #+28]
   \       0xBC   0x68A9             LDR      R1,[R5, #+8]
   \       0xBE   0x0209             LSLS     R1,R1,#+8
   \       0xC0   0x4301             ORRS     R1,R1,R0
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x61C1             STR      R1,[R0, #+28]
   3591            }
   3592          
   3593            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_IC_ConfigChannel_3: (+1)
   \       0xC6   0x203D             MOVS     R0,#+61
   \       0xC8   0x5426             STRB     R6,[R4, R0]
   3594          
   3595            __HAL_UNLOCK(htim);
   \       0xCA   0x2000             MOVS     R0,#+0
   \       0xCC   0x213C             MOVS     R1,#+60
   \       0xCE   0x5460             STRB     R0,[R4, R1]
   3596          
   3597            return HAL_OK;
   \       0xD0   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_IC_ConfigChannel_1: (+1)
   \       0xD2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3598          }
   3599          
   3600          /**
   3601            * @brief  Initializes the TIM PWM  channels according to the specified
   3602            *         parameters in the TIM_OC_InitTypeDef.
   3603            * @param  htim TIM PWM handle
   3604            * @param  sConfig TIM PWM configuration structure
   3605            * @param  Channel TIM Channels to be configured
   3606            *          This parameter can be one of the following values:
   3607            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3608            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3609            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3610            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3611            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
   3612            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
   3613            * @retval HAL status
   3614            */

   \                                 In section .text, align 2, keep-with-next
   3615          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
   3616                                                      TIM_OC_InitTypeDef *sConfig,
   3617                                                      uint32_t Channel)
   3618          {
   \                     HAL_TIM_PWM_ConfigChannel: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0017             MOVS     R7,R2
   3619            /* Check the parameters */
   3620            assert_param(IS_TIM_CHANNELS(Channel));
   3621            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3622            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3623            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   3624          
   3625            /* Process Locked */
   3626            __HAL_LOCK(htim);
   \        0x8   0x203C             MOVS     R0,#+60
   \        0xA   0x5C20             LDRB     R0,[R4, R0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE      ??HAL_TIM_PWM_ConfigChannel_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE0A9             B        ??HAL_TIM_PWM_ConfigChannel_1
   \                     ??HAL_TIM_PWM_ConfigChannel_0: (+1)
   \       0x14   0x2601             MOVS     R6,#+1
   \       0x16   0x203C             MOVS     R0,#+60
   \       0x18   0x5426             STRB     R6,[R4, R0]
   3627          
   3628            htim->State = HAL_TIM_STATE_BUSY;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0x213D             MOVS     R1,#+61
   \       0x1E   0x5460             STRB     R0,[R4, R1]
   3629          
   3630            switch (Channel)
   \       0x20   0x0038             MOVS     R0,R7
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD00A             BEQ      ??HAL_TIM_PWM_ConfigChannel_2
   \       0x26   0x2804             CMP      R0,#+4
   \       0x28   0xD01F             BEQ      ??HAL_TIM_PWM_ConfigChannel_3
   \       0x2A   0x2808             CMP      R0,#+8
   \       0x2C   0xD036             BEQ      ??HAL_TIM_PWM_ConfigChannel_4
   \       0x2E   0x280C             CMP      R0,#+12
   \       0x30   0xD04B             BEQ      ??HAL_TIM_PWM_ConfigChannel_5
   \       0x32   0x2810             CMP      R0,#+16
   \       0x34   0xD062             BEQ      ??HAL_TIM_PWM_ConfigChannel_6
   \       0x36   0x2814             CMP      R0,#+20
   \       0x38   0xD077             BEQ      ??HAL_TIM_PWM_ConfigChannel_7
   \       0x3A   0xE08F             B        ??HAL_TIM_PWM_ConfigChannel_8
   3631            {
   3632              case TIM_CHANNEL_1:
   3633              {
   3634                /* Check the parameters */
   3635                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3636          
   3637                /* Configure the Channel 1 in PWM mode */
   3638                TIM_OC1_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_2: (+1)
   \       0x3C   0x0029             MOVS     R1,R5
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x....'....        BL       TIM_OC1_SetConfig
   3639          
   3640                /* Set the Preload enable bit for channel1 */
   3641                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x6980             LDR      R0,[R0, #+24]
   \       0x48   0x2108             MOVS     R1,#+8
   \       0x4A   0x4301             ORRS     R1,R1,R0
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x6181             STR      R1,[R0, #+24]
   3642          
   3643                /* Configure the Output Fast mode */
   3644                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x6980             LDR      R0,[R0, #+24]
   \       0x54   0x2104             MOVS     R1,#+4
   \       0x56   0x4388             BICS     R0,R0,R1
   \       0x58   0x6821             LDR      R1,[R4, #+0]
   \       0x5A   0x6188             STR      R0,[R1, #+24]
   3645                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   \       0x5C   0x6820             LDR      R0,[R4, #+0]
   \       0x5E   0x6980             LDR      R0,[R0, #+24]
   \       0x60   0x6929             LDR      R1,[R5, #+16]
   \       0x62   0x4301             ORRS     R1,R1,R0
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6181             STR      R1,[R0, #+24]
   3646                break;
   \       0x68   0xE078             B        ??HAL_TIM_PWM_ConfigChannel_9
   3647              }
   3648          
   3649              case TIM_CHANNEL_2:
   3650              {
   3651                /* Check the parameters */
   3652                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3653          
   3654                /* Configure the Channel 2 in PWM mode */
   3655                TIM_OC2_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_3: (+1)
   \       0x6A   0x0029             MOVS     R1,R5
   \       0x6C   0x6820             LDR      R0,[R4, #+0]
   \       0x6E   0x....'....        BL       TIM_OC2_SetConfig
   3656          
   3657                /* Set the Preload enable bit for channel2 */
   3658                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x6980             LDR      R0,[R0, #+24]
   \       0x76   0x2180             MOVS     R1,#+128
   \       0x78   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x7A   0x4301             ORRS     R1,R1,R0
   \       0x7C   0x6820             LDR      R0,[R4, #+0]
   \       0x7E   0x6181             STR      R1,[R0, #+24]
   3659          
   3660                /* Configure the Output Fast mode */
   3661                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6980             LDR      R0,[R0, #+24]
   \       0x84   0x....             LDR      R1,??DataTable43_1  ;; 0xfffffbff
   \       0x86   0x4001             ANDS     R1,R1,R0
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x6181             STR      R1,[R0, #+24]
   3662                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6980             LDR      R0,[R0, #+24]
   \       0x90   0x6929             LDR      R1,[R5, #+16]
   \       0x92   0x0209             LSLS     R1,R1,#+8
   \       0x94   0x4301             ORRS     R1,R1,R0
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x6181             STR      R1,[R0, #+24]
   3663                break;
   \       0x9A   0xE05F             B        ??HAL_TIM_PWM_ConfigChannel_9
   3664              }
   3665          
   3666              case TIM_CHANNEL_3:
   3667              {
   3668                /* Check the parameters */
   3669                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3670          
   3671                /* Configure the Channel 3 in PWM mode */
   3672                TIM_OC3_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_4: (+1)
   \       0x9C   0x0029             MOVS     R1,R5
   \       0x9E   0x6820             LDR      R0,[R4, #+0]
   \       0xA0   0x....'....        BL       TIM_OC3_SetConfig
   3673          
   3674                /* Set the Preload enable bit for channel3 */
   3675                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   \       0xA4   0x6820             LDR      R0,[R4, #+0]
   \       0xA6   0x69C0             LDR      R0,[R0, #+28]
   \       0xA8   0x2108             MOVS     R1,#+8
   \       0xAA   0x4301             ORRS     R1,R1,R0
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x61C1             STR      R1,[R0, #+28]
   3676          
   3677                /* Configure the Output Fast mode */
   3678                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x69C0             LDR      R0,[R0, #+28]
   \       0xB4   0x2104             MOVS     R1,#+4
   \       0xB6   0x4388             BICS     R0,R0,R1
   \       0xB8   0x6821             LDR      R1,[R4, #+0]
   \       0xBA   0x61C8             STR      R0,[R1, #+28]
   3679                htim->Instance->CCMR2 |= sConfig->OCFastMode;
   \       0xBC   0x6820             LDR      R0,[R4, #+0]
   \       0xBE   0x69C0             LDR      R0,[R0, #+28]
   \       0xC0   0x6929             LDR      R1,[R5, #+16]
   \       0xC2   0x4301             ORRS     R1,R1,R0
   \       0xC4   0x6820             LDR      R0,[R4, #+0]
   \       0xC6   0x61C1             STR      R1,[R0, #+28]
   3680                break;
   \       0xC8   0xE048             B        ??HAL_TIM_PWM_ConfigChannel_9
   3681              }
   3682          
   3683              case TIM_CHANNEL_4:
   3684              {
   3685                /* Check the parameters */
   3686                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3687          
   3688                /* Configure the Channel 4 in PWM mode */
   3689                TIM_OC4_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_5: (+1)
   \       0xCA   0x0029             MOVS     R1,R5
   \       0xCC   0x6820             LDR      R0,[R4, #+0]
   \       0xCE   0x....'....        BL       TIM_OC4_SetConfig
   3690          
   3691                /* Set the Preload enable bit for channel4 */
   3692                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   \       0xD2   0x6820             LDR      R0,[R4, #+0]
   \       0xD4   0x69C0             LDR      R0,[R0, #+28]
   \       0xD6   0x2180             MOVS     R1,#+128
   \       0xD8   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0xDA   0x4301             ORRS     R1,R1,R0
   \       0xDC   0x6820             LDR      R0,[R4, #+0]
   \       0xDE   0x61C1             STR      R1,[R0, #+28]
   3693          
   3694                /* Configure the Output Fast mode */
   3695                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   \       0xE0   0x6820             LDR      R0,[R4, #+0]
   \       0xE2   0x69C0             LDR      R0,[R0, #+28]
   \       0xE4   0x....             LDR      R1,??DataTable43_1  ;; 0xfffffbff
   \       0xE6   0x4001             ANDS     R1,R1,R0
   \       0xE8   0x6820             LDR      R0,[R4, #+0]
   \       0xEA   0x61C1             STR      R1,[R0, #+28]
   3696                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
   \       0xEC   0x6820             LDR      R0,[R4, #+0]
   \       0xEE   0x69C0             LDR      R0,[R0, #+28]
   \       0xF0   0x6929             LDR      R1,[R5, #+16]
   \       0xF2   0x0209             LSLS     R1,R1,#+8
   \       0xF4   0x4301             ORRS     R1,R1,R0
   \       0xF6   0x6820             LDR      R0,[R4, #+0]
   \       0xF8   0x61C1             STR      R1,[R0, #+28]
   3697                break;
   \       0xFA   0xE02F             B        ??HAL_TIM_PWM_ConfigChannel_9
   3698              }
   3699          
   3700              case TIM_CHANNEL_5:
   3701              {
   3702                /* Check the parameters */
   3703                assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
   3704          
   3705                /* Configure the Channel 5 in PWM mode */
   3706                TIM_OC5_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_6: (+1)
   \       0xFC   0x0029             MOVS     R1,R5
   \       0xFE   0x6820             LDR      R0,[R4, #+0]
   \      0x100   0x....'....        BL       TIM_OC5_SetConfig
   3707          
   3708                /* Set the Preload enable bit for channel5*/
   3709                htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
   \      0x104   0x6820             LDR      R0,[R4, #+0]
   \      0x106   0x6D40             LDR      R0,[R0, #+84]
   \      0x108   0x2108             MOVS     R1,#+8
   \      0x10A   0x4301             ORRS     R1,R1,R0
   \      0x10C   0x6820             LDR      R0,[R4, #+0]
   \      0x10E   0x6541             STR      R1,[R0, #+84]
   3710          
   3711                /* Configure the Output Fast mode */
   3712                htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
   \      0x110   0x6820             LDR      R0,[R4, #+0]
   \      0x112   0x6D40             LDR      R0,[R0, #+84]
   \      0x114   0x2104             MOVS     R1,#+4
   \      0x116   0x4388             BICS     R0,R0,R1
   \      0x118   0x6821             LDR      R1,[R4, #+0]
   \      0x11A   0x6548             STR      R0,[R1, #+84]
   3713                htim->Instance->CCMR3 |= sConfig->OCFastMode;
   \      0x11C   0x6820             LDR      R0,[R4, #+0]
   \      0x11E   0x6D40             LDR      R0,[R0, #+84]
   \      0x120   0x6929             LDR      R1,[R5, #+16]
   \      0x122   0x4301             ORRS     R1,R1,R0
   \      0x124   0x6820             LDR      R0,[R4, #+0]
   \      0x126   0x6541             STR      R1,[R0, #+84]
   3714                break;
   \      0x128   0xE018             B        ??HAL_TIM_PWM_ConfigChannel_9
   3715              }
   3716          
   3717              case TIM_CHANNEL_6:
   3718              {
   3719                /* Check the parameters */
   3720                assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
   3721          
   3722                /* Configure the Channel 6 in PWM mode */
   3723                TIM_OC6_SetConfig(htim->Instance, sConfig);
   \                     ??HAL_TIM_PWM_ConfigChannel_7: (+1)
   \      0x12A   0x0029             MOVS     R1,R5
   \      0x12C   0x6820             LDR      R0,[R4, #+0]
   \      0x12E   0x....'....        BL       TIM_OC6_SetConfig
   3724          
   3725                /* Set the Preload enable bit for channel6 */
   3726                htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
   \      0x132   0x6820             LDR      R0,[R4, #+0]
   \      0x134   0x6D40             LDR      R0,[R0, #+84]
   \      0x136   0x2180             MOVS     R1,#+128
   \      0x138   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \      0x13A   0x4301             ORRS     R1,R1,R0
   \      0x13C   0x6820             LDR      R0,[R4, #+0]
   \      0x13E   0x6541             STR      R1,[R0, #+84]
   3727          
   3728                /* Configure the Output Fast mode */
   3729                htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
   \      0x140   0x6820             LDR      R0,[R4, #+0]
   \      0x142   0x6D40             LDR      R0,[R0, #+84]
   \      0x144   0x....             LDR      R1,??DataTable43_1  ;; 0xfffffbff
   \      0x146   0x4001             ANDS     R1,R1,R0
   \      0x148   0x6820             LDR      R0,[R4, #+0]
   \      0x14A   0x6541             STR      R1,[R0, #+84]
   3730                htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
   \      0x14C   0x6820             LDR      R0,[R4, #+0]
   \      0x14E   0x6D40             LDR      R0,[R0, #+84]
   \      0x150   0x6929             LDR      R1,[R5, #+16]
   \      0x152   0x0209             LSLS     R1,R1,#+8
   \      0x154   0x4301             ORRS     R1,R1,R0
   \      0x156   0x6820             LDR      R0,[R4, #+0]
   \      0x158   0x6541             STR      R1,[R0, #+84]
   3731                break;
   \      0x15A   0xE7FF             B        ??HAL_TIM_PWM_ConfigChannel_9
   3732              }
   3733          
   3734              default:
   3735                break;
   3736            }
   3737          
   3738            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_PWM_ConfigChannel_8: (+1)
   \                     ??HAL_TIM_PWM_ConfigChannel_9: (+1)
   \      0x15C   0x203D             MOVS     R0,#+61
   \      0x15E   0x5426             STRB     R6,[R4, R0]
   3739          
   3740            __HAL_UNLOCK(htim);
   \      0x160   0x2000             MOVS     R0,#+0
   \      0x162   0x213C             MOVS     R1,#+60
   \      0x164   0x5460             STRB     R0,[R4, R1]
   3741          
   3742            return HAL_OK;
   \      0x166   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_PWM_ConfigChannel_1: (+1)
   \      0x168   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   3743          }
   3744          
   3745          /**
   3746            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3747            *         parameters in the TIM_OnePulse_InitTypeDef.
   3748            * @param  htim TIM One Pulse handle
   3749            * @param  sConfig TIM One Pulse configuration structure
   3750            * @param  OutputChannel TIM output channel to configure
   3751            *          This parameter can be one of the following values:
   3752            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3753            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3754            * @param  InputChannel TIM input Channel to configure
   3755            *          This parameter can be one of the following values:
   3756            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3757            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3758            * @note  To output a waveform with a minimum delay user can enable the fast
   3759            *        mode by calling the @ref __HAL_TIM_ENABLE_OCxFAST macro. Then CCx
   3760            *        output is forced in response to the edge detection on TIx input,
   3761            *        without taking in account the comparison.
   3762            * @retval HAL status
   3763            */

   \                                 In section .text, align 2, keep-with-next
   3764          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef *sConfig,
   3765                                                           uint32_t OutputChannel,  uint32_t InputChannel)
   3766          {
   \                     HAL_TIM_OnePulse_ConfigChannel: (+1)
   \        0x0   0xB5F6             PUSH     {R1,R2,R4-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x001F             MOVS     R7,R3
   3767            TIM_OC_InitTypeDef temp1;
   3768          
   3769            /* Check the parameters */
   3770            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3771            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3772          
   3773            if (OutputChannel != InputChannel)
   \        0xA   0x9808             LDR      R0,[SP, #+32]
   \        0xC   0x42B8             CMP      R0,R7
   \        0xE   0xD100             BNE      .+4
   \       0x10   0xE07E             B        ??HAL_TIM_OnePulse_ConfigChannel_0
   3774            {
   3775              /* Process Locked */
   3776              __HAL_LOCK(htim);
   \       0x12   0x203C             MOVS     R0,#+60
   \       0x14   0x5C20             LDRB     R0,[R4, R0]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD101             BNE      ??HAL_TIM_OnePulse_ConfigChannel_1
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0xE079             B        ??HAL_TIM_OnePulse_ConfigChannel_2
   \                     ??HAL_TIM_OnePulse_ConfigChannel_1: (+1)
   \       0x1E   0x2601             MOVS     R6,#+1
   \       0x20   0x203C             MOVS     R0,#+60
   \       0x22   0x5426             STRB     R6,[R4, R0]
   3777          
   3778              htim->State = HAL_TIM_STATE_BUSY;
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0x213D             MOVS     R1,#+61
   \       0x28   0x5460             STRB     R0,[R4, R1]
   3779          
   3780              /* Extract the Output compare configuration from sConfig structure */
   3781              temp1.OCMode = sConfig->OCMode;
   \       0x2A   0x6828             LDR      R0,[R5, #+0]
   \       0x2C   0x9000             STR      R0,[SP, #+0]
   3782              temp1.Pulse = sConfig->Pulse;
   \       0x2E   0x6868             LDR      R0,[R5, #+4]
   \       0x30   0x9001             STR      R0,[SP, #+4]
   3783              temp1.OCPolarity = sConfig->OCPolarity;
   \       0x32   0x68A8             LDR      R0,[R5, #+8]
   \       0x34   0x9002             STR      R0,[SP, #+8]
   3784              temp1.OCNPolarity = sConfig->OCNPolarity;
   \       0x36   0x68E8             LDR      R0,[R5, #+12]
   \       0x38   0x9003             STR      R0,[SP, #+12]
   3785              temp1.OCIdleState = sConfig->OCIdleState;
   \       0x3A   0x6928             LDR      R0,[R5, #+16]
   \       0x3C   0x9005             STR      R0,[SP, #+20]
   3786              temp1.OCNIdleState = sConfig->OCNIdleState;
   \       0x3E   0x6968             LDR      R0,[R5, #+20]
   \       0x40   0x9006             STR      R0,[SP, #+24]
   3787          
   3788              switch (OutputChannel)
   \       0x42   0x9808             LDR      R0,[SP, #+32]
   \       0x44   0x2800             CMP      R0,#+0
   \       0x46   0xD002             BEQ      ??HAL_TIM_OnePulse_ConfigChannel_3
   \       0x48   0x2804             CMP      R0,#+4
   \       0x4A   0xD005             BEQ      ??HAL_TIM_OnePulse_ConfigChannel_4
   \       0x4C   0xE009             B        ??HAL_TIM_OnePulse_ConfigChannel_5
   3789              {
   3790                case TIM_CHANNEL_1:
   3791                {
   3792                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3793          
   3794                  TIM_OC1_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_3: (+1)
   \       0x4E   0x4669             MOV      R1,SP
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x....'....        BL       TIM_OC1_SetConfig
   3795                  break;
   \       0x56   0xE004             B        ??HAL_TIM_OnePulse_ConfigChannel_6
   3796                }
   3797                case TIM_CHANNEL_2:
   3798                {
   3799                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3800          
   3801                  TIM_OC2_SetConfig(htim->Instance, &temp1);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_4: (+1)
   \       0x58   0x4669             MOV      R1,SP
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x....'....        BL       TIM_OC2_SetConfig
   3802                  break;
   \       0x60   0xE7FF             B        ??HAL_TIM_OnePulse_ConfigChannel_6
   3803                }
   3804                default:
   3805                  break;
   3806              }
   3807          
   3808              switch (InputChannel)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_5: (+1)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_6: (+1)
   \       0x62   0x0038             MOVS     R0,R7
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0xD002             BEQ      ??HAL_TIM_OnePulse_ConfigChannel_7
   \       0x68   0x2804             CMP      R0,#+4
   \       0x6A   0xD025             BEQ      ??HAL_TIM_OnePulse_ConfigChannel_8
   \       0x6C   0xE049             B        ??HAL_TIM_OnePulse_ConfigChannel_9
   3809              {
   3810                case TIM_CHANNEL_1:
   3811                {
   3812                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3813          
   3814                  TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3815                                    sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_7: (+1)
   \       0x6E   0x6A2B             LDR      R3,[R5, #+32]
   \       0x70   0x69EA             LDR      R2,[R5, #+28]
   \       0x72   0x69A9             LDR      R1,[R5, #+24]
   \       0x74   0x6820             LDR      R0,[R4, #+0]
   \       0x76   0x....'....        BL       TIM_TI1_SetConfig
   3816          
   3817                  /* Reset the IC1PSC Bits */
   3818                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x6980             LDR      R0,[R0, #+24]
   \       0x7E   0x210C             MOVS     R1,#+12
   \       0x80   0x4388             BICS     R0,R0,R1
   \       0x82   0x6821             LDR      R1,[R4, #+0]
   \       0x84   0x6188             STR      R0,[R1, #+24]
   3819          
   3820                  /* Select the Trigger source */
   3821                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6880             LDR      R0,[R0, #+8]
   \       0x8A   0x....             LDR      R1,??DataTable44  ;; 0xffcfff8f
   \       0x8C   0x4001             ANDS     R1,R1,R0
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x6081             STR      R1,[R0, #+8]
   3822                  htim->Instance->SMCR |= TIM_TS_TI1FP1;
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6880             LDR      R0,[R0, #+8]
   \       0x96   0x2150             MOVS     R1,#+80
   \       0x98   0x4301             ORRS     R1,R1,R0
   \       0x9A   0x6820             LDR      R0,[R4, #+0]
   \       0x9C   0x6081             STR      R1,[R0, #+8]
   3823          
   3824                  /* Select the Slave Mode */
   3825                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \       0x9E   0x6820             LDR      R0,[R4, #+0]
   \       0xA0   0x6880             LDR      R0,[R0, #+8]
   \       0xA2   0x....             LDR      R1,??DataTable44_1  ;; 0xfffefff8
   \       0xA4   0x4001             ANDS     R1,R1,R0
   \       0xA6   0x6820             LDR      R0,[R4, #+0]
   \       0xA8   0x6081             STR      R1,[R0, #+8]
   3826                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x6880             LDR      R0,[R0, #+8]
   \       0xAE   0x2106             MOVS     R1,#+6
   \       0xB0   0x4301             ORRS     R1,R1,R0
   \       0xB2   0x6820             LDR      R0,[R4, #+0]
   \       0xB4   0x6081             STR      R1,[R0, #+8]
   3827                  break;
   \       0xB6   0xE024             B        ??HAL_TIM_OnePulse_ConfigChannel_10
   3828                }
   3829                case TIM_CHANNEL_2:
   3830                {
   3831                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3832          
   3833                  TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3834                                    sConfig->ICSelection, sConfig->ICFilter);
   \                     ??HAL_TIM_OnePulse_ConfigChannel_8: (+1)
   \       0xB8   0x6A2B             LDR      R3,[R5, #+32]
   \       0xBA   0x69EA             LDR      R2,[R5, #+28]
   \       0xBC   0x69A9             LDR      R1,[R5, #+24]
   \       0xBE   0x6820             LDR      R0,[R4, #+0]
   \       0xC0   0x....'....        BL       TIM_TI2_SetConfig
   3835          
   3836                  /* Reset the IC2PSC Bits */
   3837                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   \       0xC4   0x6820             LDR      R0,[R4, #+0]
   \       0xC6   0x6980             LDR      R0,[R0, #+24]
   \       0xC8   0x....             LDR      R1,??DataTable43  ;; 0xfffff3ff
   \       0xCA   0x4001             ANDS     R1,R1,R0
   \       0xCC   0x6820             LDR      R0,[R4, #+0]
   \       0xCE   0x6181             STR      R1,[R0, #+24]
   3838          
   3839                  /* Select the Trigger source */
   3840                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \       0xD0   0x6820             LDR      R0,[R4, #+0]
   \       0xD2   0x6880             LDR      R0,[R0, #+8]
   \       0xD4   0x....             LDR      R1,??DataTable44  ;; 0xffcfff8f
   \       0xD6   0x4001             ANDS     R1,R1,R0
   \       0xD8   0x6820             LDR      R0,[R4, #+0]
   \       0xDA   0x6081             STR      R1,[R0, #+8]
   3841                  htim->Instance->SMCR |= TIM_TS_TI2FP2;
   \       0xDC   0x6820             LDR      R0,[R4, #+0]
   \       0xDE   0x6880             LDR      R0,[R0, #+8]
   \       0xE0   0x2160             MOVS     R1,#+96
   \       0xE2   0x4301             ORRS     R1,R1,R0
   \       0xE4   0x6820             LDR      R0,[R4, #+0]
   \       0xE6   0x6081             STR      R1,[R0, #+8]
   3842          
   3843                  /* Select the Slave Mode */
   3844                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \       0xE8   0x6820             LDR      R0,[R4, #+0]
   \       0xEA   0x6880             LDR      R0,[R0, #+8]
   \       0xEC   0x....             LDR      R1,??DataTable44_1  ;; 0xfffefff8
   \       0xEE   0x4001             ANDS     R1,R1,R0
   \       0xF0   0x6820             LDR      R0,[R4, #+0]
   \       0xF2   0x6081             STR      R1,[R0, #+8]
   3845                  htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   \       0xF4   0x6820             LDR      R0,[R4, #+0]
   \       0xF6   0x6880             LDR      R0,[R0, #+8]
   \       0xF8   0x2106             MOVS     R1,#+6
   \       0xFA   0x4301             ORRS     R1,R1,R0
   \       0xFC   0x6820             LDR      R0,[R4, #+0]
   \       0xFE   0x6081             STR      R1,[R0, #+8]
   3846                  break;
   \      0x100   0xE7FF             B        ??HAL_TIM_OnePulse_ConfigChannel_10
   3847                }
   3848          
   3849                default:
   3850                  break;
   3851              }
   3852          
   3853              htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_9: (+1)
   \                     ??HAL_TIM_OnePulse_ConfigChannel_10: (+1)
   \      0x102   0x203D             MOVS     R0,#+61
   \      0x104   0x5426             STRB     R6,[R4, R0]
   3854          
   3855              __HAL_UNLOCK(htim);
   \      0x106   0x2000             MOVS     R0,#+0
   \      0x108   0x213C             MOVS     R1,#+60
   \      0x10A   0x5460             STRB     R0,[R4, R1]
   3856          
   3857              return HAL_OK;
   \      0x10C   0x2000             MOVS     R0,#+0
   \      0x10E   0xE000             B        ??HAL_TIM_OnePulse_ConfigChannel_2
   3858            }
   3859            else
   3860            {
   3861              return HAL_ERROR;
   \                     ??HAL_TIM_OnePulse_ConfigChannel_0: (+1)
   \      0x110   0x2001             MOVS     R0,#+1
   \                     ??HAL_TIM_OnePulse_ConfigChannel_2: (+1)
   \      0x112   0xB009             ADD      SP,SP,#+36
   \      0x114   0xBDF0             POP      {R4-R7,PC}       ;; return
   3862            }
   3863          }
   3864          
   3865          /**
   3866            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral
   3867            * @param  htim TIM handle
   3868            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data write
   3869            *         This parameter can be one of the following values:
   3870            *            @arg TIM_DMABASE_CR1
   3871            *            @arg TIM_DMABASE_CR2
   3872            *            @arg TIM_DMABASE_SMCR
   3873            *            @arg TIM_DMABASE_DIER
   3874            *            @arg TIM_DMABASE_SR
   3875            *            @arg TIM_DMABASE_EGR
   3876            *            @arg TIM_DMABASE_CCMR1
   3877            *            @arg TIM_DMABASE_CCMR2
   3878            *            @arg TIM_DMABASE_CCER
   3879            *            @arg TIM_DMABASE_CNT
   3880            *            @arg TIM_DMABASE_PSC
   3881            *            @arg TIM_DMABASE_ARR
   3882            *            @arg TIM_DMABASE_RCR
   3883            *            @arg TIM_DMABASE_CCR1
   3884            *            @arg TIM_DMABASE_CCR2
   3885            *            @arg TIM_DMABASE_CCR3
   3886            *            @arg TIM_DMABASE_CCR4
   3887            *            @arg TIM_DMABASE_BDTR
   3888            *            @arg TIM_DMABASE_OR1
   3889            *            @arg TIM_DMABASE_CCMR3 
   3890            *            @arg TIM_DMABASE_CCR5 
   3891            *            @arg TIM_DMABASE_CCR6 
   3892            *            @arg TIM_DMABASE_AF1  
   3893            *            @arg TIM_DMABASE_AF2  
   3894            *            @arg TIM_DMABASE_TISEL
   3895            * @param  BurstRequestSrc TIM DMA Request sources
   3896            *         This parameter can be one of the following values:
   3897            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3898            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3899            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3900            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3901            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3902            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3903            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3904            * @param  BurstBuffer The Buffer address.
   3905            * @param  BurstLength DMA Burst length. This parameter can be one value
   3906            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3907            * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
   3908            * @retval HAL status
   3909            */

   \                                 In section .text, align 2, keep-with-next
   3910          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3911                                                        uint32_t *BurstBuffer, uint32_t  BurstLength)
   3912          {
   \                     HAL_TIM_DMABurst_WriteStart: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0017             MOVS     R7,R2
   \        0x6   0x001E             MOVS     R6,R3
   \        0x8   0x9D06             LDR      R5,[SP, #+24]
   3913            /* Check the parameters */
   3914            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3915            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3916            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3917            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3918          
   3919            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xA   0x203D             MOVS     R0,#+61
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE      ??HAL_TIM_DMABurst_WriteStart_0
   3920            {
   3921              return HAL_BUSY;
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE0D9             B        ??HAL_TIM_DMABurst_WriteStart_1
   3922            }
   3923            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_DMABurst_WriteStart_0: (+1)
   \       0x16   0x203D             MOVS     R0,#+61
   \       0x18   0x5C20             LDRB     R0,[R4, R0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD108             BNE      ??HAL_TIM_DMABurst_WriteStart_2
   3924            {
   3925              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD103             BNE      ??HAL_TIM_DMABurst_WriteStart_3
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD001             BEQ      ??HAL_TIM_DMABurst_WriteStart_3
   3926              {
   3927                return HAL_ERROR;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xE0CF             B        ??HAL_TIM_DMABurst_WriteStart_1
   3928              }
   3929              else
   3930              {
   3931                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_WriteStart_3: (+1)
   \       0x2A   0x2002             MOVS     R0,#+2
   \       0x2C   0x213D             MOVS     R1,#+61
   \       0x2E   0x5460             STRB     R0,[R4, R1]
   3932              }
   3933            }
   3934            else
   3935            {
   3936              /* nothing to do */
   3937            }
   3938            switch (BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_WriteStart_2: (+1)
   \       0x30   0x0038             MOVS     R0,R7
   \       0x32   0x2180             MOVS     R1,#+128
   \       0x34   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD019             BEQ      ??HAL_TIM_DMABurst_WriteStart_4
   \       0x3A   0x2180             MOVS     R1,#+128
   \       0x3C   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD02C             BEQ      ??HAL_TIM_DMABurst_WriteStart_5
   \       0x42   0x2180             MOVS     R1,#+128
   \       0x44   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xD03F             BEQ      ??HAL_TIM_DMABurst_WriteStart_6
   \       0x4A   0x2180             MOVS     R1,#+128
   \       0x4C   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x4E   0x4288             CMP      R0,R1
   \       0x50   0xD052             BEQ      ??HAL_TIM_DMABurst_WriteStart_7
   \       0x52   0x2180             MOVS     R1,#+128
   \       0x54   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \       0x56   0x4288             CMP      R0,R1
   \       0x58   0xD065             BEQ      ??HAL_TIM_DMABurst_WriteStart_8
   \       0x5A   0x2180             MOVS     R1,#+128
   \       0x5C   0x0189             LSLS     R1,R1,#+6        ;; #+8192
   \       0x5E   0x4288             CMP      R0,R1
   \       0x60   0xD078             BEQ      ??HAL_TIM_DMABurst_WriteStart_9
   \       0x62   0x2180             MOVS     R1,#+128
   \       0x64   0x01C9             LSLS     R1,R1,#+7        ;; #+16384
   \       0x66   0x4288             CMP      R0,R1
   \       0x68   0xD100             BNE      .+4
   \       0x6A   0xE08A             B        ??HAL_TIM_DMABurst_WriteStart_10
   \       0x6C   0xE0A0             B        ??HAL_TIM_DMABurst_WriteStart_11
   3939            {
   3940              case TIM_DMA_UPDATE:
   3941              {
   3942                /* Set the DMA Period elapsed callbacks */
   3943                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_4: (+1)
   \       0x6E   0x....             LDR      R0,??DataTable44_2
   \       0x70   0x6A21             LDR      R1,[R4, #+32]
   \       0x72   0x62C8             STR      R0,[R1, #+44]
   3944                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   \       0x74   0x....             LDR      R0,??DataTable44_3
   \       0x76   0x6A21             LDR      R1,[R4, #+32]
   \       0x78   0x6308             STR      R0,[R1, #+48]
   3945          
   3946                /* Set the DMA error callback */
   3947                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \       0x7A   0x....             LDR      R0,??DataTable44_4
   \       0x7C   0x6A21             LDR      R1,[R4, #+32]
   \       0x7E   0x6348             STR      R0,[R1, #+52]
   3948          
   3949                /* Enable the DMA channel */
   3950                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0x80   0x0A2B             LSRS     R3,R5,#+8
   \       0x82   0x1C5B             ADDS     R3,R3,#+1
   \       0x84   0x6820             LDR      R0,[R4, #+0]
   \       0x86   0x0002             MOVS     R2,R0
   \       0x88   0x324C             ADDS     R2,R2,#+76
   \       0x8A   0x0031             MOVS     R1,R6
   \       0x8C   0x6A20             LDR      R0,[R4, #+32]
   \       0x8E   0x....'....        BL       HAL_DMA_Start_IT
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD001             BEQ      ??HAL_TIM_DMABurst_WriteStart_12
   3951                {
   3952                  return HAL_ERROR;
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xE097             B        ??HAL_TIM_DMABurst_WriteStart_1
   3953                }
   3954                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_12: (+1)
   \       0x9A   0xE089             B        ??HAL_TIM_DMABurst_WriteStart_13
   3955              }
   3956              case TIM_DMA_CC1:
   3957              {
   3958                /* Set the DMA compare callbacks */
   3959                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_5: (+1)
   \       0x9C   0x....             LDR      R0,??DataTable44_5
   \       0x9E   0x6A61             LDR      R1,[R4, #+36]
   \       0xA0   0x62C8             STR      R0,[R1, #+44]
   3960                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xA2   0x....             LDR      R0,??DataTable44_6
   \       0xA4   0x6A61             LDR      R1,[R4, #+36]
   \       0xA6   0x6308             STR      R0,[R1, #+48]
   3961          
   3962                /* Set the DMA error callback */
   3963                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0xA8   0x....             LDR      R0,??DataTable44_4
   \       0xAA   0x6A61             LDR      R1,[R4, #+36]
   \       0xAC   0x6348             STR      R0,[R1, #+52]
   3964          
   3965                /* Enable the DMA channel */
   3966                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer,
   3967                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0xAE   0x0A2B             LSRS     R3,R5,#+8
   \       0xB0   0x1C5B             ADDS     R3,R3,#+1
   \       0xB2   0x6820             LDR      R0,[R4, #+0]
   \       0xB4   0x0002             MOVS     R2,R0
   \       0xB6   0x324C             ADDS     R2,R2,#+76
   \       0xB8   0x0031             MOVS     R1,R6
   \       0xBA   0x6A60             LDR      R0,[R4, #+36]
   \       0xBC   0x....'....        BL       HAL_DMA_Start_IT
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD001             BEQ      ??HAL_TIM_DMABurst_WriteStart_14
   3968                {
   3969                  return HAL_ERROR;
   \       0xC4   0x2001             MOVS     R0,#+1
   \       0xC6   0xE080             B        ??HAL_TIM_DMABurst_WriteStart_1
   3970                }
   3971                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_14: (+1)
   \       0xC8   0xE072             B        ??HAL_TIM_DMABurst_WriteStart_13
   3972              }
   3973              case TIM_DMA_CC2:
   3974              {
   3975                /* Set the DMA compare callbacks */
   3976                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_6: (+1)
   \       0xCA   0x....             LDR      R0,??DataTable44_5
   \       0xCC   0x6AA1             LDR      R1,[R4, #+40]
   \       0xCE   0x62C8             STR      R0,[R1, #+44]
   3977                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xD0   0x....             LDR      R0,??DataTable44_6
   \       0xD2   0x6AA1             LDR      R1,[R4, #+40]
   \       0xD4   0x6308             STR      R0,[R1, #+48]
   3978          
   3979                /* Set the DMA error callback */
   3980                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0xD6   0x....             LDR      R0,??DataTable44_4
   \       0xD8   0x6AA1             LDR      R1,[R4, #+40]
   \       0xDA   0x6348             STR      R0,[R1, #+52]
   3981          
   3982                /* Enable the DMA channel */
   3983                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer,
   3984                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0xDC   0x0A2B             LSRS     R3,R5,#+8
   \       0xDE   0x1C5B             ADDS     R3,R3,#+1
   \       0xE0   0x6820             LDR      R0,[R4, #+0]
   \       0xE2   0x0002             MOVS     R2,R0
   \       0xE4   0x324C             ADDS     R2,R2,#+76
   \       0xE6   0x0031             MOVS     R1,R6
   \       0xE8   0x6AA0             LDR      R0,[R4, #+40]
   \       0xEA   0x....'....        BL       HAL_DMA_Start_IT
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD001             BEQ      ??HAL_TIM_DMABurst_WriteStart_15
   3985                {
   3986                  return HAL_ERROR;
   \       0xF2   0x2001             MOVS     R0,#+1
   \       0xF4   0xE069             B        ??HAL_TIM_DMABurst_WriteStart_1
   3987                }
   3988                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_15: (+1)
   \       0xF6   0xE05B             B        ??HAL_TIM_DMABurst_WriteStart_13
   3989              }
   3990              case TIM_DMA_CC3:
   3991              {
   3992                /* Set the DMA compare callbacks */
   3993                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_7: (+1)
   \       0xF8   0x....             LDR      R0,??DataTable44_5
   \       0xFA   0x6AE1             LDR      R1,[R4, #+44]
   \       0xFC   0x62C8             STR      R0,[R1, #+44]
   3994                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xFE   0x....             LDR      R0,??DataTable44_6
   \      0x100   0x6AE1             LDR      R1,[R4, #+44]
   \      0x102   0x6308             STR      R0,[R1, #+48]
   3995          
   3996                /* Set the DMA error callback */
   3997                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \      0x104   0x....             LDR      R0,??DataTable44_4
   \      0x106   0x6AE1             LDR      R1,[R4, #+44]
   \      0x108   0x6348             STR      R0,[R1, #+52]
   3998          
   3999                /* Enable the DMA channel */
   4000                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer,
   4001                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x10A   0x0A2B             LSRS     R3,R5,#+8
   \      0x10C   0x1C5B             ADDS     R3,R3,#+1
   \      0x10E   0x6820             LDR      R0,[R4, #+0]
   \      0x110   0x0002             MOVS     R2,R0
   \      0x112   0x324C             ADDS     R2,R2,#+76
   \      0x114   0x0031             MOVS     R1,R6
   \      0x116   0x6AE0             LDR      R0,[R4, #+44]
   \      0x118   0x....'....        BL       HAL_DMA_Start_IT
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD001             BEQ      ??HAL_TIM_DMABurst_WriteStart_16
   4002                {
   4003                  return HAL_ERROR;
   \      0x120   0x2001             MOVS     R0,#+1
   \      0x122   0xE052             B        ??HAL_TIM_DMABurst_WriteStart_1
   4004                }
   4005                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_16: (+1)
   \      0x124   0xE044             B        ??HAL_TIM_DMABurst_WriteStart_13
   4006              }
   4007              case TIM_DMA_CC4:
   4008              {
   4009                /* Set the DMA compare callbacks */
   4010                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_8: (+1)
   \      0x126   0x....             LDR      R0,??DataTable44_5
   \      0x128   0x6B21             LDR      R1,[R4, #+48]
   \      0x12A   0x62C8             STR      R0,[R1, #+44]
   4011                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \      0x12C   0x....             LDR      R0,??DataTable44_6
   \      0x12E   0x6B21             LDR      R1,[R4, #+48]
   \      0x130   0x6308             STR      R0,[R1, #+48]
   4012          
   4013                /* Set the DMA error callback */
   4014                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \      0x132   0x....             LDR      R0,??DataTable44_4
   \      0x134   0x6B21             LDR      R1,[R4, #+48]
   \      0x136   0x6348             STR      R0,[R1, #+52]
   4015          
   4016                /* Enable the DMA channel */
   4017                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer,
   4018                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x138   0x0A2B             LSRS     R3,R5,#+8
   \      0x13A   0x1C5B             ADDS     R3,R3,#+1
   \      0x13C   0x6820             LDR      R0,[R4, #+0]
   \      0x13E   0x0002             MOVS     R2,R0
   \      0x140   0x324C             ADDS     R2,R2,#+76
   \      0x142   0x0031             MOVS     R1,R6
   \      0x144   0x6B20             LDR      R0,[R4, #+48]
   \      0x146   0x....'....        BL       HAL_DMA_Start_IT
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xD001             BEQ      ??HAL_TIM_DMABurst_WriteStart_17
   4019                {
   4020                  return HAL_ERROR;
   \      0x14E   0x2001             MOVS     R0,#+1
   \      0x150   0xE03B             B        ??HAL_TIM_DMABurst_WriteStart_1
   4021                }
   4022                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_17: (+1)
   \      0x152   0xE02D             B        ??HAL_TIM_DMABurst_WriteStart_13
   4023              }
   4024              case TIM_DMA_COM:
   4025              {
   4026                /* Set the DMA commutation callbacks */
   4027                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_9: (+1)
   \      0x154   0x....             LDR      R0,??DataTable44_7
   \      0x156   0x6B61             LDR      R1,[R4, #+52]
   \      0x158   0x62C8             STR      R0,[R1, #+44]
   4028                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
   \      0x15A   0x....             LDR      R0,??DataTable44_8
   \      0x15C   0x6B61             LDR      R1,[R4, #+52]
   \      0x15E   0x6308             STR      R0,[R1, #+48]
   4029          
   4030                /* Set the DMA error callback */
   4031                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   \      0x160   0x....             LDR      R0,??DataTable44_4
   \      0x162   0x6B61             LDR      R1,[R4, #+52]
   \      0x164   0x6348             STR      R0,[R1, #+52]
   4032          
   4033                /* Enable the DMA channel */
   4034                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer,
   4035                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x166   0x0A2B             LSRS     R3,R5,#+8
   \      0x168   0x1C5B             ADDS     R3,R3,#+1
   \      0x16A   0x6820             LDR      R0,[R4, #+0]
   \      0x16C   0x0002             MOVS     R2,R0
   \      0x16E   0x324C             ADDS     R2,R2,#+76
   \      0x170   0x0031             MOVS     R1,R6
   \      0x172   0x6B60             LDR      R0,[R4, #+52]
   \      0x174   0x....'....        BL       HAL_DMA_Start_IT
   \      0x178   0x2800             CMP      R0,#+0
   \      0x17A   0xD001             BEQ      ??HAL_TIM_DMABurst_WriteStart_18
   4036                {
   4037                  return HAL_ERROR;
   \      0x17C   0x2001             MOVS     R0,#+1
   \      0x17E   0xE024             B        ??HAL_TIM_DMABurst_WriteStart_1
   4038                }
   4039                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_18: (+1)
   \      0x180   0xE016             B        ??HAL_TIM_DMABurst_WriteStart_13
   4040              }
   4041              case TIM_DMA_TRIGGER:
   4042              {
   4043                /* Set the DMA trigger callbacks */
   4044                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_WriteStart_10: (+1)
   \      0x182   0x....             LDR      R0,??DataTable44_9
   \      0x184   0x6BA1             LDR      R1,[R4, #+56]
   \      0x186   0x62C8             STR      R0,[R1, #+44]
   4045                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   \      0x188   0x....             LDR      R0,??DataTable45
   \      0x18A   0x6BA1             LDR      R1,[R4, #+56]
   \      0x18C   0x6308             STR      R0,[R1, #+48]
   4046          
   4047                /* Set the DMA error callback */
   4048                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   \      0x18E   0x....             LDR      R0,??DataTable44_4
   \      0x190   0x6BA1             LDR      R1,[R4, #+56]
   \      0x192   0x6348             STR      R0,[R1, #+52]
   4049          
   4050                /* Enable the DMA channel */
   4051                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer,
   4052                                     (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x194   0x0A2B             LSRS     R3,R5,#+8
   \      0x196   0x1C5B             ADDS     R3,R3,#+1
   \      0x198   0x6820             LDR      R0,[R4, #+0]
   \      0x19A   0x0002             MOVS     R2,R0
   \      0x19C   0x324C             ADDS     R2,R2,#+76
   \      0x19E   0x0031             MOVS     R1,R6
   \      0x1A0   0x6BA0             LDR      R0,[R4, #+56]
   \      0x1A2   0x....'....        BL       HAL_DMA_Start_IT
   \      0x1A6   0x2800             CMP      R0,#+0
   \      0x1A8   0xD001             BEQ      ??HAL_TIM_DMABurst_WriteStart_19
   4053                {
   4054                  return HAL_ERROR;
   \      0x1AA   0x2001             MOVS     R0,#+1
   \      0x1AC   0xE00D             B        ??HAL_TIM_DMABurst_WriteStart_1
   4055                }
   4056                break;
   \                     ??HAL_TIM_DMABurst_WriteStart_19: (+1)
   \      0x1AE   0xE7FF             B        ??HAL_TIM_DMABurst_WriteStart_13
   4057              }
   4058              default:
   4059                break;
   4060            }
   4061            /* configure the DMA Burst Mode */
   4062            htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   \                     ??HAL_TIM_DMABurst_WriteStart_11: (+1)
   \                     ??HAL_TIM_DMABurst_WriteStart_13: (+1)
   \      0x1B0   0x9800             LDR      R0,[SP, #+0]
   \      0x1B2   0x4328             ORRS     R0,R0,R5
   \      0x1B4   0x6821             LDR      R1,[R4, #+0]
   \      0x1B6   0x6488             STR      R0,[R1, #+72]
   4063          
   4064            /* Enable the TIM DMA Request */
   4065            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \      0x1B8   0x6820             LDR      R0,[R4, #+0]
   \      0x1BA   0x68C0             LDR      R0,[R0, #+12]
   \      0x1BC   0x4338             ORRS     R0,R0,R7
   \      0x1BE   0x6821             LDR      R1,[R4, #+0]
   \      0x1C0   0x60C8             STR      R0,[R1, #+12]
   4066          
   4067            htim->State = HAL_TIM_STATE_READY;
   \      0x1C2   0x2001             MOVS     R0,#+1
   \      0x1C4   0x213D             MOVS     R1,#+61
   \      0x1C6   0x5460             STRB     R0,[R4, R1]
   4068          
   4069            /* Return function status */
   4070            return HAL_OK;
   \      0x1C8   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_WriteStart_1: (+1)
   \      0x1CA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4071          }
   4072          
   4073          /**
   4074            * @brief  Stops the TIM DMA Burst mode
   4075            * @param  htim TIM handle
   4076            * @param  BurstRequestSrc TIM DMA Request sources to disable
   4077            * @retval HAL status
   4078            */

   \                                 In section .text, align 2, keep-with-next
   4079          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   4080          {
   \                     HAL_TIM_DMABurst_WriteStop: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   4081            HAL_StatusTypeDef status = HAL_OK;
   \        0x6   0x2600             MOVS     R6,#+0
   4082            /* Check the parameters */
   4083            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4084          
   4085            /* Abort the DMA transfer (at least disable the DMA channel) */
   4086            switch (BurstRequestSrc)
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x2180             MOVS     R1,#+128
   \        0xC   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xD018             BEQ      ??HAL_TIM_DMABurst_WriteStop_0
   \       0x12   0x2180             MOVS     R1,#+128
   \       0x14   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD019             BEQ      ??HAL_TIM_DMABurst_WriteStop_1
   \       0x1A   0x2180             MOVS     R1,#+128
   \       0x1C   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD01A             BEQ      ??HAL_TIM_DMABurst_WriteStop_2
   \       0x22   0x2180             MOVS     R1,#+128
   \       0x24   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD01B             BEQ      ??HAL_TIM_DMABurst_WriteStop_3
   \       0x2A   0x2180             MOVS     R1,#+128
   \       0x2C   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xD01C             BEQ      ??HAL_TIM_DMABurst_WriteStop_4
   \       0x32   0x2180             MOVS     R1,#+128
   \       0x34   0x0189             LSLS     R1,R1,#+6        ;; #+8192
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD01D             BEQ      ??HAL_TIM_DMABurst_WriteStop_5
   \       0x3A   0x2180             MOVS     R1,#+128
   \       0x3C   0x01C9             LSLS     R1,R1,#+7        ;; #+16384
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD01E             BEQ      ??HAL_TIM_DMABurst_WriteStop_6
   \       0x42   0xE022             B        ??HAL_TIM_DMABurst_WriteStop_7
   4087            {
   4088              case TIM_DMA_UPDATE:
   4089              {
   4090                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_WriteStop_0: (+1)
   \       0x44   0x6A28             LDR      R0,[R5, #+32]
   \       0x46   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x4A   0x0006             MOVS     R6,R0
   4091                break;
   \       0x4C   0xE01D             B        ??HAL_TIM_DMABurst_WriteStop_8
   4092              }
   4093              case TIM_DMA_CC1:
   4094              {
   4095                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_WriteStop_1: (+1)
   \       0x4E   0x6A68             LDR      R0,[R5, #+36]
   \       0x50   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x54   0x0006             MOVS     R6,R0
   4096                break;
   \       0x56   0xE018             B        ??HAL_TIM_DMABurst_WriteStop_8
   4097              }
   4098              case TIM_DMA_CC2:
   4099              {
   4100                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_WriteStop_2: (+1)
   \       0x58   0x6AA8             LDR      R0,[R5, #+40]
   \       0x5A   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x5E   0x0006             MOVS     R6,R0
   4101                break;
   \       0x60   0xE013             B        ??HAL_TIM_DMABurst_WriteStop_8
   4102              }
   4103              case TIM_DMA_CC3:
   4104              {
   4105                status =  HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_WriteStop_3: (+1)
   \       0x62   0x6AE8             LDR      R0,[R5, #+44]
   \       0x64   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x68   0x0006             MOVS     R6,R0
   4106                break;
   \       0x6A   0xE00E             B        ??HAL_TIM_DMABurst_WriteStop_8
   4107              }
   4108              case TIM_DMA_CC4:
   4109              {
   4110                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_WriteStop_4: (+1)
   \       0x6C   0x6B28             LDR      R0,[R5, #+48]
   \       0x6E   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x72   0x0006             MOVS     R6,R0
   4111                break;
   \       0x74   0xE009             B        ??HAL_TIM_DMABurst_WriteStop_8
   4112              }
   4113              case TIM_DMA_COM:
   4114              {
   4115                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_WriteStop_5: (+1)
   \       0x76   0x6B68             LDR      R0,[R5, #+52]
   \       0x78   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x7C   0x0006             MOVS     R6,R0
   4116                break;
   \       0x7E   0xE004             B        ??HAL_TIM_DMABurst_WriteStop_8
   4117              }
   4118              case TIM_DMA_TRIGGER:
   4119              {
   4120                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_WriteStop_6: (+1)
   \       0x80   0x6BA8             LDR      R0,[R5, #+56]
   \       0x82   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x86   0x0006             MOVS     R6,R0
   4121                break;
   \       0x88   0xE7FF             B        ??HAL_TIM_DMABurst_WriteStop_8
   4122              }
   4123              default:
   4124                break;
   4125            }
   4126          
   4127            if (HAL_OK == status)
   \                     ??HAL_TIM_DMABurst_WriteStop_7: (+1)
   \                     ??HAL_TIM_DMABurst_WriteStop_8: (+1)
   \       0x8A   0x0030             MOVS     R0,R6
   \       0x8C   0xB2C0             UXTB     R0,R0
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD104             BNE      ??HAL_TIM_DMABurst_WriteStop_9
   4128            {
   4129              /* Disable the TIM Update DMA request */
   4130              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \       0x92   0x6828             LDR      R0,[R5, #+0]
   \       0x94   0x68C0             LDR      R0,[R0, #+12]
   \       0x96   0x43A0             BICS     R0,R0,R4
   \       0x98   0x6829             LDR      R1,[R5, #+0]
   \       0x9A   0x60C8             STR      R0,[R1, #+12]
   4131            }
   4132          
   4133            /* Return function status */
   4134            return status;
   \                     ??HAL_TIM_DMABurst_WriteStop_9: (+1)
   \       0x9C   0x0030             MOVS     R0,R6
   \       0x9E   0xB2C0             UXTB     R0,R0
   \       0xA0   0xBD70             POP      {R4-R6,PC}       ;; return
   4135          }
   4136          
   4137          /**
   4138            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory
   4139            * @param  htim TIM handle
   4140            * @param  BurstBaseAddress TIM Base address from where the DMA  will start the Data read
   4141            *         This parameter can be one of the following values:
   4142            *            @arg TIM_DMABASE_CR1
   4143            *            @arg TIM_DMABASE_CR2
   4144            *            @arg TIM_DMABASE_SMCR
   4145            *            @arg TIM_DMABASE_DIER
   4146            *            @arg TIM_DMABASE_SR
   4147            *            @arg TIM_DMABASE_EGR
   4148            *            @arg TIM_DMABASE_CCMR1
   4149            *            @arg TIM_DMABASE_CCMR2
   4150            *            @arg TIM_DMABASE_CCER
   4151            *            @arg TIM_DMABASE_CNT
   4152            *            @arg TIM_DMABASE_PSC
   4153            *            @arg TIM_DMABASE_ARR
   4154            *            @arg TIM_DMABASE_RCR
   4155            *            @arg TIM_DMABASE_CCR1
   4156            *            @arg TIM_DMABASE_CCR2
   4157            *            @arg TIM_DMABASE_CCR3
   4158            *            @arg TIM_DMABASE_CCR4
   4159            *            @arg TIM_DMABASE_BDTR
   4160            *            @arg TIM_DMABASE_OR1
   4161            *            @arg TIM_DMABASE_CCMR3 
   4162            *            @arg TIM_DMABASE_CCR5 
   4163            *            @arg TIM_DMABASE_CCR6 
   4164            *            @arg TIM_DMABASE_AF1  
   4165            *            @arg TIM_DMABASE_AF2  
   4166            *            @arg TIM_DMABASE_TISEL
   4167            * @param  BurstRequestSrc TIM DMA Request sources
   4168            *         This parameter can be one of the following values:
   4169            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   4170            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   4171            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   4172            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   4173            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   4174            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   4175            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   4176            * @param  BurstBuffer The Buffer address.
   4177            * @param  BurstLength DMA Burst length. This parameter can be one value
   4178            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   4179            * @note   This function should be used only when BurstLength is equal to DMA data transfer length.
   4180            * @retval HAL status
   4181            */

   \                                 In section .text, align 2, keep-with-next
   4182          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress,
   4183                                                       uint32_t BurstRequestSrc, uint32_t  *BurstBuffer, uint32_t  BurstLength)
   4184          {
   \                     HAL_TIM_DMABurst_ReadStart: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0017             MOVS     R7,R2
   \        0x6   0x001E             MOVS     R6,R3
   \        0x8   0x9D06             LDR      R5,[SP, #+24]
   4185            /* Check the parameters */
   4186            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   4187            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   4188            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4189            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   4190          
   4191            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xA   0x203D             MOVS     R0,#+61
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE      ??HAL_TIM_DMABurst_ReadStart_0
   4192            {
   4193              return HAL_BUSY;
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE0D9             B        ??HAL_TIM_DMABurst_ReadStart_1
   4194            }
   4195            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIM_DMABurst_ReadStart_0: (+1)
   \       0x16   0x203D             MOVS     R0,#+61
   \       0x18   0x5C20             LDRB     R0,[R4, R0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD108             BNE      ??HAL_TIM_DMABurst_ReadStart_2
   4196            {
   4197              if ((BurstBuffer == NULL) && (BurstLength > 0U))
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD103             BNE      ??HAL_TIM_DMABurst_ReadStart_3
   \       0x22   0x2D00             CMP      R5,#+0
   \       0x24   0xD001             BEQ      ??HAL_TIM_DMABurst_ReadStart_3
   4198              {
   4199                return HAL_ERROR;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xE0CF             B        ??HAL_TIM_DMABurst_ReadStart_1
   4200              }
   4201              else
   4202              {
   4203                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIM_DMABurst_ReadStart_3: (+1)
   \       0x2A   0x2002             MOVS     R0,#+2
   \       0x2C   0x213D             MOVS     R1,#+61
   \       0x2E   0x5460             STRB     R0,[R4, R1]
   4204              }
   4205            }
   4206            else
   4207            {
   4208              /* nothing to do */
   4209            }
   4210            switch (BurstRequestSrc)
   \                     ??HAL_TIM_DMABurst_ReadStart_2: (+1)
   \       0x30   0x0038             MOVS     R0,R7
   \       0x32   0x2180             MOVS     R1,#+128
   \       0x34   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD019             BEQ      ??HAL_TIM_DMABurst_ReadStart_4
   \       0x3A   0x2180             MOVS     R1,#+128
   \       0x3C   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD02C             BEQ      ??HAL_TIM_DMABurst_ReadStart_5
   \       0x42   0x2180             MOVS     R1,#+128
   \       0x44   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xD03F             BEQ      ??HAL_TIM_DMABurst_ReadStart_6
   \       0x4A   0x2180             MOVS     R1,#+128
   \       0x4C   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x4E   0x4288             CMP      R0,R1
   \       0x50   0xD052             BEQ      ??HAL_TIM_DMABurst_ReadStart_7
   \       0x52   0x2180             MOVS     R1,#+128
   \       0x54   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \       0x56   0x4288             CMP      R0,R1
   \       0x58   0xD065             BEQ      ??HAL_TIM_DMABurst_ReadStart_8
   \       0x5A   0x2180             MOVS     R1,#+128
   \       0x5C   0x0189             LSLS     R1,R1,#+6        ;; #+8192
   \       0x5E   0x4288             CMP      R0,R1
   \       0x60   0xD078             BEQ      ??HAL_TIM_DMABurst_ReadStart_9
   \       0x62   0x2180             MOVS     R1,#+128
   \       0x64   0x01C9             LSLS     R1,R1,#+7        ;; #+16384
   \       0x66   0x4288             CMP      R0,R1
   \       0x68   0xD100             BNE      .+4
   \       0x6A   0xE08A             B        ??HAL_TIM_DMABurst_ReadStart_10
   \       0x6C   0xE0A0             B        ??HAL_TIM_DMABurst_ReadStart_11
   4211            {
   4212              case TIM_DMA_UPDATE:
   4213              {
   4214                /* Set the DMA Period elapsed callbacks */
   4215                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_4: (+1)
   \       0x6E   0x....             LDR      R0,??DataTable45_1
   \       0x70   0x6A21             LDR      R1,[R4, #+32]
   \       0x72   0x62C8             STR      R0,[R1, #+44]
   4216                htim->hdma[TIM_DMA_ID_UPDATE]->XferHalfCpltCallback = TIM_DMAPeriodElapsedHalfCplt;
   \       0x74   0x....             LDR      R0,??DataTable45_2
   \       0x76   0x6A21             LDR      R1,[R4, #+32]
   \       0x78   0x6308             STR      R0,[R1, #+48]
   4217          
   4218                /* Set the DMA error callback */
   4219                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   \       0x7A   0x....             LDR      R0,??DataTable45_3
   \       0x7C   0x6A21             LDR      R1,[R4, #+32]
   \       0x7E   0x6348             STR      R0,[R1, #+52]
   4220          
   4221                /* Enable the DMA channel */
   4222                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0x80   0x0A2B             LSRS     R3,R5,#+8
   \       0x82   0x1C5B             ADDS     R3,R3,#+1
   \       0x84   0x0032             MOVS     R2,R6
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x0001             MOVS     R1,R0
   \       0x8A   0x314C             ADDS     R1,R1,#+76
   \       0x8C   0x6A20             LDR      R0,[R4, #+32]
   \       0x8E   0x....'....        BL       HAL_DMA_Start_IT
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD001             BEQ      ??HAL_TIM_DMABurst_ReadStart_12
   4223                {
   4224                  return HAL_ERROR;
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0xE097             B        ??HAL_TIM_DMABurst_ReadStart_1
   4225                }
   4226                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_12: (+1)
   \       0x9A   0xE089             B        ??HAL_TIM_DMABurst_ReadStart_13
   4227              }
   4228              case TIM_DMA_CC1:
   4229              {
   4230                /* Set the DMA capture callbacks */
   4231                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_5: (+1)
   \       0x9C   0x....             LDR      R0,??DataTable45_4
   \       0x9E   0x6A61             LDR      R1,[R4, #+36]
   \       0xA0   0x62C8             STR      R0,[R1, #+44]
   4232                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xA2   0x....             LDR      R0,??DataTable45_5
   \       0xA4   0x6A61             LDR      R1,[R4, #+36]
   \       0xA6   0x6308             STR      R0,[R1, #+48]
   4233          
   4234                /* Set the DMA error callback */
   4235                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0xA8   0x....             LDR      R0,??DataTable45_3
   \       0xAA   0x6A61             LDR      R1,[R4, #+36]
   \       0xAC   0x6348             STR      R0,[R1, #+52]
   4236          
   4237                /* Enable the DMA channel */
   4238                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0xAE   0x0A2B             LSRS     R3,R5,#+8
   \       0xB0   0x1C5B             ADDS     R3,R3,#+1
   \       0xB2   0x0032             MOVS     R2,R6
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x0001             MOVS     R1,R0
   \       0xB8   0x314C             ADDS     R1,R1,#+76
   \       0xBA   0x6A60             LDR      R0,[R4, #+36]
   \       0xBC   0x....'....        BL       HAL_DMA_Start_IT
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD001             BEQ      ??HAL_TIM_DMABurst_ReadStart_14
   4239                {
   4240                  return HAL_ERROR;
   \       0xC4   0x2001             MOVS     R0,#+1
   \       0xC6   0xE080             B        ??HAL_TIM_DMABurst_ReadStart_1
   4241                }
   4242                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_14: (+1)
   \       0xC8   0xE072             B        ??HAL_TIM_DMABurst_ReadStart_13
   4243              }
   4244              case TIM_DMA_CC2:
   4245              {
   4246                /* Set the DMA capture/compare callbacks */
   4247                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_6: (+1)
   \       0xCA   0x....             LDR      R0,??DataTable45_4
   \       0xCC   0x6AA1             LDR      R1,[R4, #+40]
   \       0xCE   0x62C8             STR      R0,[R1, #+44]
   4248                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xD0   0x....             LDR      R0,??DataTable45_5
   \       0xD2   0x6AA1             LDR      R1,[R4, #+40]
   \       0xD4   0x6308             STR      R0,[R1, #+48]
   4249          
   4250                /* Set the DMA error callback */
   4251                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0xD6   0x....             LDR      R0,??DataTable45_3
   \       0xD8   0x6AA1             LDR      R1,[R4, #+40]
   \       0xDA   0x6348             STR      R0,[R1, #+52]
   4252          
   4253                /* Enable the DMA channel */
   4254                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \       0xDC   0x0A2B             LSRS     R3,R5,#+8
   \       0xDE   0x1C5B             ADDS     R3,R3,#+1
   \       0xE0   0x0032             MOVS     R2,R6
   \       0xE2   0x6820             LDR      R0,[R4, #+0]
   \       0xE4   0x0001             MOVS     R1,R0
   \       0xE6   0x314C             ADDS     R1,R1,#+76
   \       0xE8   0x6AA0             LDR      R0,[R4, #+40]
   \       0xEA   0x....'....        BL       HAL_DMA_Start_IT
   \       0xEE   0x2800             CMP      R0,#+0
   \       0xF0   0xD001             BEQ      ??HAL_TIM_DMABurst_ReadStart_15
   4255                {
   4256                  return HAL_ERROR;
   \       0xF2   0x2001             MOVS     R0,#+1
   \       0xF4   0xE069             B        ??HAL_TIM_DMABurst_ReadStart_1
   4257                }
   4258                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_15: (+1)
   \       0xF6   0xE05B             B        ??HAL_TIM_DMABurst_ReadStart_13
   4259              }
   4260              case TIM_DMA_CC3:
   4261              {
   4262                /* Set the DMA capture callbacks */
   4263                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_7: (+1)
   \       0xF8   0x....             LDR      R0,??DataTable45_4
   \       0xFA   0x6AE1             LDR      R1,[R4, #+44]
   \       0xFC   0x62C8             STR      R0,[R1, #+44]
   4264                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0xFE   0x....             LDR      R0,??DataTable45_5
   \      0x100   0x6AE1             LDR      R1,[R4, #+44]
   \      0x102   0x6308             STR      R0,[R1, #+48]
   4265          
   4266                /* Set the DMA error callback */
   4267                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \      0x104   0x....             LDR      R0,??DataTable45_3
   \      0x106   0x6AE1             LDR      R1,[R4, #+44]
   \      0x108   0x6348             STR      R0,[R1, #+52]
   4268          
   4269                /* Enable the DMA channel */
   4270                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x10A   0x0A2B             LSRS     R3,R5,#+8
   \      0x10C   0x1C5B             ADDS     R3,R3,#+1
   \      0x10E   0x0032             MOVS     R2,R6
   \      0x110   0x6820             LDR      R0,[R4, #+0]
   \      0x112   0x0001             MOVS     R1,R0
   \      0x114   0x314C             ADDS     R1,R1,#+76
   \      0x116   0x6AE0             LDR      R0,[R4, #+44]
   \      0x118   0x....'....        BL       HAL_DMA_Start_IT
   \      0x11C   0x2800             CMP      R0,#+0
   \      0x11E   0xD001             BEQ      ??HAL_TIM_DMABurst_ReadStart_16
   4271                {
   4272                  return HAL_ERROR;
   \      0x120   0x2001             MOVS     R0,#+1
   \      0x122   0xE052             B        ??HAL_TIM_DMABurst_ReadStart_1
   4273                }
   4274                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_16: (+1)
   \      0x124   0xE044             B        ??HAL_TIM_DMABurst_ReadStart_13
   4275              }
   4276              case TIM_DMA_CC4:
   4277              {
   4278                /* Set the DMA capture callbacks */
   4279                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_8: (+1)
   \      0x126   0x....             LDR      R0,??DataTable45_4
   \      0x128   0x6B21             LDR      R1,[R4, #+48]
   \      0x12A   0x62C8             STR      R0,[R1, #+44]
   4280                htim->hdma[TIM_DMA_ID_CC4]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \      0x12C   0x....             LDR      R0,??DataTable45_5
   \      0x12E   0x6B21             LDR      R1,[R4, #+48]
   \      0x130   0x6308             STR      R0,[R1, #+48]
   4281          
   4282                /* Set the DMA error callback */
   4283                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   \      0x132   0x....             LDR      R0,??DataTable45_3
   \      0x134   0x6B21             LDR      R1,[R4, #+48]
   \      0x136   0x6348             STR      R0,[R1, #+52]
   4284          
   4285                /* Enable the DMA channel */
   4286                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x138   0x0A2B             LSRS     R3,R5,#+8
   \      0x13A   0x1C5B             ADDS     R3,R3,#+1
   \      0x13C   0x0032             MOVS     R2,R6
   \      0x13E   0x6820             LDR      R0,[R4, #+0]
   \      0x140   0x0001             MOVS     R1,R0
   \      0x142   0x314C             ADDS     R1,R1,#+76
   \      0x144   0x6B20             LDR      R0,[R4, #+48]
   \      0x146   0x....'....        BL       HAL_DMA_Start_IT
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xD001             BEQ      ??HAL_TIM_DMABurst_ReadStart_17
   4287                {
   4288                  return HAL_ERROR;
   \      0x14E   0x2001             MOVS     R0,#+1
   \      0x150   0xE03B             B        ??HAL_TIM_DMABurst_ReadStart_1
   4289                }
   4290                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_17: (+1)
   \      0x152   0xE02D             B        ??HAL_TIM_DMABurst_ReadStart_13
   4291              }
   4292              case TIM_DMA_COM:
   4293              {
   4294                /* Set the DMA commutation callbacks */
   4295                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_9: (+1)
   \      0x154   0x....             LDR      R0,??DataTable46
   \      0x156   0x6B61             LDR      R1,[R4, #+52]
   \      0x158   0x62C8             STR      R0,[R1, #+44]
   4296                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback =  TIMEx_DMACommutationHalfCplt;
   \      0x15A   0x....             LDR      R0,??DataTable46_1
   \      0x15C   0x6B61             LDR      R1,[R4, #+52]
   \      0x15E   0x6308             STR      R0,[R1, #+48]
   4297          
   4298                /* Set the DMA error callback */
   4299                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   \      0x160   0x....             LDR      R0,??DataTable45_3
   \      0x162   0x6B61             LDR      R1,[R4, #+52]
   \      0x164   0x6348             STR      R0,[R1, #+52]
   4300          
   4301                /* Enable the DMA channel */
   4302                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x166   0x0A2B             LSRS     R3,R5,#+8
   \      0x168   0x1C5B             ADDS     R3,R3,#+1
   \      0x16A   0x0032             MOVS     R2,R6
   \      0x16C   0x6820             LDR      R0,[R4, #+0]
   \      0x16E   0x0001             MOVS     R1,R0
   \      0x170   0x314C             ADDS     R1,R1,#+76
   \      0x172   0x6B60             LDR      R0,[R4, #+52]
   \      0x174   0x....'....        BL       HAL_DMA_Start_IT
   \      0x178   0x2800             CMP      R0,#+0
   \      0x17A   0xD001             BEQ      ??HAL_TIM_DMABurst_ReadStart_18
   4303                {
   4304                  return HAL_ERROR;
   \      0x17C   0x2001             MOVS     R0,#+1
   \      0x17E   0xE024             B        ??HAL_TIM_DMABurst_ReadStart_1
   4305                }
   4306                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_18: (+1)
   \      0x180   0xE016             B        ??HAL_TIM_DMABurst_ReadStart_13
   4307              }
   4308              case TIM_DMA_TRIGGER:
   4309              {
   4310                /* Set the DMA trigger callbacks */
   4311                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   \                     ??HAL_TIM_DMABurst_ReadStart_10: (+1)
   \      0x182   0x....             LDR      R0,??DataTable46_2
   \      0x184   0x6BA1             LDR      R1,[R4, #+56]
   \      0x186   0x62C8             STR      R0,[R1, #+44]
   4312                htim->hdma[TIM_DMA_ID_TRIGGER]->XferHalfCpltCallback = TIM_DMATriggerHalfCplt;
   \      0x188   0x....             LDR      R0,??DataTable45
   \      0x18A   0x6BA1             LDR      R1,[R4, #+56]
   \      0x18C   0x6308             STR      R0,[R1, #+48]
   4313          
   4314                /* Set the DMA error callback */
   4315                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   \      0x18E   0x....             LDR      R0,??DataTable45_3
   \      0x190   0x6BA1             LDR      R1,[R4, #+56]
   \      0x192   0x6348             STR      R0,[R1, #+52]
   4316          
   4317                /* Enable the DMA channel */
   4318                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U) != HAL_OK)
   \      0x194   0x0A2B             LSRS     R3,R5,#+8
   \      0x196   0x1C5B             ADDS     R3,R3,#+1
   \      0x198   0x0032             MOVS     R2,R6
   \      0x19A   0x6820             LDR      R0,[R4, #+0]
   \      0x19C   0x0001             MOVS     R1,R0
   \      0x19E   0x314C             ADDS     R1,R1,#+76
   \      0x1A0   0x6BA0             LDR      R0,[R4, #+56]
   \      0x1A2   0x....'....        BL       HAL_DMA_Start_IT
   \      0x1A6   0x2800             CMP      R0,#+0
   \      0x1A8   0xD001             BEQ      ??HAL_TIM_DMABurst_ReadStart_19
   4319                {
   4320                  return HAL_ERROR;
   \      0x1AA   0x2001             MOVS     R0,#+1
   \      0x1AC   0xE00D             B        ??HAL_TIM_DMABurst_ReadStart_1
   4321                }
   4322                break;
   \                     ??HAL_TIM_DMABurst_ReadStart_19: (+1)
   \      0x1AE   0xE7FF             B        ??HAL_TIM_DMABurst_ReadStart_13
   4323              }
   4324              default:
   4325                break;
   4326            }
   4327          
   4328            /* configure the DMA Burst Mode */
   4329            htim->Instance->DCR = (BurstBaseAddress | BurstLength);
   \                     ??HAL_TIM_DMABurst_ReadStart_11: (+1)
   \                     ??HAL_TIM_DMABurst_ReadStart_13: (+1)
   \      0x1B0   0x9800             LDR      R0,[SP, #+0]
   \      0x1B2   0x4328             ORRS     R0,R0,R5
   \      0x1B4   0x6821             LDR      R1,[R4, #+0]
   \      0x1B6   0x6488             STR      R0,[R1, #+72]
   4330          
   4331            /* Enable the TIM DMA Request */
   4332            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   \      0x1B8   0x6820             LDR      R0,[R4, #+0]
   \      0x1BA   0x68C0             LDR      R0,[R0, #+12]
   \      0x1BC   0x4338             ORRS     R0,R0,R7
   \      0x1BE   0x6821             LDR      R1,[R4, #+0]
   \      0x1C0   0x60C8             STR      R0,[R1, #+12]
   4333          
   4334            htim->State = HAL_TIM_STATE_READY;
   \      0x1C2   0x2001             MOVS     R0,#+1
   \      0x1C4   0x213D             MOVS     R1,#+61
   \      0x1C6   0x5460             STRB     R0,[R4, R1]
   4335          
   4336            /* Return function status */
   4337            return HAL_OK;
   \      0x1C8   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_DMABurst_ReadStart_1: (+1)
   \      0x1CA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4338          }
   4339          
   4340          /**
   4341            * @brief  Stop the DMA burst reading
   4342            * @param  htim TIM handle
   4343            * @param  BurstRequestSrc TIM DMA Request sources to disable.
   4344            * @retval HAL status
   4345            */

   \                                 In section .text, align 2, keep-with-next
   4346          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   4347          {
   \                     HAL_TIM_DMABurst_ReadStop: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   4348            HAL_StatusTypeDef status = HAL_OK;
   \        0x6   0x2600             MOVS     R6,#+0
   4349            /* Check the parameters */
   4350            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   4351          
   4352            /* Abort the DMA transfer (at least disable the DMA channel) */
   4353            switch (BurstRequestSrc)
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0x2180             MOVS     R1,#+128
   \        0xC   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xD018             BEQ      ??HAL_TIM_DMABurst_ReadStop_0
   \       0x12   0x2180             MOVS     R1,#+128
   \       0x14   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x16   0x4288             CMP      R0,R1
   \       0x18   0xD019             BEQ      ??HAL_TIM_DMABurst_ReadStop_1
   \       0x1A   0x2180             MOVS     R1,#+128
   \       0x1C   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \       0x1E   0x4288             CMP      R0,R1
   \       0x20   0xD01A             BEQ      ??HAL_TIM_DMABurst_ReadStop_2
   \       0x22   0x2180             MOVS     R1,#+128
   \       0x24   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD01B             BEQ      ??HAL_TIM_DMABurst_ReadStop_3
   \       0x2A   0x2180             MOVS     R1,#+128
   \       0x2C   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \       0x2E   0x4288             CMP      R0,R1
   \       0x30   0xD01C             BEQ      ??HAL_TIM_DMABurst_ReadStop_4
   \       0x32   0x2180             MOVS     R1,#+128
   \       0x34   0x0189             LSLS     R1,R1,#+6        ;; #+8192
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD01D             BEQ      ??HAL_TIM_DMABurst_ReadStop_5
   \       0x3A   0x2180             MOVS     R1,#+128
   \       0x3C   0x01C9             LSLS     R1,R1,#+7        ;; #+16384
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xD01E             BEQ      ??HAL_TIM_DMABurst_ReadStop_6
   \       0x42   0xE022             B        ??HAL_TIM_DMABurst_ReadStop_7
   4354            {
   4355              case TIM_DMA_UPDATE:
   4356              {
   4357                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_UPDATE]);
   \                     ??HAL_TIM_DMABurst_ReadStop_0: (+1)
   \       0x44   0x6A28             LDR      R0,[R5, #+32]
   \       0x46   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x4A   0x0006             MOVS     R6,R0
   4358                break;
   \       0x4C   0xE01D             B        ??HAL_TIM_DMABurst_ReadStop_8
   4359              }
   4360              case TIM_DMA_CC1:
   4361              {
   4362                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \                     ??HAL_TIM_DMABurst_ReadStop_1: (+1)
   \       0x4E   0x6A68             LDR      R0,[R5, #+36]
   \       0x50   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x54   0x0006             MOVS     R6,R0
   4363                break;
   \       0x56   0xE018             B        ??HAL_TIM_DMABurst_ReadStop_8
   4364              }
   4365              case TIM_DMA_CC2:
   4366              {
   4367                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \                     ??HAL_TIM_DMABurst_ReadStop_2: (+1)
   \       0x58   0x6AA8             LDR      R0,[R5, #+40]
   \       0x5A   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x5E   0x0006             MOVS     R6,R0
   4368                break;
   \       0x60   0xE013             B        ??HAL_TIM_DMABurst_ReadStop_8
   4369              }
   4370              case TIM_DMA_CC3:
   4371              {
   4372                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \                     ??HAL_TIM_DMABurst_ReadStop_3: (+1)
   \       0x62   0x6AE8             LDR      R0,[R5, #+44]
   \       0x64   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x68   0x0006             MOVS     R6,R0
   4373                break;
   \       0x6A   0xE00E             B        ??HAL_TIM_DMABurst_ReadStop_8
   4374              }
   4375              case TIM_DMA_CC4:
   4376              {
   4377                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC4]);
   \                     ??HAL_TIM_DMABurst_ReadStop_4: (+1)
   \       0x6C   0x6B28             LDR      R0,[R5, #+48]
   \       0x6E   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x72   0x0006             MOVS     R6,R0
   4378                break;
   \       0x74   0xE009             B        ??HAL_TIM_DMABurst_ReadStop_8
   4379              }
   4380              case TIM_DMA_COM:
   4381              {
   4382                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   \                     ??HAL_TIM_DMABurst_ReadStop_5: (+1)
   \       0x76   0x6B68             LDR      R0,[R5, #+52]
   \       0x78   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x7C   0x0006             MOVS     R6,R0
   4383                break;
   \       0x7E   0xE004             B        ??HAL_TIM_DMABurst_ReadStop_8
   4384              }
   4385              case TIM_DMA_TRIGGER:
   4386              {
   4387                status = HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_TRIGGER]);
   \                     ??HAL_TIM_DMABurst_ReadStop_6: (+1)
   \       0x80   0x6BA8             LDR      R0,[R5, #+56]
   \       0x82   0x....'....        BL       HAL_DMA_Abort_IT
   \       0x86   0x0006             MOVS     R6,R0
   4388                break;
   \       0x88   0xE7FF             B        ??HAL_TIM_DMABurst_ReadStop_8
   4389              }
   4390              default:
   4391                break;
   4392            }
   4393          
   4394            if (HAL_OK == status)
   \                     ??HAL_TIM_DMABurst_ReadStop_7: (+1)
   \                     ??HAL_TIM_DMABurst_ReadStop_8: (+1)
   \       0x8A   0x0030             MOVS     R0,R6
   \       0x8C   0xB2C0             UXTB     R0,R0
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD104             BNE      ??HAL_TIM_DMABurst_ReadStop_9
   4395            {
   4396              /* Disable the TIM Update DMA request */
   4397              __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   \       0x92   0x6828             LDR      R0,[R5, #+0]
   \       0x94   0x68C0             LDR      R0,[R0, #+12]
   \       0x96   0x43A0             BICS     R0,R0,R4
   \       0x98   0x6829             LDR      R1,[R5, #+0]
   \       0x9A   0x60C8             STR      R0,[R1, #+12]
   4398            }
   4399          
   4400            /* Return function status */
   4401            return status;
   \                     ??HAL_TIM_DMABurst_ReadStop_9: (+1)
   \       0x9C   0x0030             MOVS     R0,R6
   \       0x9E   0xB2C0             UXTB     R0,R0
   \       0xA0   0xBD70             POP      {R4-R6,PC}       ;; return
   4402          }
   4403          
   4404          /**
   4405            * @brief  Generate a software event
   4406            * @param  htim TIM handle
   4407            * @param  EventSource specifies the event source.
   4408            *          This parameter can be one of the following values:
   4409            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   4410            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   4411            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   4412            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   4413            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   4414            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source
   4415            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   4416            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   4417            *            @arg TIM_EVENTSOURCE_BREAK2: Timer Break2 event source
   4418            * @note   Basic timers can only generate an update event.
   4419            * @note   TIM_EVENTSOURCE_COM is relevant only with advanced timer instances.
   4420            * @note   TIM_EVENTSOURCE_BREAK and TIM_EVENTSOURCE_BREAK2 are relevant
   4421            *         only for timer instances supporting break input(s).
   4422            * @retval HAL status
   4423            */
   4424          

   \                                 In section .text, align 2, keep-with-next
   4425          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   4426          {
   \                     HAL_TIM_GenerateEvent: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0002             MOVS     R2,R0
   4427            /* Check the parameters */
   4428            assert_param(IS_TIM_INSTANCE(htim->Instance));
   4429            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   4430          
   4431            /* Process Locked */
   4432            __HAL_LOCK(htim);
   \        0x4   0x203C             MOVS     R0,#+60
   \        0x6   0x5C10             LDRB     R0,[R2, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIM_GenerateEvent_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE00D             B        ??HAL_TIM_GenerateEvent_1
   \                     ??HAL_TIM_GenerateEvent_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x233C             MOVS     R3,#+60
   \       0x14   0x54D0             STRB     R0,[R2, R3]
   4433          
   4434            /* Change the TIM state */
   4435            htim->State = HAL_TIM_STATE_BUSY;
   \       0x16   0x2302             MOVS     R3,#+2
   \       0x18   0x243D             MOVS     R4,#+61
   \       0x1A   0x5513             STRB     R3,[R2, R4]
   4436          
   4437            /* Set the event sources */
   4438            htim->Instance->EGR = EventSource;
   \       0x1C   0x6813             LDR      R3,[R2, #+0]
   \       0x1E   0x6159             STR      R1,[R3, #+20]
   4439          
   4440            /* Change the TIM state */
   4441            htim->State = HAL_TIM_STATE_READY;
   \       0x20   0x233D             MOVS     R3,#+61
   \       0x22   0x54D0             STRB     R0,[R2, R3]
   4442          
   4443            __HAL_UNLOCK(htim);
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x233C             MOVS     R3,#+60
   \       0x28   0x54D0             STRB     R0,[R2, R3]
   4444          
   4445            /* Return function status */
   4446            return HAL_OK;
   \       0x2A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_GenerateEvent_1: (+1)
   \       0x2C   0xBD10             POP      {R4,PC}          ;; return
   4447          }
   4448          
   4449          /**
   4450            * @brief  Configures the OCRef clear feature
   4451            * @param  htim TIM handle
   4452            * @param  sClearInputConfig pointer to a TIM_ClearInputConfigTypeDef structure that
   4453            *         contains the OCREF clear feature and parameters for the TIM peripheral.
   4454            * @param  Channel specifies the TIM Channel
   4455            *          This parameter can be one of the following values:
   4456            *            @arg TIM_CHANNEL_1: TIM Channel 1
   4457            *            @arg TIM_CHANNEL_2: TIM Channel 2
   4458            *            @arg TIM_CHANNEL_3: TIM Channel 3
   4459            *            @arg TIM_CHANNEL_4: TIM Channel 4
   4460            *            @arg TIM_CHANNEL_5: TIM Channel 5
   4461            *            @arg TIM_CHANNEL_6: TIM Channel 6
   4462            * @retval HAL status
   4463            */

   \                                 In section .text, align 2, keep-with-next
   4464          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim,
   4465                                                     TIM_ClearInputConfigTypeDef *sClearInputConfig,
   4466                                                     uint32_t Channel)
   4467          {
   \                     HAL_TIM_ConfigOCrefClear: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0017             MOVS     R7,R2
   4468            /* Check the parameters */
   4469            assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
   4470            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   4471          
   4472            /* Process Locked */
   4473            __HAL_LOCK(htim);
   \        0x8   0x203C             MOVS     R0,#+60
   \        0xA   0x5C20             LDRB     R0,[R4, R0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE      ??HAL_TIM_ConfigOCrefClear_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE0B2             B        ??HAL_TIM_ConfigOCrefClear_1
   \                     ??HAL_TIM_ConfigOCrefClear_0: (+1)
   \       0x14   0x2501             MOVS     R5,#+1
   \       0x16   0x203C             MOVS     R0,#+60
   \       0x18   0x5425             STRB     R5,[R4, R0]
   4474          
   4475            htim->State = HAL_TIM_STATE_BUSY;
   \       0x1A   0x2002             MOVS     R0,#+2
   \       0x1C   0x213D             MOVS     R1,#+61
   \       0x1E   0x5460             STRB     R0,[R4, R1]
   4476          
   4477            switch (sClearInputConfig->ClearInputSource)
   \       0x20   0x6870             LDR      R0,[R6, #+4]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD002             BEQ      ??HAL_TIM_ConfigOCrefClear_2
   \       0x26   0x2801             CMP      R0,#+1
   \       0x28   0xD00D             BEQ      ??HAL_TIM_ConfigOCrefClear_3
   \       0x2A   0xE029             B        ??HAL_TIM_ConfigOCrefClear_4
   4478            {
   4479              case TIM_CLEARINPUTSOURCE_NONE:
   4480              {
   4481                /* Clear the OCREF clear selection bit and the the ETR Bits */
   4482                CLEAR_BIT(htim->Instance->SMCR, (TIM_SMCR_OCCS | TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP));
   \                     ??HAL_TIM_ConfigOCrefClear_2: (+1)
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6880             LDR      R0,[R0, #+8]
   \       0x30   0x....             LDR      R1,??DataTable48  ;; 0xffff00f7
   \       0x32   0x4001             ANDS     R1,R1,R0
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x6081             STR      R1,[R0, #+8]
   4483          
   4484                /* Clear TIMx_OR1_OCREF_CLR (reset value) */
   4485                CLEAR_BIT(htim->Instance->OR1, TIMx_OR1_OCREF_CLR);
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6D00             LDR      R0,[R0, #+80]
   \       0x3C   0x2101             MOVS     R1,#+1
   \       0x3E   0x4388             BICS     R0,R0,R1
   \       0x40   0x6821             LDR      R1,[R4, #+0]
   \       0x42   0x6508             STR      R0,[R1, #+80]
   4486                break;
   \       0x44   0xE01C             B        ??HAL_TIM_ConfigOCrefClear_5
   4487              }
   4488          #if defined(COMP1) && defined(COMP2)
   4489              case TIM_CLEARINPUTSOURCE_COMP1:
   4490              {
   4491                /* Clear the OCREF clear selection bit */
   4492                CLEAR_BIT(htim->Instance->SMCR, TIM_SMCR_OCCS);
   4493          
   4494                /* OCREF_CLR_INT is connected to COMP1 output */
   4495                CLEAR_BIT(htim->Instance->OR1, TIMx_OR1_OCREF_CLR);
   4496                break;
   4497              }
   4498              case TIM_CLEARINPUTSOURCE_COMP2:
   4499              {
   4500                /* Clear the OCREF clear selection bit */
   4501                CLEAR_BIT(htim->Instance->SMCR, TIM_SMCR_OCCS);
   4502          
   4503                /* OCREF_CLR_INT is connected to COMP2 output */
   4504                SET_BIT(htim->Instance->OR1, TIMx_OR1_OCREF_CLR);
   4505                break;
   4506              }
   4507          #endif /* COMP1 && COMP2 */
   4508          
   4509              case TIM_CLEARINPUTSOURCE_ETR:
   4510              {
   4511                /* Check the parameters */
   4512                assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   4513                assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   4514                assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   4515          
   4516                /* When OCRef clear feature is used with ETR source, ETR prescaler must be off */
   4517                if (sClearInputConfig->ClearInputPrescaler != TIM_CLEARINPUTPRESCALER_DIV1)
   \                     ??HAL_TIM_ConfigOCrefClear_3: (+1)
   \       0x46   0x68F0             LDR      R0,[R6, #+12]
   \       0x48   0x2800             CMP      R0,#+0
   \       0x4A   0xD006             BEQ      ??HAL_TIM_ConfigOCrefClear_6
   4518                {
   4519                  htim->State = HAL_TIM_STATE_READY;
   \       0x4C   0x203D             MOVS     R0,#+61
   \       0x4E   0x5425             STRB     R5,[R4, R0]
   4520                  __HAL_UNLOCK(htim);
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x213C             MOVS     R1,#+60
   \       0x54   0x5460             STRB     R0,[R4, R1]
   4521                  return HAL_ERROR;
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0xE08F             B        ??HAL_TIM_ConfigOCrefClear_1
   4522                }
   4523          
   4524                TIM_ETR_SetConfig(htim->Instance,
   4525                                  sClearInputConfig->ClearInputPrescaler,
   4526                                  sClearInputConfig->ClearInputPolarity,
   4527                                  sClearInputConfig->ClearInputFilter);
   \                     ??HAL_TIM_ConfigOCrefClear_6: (+1)
   \       0x5A   0x6933             LDR      R3,[R6, #+16]
   \       0x5C   0x68B2             LDR      R2,[R6, #+8]
   \       0x5E   0x68F1             LDR      R1,[R6, #+12]
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x....'....        BL       TIM_ETR_SetConfig
   4528          
   4529                /* Set the OCREF clear selection bit */
   4530                SET_BIT(htim->Instance->SMCR, TIM_SMCR_OCCS);
   \       0x66   0x6820             LDR      R0,[R4, #+0]
   \       0x68   0x6880             LDR      R0,[R0, #+8]
   \       0x6A   0x2108             MOVS     R1,#+8
   \       0x6C   0x4301             ORRS     R1,R1,R0
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x6081             STR      R1,[R0, #+8]
   4531          
   4532                /* Clear TIMx_OR1_OCREF_CLR (reset value) */
   4533                CLEAR_BIT(htim->Instance->OR1, TIMx_OR1_OCREF_CLR);
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x6D00             LDR      R0,[R0, #+80]
   \       0x76   0x2101             MOVS     R1,#+1
   \       0x78   0x4388             BICS     R0,R0,R1
   \       0x7A   0x6821             LDR      R1,[R4, #+0]
   \       0x7C   0x6508             STR      R0,[R1, #+80]
   4534                break;
   \       0x7E   0xE7FF             B        ??HAL_TIM_ConfigOCrefClear_5
   4535              }
   4536          
   4537              default:
   4538                break;
   4539            }
   4540          
   4541            switch (Channel)
   \                     ??HAL_TIM_ConfigOCrefClear_4: (+1)
   \                     ??HAL_TIM_ConfigOCrefClear_5: (+1)
   \       0x80   0x0038             MOVS     R0,R7
   \       0x82   0x2800             CMP      R0,#+0
   \       0x84   0xD00A             BEQ      ??HAL_TIM_ConfigOCrefClear_7
   \       0x86   0x2804             CMP      R0,#+4
   \       0x88   0xD019             BEQ      ??HAL_TIM_ConfigOCrefClear_8
   \       0x8A   0x2808             CMP      R0,#+8
   \       0x8C   0xD029             BEQ      ??HAL_TIM_ConfigOCrefClear_9
   \       0x8E   0x280C             CMP      R0,#+12
   \       0x90   0xD038             BEQ      ??HAL_TIM_ConfigOCrefClear_10
   \       0x92   0x2810             CMP      R0,#+16
   \       0x94   0xD048             BEQ      ??HAL_TIM_ConfigOCrefClear_11
   \       0x96   0x2814             CMP      R0,#+20
   \       0x98   0xD057             BEQ      ??HAL_TIM_ConfigOCrefClear_12
   \       0x9A   0xE068             B        ??HAL_TIM_ConfigOCrefClear_13
   4542            {
   4543              case TIM_CHANNEL_1:
   4544              {
   4545                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_7: (+1)
   \       0x9C   0x6830             LDR      R0,[R6, #+0]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD006             BEQ      ??HAL_TIM_ConfigOCrefClear_14
   4546                {
   4547                  /* Enable the OCREF clear feature for Channel 1 */
   4548                  SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   \       0xA2   0x6820             LDR      R0,[R4, #+0]
   \       0xA4   0x6980             LDR      R0,[R0, #+24]
   \       0xA6   0x2180             MOVS     R1,#+128
   \       0xA8   0x4301             ORRS     R1,R1,R0
   \       0xAA   0x6820             LDR      R0,[R4, #+0]
   \       0xAC   0x6181             STR      R1,[R0, #+24]
   \       0xAE   0xE005             B        ??HAL_TIM_ConfigOCrefClear_15
   4549                }
   4550                else
   4551                {
   4552                  /* Disable the OCREF clear feature for Channel 1 */
   4553                  CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC1CE);
   \                     ??HAL_TIM_ConfigOCrefClear_14: (+1)
   \       0xB0   0x6820             LDR      R0,[R4, #+0]
   \       0xB2   0x6980             LDR      R0,[R0, #+24]
   \       0xB4   0x2180             MOVS     R1,#+128
   \       0xB6   0x4388             BICS     R0,R0,R1
   \       0xB8   0x6821             LDR      R1,[R4, #+0]
   \       0xBA   0x6188             STR      R0,[R1, #+24]
   4554                }
   4555                break;
   \                     ??HAL_TIM_ConfigOCrefClear_15: (+1)
   \       0xBC   0xE057             B        ??HAL_TIM_ConfigOCrefClear_16
   4556              }
   4557              case TIM_CHANNEL_2:
   4558              {
   4559                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_8: (+1)
   \       0xBE   0x6830             LDR      R0,[R6, #+0]
   \       0xC0   0x2800             CMP      R0,#+0
   \       0xC2   0xD007             BEQ      ??HAL_TIM_ConfigOCrefClear_17
   4560                {
   4561                  /* Enable the OCREF clear feature for Channel 2 */
   4562                  SET_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   \       0xC4   0x6820             LDR      R0,[R4, #+0]
   \       0xC6   0x6980             LDR      R0,[R0, #+24]
   \       0xC8   0x2180             MOVS     R1,#+128
   \       0xCA   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0xCC   0x4301             ORRS     R1,R1,R0
   \       0xCE   0x6820             LDR      R0,[R4, #+0]
   \       0xD0   0x6181             STR      R1,[R0, #+24]
   \       0xD2   0xE005             B        ??HAL_TIM_ConfigOCrefClear_18
   4563                }
   4564                else
   4565                {
   4566                  /* Disable the OCREF clear feature for Channel 2 */
   4567                  CLEAR_BIT(htim->Instance->CCMR1, TIM_CCMR1_OC2CE);
   \                     ??HAL_TIM_ConfigOCrefClear_17: (+1)
   \       0xD4   0x6820             LDR      R0,[R4, #+0]
   \       0xD6   0x6980             LDR      R0,[R0, #+24]
   \       0xD8   0x....             LDR      R1,??DataTable49  ;; 0xffff7fff
   \       0xDA   0x4001             ANDS     R1,R1,R0
   \       0xDC   0x6820             LDR      R0,[R4, #+0]
   \       0xDE   0x6181             STR      R1,[R0, #+24]
   4568                }
   4569                break;
   \                     ??HAL_TIM_ConfigOCrefClear_18: (+1)
   \       0xE0   0xE045             B        ??HAL_TIM_ConfigOCrefClear_16
   4570              }
   4571              case TIM_CHANNEL_3:
   4572              {
   4573                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_9: (+1)
   \       0xE2   0x6830             LDR      R0,[R6, #+0]
   \       0xE4   0x2800             CMP      R0,#+0
   \       0xE6   0xD006             BEQ      ??HAL_TIM_ConfigOCrefClear_19
   4574                {
   4575                  /* Enable the OCREF clear feature for Channel 3 */
   4576                  SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   \       0xE8   0x6820             LDR      R0,[R4, #+0]
   \       0xEA   0x69C0             LDR      R0,[R0, #+28]
   \       0xEC   0x2180             MOVS     R1,#+128
   \       0xEE   0x4301             ORRS     R1,R1,R0
   \       0xF0   0x6820             LDR      R0,[R4, #+0]
   \       0xF2   0x61C1             STR      R1,[R0, #+28]
   \       0xF4   0xE005             B        ??HAL_TIM_ConfigOCrefClear_20
   4577                }
   4578                else
   4579                {
   4580                  /* Disable the OCREF clear feature for Channel 3 */
   4581                  CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC3CE);
   \                     ??HAL_TIM_ConfigOCrefClear_19: (+1)
   \       0xF6   0x6820             LDR      R0,[R4, #+0]
   \       0xF8   0x69C0             LDR      R0,[R0, #+28]
   \       0xFA   0x2180             MOVS     R1,#+128
   \       0xFC   0x4388             BICS     R0,R0,R1
   \       0xFE   0x6821             LDR      R1,[R4, #+0]
   \      0x100   0x61C8             STR      R0,[R1, #+28]
   4582                }
   4583                break;
   \                     ??HAL_TIM_ConfigOCrefClear_20: (+1)
   \      0x102   0xE034             B        ??HAL_TIM_ConfigOCrefClear_16
   4584              }
   4585              case TIM_CHANNEL_4:
   4586              {
   4587                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_10: (+1)
   \      0x104   0x6830             LDR      R0,[R6, #+0]
   \      0x106   0x2800             CMP      R0,#+0
   \      0x108   0xD007             BEQ      ??HAL_TIM_ConfigOCrefClear_21
   4588                {
   4589                  /* Enable the OCREF clear feature for Channel 4 */
   4590                  SET_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   \      0x10A   0x6820             LDR      R0,[R4, #+0]
   \      0x10C   0x69C0             LDR      R0,[R0, #+28]
   \      0x10E   0x2180             MOVS     R1,#+128
   \      0x110   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \      0x112   0x4301             ORRS     R1,R1,R0
   \      0x114   0x6820             LDR      R0,[R4, #+0]
   \      0x116   0x61C1             STR      R1,[R0, #+28]
   \      0x118   0xE005             B        ??HAL_TIM_ConfigOCrefClear_22
   4591                }
   4592                else
   4593                {
   4594                  /* Disable the OCREF clear feature for Channel 4 */
   4595                  CLEAR_BIT(htim->Instance->CCMR2, TIM_CCMR2_OC4CE);
   \                     ??HAL_TIM_ConfigOCrefClear_21: (+1)
   \      0x11A   0x6820             LDR      R0,[R4, #+0]
   \      0x11C   0x69C0             LDR      R0,[R0, #+28]
   \      0x11E   0x....             LDR      R1,??DataTable49  ;; 0xffff7fff
   \      0x120   0x4001             ANDS     R1,R1,R0
   \      0x122   0x6820             LDR      R0,[R4, #+0]
   \      0x124   0x61C1             STR      R1,[R0, #+28]
   4596                }
   4597                break;
   \                     ??HAL_TIM_ConfigOCrefClear_22: (+1)
   \      0x126   0xE022             B        ??HAL_TIM_ConfigOCrefClear_16
   4598              }
   4599              case TIM_CHANNEL_5:
   4600              {
   4601                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_11: (+1)
   \      0x128   0x6830             LDR      R0,[R6, #+0]
   \      0x12A   0x2800             CMP      R0,#+0
   \      0x12C   0xD006             BEQ      ??HAL_TIM_ConfigOCrefClear_23
   4602                {
   4603                  /* Enable the OCREF clear feature for Channel 5 */
   4604                  SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
   \      0x12E   0x6820             LDR      R0,[R4, #+0]
   \      0x130   0x6D40             LDR      R0,[R0, #+84]
   \      0x132   0x2180             MOVS     R1,#+128
   \      0x134   0x4301             ORRS     R1,R1,R0
   \      0x136   0x6820             LDR      R0,[R4, #+0]
   \      0x138   0x6541             STR      R1,[R0, #+84]
   \      0x13A   0xE005             B        ??HAL_TIM_ConfigOCrefClear_24
   4605                }
   4606                else
   4607                {
   4608                  /* Disable the OCREF clear feature for Channel 5 */
   4609                  CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC5CE);
   \                     ??HAL_TIM_ConfigOCrefClear_23: (+1)
   \      0x13C   0x6820             LDR      R0,[R4, #+0]
   \      0x13E   0x6D40             LDR      R0,[R0, #+84]
   \      0x140   0x2180             MOVS     R1,#+128
   \      0x142   0x4388             BICS     R0,R0,R1
   \      0x144   0x6821             LDR      R1,[R4, #+0]
   \      0x146   0x6548             STR      R0,[R1, #+84]
   4610                }
   4611                break;
   \                     ??HAL_TIM_ConfigOCrefClear_24: (+1)
   \      0x148   0xE011             B        ??HAL_TIM_ConfigOCrefClear_16
   4612              }
   4613              case TIM_CHANNEL_6:
   4614              {
   4615                if (sClearInputConfig->ClearInputState != (uint32_t)DISABLE)
   \                     ??HAL_TIM_ConfigOCrefClear_12: (+1)
   \      0x14A   0x6830             LDR      R0,[R6, #+0]
   \      0x14C   0x2800             CMP      R0,#+0
   \      0x14E   0xD007             BEQ      ??HAL_TIM_ConfigOCrefClear_25
   4616                {
   4617                  /* Enable the OCREF clear feature for Channel 6 */
   4618                  SET_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
   \      0x150   0x6820             LDR      R0,[R4, #+0]
   \      0x152   0x6D40             LDR      R0,[R0, #+84]
   \      0x154   0x2180             MOVS     R1,#+128
   \      0x156   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \      0x158   0x4301             ORRS     R1,R1,R0
   \      0x15A   0x6820             LDR      R0,[R4, #+0]
   \      0x15C   0x6541             STR      R1,[R0, #+84]
   \      0x15E   0xE005             B        ??HAL_TIM_ConfigOCrefClear_26
   4619                }
   4620                else
   4621                {
   4622                  /* Disable the OCREF clear feature for Channel 6 */
   4623                  CLEAR_BIT(htim->Instance->CCMR3, TIM_CCMR3_OC6CE);
   \                     ??HAL_TIM_ConfigOCrefClear_25: (+1)
   \      0x160   0x6820             LDR      R0,[R4, #+0]
   \      0x162   0x6D40             LDR      R0,[R0, #+84]
   \      0x164   0x....             LDR      R1,??DataTable49  ;; 0xffff7fff
   \      0x166   0x4001             ANDS     R1,R1,R0
   \      0x168   0x6820             LDR      R0,[R4, #+0]
   \      0x16A   0x6541             STR      R1,[R0, #+84]
   4624                }
   4625                break;
   \                     ??HAL_TIM_ConfigOCrefClear_26: (+1)
   \      0x16C   0xE7FF             B        ??HAL_TIM_ConfigOCrefClear_16
   4626              }
   4627              default:
   4628                break;
   4629            }
   4630          
   4631            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigOCrefClear_13: (+1)
   \                     ??HAL_TIM_ConfigOCrefClear_16: (+1)
   \      0x16E   0x203D             MOVS     R0,#+61
   \      0x170   0x5425             STRB     R5,[R4, R0]
   4632          
   4633            __HAL_UNLOCK(htim);
   \      0x172   0x2000             MOVS     R0,#+0
   \      0x174   0x213C             MOVS     R1,#+60
   \      0x176   0x5460             STRB     R0,[R4, R1]
   4634          
   4635            return HAL_OK;
   \      0x178   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigOCrefClear_1: (+1)
   \      0x17A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4636          }
   4637          
   4638          /**
   4639            * @brief   Configures the clock source to be used
   4640            * @param  htim TIM handle
   4641            * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
   4642            *         contains the clock source information for the TIM peripheral.
   4643            * @retval HAL status
   4644            */

   \                                 In section .text, align 2, keep-with-next
   4645          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
   4646          {
   \                     HAL_TIM_ConfigClockSource: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   4647            uint32_t tmpsmcr;
   4648          
   4649            /* Process Locked */
   4650            __HAL_LOCK(htim);
   \        0x6   0x203C             MOVS     R0,#+60
   \        0x8   0x5C20             LDRB     R0,[R4, R0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE      ??HAL_TIM_ConfigClockSource_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE06D             B        ??HAL_TIM_ConfigClockSource_1
   \                     ??HAL_TIM_ConfigClockSource_0: (+1)
   \       0x12   0x2601             MOVS     R6,#+1
   \       0x14   0x203C             MOVS     R0,#+60
   \       0x16   0x5426             STRB     R6,[R4, R0]
   4651          
   4652            htim->State = HAL_TIM_STATE_BUSY;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0x213D             MOVS     R1,#+61
   \       0x1C   0x5460             STRB     R0,[R4, R1]
   4653          
   4654            /* Check the parameters */
   4655            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   4656          
   4657            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   4658            tmpsmcr = htim->Instance->SMCR;
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6880             LDR      R0,[R0, #+8]
   4659            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   \       0x22   0x....             LDR      R1,??DataTable49_1  ;; 0xffceff88
   \       0x24   0x4001             ANDS     R1,R1,R0
   4660            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   \       0x26   0x....             LDR      R7,??DataTable49_2  ;; 0xffff00ff
   \       0x28   0x400F             ANDS     R7,R7,R1
   4661            htim->Instance->SMCR = tmpsmcr;
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x6087             STR      R7,[R0, #+8]
   4662          
   4663            switch (sClockSourceConfig->ClockSource)
   \       0x2E   0x6828             LDR      R0,[R5, #+0]
   \       0x30   0x2800             CMP      R0,#+0
   \       0x32   0xD051             BEQ      ??HAL_TIM_ConfigClockSource_2
   \       0x34   0x2810             CMP      R0,#+16
   \       0x36   0xD04F             BEQ      ??HAL_TIM_ConfigClockSource_2
   \       0x38   0x2820             CMP      R0,#+32
   \       0x3A   0xD04D             BEQ      ??HAL_TIM_ConfigClockSource_2
   \       0x3C   0x2830             CMP      R0,#+48
   \       0x3E   0xD04B             BEQ      ??HAL_TIM_ConfigClockSource_2
   \       0x40   0x2840             CMP      R0,#+64
   \       0x42   0xD03F             BEQ      ??HAL_TIM_ConfigClockSource_3
   \       0x44   0x2850             CMP      R0,#+80
   \       0x46   0xD029             BEQ      ??HAL_TIM_ConfigClockSource_4
   \       0x48   0x2860             CMP      R0,#+96
   \       0x4A   0xD031             BEQ      ??HAL_TIM_ConfigClockSource_5
   \       0x4C   0x2870             CMP      R0,#+112
   \       0x4E   0xD009             BEQ      ??HAL_TIM_ConfigClockSource_6
   \       0x50   0x2180             MOVS     R1,#+128
   \       0x52   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \       0x54   0x4288             CMP      R0,R1
   \       0x56   0xD004             BEQ      ??HAL_TIM_ConfigClockSource_7
   \       0x58   0x2180             MOVS     R1,#+128
   \       0x5A   0x0189             LSLS     R1,R1,#+6        ;; #+8192
   \       0x5C   0x4288             CMP      R0,R1
   \       0x5E   0xD00F             BEQ      ??HAL_TIM_ConfigClockSource_8
   \       0x60   0xE03F             B        ??HAL_TIM_ConfigClockSource_9
   4664            {
   4665              case TIM_CLOCKSOURCE_INTERNAL:
   4666              {
   4667                assert_param(IS_TIM_INSTANCE(htim->Instance));
   4668                break;
   \                     ??HAL_TIM_ConfigClockSource_7: (+1)
   \       0x62   0xE03E             B        ??HAL_TIM_ConfigClockSource_10
   4669              }
   4670          
   4671              case TIM_CLOCKSOURCE_ETRMODE1:
   4672              {
   4673                /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
   4674                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   4675          
   4676                /* Check ETR input conditioning related parameters */
   4677                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4678                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4679                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4680          
   4681                /* Configure the ETR Clock source */
   4682                TIM_ETR_SetConfig(htim->Instance,
   4683                                  sClockSourceConfig->ClockPrescaler,
   4684                                  sClockSourceConfig->ClockPolarity,
   4685                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_6: (+1)
   \       0x64   0x68EB             LDR      R3,[R5, #+12]
   \       0x66   0x686A             LDR      R2,[R5, #+4]
   \       0x68   0x68A9             LDR      R1,[R5, #+8]
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x....'....        BL       TIM_ETR_SetConfig
   4686          
   4687                /* Select the External clock mode1 and the ETRF trigger */
   4688                tmpsmcr = htim->Instance->SMCR;
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x6880             LDR      R0,[R0, #+8]
   4689                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   \       0x74   0x2177             MOVS     R1,#+119
   \       0x76   0x4301             ORRS     R1,R1,R0
   \       0x78   0x000F             MOVS     R7,R1
   4690                /* Write to TIMx SMCR */
   4691                htim->Instance->SMCR = tmpsmcr;
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x6087             STR      R7,[R0, #+8]
   4692                break;
   \       0x7E   0xE030             B        ??HAL_TIM_ConfigClockSource_10
   4693              }
   4694          
   4695              case TIM_CLOCKSOURCE_ETRMODE2:
   4696              {
   4697                /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
   4698                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   4699          
   4700                /* Check ETR input conditioning related parameters */
   4701                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4702                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4703                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4704          
   4705                /* Configure the ETR Clock source */
   4706                TIM_ETR_SetConfig(htim->Instance,
   4707                                  sClockSourceConfig->ClockPrescaler,
   4708                                  sClockSourceConfig->ClockPolarity,
   4709                                  sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_8: (+1)
   \       0x80   0x68EB             LDR      R3,[R5, #+12]
   \       0x82   0x686A             LDR      R2,[R5, #+4]
   \       0x84   0x68A9             LDR      R1,[R5, #+8]
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x....'....        BL       TIM_ETR_SetConfig
   4710                /* Enable the External clock mode2 */
   4711                htim->Instance->SMCR |= TIM_SMCR_ECE;
   \       0x8C   0x6820             LDR      R0,[R4, #+0]
   \       0x8E   0x6880             LDR      R0,[R0, #+8]
   \       0x90   0x2180             MOVS     R1,#+128
   \       0x92   0x01C9             LSLS     R1,R1,#+7        ;; #+16384
   \       0x94   0x4301             ORRS     R1,R1,R0
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x6081             STR      R1,[R0, #+8]
   4712                break;
   \       0x9A   0xE022             B        ??HAL_TIM_ConfigClockSource_10
   4713              }
   4714          
   4715              case TIM_CLOCKSOURCE_TI1:
   4716              {
   4717                /* Check whether or not the timer instance supports external clock mode 1 */
   4718                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4719          
   4720                /* Check TI1 input conditioning related parameters */
   4721                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4722                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4723          
   4724                TIM_TI1_ConfigInputStage(htim->Instance,
   4725                                         sClockSourceConfig->ClockPolarity,
   4726                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_4: (+1)
   \       0x9C   0x68EA             LDR      R2,[R5, #+12]
   \       0x9E   0x6869             LDR      R1,[R5, #+4]
   \       0xA0   0x6820             LDR      R0,[R4, #+0]
   \       0xA2   0x....'....        BL       TIM_TI1_ConfigInputStage
   4727                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   \       0xA6   0x2150             MOVS     R1,#+80
   \       0xA8   0x6820             LDR      R0,[R4, #+0]
   \       0xAA   0x....'....        BL       TIM_ITRx_SetConfig
   4728                break;
   \       0xAE   0xE018             B        ??HAL_TIM_ConfigClockSource_10
   4729              }
   4730          
   4731              case TIM_CLOCKSOURCE_TI2:
   4732              {
   4733                /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
   4734                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4735          
   4736                /* Check TI2 input conditioning related parameters */
   4737                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4738                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4739          
   4740                TIM_TI2_ConfigInputStage(htim->Instance,
   4741                                         sClockSourceConfig->ClockPolarity,
   4742                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_5: (+1)
   \       0xB0   0x68EA             LDR      R2,[R5, #+12]
   \       0xB2   0x6869             LDR      R1,[R5, #+4]
   \       0xB4   0x6820             LDR      R0,[R4, #+0]
   \       0xB6   0x....'....        BL       TIM_TI2_ConfigInputStage
   4743                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   \       0xBA   0x2160             MOVS     R1,#+96
   \       0xBC   0x6820             LDR      R0,[R4, #+0]
   \       0xBE   0x....'....        BL       TIM_ITRx_SetConfig
   4744                break;
   \       0xC2   0xE00E             B        ??HAL_TIM_ConfigClockSource_10
   4745              }
   4746          
   4747              case TIM_CLOCKSOURCE_TI1ED:
   4748              {
   4749                /* Check whether or not the timer instance supports external clock mode 1 */
   4750                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4751          
   4752                /* Check TI1 input conditioning related parameters */
   4753                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4754                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4755          
   4756                TIM_TI1_ConfigInputStage(htim->Instance,
   4757                                         sClockSourceConfig->ClockPolarity,
   4758                                         sClockSourceConfig->ClockFilter);
   \                     ??HAL_TIM_ConfigClockSource_3: (+1)
   \       0xC4   0x68EA             LDR      R2,[R5, #+12]
   \       0xC6   0x6869             LDR      R1,[R5, #+4]
   \       0xC8   0x6820             LDR      R0,[R4, #+0]
   \       0xCA   0x....'....        BL       TIM_TI1_ConfigInputStage
   4759                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   \       0xCE   0x2140             MOVS     R1,#+64
   \       0xD0   0x6820             LDR      R0,[R4, #+0]
   \       0xD2   0x....'....        BL       TIM_ITRx_SetConfig
   4760                break;
   \       0xD6   0xE004             B        ??HAL_TIM_ConfigClockSource_10
   4761              }
   4762          
   4763              case TIM_CLOCKSOURCE_ITR0:
   4764              case TIM_CLOCKSOURCE_ITR1:
   4765              case TIM_CLOCKSOURCE_ITR2:
   4766              case TIM_CLOCKSOURCE_ITR3:
   4767              {
   4768                /* Check whether or not the timer instance supports internal trigger input */
   4769                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4770          
   4771                TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
   \                     ??HAL_TIM_ConfigClockSource_2: (+1)
   \       0xD8   0x6829             LDR      R1,[R5, #+0]
   \       0xDA   0x6820             LDR      R0,[R4, #+0]
   \       0xDC   0x....'....        BL       TIM_ITRx_SetConfig
   4772                break;
   \       0xE0   0xE7FF             B        ??HAL_TIM_ConfigClockSource_10
   4773              }
   4774          
   4775              default:
   4776                break;
   4777            }
   4778            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIM_ConfigClockSource_9: (+1)
   \                     ??HAL_TIM_ConfigClockSource_10: (+1)
   \       0xE2   0x203D             MOVS     R0,#+61
   \       0xE4   0x5426             STRB     R6,[R4, R0]
   4779          
   4780            __HAL_UNLOCK(htim);
   \       0xE6   0x2000             MOVS     R0,#+0
   \       0xE8   0x213C             MOVS     R1,#+60
   \       0xEA   0x5460             STRB     R0,[R4, R1]
   4781          
   4782            return HAL_OK;
   \       0xEC   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_ConfigClockSource_1: (+1)
   \       0xEE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   4783          }
   4784          
   4785          /**
   4786            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4787            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4788            * @param  htim TIM handle.
   4789            * @param  TI1_Selection Indicate whether or not channel 1 is connected to the
   4790            *         output of a XOR gate.
   4791            *          This parameter can be one of the following values:
   4792            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4793            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4794            *            pins are connected to the TI1 input (XOR combination)
   4795            * @retval HAL status
   4796            */

   \                                 In section .text, align 2, keep-with-next
   4797          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4798          {
   \                     HAL_TIM_ConfigTI1Input: (+1)
   \        0x0   0x0002             MOVS     R2,R0
   4799            uint32_t tmpcr2;
   4800          
   4801            /* Check the parameters */
   4802            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
   4803            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4804          
   4805            /* Get the TIMx CR2 register value */
   4806            tmpcr2 = htim->Instance->CR2;
   \        0x2   0x6810             LDR      R0,[R2, #+0]
   \        0x4   0x6843             LDR      R3,[R0, #+4]
   4807          
   4808            /* Reset the TI1 selection */
   4809            tmpcr2 &= ~TIM_CR2_TI1S;
   \        0x6   0x2080             MOVS     R0,#+128
   \        0x8   0x4383             BICS     R3,R3,R0
   4810          
   4811            /* Set the TI1 selection */
   4812            tmpcr2 |= TI1_Selection;
   \        0xA   0x430B             ORRS     R3,R3,R1
   4813          
   4814            /* Write to TIMxCR2 */
   4815            htim->Instance->CR2 = tmpcr2;
   \        0xC   0x6810             LDR      R0,[R2, #+0]
   \        0xE   0x6043             STR      R3,[R0, #+4]
   4816          
   4817            return HAL_OK;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x4770             BX       LR               ;; return
   4818          }
   4819          
   4820          /**
   4821            * @brief  Configures the TIM in Slave mode
   4822            * @param  htim TIM handle.
   4823            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4824            *         contains the selected trigger (internal trigger input, filtered
   4825            *         timer input or external trigger input) and the Slave mode
   4826            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   4827            * @retval HAL status
   4828            */

   \                                 In section .text, align 2, keep-with-next
   4829          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef *sSlaveConfig)
   4830          {
   \                     HAL_TIM_SlaveConfigSynchro: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
   4831            /* Check the parameters */
   4832            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4833            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4834            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4835          
   4836            __HAL_LOCK(htim);
   \        0x6   0x203C             MOVS     R0,#+60
   \        0x8   0x5C20             LDRB     R0,[R4, R0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE      ??HAL_TIM_SlaveConfigSynchro_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE024             B        ??HAL_TIM_SlaveConfigSynchro_1
   \                     ??HAL_TIM_SlaveConfigSynchro_0: (+1)
   \       0x12   0x2501             MOVS     R5,#+1
   \       0x14   0x203C             MOVS     R0,#+60
   \       0x16   0x5425             STRB     R5,[R4, R0]
   4837          
   4838            htim->State = HAL_TIM_STATE_BUSY;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0x213D             MOVS     R1,#+61
   \       0x1C   0x5460             STRB     R0,[R4, R1]
   4839          
   4840            if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   \       0x1E   0x0031             MOVS     R1,R6
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x....'....        BL       TIM_SlaveTimer_SetConfig
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD006             BEQ      ??HAL_TIM_SlaveConfigSynchro_2
   4841            {
   4842              htim->State = HAL_TIM_STATE_READY;
   \       0x2A   0x203D             MOVS     R0,#+61
   \       0x2C   0x5425             STRB     R5,[R4, R0]
   4843              __HAL_UNLOCK(htim);
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x213C             MOVS     R1,#+60
   \       0x32   0x5460             STRB     R0,[R4, R1]
   4844              return HAL_ERROR;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xE011             B        ??HAL_TIM_SlaveConfigSynchro_1
   4845            }
   4846          
   4847            /* Disable Trigger Interrupt */
   4848            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   \                     ??HAL_TIM_SlaveConfigSynchro_2: (+1)
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x68C0             LDR      R0,[R0, #+12]
   \       0x3C   0x2140             MOVS     R1,#+64
   \       0x3E   0x4388             BICS     R0,R0,R1
   \       0x40   0x6821             LDR      R1,[R4, #+0]
   \       0x42   0x60C8             STR      R0,[R1, #+12]
   4849          
   4850            /* Disable Trigger DMA request */
   4851            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0x....             LDR      R1,??DataTable50  ;; 0xffffbfff
   \       0x4A   0x4001             ANDS     R1,R1,R0
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x60C1             STR      R1,[R0, #+12]
   4852          
   4853            htim->State = HAL_TIM_STATE_READY;
   \       0x50   0x203D             MOVS     R0,#+61
   \       0x52   0x5425             STRB     R5,[R4, R0]
   4854          
   4855            __HAL_UNLOCK(htim);
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x213C             MOVS     R1,#+60
   \       0x58   0x5460             STRB     R0,[R4, R1]
   4856          
   4857            return HAL_OK;
   \       0x5A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchro_1: (+1)
   \       0x5C   0xBD70             POP      {R4-R6,PC}       ;; return
   4858          }
   4859          
   4860          /**
   4861            * @brief  Configures the TIM in Slave mode in interrupt mode
   4862            * @param  htim TIM handle.
   4863            * @param  sSlaveConfig pointer to a TIM_SlaveConfigTypeDef structure that
   4864            *         contains the selected trigger (internal trigger input, filtered
   4865            *         timer input or external trigger input) and the Slave mode
   4866            *         (Disable, Reset, Gated, Trigger, External clock mode 1).
   4867            * @retval HAL status
   4868            */

   \                                 In section .text, align 2, keep-with-next
   4869          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchro_IT(TIM_HandleTypeDef *htim,
   4870                                                          TIM_SlaveConfigTypeDef *sSlaveConfig)
   4871          {
   \                     HAL_TIM_SlaveConfigSynchro_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
   4872            /* Check the parameters */
   4873            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4874            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4875            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4876          
   4877            __HAL_LOCK(htim);
   \        0x6   0x203C             MOVS     R0,#+60
   \        0x8   0x5C20             LDRB     R0,[R4, R0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE      ??HAL_TIM_SlaveConfigSynchro_IT_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE024             B        ??HAL_TIM_SlaveConfigSynchro_IT_1
   \                     ??HAL_TIM_SlaveConfigSynchro_IT_0: (+1)
   \       0x12   0x2501             MOVS     R5,#+1
   \       0x14   0x203C             MOVS     R0,#+60
   \       0x16   0x5425             STRB     R5,[R4, R0]
   4878          
   4879            htim->State = HAL_TIM_STATE_BUSY;
   \       0x18   0x2002             MOVS     R0,#+2
   \       0x1A   0x213D             MOVS     R1,#+61
   \       0x1C   0x5460             STRB     R0,[R4, R1]
   4880          
   4881            if (TIM_SlaveTimer_SetConfig(htim, sSlaveConfig) != HAL_OK)
   \       0x1E   0x0031             MOVS     R1,R6
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0x....'....        BL       TIM_SlaveTimer_SetConfig
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD006             BEQ      ??HAL_TIM_SlaveConfigSynchro_IT_2
   4882            {
   4883              htim->State = HAL_TIM_STATE_READY;
   \       0x2A   0x203D             MOVS     R0,#+61
   \       0x2C   0x5425             STRB     R5,[R4, R0]
   4884              __HAL_UNLOCK(htim);
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x213C             MOVS     R1,#+60
   \       0x32   0x5460             STRB     R0,[R4, R1]
   4885              return HAL_ERROR;
   \       0x34   0x2001             MOVS     R0,#+1
   \       0x36   0xE011             B        ??HAL_TIM_SlaveConfigSynchro_IT_1
   4886            }
   4887          
   4888            /* Enable Trigger Interrupt */
   4889            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   \                     ??HAL_TIM_SlaveConfigSynchro_IT_2: (+1)
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x68C0             LDR      R0,[R0, #+12]
   \       0x3C   0x2140             MOVS     R1,#+64
   \       0x3E   0x4301             ORRS     R1,R1,R0
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x60C1             STR      R1,[R0, #+12]
   4890          
   4891            /* Disable Trigger DMA request */
   4892            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x68C0             LDR      R0,[R0, #+12]
   \       0x48   0x....             LDR      R1,??DataTable50  ;; 0xffffbfff
   \       0x4A   0x4001             ANDS     R1,R1,R0
   \       0x4C   0x6820             LDR      R0,[R4, #+0]
   \       0x4E   0x60C1             STR      R1,[R0, #+12]
   4893          
   4894            htim->State = HAL_TIM_STATE_READY;
   \       0x50   0x203D             MOVS     R0,#+61
   \       0x52   0x5425             STRB     R5,[R4, R0]
   4895          
   4896            __HAL_UNLOCK(htim);
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x213C             MOVS     R1,#+60
   \       0x58   0x5460             STRB     R0,[R4, R1]
   4897          
   4898            return HAL_OK;
   \       0x5A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIM_SlaveConfigSynchro_IT_1: (+1)
   \       0x5C   0xBD70             POP      {R4-R6,PC}       ;; return
   4899          }
   4900          
   4901          /**
   4902            * @brief  Read the captured value from Capture Compare unit
   4903            * @param  htim TIM handle.
   4904            * @param  Channel TIM Channels to be enabled
   4905            *          This parameter can be one of the following values:
   4906            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   4907            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   4908            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   4909            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   4910            * @retval Captured value
   4911            */

   \                                 In section .text, align 2, keep-with-next
   4912          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4913          {
   \                     HAL_TIM_ReadCapturedValue: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0002             MOVS     R2,R0
   4914            uint32_t tmpreg = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   4915          
   4916            switch (Channel)
   \        0x6   0x000B             MOVS     R3,R1
   \        0x8   0x2B00             CMP      R3,#+0
   \        0xA   0xD006             BEQ      ??HAL_TIM_ReadCapturedValue_0
   \        0xC   0x2B04             CMP      R3,#+4
   \        0xE   0xD008             BEQ      ??HAL_TIM_ReadCapturedValue_1
   \       0x10   0x2B08             CMP      R3,#+8
   \       0x12   0xD00A             BEQ      ??HAL_TIM_ReadCapturedValue_2
   \       0x14   0x2B0C             CMP      R3,#+12
   \       0x16   0xD00C             BEQ      ??HAL_TIM_ReadCapturedValue_3
   \       0x18   0xE00F             B        ??HAL_TIM_ReadCapturedValue_4
   4917            {
   4918              case TIM_CHANNEL_1:
   4919              {
   4920                /* Check the parameters */
   4921                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4922          
   4923                /* Return the capture 1 value */
   4924                tmpreg =  htim->Instance->CCR1;
   \                     ??HAL_TIM_ReadCapturedValue_0: (+1)
   \       0x1A   0x6813             LDR      R3,[R2, #+0]
   \       0x1C   0x6B5B             LDR      R3,[R3, #+52]
   \       0x1E   0x0018             MOVS     R0,R3
   4925          
   4926                break;
   \       0x20   0xE00B             B        ??HAL_TIM_ReadCapturedValue_5
   4927              }
   4928              case TIM_CHANNEL_2:
   4929              {
   4930                /* Check the parameters */
   4931                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4932          
   4933                /* Return the capture 2 value */
   4934                tmpreg =   htim->Instance->CCR2;
   \                     ??HAL_TIM_ReadCapturedValue_1: (+1)
   \       0x22   0x6813             LDR      R3,[R2, #+0]
   \       0x24   0x6B9B             LDR      R3,[R3, #+56]
   \       0x26   0x0018             MOVS     R0,R3
   4935          
   4936                break;
   \       0x28   0xE007             B        ??HAL_TIM_ReadCapturedValue_5
   4937              }
   4938          
   4939              case TIM_CHANNEL_3:
   4940              {
   4941                /* Check the parameters */
   4942                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4943          
   4944                /* Return the capture 3 value */
   4945                tmpreg =   htim->Instance->CCR3;
   \                     ??HAL_TIM_ReadCapturedValue_2: (+1)
   \       0x2A   0x6813             LDR      R3,[R2, #+0]
   \       0x2C   0x6BDB             LDR      R3,[R3, #+60]
   \       0x2E   0x0018             MOVS     R0,R3
   4946          
   4947                break;
   \       0x30   0xE003             B        ??HAL_TIM_ReadCapturedValue_5
   4948              }
   4949          
   4950              case TIM_CHANNEL_4:
   4951              {
   4952                /* Check the parameters */
   4953                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4954          
   4955                /* Return the capture 4 value */
   4956                tmpreg =   htim->Instance->CCR4;
   \                     ??HAL_TIM_ReadCapturedValue_3: (+1)
   \       0x32   0x6813             LDR      R3,[R2, #+0]
   \       0x34   0x6C1B             LDR      R3,[R3, #+64]
   \       0x36   0x0018             MOVS     R0,R3
   4957          
   4958                break;
   \       0x38   0xE7FF             B        ??HAL_TIM_ReadCapturedValue_5
   4959              }
   4960          
   4961              default:
   4962                break;
   4963            }
   4964          
   4965            return tmpreg;
   \                     ??HAL_TIM_ReadCapturedValue_4: (+1)
   \                     ??HAL_TIM_ReadCapturedValue_5: (+1)
   \       0x3A   0xBD00             POP      {PC}             ;; return
   4966          }
   4967          
   4968          /**
   4969            * @}
   4970            */
   4971          
   4972          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4973            *  @brief    TIM Callbacks functions
   4974            *
   4975          @verbatim
   4976            ==============================================================================
   4977                                  ##### TIM Callbacks functions #####
   4978            ==============================================================================
   4979           [..]
   4980             This section provides TIM callback functions:
   4981             (+) TIM Period elapsed callback
   4982             (+) TIM Output Compare callback
   4983             (+) TIM Input capture callback
   4984             (+) TIM Trigger callback
   4985             (+) TIM Error callback
   4986          
   4987          @endverbatim
   4988            * @{
   4989            */
   4990          
   4991          /**
   4992            * @brief  Period elapsed callback in non-blocking mode
   4993            * @param  htim TIM handle
   4994            * @retval None
   4995            */

   \                                 In section .text, align 2
   4996          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4997          {
   4998            /* Prevent unused argument(s) compilation warning */
   4999            UNUSED(htim);
   5000          
   5001            /* NOTE : This function should not be modified, when the callback is needed,
   5002                      the HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   5003             */
   5004          }
   \                     HAL_TIM_PeriodElapsedCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   5005          
   5006          /**
   5007            * @brief  Period elapsed half complete callback in non-blocking mode
   5008            * @param  htim TIM handle
   5009            * @retval None
   5010            */

   \                                 In section .text, align 2
   5011          __weak void HAL_TIM_PeriodElapsedHalfCpltCallback(TIM_HandleTypeDef *htim)
   5012          {
   5013            /* Prevent unused argument(s) compilation warning */
   5014            UNUSED(htim);
   5015          
   5016            /* NOTE : This function should not be modified, when the callback is needed,
   5017                      the HAL_TIM_PeriodElapsedHalfCpltCallback could be implemented in the user file
   5018             */
   5019          }
   \                     HAL_TIM_PeriodElapsedHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   5020          
   5021          /**
   5022            * @brief  Output Compare callback in non-blocking mode
   5023            * @param  htim TIM OC handle
   5024            * @retval None
   5025            */

   \                                 In section .text, align 2
   5026          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   5027          {
   5028            /* Prevent unused argument(s) compilation warning */
   5029            UNUSED(htim);
   5030          
   5031            /* NOTE : This function should not be modified, when the callback is needed,
   5032                      the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   5033             */
   5034          }
   \                     HAL_TIM_OC_DelayElapsedCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   5035          
   5036          /**
   5037            * @brief  Input Capture callback in non-blocking mode
   5038            * @param  htim TIM IC handle
   5039            * @retval None
   5040            */

   \                                 In section .text, align 2
   5041          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   5042          {
   5043            /* Prevent unused argument(s) compilation warning */
   5044            UNUSED(htim);
   5045          
   5046            /* NOTE : This function should not be modified, when the callback is needed,
   5047                      the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   5048             */
   5049          }
   \                     HAL_TIM_IC_CaptureCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   5050          
   5051          /**
   5052            * @brief  Input Capture half complete callback in non-blocking mode
   5053            * @param  htim TIM IC handle
   5054            * @retval None
   5055            */

   \                                 In section .text, align 2
   5056          __weak void HAL_TIM_IC_CaptureHalfCpltCallback(TIM_HandleTypeDef *htim)
   5057          {
   5058            /* Prevent unused argument(s) compilation warning */
   5059            UNUSED(htim);
   5060          
   5061            /* NOTE : This function should not be modified, when the callback is needed,
   5062                      the HAL_TIM_IC_CaptureHalfCpltCallback could be implemented in the user file
   5063             */
   5064          }
   \                     HAL_TIM_IC_CaptureHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   5065          
   5066          /**
   5067            * @brief  PWM Pulse finished callback in non-blocking mode
   5068            * @param  htim TIM handle
   5069            * @retval None
   5070            */

   \                                 In section .text, align 2
   5071          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   5072          {
   5073            /* Prevent unused argument(s) compilation warning */
   5074            UNUSED(htim);
   5075          
   5076            /* NOTE : This function should not be modified, when the callback is needed,
   5077                      the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   5078             */
   5079          }
   \                     HAL_TIM_PWM_PulseFinishedCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   5080          
   5081          /**
   5082            * @brief  PWM Pulse finished half complete callback in non-blocking mode
   5083            * @param  htim TIM handle
   5084            * @retval None
   5085            */

   \                                 In section .text, align 2
   5086          __weak void HAL_TIM_PWM_PulseFinishedHalfCpltCallback(TIM_HandleTypeDef *htim)
   5087          {
   5088            /* Prevent unused argument(s) compilation warning */
   5089            UNUSED(htim);
   5090          
   5091            /* NOTE : This function should not be modified, when the callback is needed,
   5092                      the HAL_TIM_PWM_PulseFinishedHalfCpltCallback could be implemented in the user file
   5093             */
   5094          }
   \                     HAL_TIM_PWM_PulseFinishedHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   5095          
   5096          /**
   5097            * @brief  Hall Trigger detection callback in non-blocking mode
   5098            * @param  htim TIM handle
   5099            * @retval None
   5100            */

   \                                 In section .text, align 2
   5101          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   5102          {
   5103            /* Prevent unused argument(s) compilation warning */
   5104            UNUSED(htim);
   5105          
   5106            /* NOTE : This function should not be modified, when the callback is needed,
   5107                      the HAL_TIM_TriggerCallback could be implemented in the user file
   5108             */
   5109          }
   \                     HAL_TIM_TriggerCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   5110          
   5111          /**
   5112            * @brief  Hall Trigger detection half complete callback in non-blocking mode
   5113            * @param  htim TIM handle
   5114            * @retval None
   5115            */

   \                                 In section .text, align 2
   5116          __weak void HAL_TIM_TriggerHalfCpltCallback(TIM_HandleTypeDef *htim)
   5117          {
   5118            /* Prevent unused argument(s) compilation warning */
   5119            UNUSED(htim);
   5120          
   5121            /* NOTE : This function should not be modified, when the callback is needed,
   5122                      the HAL_TIM_TriggerHalfCpltCallback could be implemented in the user file
   5123             */
   5124          }
   \                     HAL_TIM_TriggerHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   5125          
   5126          /**
   5127            * @brief  Timer error callback in non-blocking mode
   5128            * @param  htim TIM handle
   5129            * @retval None
   5130            */

   \                                 In section .text, align 2
   5131          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   5132          {
   5133            /* Prevent unused argument(s) compilation warning */
   5134            UNUSED(htim);
   5135          
   5136            /* NOTE : This function should not be modified, when the callback is needed,
   5137                      the HAL_TIM_ErrorCallback could be implemented in the user file
   5138             */
   5139          }
   \                     HAL_TIM_ErrorCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   5140          
   5141          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5142          /**
   5143            * @brief  Register a User TIM callback to be used instead of the weak predefined callback
   5144            * @param htim tim handle
   5145            * @param CallbackID ID of the callback to be registered
   5146            *        This parameter can be one of the following values:
   5147            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   5148            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   5149            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   5150            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   5151            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   5152            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   5153            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   5154            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   5155            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   5156            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   5157            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   5158            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   5159            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
   5160            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
   5161            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   5162            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   5163            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   5164            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   5165            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   5166            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   5167            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   5168            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   5169            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   5170            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   5171            *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
   5172            *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
   5173            *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
   5174            *          @arg @ref HAL_TIM_BREAK2_CB_ID Break2 Callback ID
   5175            *          @param pCallback pointer to the callback function
   5176            *          @retval status
   5177            */
   5178          HAL_StatusTypeDef HAL_TIM_RegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID,
   5179                                                     pTIM_CallbackTypeDef pCallback)
   5180          {
   5181            HAL_StatusTypeDef status = HAL_OK;
   5182          
   5183            if (pCallback == NULL)
   5184            {
   5185              return HAL_ERROR;
   5186            }
   5187            /* Process locked */
   5188            __HAL_LOCK(htim);
   5189          
   5190            if (htim->State == HAL_TIM_STATE_READY)
   5191            {
   5192              switch (CallbackID)
   5193              {
   5194                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5195                  htim->Base_MspInitCallback                 = pCallback;
   5196                  break;
   5197          
   5198                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5199                  htim->Base_MspDeInitCallback               = pCallback;
   5200                  break;
   5201          
   5202                case HAL_TIM_IC_MSPINIT_CB_ID :
   5203                  htim->IC_MspInitCallback                   = pCallback;
   5204                  break;
   5205          
   5206                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5207                  htim->IC_MspDeInitCallback                 = pCallback;
   5208                  break;
   5209          
   5210                case HAL_TIM_OC_MSPINIT_CB_ID :
   5211                  htim->OC_MspInitCallback                   = pCallback;
   5212                  break;
   5213          
   5214                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5215                  htim->OC_MspDeInitCallback                 = pCallback;
   5216                  break;
   5217          
   5218                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5219                  htim->PWM_MspInitCallback                  = pCallback;
   5220                  break;
   5221          
   5222                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5223                  htim->PWM_MspDeInitCallback                = pCallback;
   5224                  break;
   5225          
   5226                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5227                  htim->OnePulse_MspInitCallback             = pCallback;
   5228                  break;
   5229          
   5230                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5231                  htim->OnePulse_MspDeInitCallback           = pCallback;
   5232                  break;
   5233          
   5234                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5235                  htim->Encoder_MspInitCallback              = pCallback;
   5236                  break;
   5237          
   5238                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5239                  htim->Encoder_MspDeInitCallback            = pCallback;
   5240                  break;
   5241          
   5242                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5243                  htim->HallSensor_MspInitCallback           = pCallback;
   5244                  break;
   5245          
   5246                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5247                  htim->HallSensor_MspDeInitCallback         = pCallback;
   5248                  break;
   5249          
   5250                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   5251                  htim->PeriodElapsedCallback                = pCallback;
   5252                  break;
   5253          
   5254                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   5255                  htim->PeriodElapsedHalfCpltCallback        = pCallback;
   5256                  break;
   5257          
   5258                case HAL_TIM_TRIGGER_CB_ID :
   5259                  htim->TriggerCallback                      = pCallback;
   5260                  break;
   5261          
   5262                case HAL_TIM_TRIGGER_HALF_CB_ID :
   5263                  htim->TriggerHalfCpltCallback              = pCallback;
   5264                  break;
   5265          
   5266                case HAL_TIM_IC_CAPTURE_CB_ID :
   5267                  htim->IC_CaptureCallback                   = pCallback;
   5268                  break;
   5269          
   5270                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   5271                  htim->IC_CaptureHalfCpltCallback           = pCallback;
   5272                  break;
   5273          
   5274                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   5275                  htim->OC_DelayElapsedCallback              = pCallback;
   5276                  break;
   5277          
   5278                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   5279                  htim->PWM_PulseFinishedCallback            = pCallback;
   5280                  break;
   5281          
   5282                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   5283                  htim->PWM_PulseFinishedHalfCpltCallback    = pCallback;
   5284                  break;
   5285          
   5286                case HAL_TIM_ERROR_CB_ID :
   5287                  htim->ErrorCallback                        = pCallback;
   5288                  break;
   5289          
   5290                case HAL_TIM_COMMUTATION_CB_ID :
   5291                  htim->CommutationCallback                  = pCallback;
   5292                  break;
   5293          
   5294                case HAL_TIM_COMMUTATION_HALF_CB_ID :
   5295                  htim->CommutationHalfCpltCallback          = pCallback;
   5296                  break;
   5297          
   5298                case HAL_TIM_BREAK_CB_ID :
   5299                  htim->BreakCallback                        = pCallback;
   5300                  break;
   5301          
   5302                case HAL_TIM_BREAK2_CB_ID :
   5303                  htim->Break2Callback                       = pCallback;
   5304                  break;
   5305          
   5306                default :
   5307                  /* Return error status */
   5308                  status =  HAL_ERROR;
   5309                  break;
   5310              }
   5311            }
   5312            else if (htim->State == HAL_TIM_STATE_RESET)
   5313            {
   5314              switch (CallbackID)
   5315              {
   5316                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5317                  htim->Base_MspInitCallback         = pCallback;
   5318                  break;
   5319          
   5320                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5321                  htim->Base_MspDeInitCallback       = pCallback;
   5322                  break;
   5323          
   5324                case HAL_TIM_IC_MSPINIT_CB_ID :
   5325                  htim->IC_MspInitCallback           = pCallback;
   5326                  break;
   5327          
   5328                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5329                  htim->IC_MspDeInitCallback         = pCallback;
   5330                  break;
   5331          
   5332                case HAL_TIM_OC_MSPINIT_CB_ID :
   5333                  htim->OC_MspInitCallback           = pCallback;
   5334                  break;
   5335          
   5336                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5337                  htim->OC_MspDeInitCallback         = pCallback;
   5338                  break;
   5339          
   5340                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5341                  htim->PWM_MspInitCallback          = pCallback;
   5342                  break;
   5343          
   5344                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5345                  htim->PWM_MspDeInitCallback        = pCallback;
   5346                  break;
   5347          
   5348                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5349                  htim->OnePulse_MspInitCallback     = pCallback;
   5350                  break;
   5351          
   5352                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5353                  htim->OnePulse_MspDeInitCallback   = pCallback;
   5354                  break;
   5355          
   5356                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5357                  htim->Encoder_MspInitCallback      = pCallback;
   5358                  break;
   5359          
   5360                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5361                  htim->Encoder_MspDeInitCallback    = pCallback;
   5362                  break;
   5363          
   5364                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5365                  htim->HallSensor_MspInitCallback   = pCallback;
   5366                  break;
   5367          
   5368                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5369                  htim->HallSensor_MspDeInitCallback = pCallback;
   5370                  break;
   5371          
   5372                default :
   5373                  /* Return error status */
   5374                  status =  HAL_ERROR;
   5375                  break;
   5376              }
   5377            }
   5378            else
   5379            {
   5380              /* Return error status */
   5381              status =  HAL_ERROR;
   5382            }
   5383          
   5384            /* Release Lock */
   5385            __HAL_UNLOCK(htim);
   5386          
   5387            return status;
   5388          }
   5389          
   5390          /**
   5391            * @brief  Unregister a TIM callback
   5392            *         TIM callback is redirected to the weak predefined callback
   5393            * @param htim tim handle
   5394            * @param CallbackID ID of the callback to be unregistered
   5395            *        This parameter can be one of the following values:
   5396            *          @arg @ref HAL_TIM_BASE_MSPINIT_CB_ID Base MspInit Callback ID
   5397            *          @arg @ref HAL_TIM_BASE_MSPDEINIT_CB_ID Base MspDeInit Callback ID
   5398            *          @arg @ref HAL_TIM_IC_MSPINIT_CB_ID IC MspInit Callback ID
   5399            *          @arg @ref HAL_TIM_IC_MSPDEINIT_CB_ID IC MspDeInit Callback ID
   5400            *          @arg @ref HAL_TIM_OC_MSPINIT_CB_ID OC MspInit Callback ID
   5401            *          @arg @ref HAL_TIM_OC_MSPDEINIT_CB_ID OC MspDeInit Callback ID
   5402            *          @arg @ref HAL_TIM_PWM_MSPINIT_CB_ID PWM MspInit Callback ID
   5403            *          @arg @ref HAL_TIM_PWM_MSPDEINIT_CB_ID PWM MspDeInit Callback ID
   5404            *          @arg @ref HAL_TIM_ONE_PULSE_MSPINIT_CB_ID One Pulse MspInit Callback ID
   5405            *          @arg @ref HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID One Pulse MspDeInit Callback ID
   5406            *          @arg @ref HAL_TIM_ENCODER_MSPINIT_CB_ID Encoder MspInit Callback ID
   5407            *          @arg @ref HAL_TIM_ENCODER_MSPDEINIT_CB_ID Encoder MspDeInit Callback ID
   5408            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID Hall Sensor MspInit Callback ID
   5409            *          @arg @ref HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID Hall Sensor MspDeInit Callback ID
   5410            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_CB_ID Period Elapsed Callback ID
   5411            *          @arg @ref HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID Period Elapsed half complete Callback ID
   5412            *          @arg @ref HAL_TIM_TRIGGER_CB_ID Trigger Callback ID
   5413            *          @arg @ref HAL_TIM_TRIGGER_HALF_CB_ID Trigger half complete Callback ID
   5414            *          @arg @ref HAL_TIM_IC_CAPTURE_CB_ID Input Capture Callback ID
   5415            *          @arg @ref HAL_TIM_IC_CAPTURE_HALF_CB_ID Input Capture half complete Callback ID
   5416            *          @arg @ref HAL_TIM_OC_DELAY_ELAPSED_CB_ID Output Compare Delay Elapsed Callback ID
   5417            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_CB_ID PWM Pulse Finished Callback ID
   5418            *          @arg @ref HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID PWM Pulse Finished half complete Callback ID
   5419            *          @arg @ref HAL_TIM_ERROR_CB_ID Error Callback ID
   5420            *          @arg @ref HAL_TIM_COMMUTATION_CB_ID Commutation Callback ID
   5421            *          @arg @ref HAL_TIM_COMMUTATION_HALF_CB_ID Commutation half complete Callback ID
   5422            *          @arg @ref HAL_TIM_BREAK_CB_ID Break Callback ID
   5423            *          @arg @ref HAL_TIM_BREAK2_CB_ID Break2 Callback ID
   5424            *          @retval status
   5425            */
   5426          HAL_StatusTypeDef HAL_TIM_UnRegisterCallback(TIM_HandleTypeDef *htim, HAL_TIM_CallbackIDTypeDef CallbackID)
   5427          {
   5428            HAL_StatusTypeDef status = HAL_OK;
   5429          
   5430            /* Process locked */
   5431            __HAL_LOCK(htim);
   5432          
   5433            if (htim->State == HAL_TIM_STATE_READY)
   5434            {
   5435              switch (CallbackID)
   5436              {
   5437                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5438                  htim->Base_MspInitCallback              = HAL_TIM_Base_MspInit;                      /* Legacy weak Base MspInit Callback */
   5439                  break;
   5440          
   5441                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5442                  htim->Base_MspDeInitCallback            = HAL_TIM_Base_MspDeInit;                    /* Legacy weak Base Msp DeInit Callback */
   5443                  break;
   5444          
   5445                case HAL_TIM_IC_MSPINIT_CB_ID :
   5446                  htim->IC_MspInitCallback                = HAL_TIM_IC_MspInit;                        /* Legacy weak IC Msp Init Callback */
   5447                  break;
   5448          
   5449                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5450                  htim->IC_MspDeInitCallback              = HAL_TIM_IC_MspDeInit;                      /* Legacy weak IC Msp DeInit Callback */
   5451                  break;
   5452          
   5453                case HAL_TIM_OC_MSPINIT_CB_ID :
   5454                  htim->OC_MspInitCallback                = HAL_TIM_OC_MspInit;                        /* Legacy weak OC Msp Init Callback */
   5455                  break;
   5456          
   5457                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5458                  htim->OC_MspDeInitCallback              = HAL_TIM_OC_MspDeInit;                      /* Legacy weak OC Msp DeInit Callback */
   5459                  break;
   5460          
   5461                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5462                  htim->PWM_MspInitCallback               = HAL_TIM_PWM_MspInit;                       /* Legacy weak PWM Msp Init Callback */
   5463                  break;
   5464          
   5465                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5466                  htim->PWM_MspDeInitCallback             = HAL_TIM_PWM_MspDeInit;                     /* Legacy weak PWM Msp DeInit Callback */
   5467                  break;
   5468          
   5469                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5470                  htim->OnePulse_MspInitCallback          = HAL_TIM_OnePulse_MspInit;                  /* Legacy weak One Pulse Msp Init Callback */
   5471                  break;
   5472          
   5473                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5474                  htim->OnePulse_MspDeInitCallback        = HAL_TIM_OnePulse_MspDeInit;                /* Legacy weak One Pulse Msp DeInit Callback */
   5475                  break;
   5476          
   5477                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5478                  htim->Encoder_MspInitCallback           = HAL_TIM_Encoder_MspInit;                   /* Legacy weak Encoder Msp Init Callback */
   5479                  break;
   5480          
   5481                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5482                  htim->Encoder_MspDeInitCallback         = HAL_TIM_Encoder_MspDeInit;                 /* Legacy weak Encoder Msp DeInit Callback */
   5483                  break;
   5484          
   5485                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5486                  htim->HallSensor_MspInitCallback        = HAL_TIMEx_HallSensor_MspInit;              /* Legacy weak Hall Sensor Msp Init Callback */
   5487                  break;
   5488          
   5489                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5490                  htim->HallSensor_MspDeInitCallback      = HAL_TIMEx_HallSensor_MspDeInit;            /* Legacy weak Hall Sensor Msp DeInit Callback */
   5491                  break;
   5492          
   5493                case HAL_TIM_PERIOD_ELAPSED_CB_ID :
   5494                  htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak Period Elapsed Callback */
   5495                  break;
   5496          
   5497                case HAL_TIM_PERIOD_ELAPSED_HALF_CB_ID :
   5498                  htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak Period Elapsed half complete Callback */
   5499                  break;
   5500          
   5501                case HAL_TIM_TRIGGER_CB_ID :
   5502                  htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak Trigger Callback */
   5503                  break;
   5504          
   5505                case HAL_TIM_TRIGGER_HALF_CB_ID :
   5506                  htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;           /* Legacy weak Trigger half complete Callback */
   5507                  break;
   5508          
   5509                case HAL_TIM_IC_CAPTURE_CB_ID :
   5510                  htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;                /* Legacy weak IC Capture Callback */
   5511                  break;
   5512          
   5513                case HAL_TIM_IC_CAPTURE_HALF_CB_ID :
   5514                  htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;        /* Legacy weak IC Capture half complete Callback */
   5515                  break;
   5516          
   5517                case HAL_TIM_OC_DELAY_ELAPSED_CB_ID :
   5518                  htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;           /* Legacy weak OC Delay Elapsed Callback */
   5519                  break;
   5520          
   5521                case HAL_TIM_PWM_PULSE_FINISHED_CB_ID :
   5522                  htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;         /* Legacy weak PWM Pulse Finished Callback */
   5523                  break;
   5524          
   5525                case HAL_TIM_PWM_PULSE_FINISHED_HALF_CB_ID :
   5526                  htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback; /* Legacy weak PWM Pulse Finished half complete Callback */
   5527                  break;
   5528          
   5529                case HAL_TIM_ERROR_CB_ID :
   5530                  htim->ErrorCallback                     = HAL_TIM_ErrorCallback;                     /* Legacy weak Error Callback */
   5531                  break;
   5532          
   5533                case HAL_TIM_COMMUTATION_CB_ID :
   5534                  htim->CommutationCallback               = HAL_TIMEx_CommutCallback;                  /* Legacy weak Commutation Callback */
   5535                  break;
   5536          
   5537                case HAL_TIM_COMMUTATION_HALF_CB_ID :
   5538                  htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;          /* Legacy weak Commutation half complete Callback */
   5539                  break;
   5540          
   5541                case HAL_TIM_BREAK_CB_ID :
   5542                  htim->BreakCallback                     = HAL_TIMEx_BreakCallback;                   /* Legacy weak Break Callback */
   5543                  break;
   5544          
   5545                case HAL_TIM_BREAK2_CB_ID :
   5546                  htim->Break2Callback                    = HAL_TIMEx_Break2Callback;                  /* Legacy weak Break2 Callback */
   5547                  break;
   5548          
   5549                default :
   5550                  /* Return error status */
   5551                  status =  HAL_ERROR;
   5552                  break;
   5553              }
   5554            }
   5555            else if (htim->State == HAL_TIM_STATE_RESET)
   5556            {
   5557              switch (CallbackID)
   5558              {
   5559                case HAL_TIM_BASE_MSPINIT_CB_ID :
   5560                  htim->Base_MspInitCallback         = HAL_TIM_Base_MspInit;              /* Legacy weak Base MspInit Callback */
   5561                  break;
   5562          
   5563                case HAL_TIM_BASE_MSPDEINIT_CB_ID :
   5564                  htim->Base_MspDeInitCallback       = HAL_TIM_Base_MspDeInit;            /* Legacy weak Base Msp DeInit Callback */
   5565                  break;
   5566          
   5567                case HAL_TIM_IC_MSPINIT_CB_ID :
   5568                  htim->IC_MspInitCallback           = HAL_TIM_IC_MspInit;                /* Legacy weak IC Msp Init Callback */
   5569                  break;
   5570          
   5571                case HAL_TIM_IC_MSPDEINIT_CB_ID :
   5572                  htim->IC_MspDeInitCallback         = HAL_TIM_IC_MspDeInit;              /* Legacy weak IC Msp DeInit Callback */
   5573                  break;
   5574          
   5575                case HAL_TIM_OC_MSPINIT_CB_ID :
   5576                  htim->OC_MspInitCallback           = HAL_TIM_OC_MspInit;                /* Legacy weak OC Msp Init Callback */
   5577                  break;
   5578          
   5579                case HAL_TIM_OC_MSPDEINIT_CB_ID :
   5580                  htim->OC_MspDeInitCallback         = HAL_TIM_OC_MspDeInit;              /* Legacy weak OC Msp DeInit Callback */
   5581                  break;
   5582          
   5583                case HAL_TIM_PWM_MSPINIT_CB_ID :
   5584                  htim->PWM_MspInitCallback          = HAL_TIM_PWM_MspInit;               /* Legacy weak PWM Msp Init Callback */
   5585                  break;
   5586          
   5587                case HAL_TIM_PWM_MSPDEINIT_CB_ID :
   5588                  htim->PWM_MspDeInitCallback        = HAL_TIM_PWM_MspDeInit;             /* Legacy weak PWM Msp DeInit Callback */
   5589                  break;
   5590          
   5591                case HAL_TIM_ONE_PULSE_MSPINIT_CB_ID :
   5592                  htim->OnePulse_MspInitCallback     = HAL_TIM_OnePulse_MspInit;          /* Legacy weak One Pulse Msp Init Callback */
   5593                  break;
   5594          
   5595                case HAL_TIM_ONE_PULSE_MSPDEINIT_CB_ID :
   5596                  htim->OnePulse_MspDeInitCallback   = HAL_TIM_OnePulse_MspDeInit;        /* Legacy weak One Pulse Msp DeInit Callback */
   5597                  break;
   5598          
   5599                case HAL_TIM_ENCODER_MSPINIT_CB_ID :
   5600                  htim->Encoder_MspInitCallback      = HAL_TIM_Encoder_MspInit;           /* Legacy weak Encoder Msp Init Callback */
   5601                  break;
   5602          
   5603                case HAL_TIM_ENCODER_MSPDEINIT_CB_ID :
   5604                  htim->Encoder_MspDeInitCallback    = HAL_TIM_Encoder_MspDeInit;         /* Legacy weak Encoder Msp DeInit Callback */
   5605                  break;
   5606          
   5607                case HAL_TIM_HALL_SENSOR_MSPINIT_CB_ID :
   5608                  htim->HallSensor_MspInitCallback   = HAL_TIMEx_HallSensor_MspInit;      /* Legacy weak Hall Sensor Msp Init Callback */
   5609                  break;
   5610          
   5611                case HAL_TIM_HALL_SENSOR_MSPDEINIT_CB_ID :
   5612                  htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;    /* Legacy weak Hall Sensor Msp DeInit Callback */
   5613                  break;
   5614          
   5615                default :
   5616                  /* Return error status */
   5617                  status =  HAL_ERROR;
   5618                  break;
   5619              }
   5620            }
   5621            else
   5622            {
   5623              /* Return error status */
   5624              status =  HAL_ERROR;
   5625            }
   5626          
   5627            /* Release Lock */
   5628            __HAL_UNLOCK(htim);
   5629          
   5630            return status;
   5631          }
   5632          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5633          
   5634          /**
   5635            * @}
   5636            */
   5637          
   5638          /** @defgroup TIM_Exported_Functions_Group10 TIM Peripheral State functions
   5639            *  @brief   TIM Peripheral State functions
   5640            *
   5641          @verbatim
   5642            ==============================================================================
   5643                                  ##### Peripheral State functions #####
   5644            ==============================================================================
   5645              [..]
   5646              This subsection permits to get in run-time the status of the peripheral
   5647              and the data flow.
   5648          
   5649          @endverbatim
   5650            * @{
   5651            */
   5652          
   5653          /**
   5654            * @brief  Return the TIM Base handle state.
   5655            * @param  htim TIM Base handle
   5656            * @retval HAL state
   5657            */

   \                                 In section .text, align 2, keep-with-next
   5658          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   5659          {
   5660            return htim->State;
   \                     HAL_TIM_Base_GetState: (+1)
   \        0x0   0x213D             MOVS     R1,#+61
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   5661          }
   5662          
   5663          /**
   5664            * @brief  Return the TIM OC handle state.
   5665            * @param  htim TIM Output Compare handle
   5666            * @retval HAL state
   5667            */

   \                                 In section .text, align 2, keep-with-next
   5668          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   5669          {
   5670            return htim->State;
   \                     HAL_TIM_OC_GetState: (+1)
   \        0x0   0x213D             MOVS     R1,#+61
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   5671          }
   5672          
   5673          /**
   5674            * @brief  Return the TIM PWM handle state.
   5675            * @param  htim TIM handle
   5676            * @retval HAL state
   5677            */

   \                                 In section .text, align 2, keep-with-next
   5678          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   5679          {
   5680            return htim->State;
   \                     HAL_TIM_PWM_GetState: (+1)
   \        0x0   0x213D             MOVS     R1,#+61
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   5681          }
   5682          
   5683          /**
   5684            * @brief  Return the TIM Input Capture handle state.
   5685            * @param  htim TIM IC handle
   5686            * @retval HAL state
   5687            */

   \                                 In section .text, align 2, keep-with-next
   5688          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   5689          {
   5690            return htim->State;
   \                     HAL_TIM_IC_GetState: (+1)
   \        0x0   0x213D             MOVS     R1,#+61
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   5691          }
   5692          
   5693          /**
   5694            * @brief  Return the TIM One Pulse Mode handle state.
   5695            * @param  htim TIM OPM handle
   5696            * @retval HAL state
   5697            */

   \                                 In section .text, align 2, keep-with-next
   5698          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   5699          {
   5700            return htim->State;
   \                     HAL_TIM_OnePulse_GetState: (+1)
   \        0x0   0x213D             MOVS     R1,#+61
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   5701          }
   5702          
   5703          /**
   5704            * @brief  Return the TIM Encoder Mode handle state.
   5705            * @param  htim TIM Encoder Interface handle
   5706            * @retval HAL state
   5707            */

   \                                 In section .text, align 2, keep-with-next
   5708          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   5709          {
   5710            return htim->State;
   \                     HAL_TIM_Encoder_GetState: (+1)
   \        0x0   0x213D             MOVS     R1,#+61
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   5711          }
   5712          
   5713          /**
   5714            * @}
   5715            */
   5716          
   5717          /**
   5718            * @}
   5719            */
   5720          
   5721          /** @defgroup TIM_Private_Functions TIM Private Functions
   5722            * @{
   5723            */
   5724          
   5725          /**
   5726            * @brief  TIM DMA error callback
   5727            * @param  hdma pointer to DMA handle.
   5728            * @retval None
   5729            */

   \                                 In section .text, align 2, keep-with-next
   5730          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   5731          {
   \                     TIM_DMAError: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5732            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6AA5             LDR      R5,[R4, #+40]
   5733          
   5734            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x213D             MOVS     R1,#+61
   \        0xA   0x5468             STRB     R0,[R5, R1]
   5735          
   5736          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5737            htim->ErrorCallback(htim);
   5738          #else
   5739            HAL_TIM_ErrorCallback(htim);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x....'....        BL       HAL_TIM_ErrorCallback
   5740          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5741          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5742          
   5743          /**
   5744            * @brief  TIM DMA Delay Pulse complete callback.
   5745            * @param  hdma pointer to DMA handle.
   5746            * @retval None
   5747            */

   \                                 In section .text, align 2, keep-with-next
   5748          void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   5749          {
   \                     TIM_DMADelayPulseCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5750            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6AA5             LDR      R5,[R4, #+40]
   5751          
   5752            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x213D             MOVS     R1,#+61
   \        0xA   0x5468             STRB     R0,[R5, R1]
   5753          
   5754            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0xC   0x6A69             LDR      R1,[R5, #+36]
   \        0xE   0x428C             CMP      R4,R1
   \       0x10   0xD101             BNE      ??TIM_DMADelayPulseCplt_0
   5755            {
   5756              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x12   0x7728             STRB     R0,[R5, #+28]
   \       0x14   0xE010             B        ??TIM_DMADelayPulseCplt_1
   5757            }
   5758            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMADelayPulseCplt_0: (+1)
   \       0x16   0x6AA8             LDR      R0,[R5, #+40]
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD102             BNE      ??TIM_DMADelayPulseCplt_2
   5759            {
   5760              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x7728             STRB     R0,[R5, #+28]
   \       0x20   0xE00A             B        ??TIM_DMADelayPulseCplt_1
   5761            }
   5762            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMADelayPulseCplt_2: (+1)
   \       0x22   0x6AE8             LDR      R0,[R5, #+44]
   \       0x24   0x4284             CMP      R4,R0
   \       0x26   0xD102             BNE      ??TIM_DMADelayPulseCplt_3
   5763            {
   5764              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x28   0x2004             MOVS     R0,#+4
   \       0x2A   0x7728             STRB     R0,[R5, #+28]
   \       0x2C   0xE004             B        ??TIM_DMADelayPulseCplt_1
   5765            }
   5766            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMADelayPulseCplt_3: (+1)
   \       0x2E   0x6B28             LDR      R0,[R5, #+48]
   \       0x30   0x4284             CMP      R4,R0
   \       0x32   0xD101             BNE      ??TIM_DMADelayPulseCplt_1
   5767            {
   5768              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x34   0x2008             MOVS     R0,#+8
   \       0x36   0x7728             STRB     R0,[R5, #+28]
   5769            }
   5770            else
   5771            {
   5772              /* nothing to do */
   5773            }
   5774          
   5775          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5776            htim->PWM_PulseFinishedCallback(htim);
   5777          #else
   5778            HAL_TIM_PWM_PulseFinishedCallback(htim);
   \                     ??TIM_DMADelayPulseCplt_1: (+1)
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x....'....        BL       HAL_TIM_PWM_PulseFinishedCallback
   5779          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5780          
   5781            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x7728             STRB     R0,[R5, #+28]
   5782          }
   \       0x42   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5783          
   5784          /**
   5785            * @brief  TIM DMA Delay Pulse half complete callback.
   5786            * @param  hdma pointer to DMA handle.
   5787            * @retval None
   5788            */

   \                                 In section .text, align 2, keep-with-next
   5789          void TIM_DMADelayPulseHalfCplt(DMA_HandleTypeDef *hdma)
   5790          {
   \                     TIM_DMADelayPulseHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5791            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6AA5             LDR      R5,[R4, #+40]
   5792          
   5793            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x213D             MOVS     R1,#+61
   \        0xA   0x5468             STRB     R0,[R5, R1]
   5794          
   5795            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0xC   0x6A69             LDR      R1,[R5, #+36]
   \        0xE   0x428C             CMP      R4,R1
   \       0x10   0xD101             BNE      ??TIM_DMADelayPulseHalfCplt_0
   5796            {
   5797              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x12   0x7728             STRB     R0,[R5, #+28]
   \       0x14   0xE010             B        ??TIM_DMADelayPulseHalfCplt_1
   5798            }
   5799            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMADelayPulseHalfCplt_0: (+1)
   \       0x16   0x6AA8             LDR      R0,[R5, #+40]
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD102             BNE      ??TIM_DMADelayPulseHalfCplt_2
   5800            {
   5801              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x7728             STRB     R0,[R5, #+28]
   \       0x20   0xE00A             B        ??TIM_DMADelayPulseHalfCplt_1
   5802            }
   5803            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMADelayPulseHalfCplt_2: (+1)
   \       0x22   0x6AE8             LDR      R0,[R5, #+44]
   \       0x24   0x4284             CMP      R4,R0
   \       0x26   0xD102             BNE      ??TIM_DMADelayPulseHalfCplt_3
   5804            {
   5805              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x28   0x2004             MOVS     R0,#+4
   \       0x2A   0x7728             STRB     R0,[R5, #+28]
   \       0x2C   0xE004             B        ??TIM_DMADelayPulseHalfCplt_1
   5806            }
   5807            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMADelayPulseHalfCplt_3: (+1)
   \       0x2E   0x6B28             LDR      R0,[R5, #+48]
   \       0x30   0x4284             CMP      R4,R0
   \       0x32   0xD101             BNE      ??TIM_DMADelayPulseHalfCplt_1
   5808            {
   5809              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x34   0x2008             MOVS     R0,#+8
   \       0x36   0x7728             STRB     R0,[R5, #+28]
   5810            }
   5811            else
   5812            {
   5813              /* nothing to do */
   5814            }
   5815          
   5816          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5817            htim->PWM_PulseFinishedHalfCpltCallback(htim);
   5818          #else
   5819            HAL_TIM_PWM_PulseFinishedHalfCpltCallback(htim);
   \                     ??TIM_DMADelayPulseHalfCplt_1: (+1)
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x....'....        BL       HAL_TIM_PWM_PulseFinishedHalfCpltCallback
   5820          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5821          
   5822            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x7728             STRB     R0,[R5, #+28]
   5823          }
   \       0x42   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5824          
   5825          /**
   5826            * @brief  TIM DMA Capture complete callback.
   5827            * @param  hdma pointer to DMA handle.
   5828            * @retval None
   5829            */

   \                                 In section .text, align 2, keep-with-next
   5830          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   5831          {
   \                     TIM_DMACaptureCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5832            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6AA5             LDR      R5,[R4, #+40]
   5833          
   5834            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x213D             MOVS     R1,#+61
   \        0xA   0x5468             STRB     R0,[R5, R1]
   5835          
   5836            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0xC   0x6A69             LDR      R1,[R5, #+36]
   \        0xE   0x428C             CMP      R4,R1
   \       0x10   0xD101             BNE      ??TIM_DMACaptureCplt_0
   5837            {
   5838              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x12   0x7728             STRB     R0,[R5, #+28]
   \       0x14   0xE010             B        ??TIM_DMACaptureCplt_1
   5839            }
   5840            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMACaptureCplt_0: (+1)
   \       0x16   0x6AA8             LDR      R0,[R5, #+40]
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD102             BNE      ??TIM_DMACaptureCplt_2
   5841            {
   5842              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x7728             STRB     R0,[R5, #+28]
   \       0x20   0xE00A             B        ??TIM_DMACaptureCplt_1
   5843            }
   5844            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMACaptureCplt_2: (+1)
   \       0x22   0x6AE8             LDR      R0,[R5, #+44]
   \       0x24   0x4284             CMP      R4,R0
   \       0x26   0xD102             BNE      ??TIM_DMACaptureCplt_3
   5845            {
   5846              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x28   0x2004             MOVS     R0,#+4
   \       0x2A   0x7728             STRB     R0,[R5, #+28]
   \       0x2C   0xE004             B        ??TIM_DMACaptureCplt_1
   5847            }
   5848            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMACaptureCplt_3: (+1)
   \       0x2E   0x6B28             LDR      R0,[R5, #+48]
   \       0x30   0x4284             CMP      R4,R0
   \       0x32   0xD101             BNE      ??TIM_DMACaptureCplt_1
   5849            {
   5850              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x34   0x2008             MOVS     R0,#+8
   \       0x36   0x7728             STRB     R0,[R5, #+28]
   5851            }
   5852            else
   5853            {
   5854              /* nothing to do */
   5855            }
   5856          
   5857          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5858            htim->IC_CaptureCallback(htim);
   5859          #else
   5860            HAL_TIM_IC_CaptureCallback(htim);
   \                     ??TIM_DMACaptureCplt_1: (+1)
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x....'....        BL       HAL_TIM_IC_CaptureCallback
   5861          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5862          
   5863            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x7728             STRB     R0,[R5, #+28]
   5864          }
   \       0x42   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5865          
   5866          /**
   5867            * @brief  TIM DMA Capture half complete callback.
   5868            * @param  hdma pointer to DMA handle.
   5869            * @retval None
   5870            */

   \                                 In section .text, align 2, keep-with-next
   5871          void TIM_DMACaptureHalfCplt(DMA_HandleTypeDef *hdma)
   5872          {
   \                     TIM_DMACaptureHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5873            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6AA5             LDR      R5,[R4, #+40]
   5874          
   5875            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x213D             MOVS     R1,#+61
   \        0xA   0x5468             STRB     R0,[R5, R1]
   5876          
   5877            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   \        0xC   0x6A69             LDR      R1,[R5, #+36]
   \        0xE   0x428C             CMP      R4,R1
   \       0x10   0xD101             BNE      ??TIM_DMACaptureHalfCplt_0
   5878            {
   5879              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   \       0x12   0x7728             STRB     R0,[R5, #+28]
   \       0x14   0xE010             B        ??TIM_DMACaptureHalfCplt_1
   5880            }
   5881            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   \                     ??TIM_DMACaptureHalfCplt_0: (+1)
   \       0x16   0x6AA8             LDR      R0,[R5, #+40]
   \       0x18   0x4284             CMP      R4,R0
   \       0x1A   0xD102             BNE      ??TIM_DMACaptureHalfCplt_2
   5882            {
   5883              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   \       0x1C   0x2002             MOVS     R0,#+2
   \       0x1E   0x7728             STRB     R0,[R5, #+28]
   \       0x20   0xE00A             B        ??TIM_DMACaptureHalfCplt_1
   5884            }
   5885            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   \                     ??TIM_DMACaptureHalfCplt_2: (+1)
   \       0x22   0x6AE8             LDR      R0,[R5, #+44]
   \       0x24   0x4284             CMP      R4,R0
   \       0x26   0xD102             BNE      ??TIM_DMACaptureHalfCplt_3
   5886            {
   5887              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   \       0x28   0x2004             MOVS     R0,#+4
   \       0x2A   0x7728             STRB     R0,[R5, #+28]
   \       0x2C   0xE004             B        ??TIM_DMACaptureHalfCplt_1
   5888            }
   5889            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   \                     ??TIM_DMACaptureHalfCplt_3: (+1)
   \       0x2E   0x6B28             LDR      R0,[R5, #+48]
   \       0x30   0x4284             CMP      R4,R0
   \       0x32   0xD101             BNE      ??TIM_DMACaptureHalfCplt_1
   5890            {
   5891              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   \       0x34   0x2008             MOVS     R0,#+8
   \       0x36   0x7728             STRB     R0,[R5, #+28]
   5892            }
   5893            else
   5894            {
   5895              /* nothing to do */
   5896            }
   5897          
   5898          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5899            htim->IC_CaptureHalfCpltCallback(htim);
   5900          #else
   5901            HAL_TIM_IC_CaptureHalfCpltCallback(htim);
   \                     ??TIM_DMACaptureHalfCplt_1: (+1)
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x....'....        BL       HAL_TIM_IC_CaptureHalfCpltCallback
   5902          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5903          
   5904            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x7728             STRB     R0,[R5, #+28]
   5905          }
   \       0x42   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5906          
   5907          /**
   5908            * @brief  TIM DMA Period Elapse complete callback.
   5909            * @param  hdma pointer to DMA handle.
   5910            * @retval None
   5911            */

   \                                 In section .text, align 2, keep-with-next
   5912          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   5913          {
   \                     TIM_DMAPeriodElapsedCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5914            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6AA5             LDR      R5,[R4, #+40]
   5915          
   5916            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x213D             MOVS     R1,#+61
   \        0xA   0x5468             STRB     R0,[R5, R1]
   5917          
   5918          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5919            htim->PeriodElapsedCallback(htim);
   5920          #else
   5921            HAL_TIM_PeriodElapsedCallback(htim);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x....'....        BL       HAL_TIM_PeriodElapsedCallback
   5922          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5923          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5924          
   5925          /**
   5926            * @brief  TIM DMA Period Elapse half complete callback.
   5927            * @param  hdma pointer to DMA handle.
   5928            * @retval None
   5929            */

   \                                 In section .text, align 2, keep-with-next
   5930          static void TIM_DMAPeriodElapsedHalfCplt(DMA_HandleTypeDef *hdma)
   5931          {
   \                     TIM_DMAPeriodElapsedHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5932            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6AA5             LDR      R5,[R4, #+40]
   5933          
   5934            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x213D             MOVS     R1,#+61
   \        0xA   0x5468             STRB     R0,[R5, R1]
   5935          
   5936          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5937            htim->PeriodElapsedHalfCpltCallback(htim);
   5938          #else
   5939            HAL_TIM_PeriodElapsedHalfCpltCallback(htim);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x....'....        BL       HAL_TIM_PeriodElapsedHalfCpltCallback
   5940          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5941          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5942          
   5943          /**
   5944            * @brief  TIM DMA Trigger callback.
   5945            * @param  hdma pointer to DMA handle.
   5946            * @retval None
   5947            */

   \                                 In section .text, align 2, keep-with-next
   5948          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   5949          {
   \                     TIM_DMATriggerCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5950            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6AA5             LDR      R5,[R4, #+40]
   5951          
   5952            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x213D             MOVS     R1,#+61
   \        0xA   0x5468             STRB     R0,[R5, R1]
   5953          
   5954          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5955            htim->TriggerCallback(htim);
   5956          #else
   5957            HAL_TIM_TriggerCallback(htim);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x....'....        BL       HAL_TIM_TriggerCallback
   5958          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5959          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5960          
   5961          /**
   5962            * @brief  TIM DMA Trigger half complete callback.
   5963            * @param  hdma pointer to DMA handle.
   5964            * @retval None
   5965            */

   \                                 In section .text, align 2, keep-with-next
   5966          static void TIM_DMATriggerHalfCplt(DMA_HandleTypeDef *hdma)
   5967          {
   \                     TIM_DMATriggerHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   5968            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6AA5             LDR      R5,[R4, #+40]
   5969          
   5970            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x213D             MOVS     R1,#+61
   \        0xA   0x5468             STRB     R0,[R5, R1]
   5971          
   5972          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   5973            htim->TriggerHalfCpltCallback(htim);
   5974          #else
   5975            HAL_TIM_TriggerHalfCpltCallback(htim);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x....'....        BL       HAL_TIM_TriggerHalfCpltCallback
   5976          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   5977          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   5978          
   5979          /**
   5980            * @brief  Time Base configuration
   5981            * @param  TIMx TIM peripheral
   5982            * @param  Structure TIM Base configuration structure
   5983            * @retval None
   5984            */

   \                                 In section .text, align 2, keep-with-next
   5985          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   5986          {
   \                     TIM_Base_SetConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   5987            uint32_t tmpcr1;
   5988            tmpcr1 = TIMx->CR1;
   \        0x2   0x6803             LDR      R3,[R0, #+0]
   5989          
   5990            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   5991            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   \        0x4   0x....             LDR      R2,??DataTable54  ;; 0x40012c00
   \        0x6   0x4290             CMP      R0,R2
   \        0x8   0xD002             BEQ      ??TIM_Base_SetConfig_0
   \        0xA   0x....             LDR      R4,??DataTable54_1  ;; 0x40000400
   \        0xC   0x42A0             CMP      R0,R4
   \        0xE   0xD104             BNE      ??TIM_Base_SetConfig_1
   5992            {
   5993              /* Select the Counter Mode */
   5994              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   \                     ??TIM_Base_SetConfig_0: (+1)
   \       0x10   0x2470             MOVS     R4,#+112
   \       0x12   0x43A3             BICS     R3,R3,R4
   5995              tmpcr1 |= Structure->CounterMode;
   \       0x14   0x001C             MOVS     R4,R3
   \       0x16   0x684B             LDR      R3,[R1, #+4]
   \       0x18   0x4323             ORRS     R3,R3,R4
   5996            }
   5997          
   5998            if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   \                     ??TIM_Base_SetConfig_1: (+1)
   \       0x1A   0x4290             CMP      R0,R2
   \       0x1C   0xD00B             BEQ      ??TIM_Base_SetConfig_2
   \       0x1E   0x....             LDR      R4,??DataTable54_1  ;; 0x40000400
   \       0x20   0x42A0             CMP      R0,R4
   \       0x22   0xD008             BEQ      ??TIM_Base_SetConfig_2
   \       0x24   0x....             LDR      R4,??DataTable54_2  ;; 0x40002000
   \       0x26   0x42A0             CMP      R0,R4
   \       0x28   0xD005             BEQ      ??TIM_Base_SetConfig_2
   \       0x2A   0x....             LDR      R4,??DataTable54_3  ;; 0x40014400
   \       0x2C   0x42A0             CMP      R0,R4
   \       0x2E   0xD002             BEQ      ??TIM_Base_SetConfig_2
   \       0x30   0x....             LDR      R4,??DataTable55  ;; 0x40014800
   \       0x32   0x42A0             CMP      R0,R4
   \       0x34   0xD103             BNE      ??TIM_Base_SetConfig_3
   5999            {
   6000              /* Set the clock division */
   6001              tmpcr1 &= ~TIM_CR1_CKD;
   \                     ??TIM_Base_SetConfig_2: (+1)
   \       0x36   0x....             LDR      R4,??DataTable54_4  ;; 0xfffffcff
   \       0x38   0x401C             ANDS     R4,R4,R3
   6002              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   \       0x3A   0x68CB             LDR      R3,[R1, #+12]
   \       0x3C   0x4323             ORRS     R3,R3,R4
   6003            }
   6004          
   6005            /* Set the auto-reload preload */
   6006            MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
   \                     ??TIM_Base_SetConfig_3: (+1)
   \       0x3E   0x2480             MOVS     R4,#+128
   \       0x40   0x43A3             BICS     R3,R3,R4
   \       0x42   0x694C             LDR      R4,[R1, #+20]
   \       0x44   0x431C             ORRS     R4,R4,R3
   6007          
   6008            TIMx->CR1 = tmpcr1;
   \       0x46   0x6004             STR      R4,[R0, #+0]
   6009          
   6010            /* Set the Autoreload value */
   6011            TIMx->ARR = (uint32_t)Structure->Period ;
   \       0x48   0x688B             LDR      R3,[R1, #+8]
   \       0x4A   0x62C3             STR      R3,[R0, #+44]
   6012          
   6013            /* Set the Prescaler value */
   6014            TIMx->PSC = Structure->Prescaler;
   \       0x4C   0x680B             LDR      R3,[R1, #+0]
   \       0x4E   0x6283             STR      R3,[R0, #+40]
   6015          
   6016            if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   \       0x50   0x4290             CMP      R0,R2
   \       0x52   0xD005             BEQ      ??TIM_Base_SetConfig_4
   \       0x54   0x....             LDR      R2,??DataTable54_3  ;; 0x40014400
   \       0x56   0x4290             CMP      R0,R2
   \       0x58   0xD002             BEQ      ??TIM_Base_SetConfig_4
   \       0x5A   0x....             LDR      R2,??DataTable55  ;; 0x40014800
   \       0x5C   0x4290             CMP      R0,R2
   \       0x5E   0xD101             BNE      ??TIM_Base_SetConfig_5
   6017            {
   6018              /* Set the Repetition Counter value */
   6019              TIMx->RCR = Structure->RepetitionCounter;
   \                     ??TIM_Base_SetConfig_4: (+1)
   \       0x60   0x690A             LDR      R2,[R1, #+16]
   \       0x62   0x6302             STR      R2,[R0, #+48]
   6020            }
   6021          
   6022            /* Generate an update event to reload the Prescaler
   6023               and the repetition counter (only for advanced timer) value immediately */
   6024            TIMx->EGR = TIM_EGR_UG;
   \                     ??TIM_Base_SetConfig_5: (+1)
   \       0x64   0x2201             MOVS     R2,#+1
   \       0x66   0x6142             STR      R2,[R0, #+20]
   6025          }
   \       0x68   0xBD10             POP      {R4,PC}          ;; return
   6026          
   6027          /**
   6028            * @brief  Timer Output Compare 1 configuration
   6029            * @param  TIMx to select the TIM peripheral
   6030            * @param  OC_Config The ouput configuration structure
   6031            * @retval None
   6032            */

   \                                 In section .text, align 2, keep-with-next
   6033          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6034          {
   \                     TIM_OC1_SetConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   6035            uint32_t tmpccmrx;
   6036            uint32_t tmpccer;
   6037            uint32_t tmpcr2;
   6038          
   6039            /* Disable the Channel 1: Reset the CC1E Bit */
   6040            TIMx->CCER &= ~TIM_CCER_CC1E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0x2301             MOVS     R3,#+1
   \        0x6   0x439A             BICS     R2,R2,R3
   \        0x8   0x6202             STR      R2,[R0, #+32]
   6041          
   6042            /* Get the TIMx CCER register value */
   6043            tmpccer = TIMx->CCER;
   \        0xA   0x6A05             LDR      R5,[R0, #+32]
   6044            /* Get the TIMx CR2 register value */
   6045            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6842             LDR      R2,[R0, #+4]
   6046          
   6047            /* Get the TIMx CCMR1 register value */
   6048            tmpccmrx = TIMx->CCMR1;
   \        0xE   0x6983             LDR      R3,[R0, #+24]
   6049          
   6050            /* Reset the Output Compare Mode Bits */
   6051            tmpccmrx &= ~TIM_CCMR1_OC1M;
   \       0x10   0x....             LDR      R4,??DataTable55_1  ;; 0xfffeff8f
   \       0x12   0x401C             ANDS     R4,R4,R3
   6052            tmpccmrx &= ~TIM_CCMR1_CC1S;
   \       0x14   0x2303             MOVS     R3,#+3
   \       0x16   0x439C             BICS     R4,R4,R3
   6053            /* Select the Output Compare Mode */
   6054            tmpccmrx |= OC_Config->OCMode;
   \       0x18   0x680B             LDR      R3,[R1, #+0]
   \       0x1A   0x4323             ORRS     R3,R3,R4
   6055          
   6056            /* Reset the Output Polarity level */
   6057            tmpccer &= ~TIM_CCER_CC1P;
   \       0x1C   0x2402             MOVS     R4,#+2
   \       0x1E   0x43A5             BICS     R5,R5,R4
   6058            /* Set the Output Compare Polarity */
   6059            tmpccer |= OC_Config->OCPolarity;
   \       0x20   0x688C             LDR      R4,[R1, #+8]
   \       0x22   0x432C             ORRS     R4,R4,R5
   6060          
   6061            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   \       0x24   0x....             LDR      R5,??DataTable54  ;; 0x40012c00
   \       0x26   0x42A8             CMP      R0,R5
   \       0x28   0xD005             BEQ      ??TIM_OC1_SetConfig_0
   \       0x2A   0x....             LDR      R6,??DataTable54_3  ;; 0x40014400
   \       0x2C   0x42B0             CMP      R0,R6
   \       0x2E   0xD002             BEQ      ??TIM_OC1_SetConfig_0
   \       0x30   0x....             LDR      R6,??DataTable55  ;; 0x40014800
   \       0x32   0x42B0             CMP      R0,R6
   \       0x34   0xD106             BNE      ??TIM_OC1_SetConfig_1
   6062            {
   6063              /* Check parameters */
   6064              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   6065          
   6066              /* Reset the Output N Polarity level */
   6067              tmpccer &= ~TIM_CCER_CC1NP;
   \                     ??TIM_OC1_SetConfig_0: (+1)
   \       0x36   0x2608             MOVS     R6,#+8
   \       0x38   0x43B4             BICS     R4,R4,R6
   6068              /* Set the Output N Polarity */
   6069              tmpccer |= OC_Config->OCNPolarity;
   \       0x3A   0x0026             MOVS     R6,R4
   \       0x3C   0x68CC             LDR      R4,[R1, #+12]
   \       0x3E   0x4334             ORRS     R4,R4,R6
   6070              /* Reset the Output N State */
   6071              tmpccer &= ~TIM_CCER_CC1NE;
   \       0x40   0x2604             MOVS     R6,#+4
   \       0x42   0x43B4             BICS     R4,R4,R6
   6072            }
   6073          
   6074            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \                     ??TIM_OC1_SetConfig_1: (+1)
   \       0x44   0x42A8             CMP      R0,R5
   \       0x46   0xD005             BEQ      ??TIM_OC1_SetConfig_2
   \       0x48   0x....             LDR      R5,??DataTable54_3  ;; 0x40014400
   \       0x4A   0x42A8             CMP      R0,R5
   \       0x4C   0xD002             BEQ      ??TIM_OC1_SetConfig_2
   \       0x4E   0x....             LDR      R5,??DataTable55  ;; 0x40014800
   \       0x50   0x42A8             CMP      R0,R5
   \       0x52   0xD107             BNE      ??TIM_OC1_SetConfig_3
   6075            {
   6076              /* Check parameters */
   6077              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   6078              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6079          
   6080              /* Reset the Output Compare and Output Compare N IDLE State */
   6081              tmpcr2 &= ~TIM_CR2_OIS1;
   \                     ??TIM_OC1_SetConfig_2: (+1)
   \       0x54   0x....             LDR      R5,??DataTable56  ;; 0xfffffeff
   \       0x56   0x4015             ANDS     R5,R5,R2
   6082              tmpcr2 &= ~TIM_CR2_OIS1N;
   \       0x58   0x....             LDR      R2,??DataTable57  ;; 0xfffffdff
   \       0x5A   0x402A             ANDS     R2,R2,R5
   6083              /* Set the Output Idle state */
   6084              tmpcr2 |= OC_Config->OCIdleState;
   \       0x5C   0x694D             LDR      R5,[R1, #+20]
   \       0x5E   0x4315             ORRS     R5,R5,R2
   6085              /* Set the Output N Idle state */
   6086              tmpcr2 |= OC_Config->OCNIdleState;
   \       0x60   0x698A             LDR      R2,[R1, #+24]
   \       0x62   0x432A             ORRS     R2,R2,R5
   6087            }
   6088          
   6089            /* Write to TIMx CR2 */
   6090            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC1_SetConfig_3: (+1)
   \       0x64   0x6042             STR      R2,[R0, #+4]
   6091          
   6092            /* Write to TIMx CCMR1 */
   6093            TIMx->CCMR1 = tmpccmrx;
   \       0x66   0x6183             STR      R3,[R0, #+24]
   6094          
   6095            /* Set the Capture Compare Register value */
   6096            TIMx->CCR1 = OC_Config->Pulse;
   \       0x68   0x684D             LDR      R5,[R1, #+4]
   \       0x6A   0x6345             STR      R5,[R0, #+52]
   6097          
   6098            /* Write to TIMx CCER */
   6099            TIMx->CCER = tmpccer;
   \       0x6C   0x6204             STR      R4,[R0, #+32]
   6100          }
   \       0x6E   0xBD70             POP      {R4-R6,PC}       ;; return
   6101          
   6102          /**
   6103            * @brief  Timer Output Compare 2 configuration
   6104            * @param  TIMx to select the TIM peripheral
   6105            * @param  OC_Config The ouput configuration structure
   6106            * @retval None
   6107            */

   \                                 In section .text, align 2, keep-with-next
   6108          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6109          {
   \                     TIM_OC2_SetConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   6110            uint32_t tmpccmrx;
   6111            uint32_t tmpccer;
   6112            uint32_t tmpcr2;
   6113          
   6114            /* Disable the Channel 2: Reset the CC2E Bit */
   6115            TIMx->CCER &= ~TIM_CCER_CC2E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0x2310             MOVS     R3,#+16
   \        0x6   0x439A             BICS     R2,R2,R3
   \        0x8   0x6202             STR      R2,[R0, #+32]
   6116          
   6117            /* Get the TIMx CCER register value */
   6118            tmpccer = TIMx->CCER;
   \        0xA   0x6A03             LDR      R3,[R0, #+32]
   6119            /* Get the TIMx CR2 register value */
   6120            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6842             LDR      R2,[R0, #+4]
   6121          
   6122            /* Get the TIMx CCMR1 register value */
   6123            tmpccmrx = TIMx->CCMR1;
   \        0xE   0x6984             LDR      R4,[R0, #+24]
   6124          
   6125            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   6126            tmpccmrx &= ~TIM_CCMR1_OC2M;
   \       0x10   0x....             LDR      R5,??DataTable56_1  ;; 0xfeff8fff
   \       0x12   0x4025             ANDS     R5,R5,R4
   6127            tmpccmrx &= ~TIM_CCMR1_CC2S;
   \       0x14   0x....             LDR      R6,??DataTable54_4  ;; 0xfffffcff
   \       0x16   0x402E             ANDS     R6,R6,R5
   6128          
   6129            /* Select the Output Compare Mode */
   6130            tmpccmrx |= (OC_Config->OCMode << 8U);
   \       0x18   0x680C             LDR      R4,[R1, #+0]
   \       0x1A   0x0224             LSLS     R4,R4,#+8
   \       0x1C   0x4334             ORRS     R4,R4,R6
   6131          
   6132            /* Reset the Output Polarity level */
   6133            tmpccer &= ~TIM_CCER_CC2P;
   \       0x1E   0x2520             MOVS     R5,#+32
   \       0x20   0x43AB             BICS     R3,R3,R5
   6134            /* Set the Output Compare Polarity */
   6135            tmpccer |= (OC_Config->OCPolarity << 4U);
   \       0x22   0x688D             LDR      R5,[R1, #+8]
   \       0x24   0x012D             LSLS     R5,R5,#+4
   \       0x26   0x431D             ORRS     R5,R5,R3
   6136          
   6137            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   \       0x28   0x....             LDR      R3,??DataTable54  ;; 0x40012c00
   \       0x2A   0x4298             CMP      R0,R3
   \       0x2C   0xD107             BNE      ??TIM_OC2_SetConfig_0
   6138            {
   6139              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   6140          
   6141              /* Reset the Output N Polarity level */
   6142              tmpccer &= ~TIM_CCER_CC2NP;
   \       0x2E   0x2680             MOVS     R6,#+128
   \       0x30   0x43B5             BICS     R5,R5,R6
   6143              /* Set the Output N Polarity */
   6144              tmpccer |= (OC_Config->OCNPolarity << 4U);
   \       0x32   0x002E             MOVS     R6,R5
   \       0x34   0x68CD             LDR      R5,[R1, #+12]
   \       0x36   0x012D             LSLS     R5,R5,#+4
   \       0x38   0x4335             ORRS     R5,R5,R6
   6145              /* Reset the Output N State */
   6146              tmpccer &= ~TIM_CCER_CC2NE;
   \       0x3A   0x2640             MOVS     R6,#+64
   \       0x3C   0x43B5             BICS     R5,R5,R6
   6147          
   6148            }
   6149          
   6150            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \                     ??TIM_OC2_SetConfig_0: (+1)
   \       0x3E   0x4298             CMP      R0,R3
   \       0x40   0xD005             BEQ      ??TIM_OC2_SetConfig_1
   \       0x42   0x....             LDR      R3,??DataTable54_3  ;; 0x40014400
   \       0x44   0x4298             CMP      R0,R3
   \       0x46   0xD002             BEQ      ??TIM_OC2_SetConfig_1
   \       0x48   0x....             LDR      R3,??DataTable55  ;; 0x40014800
   \       0x4A   0x4298             CMP      R0,R3
   \       0x4C   0xD109             BNE      ??TIM_OC2_SetConfig_2
   6151            {
   6152              /* Check parameters */
   6153              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   6154              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6155          
   6156              /* Reset the Output Compare and Output Compare N IDLE State */
   6157              tmpcr2 &= ~TIM_CR2_OIS2;
   \                     ??TIM_OC2_SetConfig_1: (+1)
   \       0x4E   0x....             LDR      R3,??DataTable56_2  ;; 0xfffffbff
   \       0x50   0x4013             ANDS     R3,R3,R2
   6158              tmpcr2 &= ~TIM_CR2_OIS2N;
   \       0x52   0x....             LDR      R2,??DataTable58  ;; 0xfffff7ff
   \       0x54   0x401A             ANDS     R2,R2,R3
   6159              /* Set the Output Idle state */
   6160              tmpcr2 |= (OC_Config->OCIdleState << 2U);
   \       0x56   0x694B             LDR      R3,[R1, #+20]
   \       0x58   0x009B             LSLS     R3,R3,#+2
   \       0x5A   0x4313             ORRS     R3,R3,R2
   6161              /* Set the Output N Idle state */
   6162              tmpcr2 |= (OC_Config->OCNIdleState << 2U);
   \       0x5C   0x698A             LDR      R2,[R1, #+24]
   \       0x5E   0x0092             LSLS     R2,R2,#+2
   \       0x60   0x431A             ORRS     R2,R2,R3
   6163            }
   6164          
   6165            /* Write to TIMx CR2 */
   6166            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC2_SetConfig_2: (+1)
   \       0x62   0x6042             STR      R2,[R0, #+4]
   6167          
   6168            /* Write to TIMx CCMR1 */
   6169            TIMx->CCMR1 = tmpccmrx;
   \       0x64   0x6184             STR      R4,[R0, #+24]
   6170          
   6171            /* Set the Capture Compare Register value */
   6172            TIMx->CCR2 = OC_Config->Pulse;
   \       0x66   0x684B             LDR      R3,[R1, #+4]
   \       0x68   0x6383             STR      R3,[R0, #+56]
   6173          
   6174            /* Write to TIMx CCER */
   6175            TIMx->CCER = tmpccer;
   \       0x6A   0x6205             STR      R5,[R0, #+32]
   6176          }
   \       0x6C   0xBD70             POP      {R4-R6,PC}       ;; return
   6177          
   6178          /**
   6179            * @brief  Timer Output Compare 3 configuration
   6180            * @param  TIMx to select the TIM peripheral
   6181            * @param  OC_Config The ouput configuration structure
   6182            * @retval None
   6183            */

   \                                 In section .text, align 2, keep-with-next
   6184          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6185          {
   \                     TIM_OC3_SetConfig: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   6186            uint32_t tmpccmrx;
   6187            uint32_t tmpccer;
   6188            uint32_t tmpcr2;
   6189          
   6190            /* Disable the Channel 3: Reset the CC2E Bit */
   6191            TIMx->CCER &= ~TIM_CCER_CC3E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0x....             LDR      R3,??DataTable56  ;; 0xfffffeff
   \        0x6   0x4013             ANDS     R3,R3,R2
   \        0x8   0x6203             STR      R3,[R0, #+32]
   6192          
   6193            /* Get the TIMx CCER register value */
   6194            tmpccer = TIMx->CCER;
   \        0xA   0x6A04             LDR      R4,[R0, #+32]
   6195            /* Get the TIMx CR2 register value */
   6196            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6842             LDR      R2,[R0, #+4]
   6197          
   6198            /* Get the TIMx CCMR2 register value */
   6199            tmpccmrx = TIMx->CCMR2;
   \        0xE   0x69C3             LDR      R3,[R0, #+28]
   6200          
   6201            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   6202            tmpccmrx &= ~TIM_CCMR2_OC3M;
   \       0x10   0x....             LDR      R5,??DataTable55_1  ;; 0xfffeff8f
   \       0x12   0x401D             ANDS     R5,R5,R3
   6203            tmpccmrx &= ~TIM_CCMR2_CC3S;
   \       0x14   0x2303             MOVS     R3,#+3
   \       0x16   0x439D             BICS     R5,R5,R3
   6204            /* Select the Output Compare Mode */
   6205            tmpccmrx |= OC_Config->OCMode;
   \       0x18   0x680B             LDR      R3,[R1, #+0]
   \       0x1A   0x432B             ORRS     R3,R3,R5
   6206          
   6207            /* Reset the Output Polarity level */
   6208            tmpccer &= ~TIM_CCER_CC3P;
   \       0x1C   0x....             LDR      R5,??DataTable57  ;; 0xfffffdff
   \       0x1E   0x4025             ANDS     R5,R5,R4
   6209            /* Set the Output Compare Polarity */
   6210            tmpccer |= (OC_Config->OCPolarity << 8U);
   \       0x20   0x688C             LDR      R4,[R1, #+8]
   \       0x22   0x0224             LSLS     R4,R4,#+8
   \       0x24   0x432C             ORRS     R4,R4,R5
   6211          
   6212            if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   \       0x26   0x....             LDR      R5,??DataTable54  ;; 0x40012c00
   \       0x28   0x42A8             CMP      R0,R5
   \       0x2A   0xD106             BNE      ??TIM_OC3_SetConfig_0
   6213            {
   6214              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   6215          
   6216              /* Reset the Output N Polarity level */
   6217              tmpccer &= ~TIM_CCER_CC3NP;
   \       0x2C   0x....             LDR      R6,??DataTable58  ;; 0xfffff7ff
   \       0x2E   0x4026             ANDS     R6,R6,R4
   6218              /* Set the Output N Polarity */
   6219              tmpccer |= (OC_Config->OCNPolarity << 8U);
   \       0x30   0x68CC             LDR      R4,[R1, #+12]
   \       0x32   0x0227             LSLS     R7,R4,#+8
   \       0x34   0x4337             ORRS     R7,R7,R6
   6220              /* Reset the Output N State */
   6221              tmpccer &= ~TIM_CCER_CC3NE;
   \       0x36   0x....             LDR      R4,??DataTable56_2  ;; 0xfffffbff
   \       0x38   0x403C             ANDS     R4,R4,R7
   6222            }
   6223          
   6224            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \                     ??TIM_OC3_SetConfig_0: (+1)
   \       0x3A   0x42A8             CMP      R0,R5
   \       0x3C   0xD005             BEQ      ??TIM_OC3_SetConfig_1
   \       0x3E   0x....             LDR      R5,??DataTable54_3  ;; 0x40014400
   \       0x40   0x42A8             CMP      R0,R5
   \       0x42   0xD002             BEQ      ??TIM_OC3_SetConfig_1
   \       0x44   0x....             LDR      R5,??DataTable55  ;; 0x40014800
   \       0x46   0x42A8             CMP      R0,R5
   \       0x48   0xD109             BNE      ??TIM_OC3_SetConfig_2
   6225            {
   6226              /* Check parameters */
   6227              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   6228              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6229          
   6230              /* Reset the Output Compare and Output Compare N IDLE State */
   6231              tmpcr2 &= ~TIM_CR2_OIS3;
   \                     ??TIM_OC3_SetConfig_1: (+1)
   \       0x4A   0x....             LDR      R5,??DataTable58_1  ;; 0xffffefff
   \       0x4C   0x4015             ANDS     R5,R5,R2
   6232              tmpcr2 &= ~TIM_CR2_OIS3N;
   \       0x4E   0x....             LDR      R2,??DataTable60  ;; 0xffffdfff
   \       0x50   0x402A             ANDS     R2,R2,R5
   6233              /* Set the Output Idle state */
   6234              tmpcr2 |= (OC_Config->OCIdleState << 4U);
   \       0x52   0x694D             LDR      R5,[R1, #+20]
   \       0x54   0x012D             LSLS     R5,R5,#+4
   \       0x56   0x4315             ORRS     R5,R5,R2
   6235              /* Set the Output N Idle state */
   6236              tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   \       0x58   0x698A             LDR      R2,[R1, #+24]
   \       0x5A   0x0112             LSLS     R2,R2,#+4
   \       0x5C   0x432A             ORRS     R2,R2,R5
   6237            }
   6238          
   6239            /* Write to TIMx CR2 */
   6240            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC3_SetConfig_2: (+1)
   \       0x5E   0x6042             STR      R2,[R0, #+4]
   6241          
   6242            /* Write to TIMx CCMR2 */
   6243            TIMx->CCMR2 = tmpccmrx;
   \       0x60   0x61C3             STR      R3,[R0, #+28]
   6244          
   6245            /* Set the Capture Compare Register value */
   6246            TIMx->CCR3 = OC_Config->Pulse;
   \       0x62   0x684D             LDR      R5,[R1, #+4]
   \       0x64   0x63C5             STR      R5,[R0, #+60]
   6247          
   6248            /* Write to TIMx CCER */
   6249            TIMx->CCER = tmpccer;
   \       0x66   0x6204             STR      R4,[R0, #+32]
   6250          }
   \       0x68   0xBDF0             POP      {R4-R7,PC}       ;; return
   6251          
   6252          /**
   6253            * @brief  Timer Output Compare 4 configuration
   6254            * @param  TIMx to select the TIM peripheral
   6255            * @param  OC_Config The ouput configuration structure
   6256            * @retval None
   6257            */

   \                                 In section .text, align 2, keep-with-next
   6258          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   6259          {
   \                     TIM_OC4_SetConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   6260            uint32_t tmpccmrx;
   6261            uint32_t tmpccer;
   6262            uint32_t tmpcr2;
   6263          
   6264            /* Disable the Channel 4: Reset the CC4E Bit */
   6265            TIMx->CCER &= ~TIM_CCER_CC4E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0x....             LDR      R3,??DataTable58_1  ;; 0xffffefff
   \        0x6   0x4013             ANDS     R3,R3,R2
   \        0x8   0x6203             STR      R3,[R0, #+32]
   6266          
   6267            /* Get the TIMx CCER register value */
   6268            tmpccer = TIMx->CCER;
   \        0xA   0x6A03             LDR      R3,[R0, #+32]
   6269            /* Get the TIMx CR2 register value */
   6270            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6842             LDR      R2,[R0, #+4]
   6271          
   6272            /* Get the TIMx CCMR2 register value */
   6273            tmpccmrx = TIMx->CCMR2;
   \        0xE   0x69C4             LDR      R4,[R0, #+28]
   6274          
   6275            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   6276            tmpccmrx &= ~TIM_CCMR2_OC4M;
   \       0x10   0x....             LDR      R5,??DataTable56_1  ;; 0xfeff8fff
   \       0x12   0x4025             ANDS     R5,R5,R4
   6277            tmpccmrx &= ~TIM_CCMR2_CC4S;
   \       0x14   0x....             LDR      R6,??DataTable54_4  ;; 0xfffffcff
   \       0x16   0x402E             ANDS     R6,R6,R5
   6278          
   6279            /* Select the Output Compare Mode */
   6280            tmpccmrx |= (OC_Config->OCMode << 8U);
   \       0x18   0x680C             LDR      R4,[R1, #+0]
   \       0x1A   0x0224             LSLS     R4,R4,#+8
   \       0x1C   0x4334             ORRS     R4,R4,R6
   6281          
   6282            /* Reset the Output Polarity level */
   6283            tmpccer &= ~TIM_CCER_CC4P;
   \       0x1E   0x....             LDR      R5,??DataTable60  ;; 0xffffdfff
   \       0x20   0x401D             ANDS     R5,R5,R3
   6284            /* Set the Output Compare Polarity */
   6285            tmpccer |= (OC_Config->OCPolarity << 12U);
   \       0x22   0x688B             LDR      R3,[R1, #+8]
   \       0x24   0x031B             LSLS     R3,R3,#+12
   \       0x26   0x432B             ORRS     R3,R3,R5
   6286          
   6287            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x28   0x....             LDR      R5,??DataTable54  ;; 0x40012c00
   \       0x2A   0x42A8             CMP      R0,R5
   \       0x2C   0xD005             BEQ      ??TIM_OC4_SetConfig_0
   \       0x2E   0x....             LDR      R5,??DataTable54_3  ;; 0x40014400
   \       0x30   0x42A8             CMP      R0,R5
   \       0x32   0xD002             BEQ      ??TIM_OC4_SetConfig_0
   \       0x34   0x....             LDR      R5,??DataTable55  ;; 0x40014800
   \       0x36   0x42A8             CMP      R0,R5
   \       0x38   0xD104             BNE      ??TIM_OC4_SetConfig_1
   6288            {
   6289              /* Check parameters */
   6290              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   6291          
   6292              /* Reset the Output Compare IDLE State */
   6293              tmpcr2 &= ~TIM_CR2_OIS4;
   \                     ??TIM_OC4_SetConfig_0: (+1)
   \       0x3A   0x....             LDR      R5,??DataTable64  ;; 0xffffbfff
   \       0x3C   0x4015             ANDS     R5,R5,R2
   6294          
   6295              /* Set the Output Idle state */
   6296              tmpcr2 |= (OC_Config->OCIdleState << 6U);
   \       0x3E   0x694A             LDR      R2,[R1, #+20]
   \       0x40   0x0192             LSLS     R2,R2,#+6
   \       0x42   0x432A             ORRS     R2,R2,R5
   6297            }
   6298          
   6299            /* Write to TIMx CR2 */
   6300            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC4_SetConfig_1: (+1)
   \       0x44   0x6042             STR      R2,[R0, #+4]
   6301          
   6302            /* Write to TIMx CCMR2 */
   6303            TIMx->CCMR2 = tmpccmrx;
   \       0x46   0x61C4             STR      R4,[R0, #+28]
   6304          
   6305            /* Set the Capture Compare Register value */
   6306            TIMx->CCR4 = OC_Config->Pulse;
   \       0x48   0x684D             LDR      R5,[R1, #+4]
   \       0x4A   0x6405             STR      R5,[R0, #+64]
   6307          
   6308            /* Write to TIMx CCER */
   6309            TIMx->CCER = tmpccer;
   \       0x4C   0x6203             STR      R3,[R0, #+32]
   6310          }
   \       0x4E   0xBD70             POP      {R4-R6,PC}       ;; return
   6311          
   6312          /**
   6313            * @brief  Timer Output Compare 5 configuration
   6314            * @param  TIMx to select the TIM peripheral
   6315            * @param  OC_Config The ouput configuration structure
   6316            * @retval None
   6317            */

   \                                 In section .text, align 2, keep-with-next
   6318          static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
   6319                                        TIM_OC_InitTypeDef *OC_Config)
   6320          {
   \                     TIM_OC5_SetConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   6321            uint32_t tmpccmrx;
   6322            uint32_t tmpccer;
   6323            uint32_t tmpcr2;
   6324          
   6325            /* Disable the output: Reset the CCxE Bit */
   6326            TIMx->CCER &= ~TIM_CCER_CC5E;
   \        0x2   0x....             LDR      R3,??DataTable62  ;; 0xfffeffff
   \        0x4   0x6A02             LDR      R2,[R0, #+32]
   \        0x6   0x401A             ANDS     R2,R2,R3
   \        0x8   0x6202             STR      R2,[R0, #+32]
   6327          
   6328            /* Get the TIMx CCER register value */
   6329            tmpccer = TIMx->CCER;
   \        0xA   0x6A04             LDR      R4,[R0, #+32]
   6330            /* Get the TIMx CR2 register value */
   6331            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6842             LDR      R2,[R0, #+4]
   6332            /* Get the TIMx CCMR1 register value */
   6333            tmpccmrx = TIMx->CCMR3;
   \        0xE   0x6D45             LDR      R5,[R0, #+84]
   6334          
   6335            /* Reset the Output Compare Mode Bits */
   6336            tmpccmrx &= ~(TIM_CCMR3_OC5M);
   \       0x10   0x....             LDR      R6,??DataTable55_1  ;; 0xfffeff8f
   \       0x12   0x402E             ANDS     R6,R6,R5
   6337            /* Select the Output Compare Mode */
   6338            tmpccmrx |= OC_Config->OCMode;
   \       0x14   0x680D             LDR      R5,[R1, #+0]
   \       0x16   0x4335             ORRS     R5,R5,R6
   6339          
   6340            /* Reset the Output Polarity level */
   6341            tmpccer &= ~TIM_CCER_CC5P;
   \       0x18   0x....             LDR      R6,??DataTable63  ;; 0xfffdffff
   \       0x1A   0x4026             ANDS     R6,R6,R4
   6342            /* Set the Output Compare Polarity */
   6343            tmpccer |= (OC_Config->OCPolarity << 16U);
   \       0x1C   0x688C             LDR      R4,[R1, #+8]
   \       0x1E   0x0424             LSLS     R4,R4,#+16
   \       0x20   0x4334             ORRS     R4,R4,R6
   6344          
   6345            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x22   0x....             LDR      R6,??DataTable64_1  ;; 0x40012c00
   \       0x24   0x42B0             CMP      R0,R6
   \       0x26   0xD005             BEQ      ??TIM_OC5_SetConfig_0
   \       0x28   0x....             LDR      R6,??DataTable64_2  ;; 0x40014400
   \       0x2A   0x42B0             CMP      R0,R6
   \       0x2C   0xD002             BEQ      ??TIM_OC5_SetConfig_0
   \       0x2E   0x....             LDR      R6,??DataTable64_3  ;; 0x40014800
   \       0x30   0x42B0             CMP      R0,R6
   \       0x32   0xD103             BNE      ??TIM_OC5_SetConfig_1
   6346            {
   6347              /* Reset the Output Compare IDLE State */
   6348              tmpcr2 &= ~TIM_CR2_OIS5;
   \                     ??TIM_OC5_SetConfig_0: (+1)
   \       0x34   0x4013             ANDS     R3,R3,R2
   6349              /* Set the Output Idle state */
   6350              tmpcr2 |= (OC_Config->OCIdleState << 8U);
   \       0x36   0x694A             LDR      R2,[R1, #+20]
   \       0x38   0x0212             LSLS     R2,R2,#+8
   \       0x3A   0x431A             ORRS     R2,R2,R3
   6351            }
   6352            /* Write to TIMx CR2 */
   6353            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC5_SetConfig_1: (+1)
   \       0x3C   0x6042             STR      R2,[R0, #+4]
   6354          
   6355            /* Write to TIMx CCMR3 */
   6356            TIMx->CCMR3 = tmpccmrx;
   \       0x3E   0x6545             STR      R5,[R0, #+84]
   6357          
   6358            /* Set the Capture Compare Register value */
   6359            TIMx->CCR5 = OC_Config->Pulse;
   \       0x40   0x684B             LDR      R3,[R1, #+4]
   \       0x42   0x6583             STR      R3,[R0, #+88]
   6360          
   6361            /* Write to TIMx CCER */
   6362            TIMx->CCER = tmpccer;
   \       0x44   0x6204             STR      R4,[R0, #+32]
   6363          }
   \       0x46   0xBD70             POP      {R4-R6,PC}       ;; return
   6364          
   6365          /**
   6366            * @brief  Timer Output Compare 6 configuration
   6367            * @param  TIMx to select the TIM peripheral
   6368            * @param  OC_Config The ouput configuration structure
   6369            * @retval None
   6370            */

   \                                 In section .text, align 2, keep-with-next
   6371          static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
   6372                                        TIM_OC_InitTypeDef *OC_Config)
   6373          {
   \                     TIM_OC6_SetConfig: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   6374            uint32_t tmpccmrx;
   6375            uint32_t tmpccer;
   6376            uint32_t tmpcr2;
   6377          
   6378            /* Disable the output: Reset the CCxE Bit */
   6379            TIMx->CCER &= ~TIM_CCER_CC6E;
   \        0x2   0x6A02             LDR      R2,[R0, #+32]
   \        0x4   0x....             LDR      R3,??DataTable64_4  ;; 0xffefffff
   \        0x6   0x4013             ANDS     R3,R3,R2
   \        0x8   0x6203             STR      R3,[R0, #+32]
   6380          
   6381            /* Get the TIMx CCER register value */
   6382            tmpccer = TIMx->CCER;
   \        0xA   0x6A04             LDR      R4,[R0, #+32]
   6383            /* Get the TIMx CR2 register value */
   6384            tmpcr2 =  TIMx->CR2;
   \        0xC   0x6842             LDR      R2,[R0, #+4]
   6385            /* Get the TIMx CCMR1 register value */
   6386            tmpccmrx = TIMx->CCMR3;
   \        0xE   0x6D43             LDR      R3,[R0, #+84]
   6387          
   6388            /* Reset the Output Compare Mode Bits */
   6389            tmpccmrx &= ~(TIM_CCMR3_OC6M);
   \       0x10   0x....             LDR      R5,??DataTable56_1  ;; 0xfeff8fff
   \       0x12   0x401D             ANDS     R5,R5,R3
   6390            /* Select the Output Compare Mode */
   6391            tmpccmrx |= (OC_Config->OCMode << 8U);
   \       0x14   0x680B             LDR      R3,[R1, #+0]
   \       0x16   0x021B             LSLS     R3,R3,#+8
   \       0x18   0x432B             ORRS     R3,R3,R5
   6392          
   6393            /* Reset the Output Polarity level */
   6394            tmpccer &= (uint32_t)~TIM_CCER_CC6P;
   \       0x1A   0x....             LDR      R5,??DataTable64_5  ;; 0xffdfffff
   \       0x1C   0x4025             ANDS     R5,R5,R4
   6395            /* Set the Output Compare Polarity */
   6396            tmpccer |= (OC_Config->OCPolarity << 20U);
   \       0x1E   0x688C             LDR      R4,[R1, #+8]
   \       0x20   0x0524             LSLS     R4,R4,#+20
   \       0x22   0x432C             ORRS     R4,R4,R5
   6397          
   6398            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x24   0x....             LDR      R5,??DataTable64_1  ;; 0x40012c00
   \       0x26   0x42A8             CMP      R0,R5
   \       0x28   0xD005             BEQ      ??TIM_OC6_SetConfig_0
   \       0x2A   0x....             LDR      R5,??DataTable64_2  ;; 0x40014400
   \       0x2C   0x42A8             CMP      R0,R5
   \       0x2E   0xD002             BEQ      ??TIM_OC6_SetConfig_0
   \       0x30   0x....             LDR      R5,??DataTable64_3  ;; 0x40014800
   \       0x32   0x42A8             CMP      R0,R5
   \       0x34   0xD104             BNE      ??TIM_OC6_SetConfig_1
   6399            {
   6400              /* Reset the Output Compare IDLE State */
   6401              tmpcr2 &= ~TIM_CR2_OIS6;
   \                     ??TIM_OC6_SetConfig_0: (+1)
   \       0x36   0x....             LDR      R5,??DataTable64_6  ;; 0xfffbffff
   \       0x38   0x4015             ANDS     R5,R5,R2
   6402              /* Set the Output Idle state */
   6403              tmpcr2 |= (OC_Config->OCIdleState << 10U);
   \       0x3A   0x694A             LDR      R2,[R1, #+20]
   \       0x3C   0x0292             LSLS     R2,R2,#+10
   \       0x3E   0x432A             ORRS     R2,R2,R5
   6404            }
   6405          
   6406            /* Write to TIMx CR2 */
   6407            TIMx->CR2 = tmpcr2;
   \                     ??TIM_OC6_SetConfig_1: (+1)
   \       0x40   0x6042             STR      R2,[R0, #+4]
   6408          
   6409            /* Write to TIMx CCMR3 */
   6410            TIMx->CCMR3 = tmpccmrx;
   \       0x42   0x6543             STR      R3,[R0, #+84]
   6411          
   6412            /* Set the Capture Compare Register value */
   6413            TIMx->CCR6 = OC_Config->Pulse;
   \       0x44   0x684D             LDR      R5,[R1, #+4]
   \       0x46   0x65C5             STR      R5,[R0, #+92]
   6414          
   6415            /* Write to TIMx CCER */
   6416            TIMx->CCER = tmpccer;
   \       0x48   0x6204             STR      R4,[R0, #+32]
   6417          }
   \       0x4A   0xBD30             POP      {R4,R5,PC}       ;; return
   6418          
   6419          /**
   6420            * @brief  Slave Timer configuration function
   6421            * @param  htim TIM handle
   6422            * @param  sSlaveConfig Slave timer configuration
   6423            * @retval None
   6424            */

   \                                 In section .text, align 2, keep-with-next
   6425          static HAL_StatusTypeDef TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   6426                                                            TIM_SlaveConfigTypeDef *sSlaveConfig)
   6427          {
   \                     TIM_SlaveTimer_SetConfig: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   6428            uint32_t tmpsmcr;
   6429            uint32_t tmpccmr1;
   6430            uint32_t tmpccer;
   6431          
   6432            /* Get the TIMx SMCR register value */
   6433            tmpsmcr = htim->Instance->SMCR;
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x6880             LDR      R0,[R0, #+8]
   6434          
   6435            /* Reset the Trigger Selection Bits */
   6436            tmpsmcr &= ~TIM_SMCR_TS;
   \        0xA   0x....             LDR      R1,??DataTable64_7  ;; 0xffcfff8f
   \        0xC   0x4001             ANDS     R1,R1,R0
   6437            /* Set the Input Trigger source */
   6438            tmpsmcr |= sSlaveConfig->InputTrigger;
   \        0xE   0x6860             LDR      R0,[R4, #+4]
   \       0x10   0x4308             ORRS     R0,R0,R1
   6439          
   6440            /* Reset the slave mode Bits */
   6441            tmpsmcr &= ~TIM_SMCR_SMS;
   \       0x12   0x....             LDR      R1,??DataTable64_8  ;; 0xfffefff8
   \       0x14   0x4001             ANDS     R1,R1,R0
   6442            /* Set the slave mode */
   6443            tmpsmcr |= sSlaveConfig->SlaveMode;
   \       0x16   0x6826             LDR      R6,[R4, #+0]
   \       0x18   0x430E             ORRS     R6,R6,R1
   6444          
   6445            /* Write to TIMx SMCR */
   6446            htim->Instance->SMCR = tmpsmcr;
   \       0x1A   0x6828             LDR      R0,[R5, #+0]
   \       0x1C   0x6086             STR      R6,[R0, #+8]
   6447          
   6448            /* Configure the trigger prescaler, filter, and polarity */
   6449            switch (sSlaveConfig->InputTrigger)
   \       0x1E   0x6860             LDR      R0,[R4, #+4]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD03C             BEQ      ??TIM_SlaveTimer_SetConfig_0
   \       0x24   0x2810             CMP      R0,#+16
   \       0x26   0xD03A             BEQ      ??TIM_SlaveTimer_SetConfig_0
   \       0x28   0x2820             CMP      R0,#+32
   \       0x2A   0xD038             BEQ      ??TIM_SlaveTimer_SetConfig_0
   \       0x2C   0x2830             CMP      R0,#+48
   \       0x2E   0xD036             BEQ      ??TIM_SlaveTimer_SetConfig_0
   \       0x30   0x2840             CMP      R0,#+64
   \       0x32   0xD00C             BEQ      ??TIM_SlaveTimer_SetConfig_1
   \       0x34   0x2850             CMP      R0,#+80
   \       0x36   0xD026             BEQ      ??TIM_SlaveTimer_SetConfig_2
   \       0x38   0x2860             CMP      R0,#+96
   \       0x3A   0xD02A             BEQ      ??TIM_SlaveTimer_SetConfig_3
   \       0x3C   0x2870             CMP      R0,#+112
   \       0x3E   0xD12F             BNE      ??TIM_SlaveTimer_SetConfig_4
   6450            {
   6451              case TIM_TS_ETRF:
   6452              {
   6453                /* Check the parameters */
   6454                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   6455                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   6456                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6457                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6458                /* Configure the ETR Trigger source */
   6459                TIM_ETR_SetConfig(htim->Instance,
   6460                                  sSlaveConfig->TriggerPrescaler,
   6461                                  sSlaveConfig->TriggerPolarity,
   6462                                  sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_5: (+1)
   \       0x40   0x6923             LDR      R3,[R4, #+16]
   \       0x42   0x68A2             LDR      R2,[R4, #+8]
   \       0x44   0x68E1             LDR      R1,[R4, #+12]
   \       0x46   0x6828             LDR      R0,[R5, #+0]
   \       0x48   0x....'....        BL       TIM_ETR_SetConfig
   6463                break;
   \       0x4C   0xE028             B        ??TIM_SlaveTimer_SetConfig_6
   6464              }
   6465          
   6466              case TIM_TS_TI1F_ED:
   6467              {
   6468                /* Check the parameters */
   6469                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   6470                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6471          
   6472                if(sSlaveConfig->SlaveMode == TIM_SLAVEMODE_GATED)
   \                     ??TIM_SlaveTimer_SetConfig_1: (+1)
   \       0x4E   0x6820             LDR      R0,[R4, #+0]
   \       0x50   0x2805             CMP      R0,#+5
   \       0x52   0xD101             BNE      ??TIM_SlaveTimer_SetConfig_7
   6473                {
   6474                  return HAL_ERROR;
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0xE024             B        ??TIM_SlaveTimer_SetConfig_8
   6475                }
   6476          
   6477                /* Disable the Channel 1: Reset the CC1E Bit */
   6478                tmpccer = htim->Instance->CCER;
   \                     ??TIM_SlaveTimer_SetConfig_7: (+1)
   \       0x58   0x6828             LDR      R0,[R5, #+0]
   \       0x5A   0x6A00             LDR      R0,[R0, #+32]
   \       0x5C   0x0007             MOVS     R7,R0
   6479                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   \       0x5E   0x6828             LDR      R0,[R5, #+0]
   \       0x60   0x6A00             LDR      R0,[R0, #+32]
   \       0x62   0x2101             MOVS     R1,#+1
   \       0x64   0x4388             BICS     R0,R0,R1
   \       0x66   0x6829             LDR      R1,[R5, #+0]
   \       0x68   0x6208             STR      R0,[R1, #+32]
   6480                tmpccmr1 = htim->Instance->CCMR1;
   \       0x6A   0x6828             LDR      R0,[R5, #+0]
   \       0x6C   0x6980             LDR      R0,[R0, #+24]
   6481          
   6482                /* Set the filter */
   6483                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \       0x6E   0x21F0             MOVS     R1,#+240
   \       0x70   0x4388             BICS     R0,R0,R1
   6484                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
   \       0x72   0x6921             LDR      R1,[R4, #+16]
   \       0x74   0x0109             LSLS     R1,R1,#+4
   \       0x76   0x4301             ORRS     R1,R1,R0
   \       0x78   0x9100             STR      R1,[SP, #+0]
   6485          
   6486                /* Write to TIMx CCMR1 and CCER registers */
   6487                htim->Instance->CCMR1 = tmpccmr1;
   \       0x7A   0x9800             LDR      R0,[SP, #+0]
   \       0x7C   0x6829             LDR      R1,[R5, #+0]
   \       0x7E   0x6188             STR      R0,[R1, #+24]
   6488                htim->Instance->CCER = tmpccer;
   \       0x80   0x6828             LDR      R0,[R5, #+0]
   \       0x82   0x6207             STR      R7,[R0, #+32]
   6489                break;
   \       0x84   0xE00C             B        ??TIM_SlaveTimer_SetConfig_6
   6490              }
   6491          
   6492              case TIM_TS_TI1FP1:
   6493              {
   6494                /* Check the parameters */
   6495                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   6496                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6497                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6498          
   6499                /* Configure TI1 Filter and Polarity */
   6500                TIM_TI1_ConfigInputStage(htim->Instance,
   6501                                         sSlaveConfig->TriggerPolarity,
   6502                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_2: (+1)
   \       0x86   0x6922             LDR      R2,[R4, #+16]
   \       0x88   0x68A1             LDR      R1,[R4, #+8]
   \       0x8A   0x6828             LDR      R0,[R5, #+0]
   \       0x8C   0x....'....        BL       TIM_TI1_ConfigInputStage
   6503                break;
   \       0x90   0xE006             B        ??TIM_SlaveTimer_SetConfig_6
   6504              }
   6505          
   6506              case TIM_TS_TI2FP2:
   6507              {
   6508                /* Check the parameters */
   6509                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   6510                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   6511                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   6512          
   6513                /* Configure TI2 Filter and Polarity */
   6514                TIM_TI2_ConfigInputStage(htim->Instance,
   6515                                         sSlaveConfig->TriggerPolarity,
   6516                                         sSlaveConfig->TriggerFilter);
   \                     ??TIM_SlaveTimer_SetConfig_3: (+1)
   \       0x92   0x6922             LDR      R2,[R4, #+16]
   \       0x94   0x68A1             LDR      R1,[R4, #+8]
   \       0x96   0x6828             LDR      R0,[R5, #+0]
   \       0x98   0x....'....        BL       TIM_TI2_ConfigInputStage
   6517                break;
   \       0x9C   0xE000             B        ??TIM_SlaveTimer_SetConfig_6
   6518              }
   6519          
   6520              case TIM_TS_ITR0:
   6521              case TIM_TS_ITR1:
   6522              case TIM_TS_ITR2:
   6523              case TIM_TS_ITR3:
   6524              {
   6525                /* Check the parameter */
   6526                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   6527                break;
   \                     ??TIM_SlaveTimer_SetConfig_0: (+1)
   \       0x9E   0xE7FF             B        ??TIM_SlaveTimer_SetConfig_6
   6528              }
   6529          
   6530              default:
   6531                break;
   6532            }
   6533            return HAL_OK;
   \                     ??TIM_SlaveTimer_SetConfig_4: (+1)
   \                     ??TIM_SlaveTimer_SetConfig_6: (+1)
   \       0xA0   0x2000             MOVS     R0,#+0
   \                     ??TIM_SlaveTimer_SetConfig_8: (+1)
   \       0xA2   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   6534          }
   6535          
   6536          /**
   6537            * @brief  Configure the TI1 as Input.
   6538            * @param  TIMx to select the TIM peripheral.
   6539            * @param  TIM_ICPolarity The Input Polarity.
   6540            *          This parameter can be one of the following values:
   6541            *            @arg TIM_ICPOLARITY_RISING
   6542            *            @arg TIM_ICPOLARITY_FALLING
   6543            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6544            * @param  TIM_ICSelection specifies the input to be used.
   6545            *          This parameter can be one of the following values:
   6546            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 1 is selected to be connected to IC1.
   6547            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 1 is selected to be connected to IC2.
   6548            *            @arg TIM_ICSELECTION_TRC: TIM Input 1 is selected to be connected to TRC.
   6549            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6550            *          This parameter must be a value between 0x00 and 0x0F.
   6551            * @retval None
   6552            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1
   6553            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be
   6554            *        protected against un-initialized filter and polarity values.
   6555            */

   \                                 In section .text, align 2, keep-with-next
   6556          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6557                                 uint32_t TIM_ICFilter)
   6558          {
   \                     TIM_TI1_SetConfig: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   6559            uint32_t tmpccmr1;
   6560            uint32_t tmpccer;
   6561          
   6562            /* Disable the Channel 1: Reset the CC1E Bit */
   6563            TIMx->CCER &= ~TIM_CCER_CC1E;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   \        0x4   0x2501             MOVS     R5,#+1
   \        0x6   0x43AC             BICS     R4,R4,R5
   \        0x8   0x6204             STR      R4,[R0, #+32]
   6564            tmpccmr1 = TIMx->CCMR1;
   \        0xA   0x6986             LDR      R6,[R0, #+24]
   6565            tmpccer = TIMx->CCER;
   \        0xC   0x6A05             LDR      R5,[R0, #+32]
   6566          
   6567            /* Select the Input */
   6568            if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   \        0xE   0x....             LDR      R4,??DataTable64_1  ;; 0x40012c00
   \       0x10   0x42A0             CMP      R0,R4
   \       0x12   0xD002             BEQ      ??TIM_TI1_SetConfig_0
   \       0x14   0x....             LDR      R4,??DataTable64_9  ;; 0x40000400
   \       0x16   0x42A0             CMP      R0,R4
   \       0x18   0xD101             BNE      ??TIM_TI1_SetConfig_1
   \                     ??TIM_TI1_SetConfig_0: (+1)
   \       0x1A   0x2401             MOVS     R4,#+1
   \       0x1C   0xE000             B        ??TIM_TI1_SetConfig_2
   \                     ??TIM_TI1_SetConfig_1: (+1)
   \       0x1E   0x2400             MOVS     R4,#+0
   \                     ??TIM_TI1_SetConfig_2: (+1)
   \       0x20   0xB2E4             UXTB     R4,R4
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD003             BEQ      ??TIM_TI1_SetConfig_3
   6569            {
   6570              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   \       0x26   0x2403             MOVS     R4,#+3
   \       0x28   0x43A6             BICS     R6,R6,R4
   6571              tmpccmr1 |= TIM_ICSelection;
   \       0x2A   0x4316             ORRS     R6,R6,R2
   \       0x2C   0xE002             B        ??TIM_TI1_SetConfig_4
   6572            }
   6573            else
   6574            {
   6575              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   \                     ??TIM_TI1_SetConfig_3: (+1)
   \       0x2E   0x2401             MOVS     R4,#+1
   \       0x30   0x4334             ORRS     R4,R4,R6
   \       0x32   0x0026             MOVS     R6,R4
   6576            }
   6577          
   6578            /* Set the filter */
   6579            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \                     ??TIM_TI1_SetConfig_4: (+1)
   \       0x34   0x24F0             MOVS     R4,#+240
   \       0x36   0x43A6             BICS     R6,R6,R4
   6580            tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
   \       0x38   0x011F             LSLS     R7,R3,#+4
   \       0x3A   0x24F0             MOVS     R4,#+240
   \       0x3C   0x403C             ANDS     R4,R4,R7
   \       0x3E   0x4334             ORRS     R4,R4,R6
   6581          
   6582            /* Select the Polarity and set the CC1E Bit */
   6583            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   \       0x40   0x260A             MOVS     R6,#+10
   \       0x42   0x43B5             BICS     R5,R5,R6
   6584            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   \       0x44   0x260A             MOVS     R6,#+10
   \       0x46   0x400E             ANDS     R6,R6,R1
   \       0x48   0x432E             ORRS     R6,R6,R5
   6585          
   6586            /* Write to TIMx CCMR1 and CCER registers */
   6587            TIMx->CCMR1 = tmpccmr1;
   \       0x4A   0x6184             STR      R4,[R0, #+24]
   6588            TIMx->CCER = tmpccer;
   \       0x4C   0x6206             STR      R6,[R0, #+32]
   6589          }
   \       0x4E   0xBDF0             POP      {R4-R7,PC}       ;; return
   6590          
   6591          /**
   6592            * @brief  Configure the Polarity and Filter for TI1.
   6593            * @param  TIMx to select the TIM peripheral.
   6594            * @param  TIM_ICPolarity The Input Polarity.
   6595            *          This parameter can be one of the following values:
   6596            *            @arg TIM_ICPOLARITY_RISING
   6597            *            @arg TIM_ICPOLARITY_FALLING
   6598            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6599            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6600            *          This parameter must be a value between 0x00 and 0x0F.
   6601            * @retval None
   6602            */

   \                                 In section .text, align 2, keep-with-next
   6603          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   6604          {
   \                     TIM_TI1_ConfigInputStage: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   6605            uint32_t tmpccmr1;
   6606            uint32_t tmpccer;
   6607          
   6608            /* Disable the Channel 1: Reset the CC1E Bit */
   6609            tmpccer = TIMx->CCER;
   \        0x2   0x6A03             LDR      R3,[R0, #+32]
   6610            TIMx->CCER &= ~TIM_CCER_CC1E;
   \        0x4   0x6A04             LDR      R4,[R0, #+32]
   \        0x6   0x2501             MOVS     R5,#+1
   \        0x8   0x43AC             BICS     R4,R4,R5
   \        0xA   0x6204             STR      R4,[R0, #+32]
   6611            tmpccmr1 = TIMx->CCMR1;
   \        0xC   0x6984             LDR      R4,[R0, #+24]
   6612          
   6613            /* Set the filter */
   6614            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   \        0xE   0x25F0             MOVS     R5,#+240
   \       0x10   0x43AC             BICS     R4,R4,R5
   6615            tmpccmr1 |= (TIM_ICFilter << 4U);
   \       0x12   0x0115             LSLS     R5,R2,#+4
   \       0x14   0x4325             ORRS     R5,R5,R4
   6616          
   6617            /* Select the Polarity and set the CC1E Bit */
   6618            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   \       0x16   0x240A             MOVS     R4,#+10
   \       0x18   0x43A3             BICS     R3,R3,R4
   6619            tmpccer |= TIM_ICPolarity;
   \       0x1A   0x430B             ORRS     R3,R3,R1
   6620          
   6621            /* Write to TIMx CCMR1 and CCER registers */
   6622            TIMx->CCMR1 = tmpccmr1;
   \       0x1C   0x6185             STR      R5,[R0, #+24]
   6623            TIMx->CCER = tmpccer;
   \       0x1E   0x6203             STR      R3,[R0, #+32]
   6624          }
   \       0x20   0xBC30             POP      {R4,R5}
   \       0x22   0x4770             BX       LR               ;; return
   6625          
   6626          /**
   6627            * @brief  Configure the TI2 as Input.
   6628            * @param  TIMx to select the TIM peripheral
   6629            * @param  TIM_ICPolarity The Input Polarity.
   6630            *          This parameter can be one of the following values:
   6631            *            @arg TIM_ICPOLARITY_RISING
   6632            *            @arg TIM_ICPOLARITY_FALLING
   6633            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6634            * @param  TIM_ICSelection specifies the input to be used.
   6635            *          This parameter can be one of the following values:
   6636            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 2 is selected to be connected to IC2.
   6637            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
   6638            *            @arg TIM_ICSELECTION_TRC: TIM Input 2 is selected to be connected to TRC.
   6639            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6640            *          This parameter must be a value between 0x00 and 0x0F.
   6641            * @retval None
   6642            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2
   6643            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be
   6644            *        protected against un-initialized filter and polarity values.
   6645            */

   \                                 In section .text, align 2, keep-with-next
   6646          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6647                                        uint32_t TIM_ICFilter)
   6648          {
   \                     TIM_TI2_SetConfig: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   6649            uint32_t tmpccmr1;
   6650            uint32_t tmpccer;
   6651          
   6652            /* Disable the Channel 2: Reset the CC2E Bit */
   6653            TIMx->CCER &= ~TIM_CCER_CC2E;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   \        0x4   0x2510             MOVS     R5,#+16
   \        0x6   0x43AC             BICS     R4,R4,R5
   \        0x8   0x6204             STR      R4,[R0, #+32]
   6654            tmpccmr1 = TIMx->CCMR1;
   \        0xA   0x6985             LDR      R5,[R0, #+24]
   6655            tmpccer = TIMx->CCER;
   \        0xC   0x6A04             LDR      R4,[R0, #+32]
   6656          
   6657            /* Select the Input */
   6658            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   \        0xE   0x....             LDR      R6,??DataTable64_10  ;; 0xfffffcff
   \       0x10   0x402E             ANDS     R6,R6,R5
   6659            tmpccmr1 |= (TIM_ICSelection << 8U);
   \       0x12   0x0217             LSLS     R7,R2,#+8
   \       0x14   0x4337             ORRS     R7,R7,R6
   6660          
   6661            /* Set the filter */
   6662            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   \       0x16   0x....             LDR      R5,??DataTable64_11  ;; 0xffff0fff
   \       0x18   0x403D             ANDS     R5,R5,R7
   6663            tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
   \       0x1A   0x031F             LSLS     R7,R3,#+12
   \       0x1C   0x26F0             MOVS     R6,#+240
   \       0x1E   0x0236             LSLS     R6,R6,#+8        ;; #+61440
   \       0x20   0x403E             ANDS     R6,R6,R7
   \       0x22   0x432E             ORRS     R6,R6,R5
   6664          
   6665            /* Select the Polarity and set the CC2E Bit */
   6666            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \       0x24   0x25A0             MOVS     R5,#+160
   \       0x26   0x43AC             BICS     R4,R4,R5
   6667            tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   \       0x28   0x010F             LSLS     R7,R1,#+4
   \       0x2A   0x25A0             MOVS     R5,#+160
   \       0x2C   0x403D             ANDS     R5,R5,R7
   \       0x2E   0x4325             ORRS     R5,R5,R4
   6668          
   6669            /* Write to TIMx CCMR1 and CCER registers */
   6670            TIMx->CCMR1 = tmpccmr1 ;
   \       0x30   0x6186             STR      R6,[R0, #+24]
   6671            TIMx->CCER = tmpccer;
   \       0x32   0x6205             STR      R5,[R0, #+32]
   6672          }
   \       0x34   0xBCF0             POP      {R4-R7}
   \       0x36   0x4770             BX       LR               ;; return
   6673          
   6674          /**
   6675            * @brief  Configure the Polarity and Filter for TI2.
   6676            * @param  TIMx to select the TIM peripheral.
   6677            * @param  TIM_ICPolarity The Input Polarity.
   6678            *          This parameter can be one of the following values:
   6679            *            @arg TIM_ICPOLARITY_RISING
   6680            *            @arg TIM_ICPOLARITY_FALLING
   6681            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6682            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6683            *          This parameter must be a value between 0x00 and 0x0F.
   6684            * @retval None
   6685            */

   \                                 In section .text, align 2, keep-with-next
   6686          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   6687          {
   \                     TIM_TI2_ConfigInputStage: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   6688            uint32_t tmpccmr1;
   6689            uint32_t tmpccer;
   6690          
   6691            /* Disable the Channel 2: Reset the CC2E Bit */
   6692            TIMx->CCER &= ~TIM_CCER_CC2E;
   \        0x2   0x6A03             LDR      R3,[R0, #+32]
   \        0x4   0x2410             MOVS     R4,#+16
   \        0x6   0x43A3             BICS     R3,R3,R4
   \        0x8   0x6203             STR      R3,[R0, #+32]
   6693            tmpccmr1 = TIMx->CCMR1;
   \        0xA   0x6984             LDR      R4,[R0, #+24]
   6694            tmpccer = TIMx->CCER;
   \        0xC   0x6A03             LDR      R3,[R0, #+32]
   6695          
   6696            /* Set the filter */
   6697            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   \        0xE   0x....             LDR      R5,??DataTable64_11  ;; 0xffff0fff
   \       0x10   0x4025             ANDS     R5,R5,R4
   6698            tmpccmr1 |= (TIM_ICFilter << 12U);
   \       0x12   0x0314             LSLS     R4,R2,#+12
   \       0x14   0x432C             ORRS     R4,R4,R5
   6699          
   6700            /* Select the Polarity and set the CC2E Bit */
   6701            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \       0x16   0x25A0             MOVS     R5,#+160
   \       0x18   0x43AB             BICS     R3,R3,R5
   6702            tmpccer |= (TIM_ICPolarity << 4U);
   \       0x1A   0x010D             LSLS     R5,R1,#+4
   \       0x1C   0x431D             ORRS     R5,R5,R3
   6703          
   6704            /* Write to TIMx CCMR1 and CCER registers */
   6705            TIMx->CCMR1 = tmpccmr1 ;
   \       0x1E   0x6184             STR      R4,[R0, #+24]
   6706            TIMx->CCER = tmpccer;
   \       0x20   0x6205             STR      R5,[R0, #+32]
   6707          }
   \       0x22   0xBC30             POP      {R4,R5}
   \       0x24   0x4770             BX       LR               ;; return
   6708          
   6709          /**
   6710            * @brief  Configure the TI3 as Input.
   6711            * @param  TIMx to select the TIM peripheral
   6712            * @param  TIM_ICPolarity The Input Polarity.
   6713            *          This parameter can be one of the following values:
   6714            *            @arg TIM_ICPOLARITY_RISING
   6715            *            @arg TIM_ICPOLARITY_FALLING
   6716            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6717            * @param  TIM_ICSelection specifies the input to be used.
   6718            *          This parameter can be one of the following values:
   6719            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 3 is selected to be connected to IC3.
   6720            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
   6721            *            @arg TIM_ICSELECTION_TRC: TIM Input 3 is selected to be connected to TRC.
   6722            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6723            *          This parameter must be a value between 0x00 and 0x0F.
   6724            * @retval None
   6725            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4
   6726            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   6727            *        protected against un-initialized filter and polarity values.
   6728            */

   \                                 In section .text, align 2, keep-with-next
   6729          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6730                                        uint32_t TIM_ICFilter)
   6731          {
   \                     TIM_TI3_SetConfig: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   6732            uint32_t tmpccmr2;
   6733            uint32_t tmpccer;
   6734          
   6735            /* Disable the Channel 3: Reset the CC3E Bit */
   6736            TIMx->CCER &= ~TIM_CCER_CC3E;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   \        0x4   0x....             LDR      R5,??DataTable64_12  ;; 0xfffffeff
   \        0x6   0x4025             ANDS     R5,R5,R4
   \        0x8   0x6205             STR      R5,[R0, #+32]
   6737            tmpccmr2 = TIMx->CCMR2;
   \        0xA   0x69C6             LDR      R6,[R0, #+28]
   6738            tmpccer = TIMx->CCER;
   \        0xC   0x6A05             LDR      R5,[R0, #+32]
   6739          
   6740            /* Select the Input */
   6741            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   \        0xE   0x2403             MOVS     R4,#+3
   \       0x10   0x43A6             BICS     R6,R6,R4
   6742            tmpccmr2 |= TIM_ICSelection;
   \       0x12   0x4316             ORRS     R6,R6,R2
   6743          
   6744            /* Set the filter */
   6745            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   \       0x14   0x24F0             MOVS     R4,#+240
   \       0x16   0x43A6             BICS     R6,R6,R4
   6746            tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
   \       0x18   0x011F             LSLS     R7,R3,#+4
   \       0x1A   0x24F0             MOVS     R4,#+240
   \       0x1C   0x403C             ANDS     R4,R4,R7
   \       0x1E   0x4334             ORRS     R4,R4,R6
   6747          
   6748            /* Select the Polarity and set the CC3E Bit */
   6749            tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
   \       0x20   0x....             LDR      R6,??DataTable64_13  ;; 0xfffff5ff
   \       0x22   0x402E             ANDS     R6,R6,R5
   6750            tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
   \       0x24   0x020F             LSLS     R7,R1,#+8
   \       0x26   0x25A0             MOVS     R5,#+160
   \       0x28   0x012D             LSLS     R5,R5,#+4        ;; #+2560
   \       0x2A   0x403D             ANDS     R5,R5,R7
   \       0x2C   0x4335             ORRS     R5,R5,R6
   6751          
   6752            /* Write to TIMx CCMR2 and CCER registers */
   6753            TIMx->CCMR2 = tmpccmr2;
   \       0x2E   0x61C4             STR      R4,[R0, #+28]
   6754            TIMx->CCER = tmpccer;
   \       0x30   0x6205             STR      R5,[R0, #+32]
   6755          }
   \       0x32   0xBCF0             POP      {R4-R7}
   \       0x34   0x4770             BX       LR               ;; return
   6756          
   6757          /**
   6758            * @brief  Configure the TI4 as Input.
   6759            * @param  TIMx to select the TIM peripheral
   6760            * @param  TIM_ICPolarity The Input Polarity.
   6761            *          This parameter can be one of the following values:
   6762            *            @arg TIM_ICPOLARITY_RISING
   6763            *            @arg TIM_ICPOLARITY_FALLING
   6764            *            @arg TIM_ICPOLARITY_BOTHEDGE
   6765            * @param  TIM_ICSelection specifies the input to be used.
   6766            *          This parameter can be one of the following values:
   6767            *            @arg TIM_ICSELECTION_DIRECTTI: TIM Input 4 is selected to be connected to IC4.
   6768            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
   6769            *            @arg TIM_ICSELECTION_TRC: TIM Input 4 is selected to be connected to TRC.
   6770            * @param  TIM_ICFilter Specifies the Input Capture Filter.
   6771            *          This parameter must be a value between 0x00 and 0x0F.
   6772            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3
   6773            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
   6774            *        protected against un-initialized filter and polarity values.
   6775            * @retval None
   6776            */

   \                                 In section .text, align 2, keep-with-next
   6777          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   6778                                        uint32_t TIM_ICFilter)
   6779          {
   \                     TIM_TI4_SetConfig: (+1)
   \        0x0   0xB4F0             PUSH     {R4-R7}
   6780            uint32_t tmpccmr2;
   6781            uint32_t tmpccer;
   6782          
   6783            /* Disable the Channel 4: Reset the CC4E Bit */
   6784            TIMx->CCER &= ~TIM_CCER_CC4E;
   \        0x2   0x6A04             LDR      R4,[R0, #+32]
   \        0x4   0x....             LDR      R5,??DataTable64_14  ;; 0xffffefff
   \        0x6   0x4025             ANDS     R5,R5,R4
   \        0x8   0x6205             STR      R5,[R0, #+32]
   6785            tmpccmr2 = TIMx->CCMR2;
   \        0xA   0x69C4             LDR      R4,[R0, #+28]
   6786            tmpccer = TIMx->CCER;
   \        0xC   0x6A05             LDR      R5,[R0, #+32]
   6787          
   6788            /* Select the Input */
   6789            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   \        0xE   0x....             LDR      R6,??DataTable64_10  ;; 0xfffffcff
   \       0x10   0x4026             ANDS     R6,R6,R4
   6790            tmpccmr2 |= (TIM_ICSelection << 8U);
   \       0x12   0x0214             LSLS     R4,R2,#+8
   \       0x14   0x4334             ORRS     R4,R4,R6
   6791          
   6792            /* Set the filter */
   6793            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   \       0x16   0x....             LDR      R6,??DataTable64_11  ;; 0xffff0fff
   \       0x18   0x4026             ANDS     R6,R6,R4
   6794            tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
   \       0x1A   0x031F             LSLS     R7,R3,#+12
   \       0x1C   0x24F0             MOVS     R4,#+240
   \       0x1E   0x0224             LSLS     R4,R4,#+8        ;; #+61440
   \       0x20   0x403C             ANDS     R4,R4,R7
   \       0x22   0x4334             ORRS     R4,R4,R6
   6795          
   6796            /* Select the Polarity and set the CC4E Bit */
   6797            tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
   \       0x24   0x....             LDR      R6,??DataTable64_15  ;; 0xffff5fff
   \       0x26   0x402E             ANDS     R6,R6,R5
   6798            tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
   \       0x28   0x030F             LSLS     R7,R1,#+12
   \       0x2A   0x25A0             MOVS     R5,#+160
   \       0x2C   0x022D             LSLS     R5,R5,#+8        ;; #+40960
   \       0x2E   0x403D             ANDS     R5,R5,R7
   \       0x30   0x4335             ORRS     R5,R5,R6
   6799          
   6800            /* Write to TIMx CCMR2 and CCER registers */
   6801            TIMx->CCMR2 = tmpccmr2;
   \       0x32   0x61C4             STR      R4,[R0, #+28]
   6802            TIMx->CCER = tmpccer ;
   \       0x34   0x6205             STR      R5,[R0, #+32]
   6803          }
   \       0x36   0xBCF0             POP      {R4-R7}
   \       0x38   0x4770             BX       LR               ;; return
   6804          
   6805          /**
   6806            * @brief  Selects the Input Trigger source
   6807            * @param  TIMx to select the TIM peripheral
   6808            * @param  InputTriggerSource The Input Trigger source.
   6809            *          This parameter can be one of the following values:
   6810            *            @arg TIM_TS_ITR0: Internal Trigger 0
   6811            *            @arg TIM_TS_ITR1: Internal Trigger 1
   6812            *            @arg TIM_TS_ITR2: Internal Trigger 2
   6813            *            @arg TIM_TS_ITR3: Internal Trigger 3
   6814            *            @arg TIM_TS_TI1F_ED: TI1 Edge Detector
   6815            *            @arg TIM_TS_TI1FP1: Filtered Timer Input 1
   6816            *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
   6817            *            @arg TIM_TS_ETRF: External Trigger input
   6818            * @retval None
   6819            */

   \                                 In section .text, align 2, keep-with-next
   6820          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
   6821          {
   6822            uint32_t tmpsmcr;
   6823          
   6824            /* Get the TIMx SMCR register value */
   6825            tmpsmcr = TIMx->SMCR;
   \                     TIM_ITRx_SetConfig: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   6826            /* Reset the TS Bits */
   6827            tmpsmcr &= ~TIM_SMCR_TS;
   \        0x2   0x....             LDR      R3,??DataTable64_7  ;; 0xffcfff8f
   \        0x4   0x4013             ANDS     R3,R3,R2
   6828            /* Set the Input Trigger source and the slave mode*/
   6829            tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
   \        0x6   0x2207             MOVS     R2,#+7
   \        0x8   0x430A             ORRS     R2,R2,R1
   \        0xA   0x431A             ORRS     R2,R2,R3
   6830            /* Write to TIMx SMCR */
   6831            TIMx->SMCR = tmpsmcr;
   \        0xC   0x6082             STR      R2,[R0, #+8]
   6832          }
   \        0xE   0x4770             BX       LR               ;; return
   6833          /**
   6834            * @brief  Configures the TIMx External Trigger (ETR).
   6835            * @param  TIMx to select the TIM peripheral
   6836            * @param  TIM_ExtTRGPrescaler The external Trigger Prescaler.
   6837            *          This parameter can be one of the following values:
   6838            *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
   6839            *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
   6840            *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
   6841            *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
   6842            * @param  TIM_ExtTRGPolarity The external Trigger Polarity.
   6843            *          This parameter can be one of the following values:
   6844            *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
   6845            *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
   6846            * @param  ExtTRGFilter External Trigger Filter.
   6847            *          This parameter must be a value between 0x00 and 0x0F
   6848            * @retval None
   6849            */

   \                                 In section .text, align 2, keep-with-next
   6850          void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
   6851                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   6852          {
   \                     TIM_ETR_SetConfig: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   6853            uint32_t tmpsmcr;
   6854          
   6855            tmpsmcr = TIMx->SMCR;
   \        0x2   0x6884             LDR      R4,[R0, #+8]
   6856          
   6857            /* Reset the ETR Bits */
   6858            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   \        0x4   0x....             LDR      R5,??DataTable64_16  ;; 0xffff00ff
   \        0x6   0x4025             ANDS     R5,R5,R4
   6859          
   6860            /* Set the Prescaler, the Filter value and the Polarity */
   6861            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   \        0x8   0x0016             MOVS     R6,R2
   \        0xA   0x430E             ORRS     R6,R6,R1
   \        0xC   0x021C             LSLS     R4,R3,#+8
   \        0xE   0x4334             ORRS     R4,R4,R6
   \       0x10   0x432C             ORRS     R4,R4,R5
   6862          
   6863            /* Write to TIMx SMCR */
   6864            TIMx->SMCR = tmpsmcr;
   \       0x12   0x6084             STR      R4,[R0, #+8]
   6865          }
   \       0x14   0xBC70             POP      {R4-R6}
   \       0x16   0x4770             BX       LR               ;; return
   6866          
   6867          /**
   6868            * @brief  Enables or disables the TIM Capture Compare Channel x.
   6869            * @param  TIMx to select the TIM peripheral
   6870            * @param  Channel specifies the TIM Channel
   6871            *          This parameter can be one of the following values:
   6872            *            @arg TIM_CHANNEL_1: TIM Channel 1
   6873            *            @arg TIM_CHANNEL_2: TIM Channel 2
   6874            *            @arg TIM_CHANNEL_3: TIM Channel 3
   6875            *            @arg TIM_CHANNEL_4: TIM Channel 4
   6876            *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
   6877            *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
   6878            * @param  ChannelState specifies the TIM Channel CCxE bit new state.
   6879            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
   6880            * @retval None
   6881            */

   \                                 In section .text, align 2, keep-with-next
   6882          void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
   6883          {
   \                     TIM_CCxChannelCmd: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   6884            uint32_t tmp;
   6885          
   6886            /* Check the parameters */
   6887            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   6888            assert_param(IS_TIM_CHANNELS(Channel));
   6889          
   6890            tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   \        0x2   0x231F             MOVS     R3,#+31
   \        0x4   0x2401             MOVS     R4,#+1
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x401D             ANDS     R5,R5,R3
   \        0xA   0x40AC             LSLS     R4,R4,R5
   6891          
   6892            /* Reset the CCxE Bit */
   6893            TIMx->CCER &= ~tmp;
   \        0xC   0x6A05             LDR      R5,[R0, #+32]
   \        0xE   0x43A5             BICS     R5,R5,R4
   \       0x10   0x6205             STR      R5,[R0, #+32]
   6894          
   6895            /* Set or reset the CCxE Bit */
   6896            TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   \       0x12   0x6A05             LDR      R5,[R0, #+32]
   \       0x14   0x000E             MOVS     R6,R1
   \       0x16   0x4033             ANDS     R3,R3,R6
   \       0x18   0x0016             MOVS     R6,R2
   \       0x1A   0x409E             LSLS     R6,R6,R3
   \       0x1C   0x432E             ORRS     R6,R6,R5
   \       0x1E   0x6206             STR      R6,[R0, #+32]
   6897          }
   \       0x20   0xBC70             POP      {R4-R6}
   \       0x22   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x0001'0007        DC32     0x10007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0xFFFF'7FFF        DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0x0001'0007        DC32     0x10007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \        0x0   0xFFFF'F7FF        DC32     0xfffff7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \        0x0   0xFFFF'EFFF        DC32     0xffffefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0xFFFF'7FFF        DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x0001'0007        DC32     0x10007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0xFFFF'7FFF        DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \        0x0   0x0001'0007        DC32     0x10007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \        0x0   0xFFFF'F7FF        DC32     0xfffff7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \        0x0   0xFFFF'EFFF        DC32     0xffffefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \        0x0   0xFFFF'7FFF        DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \        0x0   0x....'....        DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \        0x0   0x....'....        DC32     TIM_DMACaptureHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32:
   \        0x0   0x0001'0007        DC32     0x10007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_1:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_2:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_3:
   \        0x0   0xFFFF'F7FF        DC32     0xfffff7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_4:
   \        0x0   0xFFFF'EFFF        DC32     0xffffefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable32_5:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable33:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable34_1:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35_1:
   \        0x0   0xFFFF'7FFF        DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \        0x0   0xFFFE'BFF8        DC32     0xfffebff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_2:
   \        0x0   0xFFFF'FCFC        DC32     0xfffffcfc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_3:
   \        0x0   0xFFFF'F3F3        DC32     0xfffff3f3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_4:
   \        0x0   0xFFFF'0F0F        DC32     0xffff0f0f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_5:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39:
   \        0x0   0x....'....        DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_1:
   \        0x0   0x....'....        DC32     TIM_DMACaptureHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable39_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_1:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_2:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable40_3:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable42:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43:
   \        0x0   0xFFFF'F3FF        DC32     0xfffff3ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable43_1:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44:
   \        0x0   0xFFCF'FF8F        DC32     0xffcfff8f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_1:
   \        0x0   0xFFFE'FFF8        DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_2:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_3:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_4:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_5:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_6:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_7:
   \        0x0   0x....'....        DC32     TIMEx_DMACommutationCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_8:
   \        0x0   0x....'....        DC32     TIMEx_DMACommutationHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable44_9:
   \        0x0   0x....'....        DC32     TIM_DMATriggerCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45:
   \        0x0   0x....'....        DC32     TIM_DMATriggerHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_1:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_2:
   \        0x0   0x....'....        DC32     TIM_DMAPeriodElapsedHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_3:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_4:
   \        0x0   0x....'....        DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable45_5:
   \        0x0   0x....'....        DC32     TIM_DMACaptureHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46:
   \        0x0   0x....'....        DC32     TIMEx_DMACommutationCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_1:
   \        0x0   0x....'....        DC32     TIMEx_DMACommutationHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable46_2:
   \        0x0   0x....'....        DC32     TIM_DMATriggerCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable48:
   \        0x0   0xFFFF'00F7        DC32     0xffff00f7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49:
   \        0x0   0xFFFF'7FFF        DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_1:
   \        0x0   0xFFCE'FF88        DC32     0xffceff88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable49_2:
   \        0x0   0xFFFF'00FF        DC32     0xffff00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable50:
   \        0x0   0xFFFF'BFFF        DC32     0xffffbfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable54:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable54_1:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable54_2:
   \        0x0   0x4000'2000        DC32     0x40002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable54_3:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable54_4:
   \        0x0   0xFFFF'FCFF        DC32     0xfffffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable55_1:
   \        0x0   0xFFFE'FF8F        DC32     0xfffeff8f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_1:
   \        0x0   0xFEFF'8FFF        DC32     0xfeff8fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable56_2:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable57:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58:
   \        0x0   0xFFFF'F7FF        DC32     0xfffff7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable58_1:
   \        0x0   0xFFFF'EFFF        DC32     0xffffefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable60:
   \        0x0   0xFFFF'DFFF        DC32     0xffffdfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable62:
   \        0x0   0xFFFE'FFFF        DC32     0xfffeffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable63:
   \        0x0   0xFFFD'FFFF        DC32     0xfffdffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64:
   \        0x0   0xFFFF'BFFF        DC32     0xffffbfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_1:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_2:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_3:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_4:
   \        0x0   0xFFEF'FFFF        DC32     0xffefffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_5:
   \        0x0   0xFFDF'FFFF        DC32     0xffdfffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_6:
   \        0x0   0xFFFB'FFFF        DC32     0xfffbffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_7:
   \        0x0   0xFFCF'FF8F        DC32     0xffcfff8f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_8:
   \        0x0   0xFFFE'FFF8        DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_9:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_10:
   \        0x0   0xFFFF'FCFF        DC32     0xfffffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_11:
   \        0x0   0xFFFF'0FFF        DC32     0xffff0fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_12:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_13:
   \        0x0   0xFFFF'F5FF        DC32     0xfffff5ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_14:
   \        0x0   0xFFFF'EFFF        DC32     0xffffefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_15:
   \        0x0   0xFFFF'5FFF        DC32     0xffff5fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable64_16:
   \        0x0   0xFFFF'00FF        DC32     0xffff00ff
   6898          
   6899          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   6900          /**
   6901            * @brief  Reset interrupt callbacks to the legacy weak callbacks.
   6902            * @param  htim pointer to a TIM_HandleTypeDef structure that contains
   6903            *                the configuration information for TIM module.
   6904            * @retval None
   6905            */
   6906          void TIM_ResetCallback(TIM_HandleTypeDef *htim)
   6907          {
   6908            /* Reset the TIM callback to the legacy weak callbacks */
   6909            htim->PeriodElapsedCallback             = HAL_TIM_PeriodElapsedCallback;             /* Legacy weak PeriodElapsedCallback             */
   6910            htim->PeriodElapsedHalfCpltCallback     = HAL_TIM_PeriodElapsedHalfCpltCallback;     /* Legacy weak PeriodElapsedHalfCpltCallback     */
   6911            htim->TriggerCallback                   = HAL_TIM_TriggerCallback;                   /* Legacy weak TriggerCallback                   */
   6912            htim->TriggerHalfCpltCallback           = HAL_TIM_TriggerHalfCpltCallback;           /* Legacy weak TriggerHalfCpltCallback           */
   6913            htim->IC_CaptureCallback                = HAL_TIM_IC_CaptureCallback;                /* Legacy weak IC_CaptureCallback                */
   6914            htim->IC_CaptureHalfCpltCallback        = HAL_TIM_IC_CaptureHalfCpltCallback;        /* Legacy weak IC_CaptureHalfCpltCallback        */
   6915            htim->OC_DelayElapsedCallback           = HAL_TIM_OC_DelayElapsedCallback;           /* Legacy weak OC_DelayElapsedCallback           */
   6916            htim->PWM_PulseFinishedCallback         = HAL_TIM_PWM_PulseFinishedCallback;         /* Legacy weak PWM_PulseFinishedCallback         */
   6917            htim->PWM_PulseFinishedHalfCpltCallback = HAL_TIM_PWM_PulseFinishedHalfCpltCallback; /* Legacy weak PWM_PulseFinishedHalfCpltCallback */
   6918            htim->ErrorCallback                     = HAL_TIM_ErrorCallback;                     /* Legacy weak ErrorCallback                     */
   6919            htim->CommutationCallback               = HAL_TIMEx_CommutCallback;                  /* Legacy weak CommutationCallback               */
   6920            htim->CommutationHalfCpltCallback       = HAL_TIMEx_CommutHalfCpltCallback;          /* Legacy weak CommutationHalfCpltCallback       */
   6921            htim->BreakCallback                     = HAL_TIMEx_BreakCallback;                   /* Legacy weak BreakCallback                     */
   6922            htim->Break2Callback                    = HAL_TIMEx_Break2Callback;                  /* Legacy weak Break2Callback                    */
   6923          }
   6924          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   6925          
   6926          /**
   6927            * @}
   6928            */
   6929          
   6930          #endif /* HAL_TIM_MODULE_ENABLED */
   6931          /**
   6932            * @}
   6933            */
   6934          
   6935          /**
   6936            * @}
   6937            */
   6938          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
       8   HAL_TIM_Base_Init
         8   -> HAL_TIM_Base_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       4   HAL_TIM_Base_Start
      16   HAL_TIM_Base_Start_DMA
        16   -> HAL_DMA_Start_IT
       4   HAL_TIM_Base_Start_IT
       4   HAL_TIM_Base_Stop
       8   HAL_TIM_Base_Stop_DMA
         8   -> HAL_DMA_Abort_IT
       4   HAL_TIM_Base_Stop_IT
      24   HAL_TIM_ConfigClockSource
        24   -> TIM_ETR_SetConfig
        24   -> TIM_ITRx_SetConfig
        24   -> TIM_TI1_ConfigInputStage
        24   -> TIM_TI2_ConfigInputStage
      24   HAL_TIM_ConfigOCrefClear
        24   -> TIM_ETR_SetConfig
       0   HAL_TIM_ConfigTI1Input
      24   HAL_TIM_DMABurst_ReadStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort_IT
      24   HAL_TIM_DMABurst_WriteStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort_IT
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      16   HAL_TIM_Encoder_Init
        16   -> HAL_TIM_Encoder_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
      16   HAL_TIM_Encoder_Start
        16   -> TIM_CCxChannelCmd
      32   HAL_TIM_Encoder_Start_DMA
        32   -> HAL_DMA_Start_IT
        32   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_ErrorCallback
       8   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
       0   HAL_TIM_IC_CaptureHalfCpltCallback
      24   HAL_TIM_IC_ConfigChannel
        24   -> TIM_TI1_SetConfig
        24   -> TIM_TI2_SetConfig
        24   -> TIM_TI3_SetConfig
        24   -> TIM_TI4_SetConfig
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
       8   HAL_TIM_IC_Init
         8   -> HAL_TIM_IC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
      16   HAL_TIM_IC_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_IC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IRQHandler
        16   -> HAL_TIMEx_Break2Callback
        16   -> HAL_TIMEx_BreakCallback
        16   -> HAL_TIMEx_CommutCallback
        16   -> HAL_TIM_IC_CaptureCallback
        16   -> HAL_TIM_OC_DelayElapsedCallback
        16   -> HAL_TIM_PWM_PulseFinishedCallback
        16   -> HAL_TIM_PeriodElapsedCallback
        16   -> HAL_TIM_TriggerCallback
      24   HAL_TIM_OC_ConfigChannel
        24   -> TIM_OC1_SetConfig
        24   -> TIM_OC2_SetConfig
        24   -> TIM_OC3_SetConfig
        24   -> TIM_OC4_SetConfig
        24   -> TIM_OC5_SetConfig
        24   -> TIM_OC6_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
       8   HAL_TIM_OC_Init
         8   -> HAL_TIM_OC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
      16   HAL_TIM_OC_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_OC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_IT
        16   -> TIM_CCxChannelCmd
      56   HAL_TIM_OnePulse_ConfigChannel
        56   -> TIM_OC1_SetConfig
        56   -> TIM_OC2_SetConfig
        56   -> TIM_TI1_SetConfig
        56   -> TIM_TI2_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
      16   HAL_TIM_OnePulse_Start
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop_IT
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_ConfigChannel
        24   -> TIM_OC1_SetConfig
        24   -> TIM_OC2_SetConfig
        24   -> TIM_OC3_SetConfig
        24   -> TIM_OC4_SetConfig
        24   -> TIM_OC5_SetConfig
        24   -> TIM_OC6_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
       8   HAL_TIM_PWM_Init
         8   -> HAL_TIM_PWM_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
       0   HAL_TIM_PWM_PulseFinishedHalfCpltCallback
      16   HAL_TIM_PWM_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_PeriodElapsedHalfCpltCallback
       4   HAL_TIM_ReadCapturedValue
      16   HAL_TIM_SlaveConfigSynchro
        16   -> TIM_SlaveTimer_SetConfig
      16   HAL_TIM_SlaveConfigSynchro_IT
        16   -> TIM_SlaveTimer_SetConfig
       0   HAL_TIM_TriggerCallback
       0   HAL_TIM_TriggerHalfCpltCallback
       8   TIM_Base_SetConfig
      12   TIM_CCxChannelCmd
      16   TIM_DMACaptureCplt
        16   -> HAL_TIM_IC_CaptureCallback
      16   TIM_DMACaptureHalfCplt
        16   -> HAL_TIM_IC_CaptureHalfCpltCallback
      16   TIM_DMADelayPulseCplt
        16   -> HAL_TIM_PWM_PulseFinishedCallback
      16   TIM_DMADelayPulseHalfCplt
        16   -> HAL_TIM_PWM_PulseFinishedHalfCpltCallback
      16   TIM_DMAError
        16   -> HAL_TIM_ErrorCallback
      16   TIM_DMAPeriodElapsedCplt
        16   -> HAL_TIM_PeriodElapsedCallback
      16   TIM_DMAPeriodElapsedHalfCplt
        16   -> HAL_TIM_PeriodElapsedHalfCpltCallback
      16   TIM_DMATriggerCplt
        16   -> HAL_TIM_TriggerCallback
      16   TIM_DMATriggerHalfCplt
        16   -> HAL_TIM_TriggerHalfCpltCallback
      12   TIM_ETR_SetConfig
       0   TIM_ITRx_SetConfig
      16   TIM_OC1_SetConfig
      16   TIM_OC2_SetConfig
      20   TIM_OC3_SetConfig
      16   TIM_OC4_SetConfig
      16   TIM_OC5_SetConfig
      12   TIM_OC6_SetConfig
      24   TIM_SlaveTimer_SetConfig
        24   -> TIM_ETR_SetConfig
        24   -> TIM_TI1_ConfigInputStage
        24   -> TIM_TI2_ConfigInputStage
       8   TIM_TI1_ConfigInputStage
      20   TIM_TI1_SetConfig
       8   TIM_TI2_ConfigInputStage
      16   TIM_TI2_SetConfig
      16   TIM_TI3_SetConfig
      16   TIM_TI4_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable13
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable21
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_2
       4  ??DataTable32
       4  ??DataTable32_1
       4  ??DataTable32_2
       4  ??DataTable32_3
       4  ??DataTable32_4
       4  ??DataTable32_5
       4  ??DataTable33
       4  ??DataTable34
       4  ??DataTable34_1
       4  ??DataTable35
       4  ??DataTable35_1
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable37_2
       4  ??DataTable37_3
       4  ??DataTable37_4
       4  ??DataTable37_5
       4  ??DataTable39
       4  ??DataTable39_1
       4  ??DataTable39_2
       4  ??DataTable40
       4  ??DataTable40_1
       4  ??DataTable40_2
       4  ??DataTable40_3
       4  ??DataTable42
       4  ??DataTable43
       4  ??DataTable43_1
       4  ??DataTable44
       4  ??DataTable44_1
       4  ??DataTable44_2
       4  ??DataTable44_3
       4  ??DataTable44_4
       4  ??DataTable44_5
       4  ??DataTable44_6
       4  ??DataTable44_7
       4  ??DataTable44_8
       4  ??DataTable44_9
       4  ??DataTable45
       4  ??DataTable45_1
       4  ??DataTable45_2
       4  ??DataTable45_3
       4  ??DataTable45_4
       4  ??DataTable45_5
       4  ??DataTable46
       4  ??DataTable46_1
       4  ??DataTable46_2
       4  ??DataTable48
       4  ??DataTable49
       4  ??DataTable49_1
       4  ??DataTable49_2
       4  ??DataTable50
       4  ??DataTable54
       4  ??DataTable54_1
       4  ??DataTable54_2
       4  ??DataTable54_3
       4  ??DataTable54_4
       4  ??DataTable55
       4  ??DataTable55_1
       4  ??DataTable56
       4  ??DataTable56_1
       4  ??DataTable56_2
       4  ??DataTable57
       4  ??DataTable58
       4  ??DataTable58_1
       4  ??DataTable60
       4  ??DataTable62
       4  ??DataTable63
       4  ??DataTable64
       4  ??DataTable64_1
       4  ??DataTable64_10
       4  ??DataTable64_11
       4  ??DataTable64_12
       4  ??DataTable64_13
       4  ??DataTable64_14
       4  ??DataTable64_15
       4  ??DataTable64_16
       4  ??DataTable64_2
       4  ??DataTable64_3
       4  ??DataTable64_4
       4  ??DataTable64_5
       4  ??DataTable64_6
       4  ??DataTable64_7
       4  ??DataTable64_8
       4  ??DataTable64_9
       4  ??DataTable8
       4  ??DataTable9
       4  ??DataTable9_1
      68  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
      56  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      52  HAL_TIM_Base_Start
     144  HAL_TIM_Base_Start_DMA
      50  HAL_TIM_Base_Start_IT
      56  HAL_TIM_Base_Stop
      68  HAL_TIM_Base_Stop_DMA
      56  HAL_TIM_Base_Stop_IT
     240  HAL_TIM_ConfigClockSource
     380  HAL_TIM_ConfigOCrefClear
      20  HAL_TIM_ConfigTI1Input
     460  HAL_TIM_DMABurst_ReadStart
     162  HAL_TIM_DMABurst_ReadStop
     460  HAL_TIM_DMABurst_WriteStart
     162  HAL_TIM_DMABurst_WriteStop
      68  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     160  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      78  HAL_TIM_Encoder_Start
     382  HAL_TIM_Encoder_Start_DMA
     126  HAL_TIM_Encoder_Start_IT
     102  HAL_TIM_Encoder_Stop
     176  HAL_TIM_Encoder_Stop_DMA
     152  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      46  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
       2  HAL_TIM_IC_CaptureHalfCpltCallback
     212  HAL_TIM_IC_ConfigChannel
      68  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
      56  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
      52  HAL_TIM_IC_Start
     358  HAL_TIM_IC_Start_DMA
     128  HAL_TIM_IC_Start_IT
      56  HAL_TIM_IC_Stop
     162  HAL_TIM_IC_Stop_DMA
     132  HAL_TIM_IC_Stop_IT
     458  HAL_TIM_IRQHandler
     134  HAL_TIM_OC_ConfigChannel
      68  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
      56  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
     102  HAL_TIM_OC_Start
     408  HAL_TIM_OC_Start_DMA
     178  HAL_TIM_OC_Start_IT
     128  HAL_TIM_OC_Stop
     234  HAL_TIM_OC_Stop_DMA
     204  HAL_TIM_OC_Stop_IT
     278  HAL_TIM_OnePulse_ConfigChannel
      68  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
      80  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      80  HAL_TIM_OnePulse_Start
     104  HAL_TIM_OnePulse_Start_IT
     138  HAL_TIM_OnePulse_Stop
     162  HAL_TIM_OnePulse_Stop_IT
     362  HAL_TIM_PWM_ConfigChannel
      68  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
      56  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
       2  HAL_TIM_PWM_PulseFinishedHalfCpltCallback
     102  HAL_TIM_PWM_Start
     408  HAL_TIM_PWM_Start_DMA
     178  HAL_TIM_PWM_Start_IT
     134  HAL_TIM_PWM_Stop
     234  HAL_TIM_PWM_Stop_DMA
     204  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
       2  HAL_TIM_PeriodElapsedHalfCpltCallback
      60  HAL_TIM_ReadCapturedValue
      94  HAL_TIM_SlaveConfigSynchro
      94  HAL_TIM_SlaveConfigSynchro_IT
       2  HAL_TIM_TriggerCallback
       2  HAL_TIM_TriggerHalfCpltCallback
     106  TIM_Base_SetConfig
      36  TIM_CCxChannelCmd
      68  TIM_DMACaptureCplt
      68  TIM_DMACaptureHalfCplt
      68  TIM_DMADelayPulseCplt
      68  TIM_DMADelayPulseHalfCplt
      20  TIM_DMAError
      20  TIM_DMAPeriodElapsedCplt
      20  TIM_DMAPeriodElapsedHalfCplt
      20  TIM_DMATriggerCplt
      20  TIM_DMATriggerHalfCplt
      24  TIM_ETR_SetConfig
      16  TIM_ITRx_SetConfig
     112  TIM_OC1_SetConfig
     110  TIM_OC2_SetConfig
     106  TIM_OC3_SetConfig
      80  TIM_OC4_SetConfig
      72  TIM_OC5_SetConfig
      76  TIM_OC6_SetConfig
     164  TIM_SlaveTimer_SetConfig
      36  TIM_TI1_ConfigInputStage
      80  TIM_TI1_SetConfig
      38  TIM_TI2_ConfigInputStage
      56  TIM_TI2_SetConfig
      54  TIM_TI3_SetConfig
      58  TIM_TI4_SetConfig

 
 12'038 bytes in section .text
 
 11'994 bytes of CODE memory (+ 44 bytes shared)

Errors: none
Warnings: none

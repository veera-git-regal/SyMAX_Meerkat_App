###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         04/Feb/2022  12:58:55
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_gpio.c
#    Command line      =
#        -f C:\Users\610126~1\AppData\Local\Temp\EWE1.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_gpio.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\stm32g0xx_hal_gpio.lst
#    Object file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\stm32g0xx_hal_gpio.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32g0xx_hal_gpio.c
      4            * @author  MCD Application Team
      5            * @brief   GPIO HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the General Purpose Input/Output (GPIO) peripheral:
      8            *           + Initialization and de-initialization functions
      9            *           + IO operation functions
     10            *
     11            @verbatim
     12            ==============================================================================
     13                              ##### GPIO Peripheral features #####
     14            ==============================================================================
     15            [..]
     16              (+) Each port bit of the general-purpose I/O (GPIO) ports can be individually
     17                  configured by software in several modes:
     18                  (++) Input mode
     19                  (++) Analog mode
     20                  (++) Output mode
     21                  (++) Alternate function mode
     22                  (++) External interrupt/event lines
     23          
     24              (+) During and just after reset, the alternate functions and external interrupt
     25                  lines are not active and the I/O ports are configured in input floating mode.
     26          
     27              (+) All GPIO pins have weak internal pull-up and pull-down resistors, which can be
     28                  activated or not.
     29          
     30              (+) In Output or Alternate mode, each IO can be configured on open-drain or push-pull
     31                  type and the IO speed can be selected depending on the VDD value.
     32          
     33              (+) The microcontroller IO pins are connected to onboard peripherals/modules through a
     34                  multiplexer that allows only one peripheral alternate function (AF) connected
     35                 to an IO pin at a time. In this way, there can be no conflict between peripherals
     36                 sharing the same IO pin.
     37          
     38              (+) All ports have external interrupt/event capability. To use external interrupt
     39                  lines, the port must be configured in input mode. All available GPIO pins are
     40                  connected to the 16 external interrupt/event lines from EXTI0 to EXTI15.
     41          
     42              (+) The external interrupt/event controller consists of up to 28 edge detectors
     43                  (16 lines are connected to GPIO) for generating event/interrupt requests (each
     44                  input line can be independently configured to select the type (interrupt or event)
     45                  and the corresponding trigger event (rising or falling or both). Each line can
     46                  also be masked independently.
     47          
     48                               ##### How to use this driver #####
     49            ==============================================================================
     50            [..]
     51              (#) Enable the GPIO AHB clock using the following function: __HAL_RCC_GPIOx_CLK_ENABLE().
     52          
     53              (#) Configure the GPIO pin(s) using HAL_GPIO_Init().
     54                  (++) Configure the IO mode using "Mode" member from GPIO_InitTypeDef structure
     55                  (++) Activate Pull-up, Pull-down resistor using "Pull" member from GPIO_InitTypeDef
     56                       structure.
     57                  (++) In case of Output or alternate function mode selection: the speed is
     58                       configured through "Speed" member from GPIO_InitTypeDef structure.
     59                  (++) In alternate mode is selection, the alternate function connected to the IO
     60                       is configured through "Alternate" member from GPIO_InitTypeDef structure.
     61                  (++) Analog mode is required when a pin is to be used as ADC channel
     62                       or DAC output.
     63                  (++) In case of external interrupt/event selection the "Mode" member from
     64                       GPIO_InitTypeDef structure select the type (interrupt or event) and
     65                       the corresponding trigger event (rising or falling or both).
     66          
     67              (#) In case of external interrupt/event mode selection, configure NVIC IRQ priority
     68                  mapped to the EXTI line using HAL_NVIC_SetPriority() and enable it using
     69                  HAL_NVIC_EnableIRQ().
     70          
     71              (#) To get the level of a pin configured in input mode use HAL_GPIO_ReadPin().
     72          
     73              (#) To set/reset the level of a pin configured in output mode use
     74                  HAL_GPIO_WritePin()/HAL_GPIO_TogglePin().
     75          
     76             (#) To lock pin configuration until next reset use HAL_GPIO_LockPin().
     77          
     78              (#) During and just after reset, the alternate functions are not
     79                  active and the GPIO pins are configured in input floating mode (except JTAG
     80                  pins).
     81          
     82              (#) The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as general purpose
     83                  (PC14 and PC15, respectively) when the LSE oscillator is off. The LSE has
     84                  priority over the GPIO function.
     85          
     86              (#) The HSE oscillator pins OSC_IN/OSC_OUT can be used as
     87                  general purpose PF0 and PF1, respectively, when the HSE oscillator is off.
     88                  The HSE has priority over the GPIO function.
     89          
     90            @endverbatim
     91            ******************************************************************************
     92            * @attention
     93            *
     94            * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics. 
     95            * All rights reserved.</center></h2>
     96            *
     97            * This software component is licensed by ST under BSD 3-Clause license,
     98            * the "License"; You may not use this file except in compliance with the 
     99            * License. You may obtain a copy of the License at:
    100            *                        opensource.org/licenses/BSD-3-Clause
    101            *
    102            ******************************************************************************
    103            */
    104          
    105          /* Includes ------------------------------------------------------------------*/
    106          #include "stm32g0xx_hal.h"
    107          
    108          /** @addtogroup STM32G0xx_HAL_Driver
    109            * @{
    110            */
    111          
    112          /** @addtogroup GPIO
    113            * @{
    114            */
    115          /** MISRA C:2012 deviation rule has been granted for following rules:
    116            * Rule-12.2 - Medium: RHS argument is in interval [0,INF] which is out of
    117            * range of the shift operator in following API :
    118            * HAL_GPIO_Init
    119            * HAL_GPIO_DeInit
    120            */
    121          
    122          #ifdef HAL_GPIO_MODULE_ENABLED
    123          
    124          /* Private typedef -----------------------------------------------------------*/
    125          /* Private defines ------------------------------------------------------------*/
    126          /** @defgroup GPIO_Private_Constants GPIO Private Constants
    127            * @{
    128            */
    129          #define GPIO_MODE             (0x00000003u)
    130          #define EXTI_MODE             (0x10000000u)
    131          #define GPIO_MODE_IT          (0x00010000u)
    132          #define GPIO_MODE_EVT         (0x00020000u)
    133          #define RISING_EDGE           (0x00100000u)
    134          #define FALLING_EDGE          (0x00200000u)
    135          #define GPIO_OUTPUT_TYPE      (0x00000010u)
    136          
    137          #define GPIO_NUMBER           (16u)
    138          /**
    139            * @}
    140            */
    141          
    142          /* Private macros ------------------------------------------------------------*/
    143          /* Private variables ---------------------------------------------------------*/
    144          /* Private function prototypes -----------------------------------------------*/
    145          /* Exported functions --------------------------------------------------------*/
    146          
    147          /** @addtogroup GPIO_Exported_Functions
    148            * @{
    149            */
    150          
    151          /** @addtogroup GPIO_Exported_Functions_Group1
    152           *  @brief    Initialization and Configuration functions
    153           *
    154          @verbatim
    155           ===============================================================================
    156                        ##### Initialization and de-initialization functions #####
    157           ===============================================================================
    158          
    159          @endverbatim
    160            * @{
    161            */
    162          
    163          /**
    164            * @brief  Initialize the GPIOx peripheral according to the specified parameters in the GPIO_Init.
    165            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32G0xx family
    166            * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
    167            *         the configuration information for the specified GPIO peripheral.
    168            * @retval None
    169            */

   \                                 In section .text, align 2, keep-with-next
    170          void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
    171          {
   \                     HAL_GPIO_Init: (+1)
   \        0x0   0xB5FC             PUSH     {R2-R7,LR}
   \        0x2   0x0002             MOVS     R2,R0
    172            uint32_t position = 0x00u;
   \        0x4   0x2400             MOVS     R4,#+0
    173            uint32_t iocurrent;
    174            uint32_t temp;
    175          
    176            /* Check the parameters */
    177            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    178            assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
    179            assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
    180            assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
    181          
    182            /* Configure the port pins */
    183            while (((GPIO_Init->Pin) >> position) != 0x00u)
   \                     ??HAL_GPIO_Init_0: (+1)
   \        0x6   0x6808             LDR      R0,[R1, #+0]
   \        0x8   0x40E0             LSRS     R0,R0,R4
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD100             BNE      .+4
   \        0xE   0xE0E9             B        ??HAL_GPIO_Init_1
    184            {
    185              /* Get current io position */
    186              iocurrent = (GPIO_Init->Pin) & (1uL << position);
   \       0x10   0x2501             MOVS     R5,#+1
   \       0x12   0x6808             LDR      R0,[R1, #+0]
   \       0x14   0x002E             MOVS     R6,R5
   \       0x16   0x40A6             LSLS     R6,R6,R4
   \       0x18   0x4006             ANDS     R6,R6,R0
   \       0x1A   0x9601             STR      R6,[SP, #+4]
    187          
    188              if (iocurrent != 0x00u)
   \       0x1C   0x9801             LDR      R0,[SP, #+4]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD100             BNE      .+4
   \       0x22   0xE0DD             B        ??HAL_GPIO_Init_2
    189              {
    190                /*--------------------- GPIO Mode Configuration ------------------------*/
    191                /* In case of Alternate function mode selection */
    192                if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
   \       0x24   0x6848             LDR      R0,[R1, #+4]
   \       0x26   0x2802             CMP      R0,#+2
   \       0x28   0xD002             BEQ      ??HAL_GPIO_Init_3
   \       0x2A   0x6848             LDR      R0,[R1, #+4]
   \       0x2C   0x2812             CMP      R0,#+18
   \       0x2E   0xD11F             BNE      ??HAL_GPIO_Init_4
    193                {
    194                  /* Check the Alternate function parameters */
    195                  assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
    196                  assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
    197          
    198                  /* Configure Alternate function mapped with the current IO */
    199                  temp = GPIOx->AFR[position >> 3u];
   \                     ??HAL_GPIO_Init_3: (+1)
   \       0x30   0x08E0             LSRS     R0,R4,#+3
   \       0x32   0x2604             MOVS     R6,#+4
   \       0x34   0x4370             MULS     R0,R6,R0
   \       0x36   0x1810             ADDS     R0,R2,R0
   \       0x38   0x6A07             LDR      R7,[R0, #+32]
    200                  temp &= ~(0xFu << ((position & 0x07u) * 4u));
   \       0x3A   0x2007             MOVS     R0,#+7
   \       0x3C   0x9700             STR      R7,[SP, #+0]
   \       0x3E   0x260F             MOVS     R6,#+15
   \       0x40   0x46B4             MOV      R12,R6
   \       0x42   0x0027             MOVS     R7,R4
   \       0x44   0x4007             ANDS     R7,R7,R0
   \       0x46   0x2604             MOVS     R6,#+4
   \       0x48   0x4377             MULS     R7,R6,R7
   \       0x4A   0x4666             MOV      R6,R12
   \       0x4C   0x40BE             LSLS     R6,R6,R7
   \       0x4E   0x9F00             LDR      R7,[SP, #+0]
   \       0x50   0x43B7             BICS     R7,R7,R6
    201                  temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
   \       0x52   0x46BC             MOV      R12,R7
   \       0x54   0x690E             LDR      R6,[R1, #+16]
   \       0x56   0x0027             MOVS     R7,R4
   \       0x58   0x4038             ANDS     R0,R0,R7
   \       0x5A   0x2704             MOVS     R7,#+4
   \       0x5C   0x4378             MULS     R0,R7,R0
   \       0x5E   0x4086             LSLS     R6,R6,R0
   \       0x60   0x4667             MOV      R7,R12
   \       0x62   0x433E             ORRS     R6,R6,R7
   \       0x64   0x0033             MOVS     R3,R6
    202                  GPIOx->AFR[position >> 3u] = temp;
   \       0x66   0x08E0             LSRS     R0,R4,#+3
   \       0x68   0x2604             MOVS     R6,#+4
   \       0x6A   0x4370             MULS     R0,R6,R0
   \       0x6C   0x1810             ADDS     R0,R2,R0
   \       0x6E   0x6203             STR      R3,[R0, #+32]
    203                }
    204          
    205                /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
    206                temp = GPIOx->MODER;
   \                     ??HAL_GPIO_Init_4: (+1)
   \       0x70   0x6817             LDR      R7,[R2, #+0]
    207                temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
   \       0x72   0x2603             MOVS     R6,#+3
   \       0x74   0x46BC             MOV      R12,R7
   \       0x76   0x0027             MOVS     R7,R4
   \       0x78   0x2002             MOVS     R0,#+2
   \       0x7A   0x4347             MULS     R7,R0,R7
   \       0x7C   0x0030             MOVS     R0,R6
   \       0x7E   0x40B8             LSLS     R0,R0,R7
   \       0x80   0x4667             MOV      R7,R12
   \       0x82   0x4387             BICS     R7,R7,R0
    208                temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
   \       0x84   0x9700             STR      R7,[SP, #+0]
   \       0x86   0x684F             LDR      R7,[R1, #+4]
   \       0x88   0x4037             ANDS     R7,R7,R6
   \       0x8A   0x46BC             MOV      R12,R7
   \       0x8C   0x0020             MOVS     R0,R4
   \       0x8E   0x2702             MOVS     R7,#+2
   \       0x90   0x4378             MULS     R0,R7,R0
   \       0x92   0x4667             MOV      R7,R12
   \       0x94   0x4087             LSLS     R7,R7,R0
   \       0x96   0x9800             LDR      R0,[SP, #+0]
   \       0x98   0x4307             ORRS     R7,R7,R0
    209                GPIOx->MODER = temp;
   \       0x9A   0x6017             STR      R7,[R2, #+0]
    210          
    211                /* In case of Output or Alternate function mode selection */
    212                if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
    213                    (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
   \       0x9C   0x6848             LDR      R0,[R1, #+4]
   \       0x9E   0x2801             CMP      R0,#+1
   \       0xA0   0xD008             BEQ      ??HAL_GPIO_Init_5
   \       0xA2   0x6848             LDR      R0,[R1, #+4]
   \       0xA4   0x2802             CMP      R0,#+2
   \       0xA6   0xD005             BEQ      ??HAL_GPIO_Init_5
   \       0xA8   0x6848             LDR      R0,[R1, #+4]
   \       0xAA   0x2811             CMP      R0,#+17
   \       0xAC   0xD002             BEQ      ??HAL_GPIO_Init_5
   \       0xAE   0x6848             LDR      R0,[R1, #+4]
   \       0xB0   0x2812             CMP      R0,#+18
   \       0xB2   0xD120             BNE      ??HAL_GPIO_Init_6
    214                {
    215                  /* Check the Speed parameter */
    216                  assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
    217                  /* Configure the IO Speed */
    218                  temp = GPIOx->OSPEEDR;
   \                     ??HAL_GPIO_Init_5: (+1)
   \       0xB4   0x6893             LDR      R3,[R2, #+8]
    219                  temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
   \       0xB6   0x469C             MOV      R12,R3
   \       0xB8   0x0023             MOVS     R3,R4
   \       0xBA   0x2002             MOVS     R0,#+2
   \       0xBC   0x4343             MULS     R3,R0,R3
   \       0xBE   0x0030             MOVS     R0,R6
   \       0xC0   0x4098             LSLS     R0,R0,R3
   \       0xC2   0x4663             MOV      R3,R12
   \       0xC4   0x4383             BICS     R3,R3,R0
    220                  temp |= (GPIO_Init->Speed << (position * 2u));
   \       0xC6   0x9300             STR      R3,[SP, #+0]
   \       0xC8   0x68C8             LDR      R0,[R1, #+12]
   \       0xCA   0x4684             MOV      R12,R0
   \       0xCC   0x0023             MOVS     R3,R4
   \       0xCE   0x2002             MOVS     R0,#+2
   \       0xD0   0x4343             MULS     R3,R0,R3
   \       0xD2   0x4660             MOV      R0,R12
   \       0xD4   0x4098             LSLS     R0,R0,R3
   \       0xD6   0x9B00             LDR      R3,[SP, #+0]
   \       0xD8   0x4318             ORRS     R0,R0,R3
   \       0xDA   0x9000             STR      R0,[SP, #+0]
    221                  GPIOx->OSPEEDR = temp;
   \       0xDC   0x9800             LDR      R0,[SP, #+0]
   \       0xDE   0x6090             STR      R0,[R2, #+8]
    222          
    223                  /* Configure the IO Output Type */
    224                  temp = GPIOx->OTYPER;
   \       0xE0   0x6853             LDR      R3,[R2, #+4]
    225                  temp &= ~(GPIO_OTYPER_OT0 << position) ;
   \       0xE2   0x0028             MOVS     R0,R5
   \       0xE4   0x40A0             LSLS     R0,R0,R4
   \       0xE6   0x4383             BICS     R3,R3,R0
    226                  temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
   \       0xE8   0x6848             LDR      R0,[R1, #+4]
   \       0xEA   0x0900             LSRS     R0,R0,#+4
   \       0xEC   0x4028             ANDS     R0,R0,R5
   \       0xEE   0x40A0             LSLS     R0,R0,R4
   \       0xF0   0x4318             ORRS     R0,R0,R3
   \       0xF2   0x0007             MOVS     R7,R0
    227                  GPIOx->OTYPER = temp;
   \       0xF4   0x6057             STR      R7,[R2, #+4]
    228                }
    229          
    230                /* Activate the Pull-up or Pull down resistor for the current IO */
    231                temp = GPIOx->PUPDR;
   \                     ??HAL_GPIO_Init_6: (+1)
   \       0xF6   0x68D3             LDR      R3,[R2, #+12]
    232                temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
   \       0xF8   0x469C             MOV      R12,R3
   \       0xFA   0x0023             MOVS     R3,R4
   \       0xFC   0x2002             MOVS     R0,#+2
   \       0xFE   0x4343             MULS     R3,R0,R3
   \      0x100   0x0030             MOVS     R0,R6
   \      0x102   0x4098             LSLS     R0,R0,R3
   \      0x104   0x4663             MOV      R3,R12
   \      0x106   0x4383             BICS     R3,R3,R0
    233                temp |= ((GPIO_Init->Pull) << (position * 2u));
   \      0x108   0x9300             STR      R3,[SP, #+0]
   \      0x10A   0x688B             LDR      R3,[R1, #+8]
   \      0x10C   0x469C             MOV      R12,R3
   \      0x10E   0x0020             MOVS     R0,R4
   \      0x110   0x2302             MOVS     R3,#+2
   \      0x112   0x4358             MULS     R0,R3,R0
   \      0x114   0x4663             MOV      R3,R12
   \      0x116   0x4083             LSLS     R3,R3,R0
   \      0x118   0x9800             LDR      R0,[SP, #+0]
   \      0x11A   0x4303             ORRS     R3,R3,R0
    234                GPIOx->PUPDR = temp;
   \      0x11C   0x60D3             STR      R3,[R2, #+12]
    235          
    236                /*--------------------- EXTI Mode Configuration ------------------------*/
    237                /* Configure the External Interrupt or event for the current IO */
    238                if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
   \      0x11E   0x6848             LDR      R0,[R1, #+4]
   \      0x120   0x00C0             LSLS     R0,R0,#+3
   \      0x122   0xD55D             BPL      ??HAL_GPIO_Init_2
    239                {
    240                  temp = EXTI->EXTICR[position >> 2u];
   \      0x124   0x....             LDR      R0,??DataTable2  ;; 0x40021860
   \      0x126   0x4684             MOV      R12,R0
   \      0x128   0x08A7             LSRS     R7,R4,#+2
   \      0x12A   0x2004             MOVS     R0,#+4
   \      0x12C   0x4347             MULS     R7,R0,R7
   \      0x12E   0x4660             MOV      R0,R12
   \      0x130   0x59C0             LDR      R0,[R0, R7]
    241                  temp &= ~(0x0FuL << (8u * (position & 0x03u)));
   \      0x132   0x9000             STR      R0,[SP, #+0]
   \      0x134   0x270F             MOVS     R7,#+15
   \      0x136   0x46BC             MOV      R12,R7
   \      0x138   0x0027             MOVS     R7,R4
   \      0x13A   0x0030             MOVS     R0,R6
   \      0x13C   0x4038             ANDS     R0,R0,R7
   \      0x13E   0x2708             MOVS     R7,#+8
   \      0x140   0x4378             MULS     R0,R7,R0
   \      0x142   0x4667             MOV      R7,R12
   \      0x144   0x4087             LSLS     R7,R7,R0
   \      0x146   0x9800             LDR      R0,[SP, #+0]
   \      0x148   0x43B8             BICS     R0,R0,R7
    242                  temp |= (GPIO_GET_INDEX(GPIOx) << (8u * (position & 0x03u)));
   \      0x14A   0x27A0             MOVS     R7,#+160
   \      0x14C   0x05FF             LSLS     R7,R7,#+23       ;; #+1342177280
   \      0x14E   0x42BA             CMP      R2,R7
   \      0x150   0xD101             BNE      ??HAL_GPIO_Init_7
   \      0x152   0x2500             MOVS     R5,#+0
   \      0x154   0xE00D             B        ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_7: (+1)
   \      0x156   0x....             LDR      R3,??DataTable2_1  ;; 0x50000400
   \      0x158   0x429A             CMP      R2,R3
   \      0x15A   0xD00A             BEQ      ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_9: (+1)
   \      0x15C   0x....             LDR      R3,??DataTable2_2  ;; 0x50000800
   \      0x15E   0x429A             CMP      R2,R3
   \      0x160   0xD101             BNE      ??HAL_GPIO_Init_10
   \      0x162   0x2502             MOVS     R5,#+2
   \      0x164   0xE005             B        ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_10: (+1)
   \      0x166   0x....             LDR      R3,??DataTable2_3  ;; 0x50000c00
   \      0x168   0x429A             CMP      R2,R3
   \      0x16A   0xD101             BNE      ??HAL_GPIO_Init_11
   \      0x16C   0x0035             MOVS     R5,R6
   \      0x16E   0xE000             B        ??HAL_GPIO_Init_8
   \                     ??HAL_GPIO_Init_11: (+1)
   \      0x170   0x2505             MOVS     R5,#+5
   \                     ??HAL_GPIO_Init_8: (+1)
   \      0x172   0x0023             MOVS     R3,R4
   \      0x174   0x401E             ANDS     R6,R6,R3
   \      0x176   0x2308             MOVS     R3,#+8
   \      0x178   0x435E             MULS     R6,R3,R6
   \      0x17A   0x40B5             LSLS     R5,R5,R6
   \      0x17C   0x4305             ORRS     R5,R5,R0
    243                  EXTI->EXTICR[position >> 2u] = temp;
   \      0x17E   0x....             LDR      R0,??DataTable2  ;; 0x40021860
   \      0x180   0x08A3             LSRS     R3,R4,#+2
   \      0x182   0x2604             MOVS     R6,#+4
   \      0x184   0x4373             MULS     R3,R6,R3
   \      0x186   0x50C5             STR      R5,[R0, R3]
    244          
    245                  /* Clear EXTI line configuration */
    246                  temp = EXTI->IMR1;
   \      0x188   0x....             LDR      R3,??DataTable2_4  ;; 0x40021880
   \      0x18A   0x6818             LDR      R0,[R3, #+0]
    247                  temp &= ~(iocurrent);
   \      0x18C   0x9E01             LDR      R6,[SP, #+4]
   \      0x18E   0x43B0             BICS     R0,R0,R6
    248                  if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
   \      0x190   0x684E             LDR      R6,[R1, #+4]
   \      0x192   0x03F6             LSLS     R6,R6,#+15
   \      0x194   0xD502             BPL      ??HAL_GPIO_Init_12
    249                  {
    250                    temp |= iocurrent;
   \      0x196   0x0005             MOVS     R5,R0
   \      0x198   0x9801             LDR      R0,[SP, #+4]
   \      0x19A   0x4328             ORRS     R0,R0,R5
    251                  }
    252                  EXTI->IMR1 = temp;
   \                     ??HAL_GPIO_Init_12: (+1)
   \      0x19C   0x6018             STR      R0,[R3, #+0]
    253          
    254                  temp = EXTI->EMR1;
   \      0x19E   0x....             LDR      R5,??DataTable2_5  ;; 0x40021884
   \      0x1A0   0x682B             LDR      R3,[R5, #+0]
    255                  temp &= ~(iocurrent);
   \      0x1A2   0x9E01             LDR      R6,[SP, #+4]
   \      0x1A4   0x43B3             BICS     R3,R3,R6
    256                  if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
   \      0x1A6   0x684E             LDR      R6,[R1, #+4]
   \      0x1A8   0x03B6             LSLS     R6,R6,#+14
   \      0x1AA   0xD502             BPL      ??HAL_GPIO_Init_13
    257                  {
    258                    temp |= iocurrent;
   \      0x1AC   0x0018             MOVS     R0,R3
   \      0x1AE   0x9B01             LDR      R3,[SP, #+4]
   \      0x1B0   0x4303             ORRS     R3,R3,R0
    259                  }
    260                  EXTI->EMR1 = temp;
   \                     ??HAL_GPIO_Init_13: (+1)
   \      0x1B2   0x602B             STR      R3,[R5, #+0]
    261          
    262                  /* Clear Rising Falling edge configuration */
    263                  temp = EXTI->RTSR1;
   \      0x1B4   0x....             LDR      R5,??DataTable2_6  ;; 0x40021800
   \      0x1B6   0x6828             LDR      R0,[R5, #+0]
    264                  temp &= ~(iocurrent);
   \      0x1B8   0x9E01             LDR      R6,[SP, #+4]
   \      0x1BA   0x43B0             BICS     R0,R0,R6
    265                  if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
   \      0x1BC   0x684E             LDR      R6,[R1, #+4]
   \      0x1BE   0x02F6             LSLS     R6,R6,#+11
   \      0x1C0   0xD502             BPL      ??HAL_GPIO_Init_14
    266                  {
    267                    temp |= iocurrent;
   \      0x1C2   0x0003             MOVS     R3,R0
   \      0x1C4   0x9801             LDR      R0,[SP, #+4]
   \      0x1C6   0x4318             ORRS     R0,R0,R3
    268                  }
    269                  EXTI->RTSR1 = temp;
   \                     ??HAL_GPIO_Init_14: (+1)
   \      0x1C8   0x6028             STR      R0,[R5, #+0]
    270          
    271                  temp = EXTI->FTSR1;
   \      0x1CA   0x....             LDR      R5,??DataTable2_7  ;; 0x40021804
   \      0x1CC   0x682B             LDR      R3,[R5, #+0]
    272                  temp &= ~(iocurrent);
   \      0x1CE   0x9E01             LDR      R6,[SP, #+4]
   \      0x1D0   0x43B3             BICS     R3,R3,R6
    273                  if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
   \      0x1D2   0x684E             LDR      R6,[R1, #+4]
   \      0x1D4   0x02B6             LSLS     R6,R6,#+10
   \      0x1D6   0xD502             BPL      ??HAL_GPIO_Init_15
    274                  {
    275                    temp |= iocurrent;
   \      0x1D8   0x0018             MOVS     R0,R3
   \      0x1DA   0x9B01             LDR      R3,[SP, #+4]
   \      0x1DC   0x4303             ORRS     R3,R3,R0
    276                  }
    277                  EXTI->FTSR1 = temp;
   \                     ??HAL_GPIO_Init_15: (+1)
   \      0x1DE   0x602B             STR      R3,[R5, #+0]
    278                }
    279              }
    280          
    281              position++;
   \                     ??HAL_GPIO_Init_2: (+1)
   \      0x1E0   0x1C64             ADDS     R4,R4,#+1
   \      0x1E2   0xE710             B        ??HAL_GPIO_Init_0
    282            }
    283          }
   \                     ??HAL_GPIO_Init_1: (+1)
   \      0x1E4   0xBDF3             POP      {R0,R1,R4-R7,PC}  ;; return
    284          
    285          /**
    286            * @brief  De-initialize the GPIOx peripheral registers to their default reset values.
    287            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32G0xx family
    288            * @param  GPIO_Pin specifies the port bit to be written.
    289            *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    290            * @retval None
    291            */

   \                                 In section .text, align 2, keep-with-next
    292          void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
    293          {
   \                     HAL_GPIO_DeInit: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x0001             MOVS     R1,R0
    294            uint32_t position = 0x00u;
   \        0x6   0x2200             MOVS     R2,#+0
    295            uint32_t iocurrent;
    296            uint32_t tmp;
    297          
    298            /* Check the parameters */
    299            assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
    300            assert_param(IS_GPIO_PIN(GPIO_Pin));
    301          
    302            /* Configure the port pins */
    303            while ((GPIO_Pin >> position) != 0x00u)
   \                     ??HAL_GPIO_DeInit_0: (+1)
   \        0x8   0x9802             LDR      R0,[SP, #+8]
   \        0xA   0x40D0             LSRS     R0,R0,R2
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD100             BNE      .+4
   \       0x10   0xE093             B        ??HAL_GPIO_DeInit_1
    304            {
    305              /* Get current io position */
    306              iocurrent = (GPIO_Pin) & (1uL << position);
   \       0x12   0x2301             MOVS     R3,#+1
   \       0x14   0x9802             LDR      R0,[SP, #+8]
   \       0x16   0x001C             MOVS     R4,R3
   \       0x18   0x4094             LSLS     R4,R4,R2
   \       0x1A   0x4004             ANDS     R4,R4,R0
   \       0x1C   0x9400             STR      R4,[SP, #+0]
    307          
    308              if (iocurrent != 0x00u)
   \       0x1E   0x9800             LDR      R0,[SP, #+0]
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD100             BNE      .+4
   \       0x24   0xE087             B        ??HAL_GPIO_DeInit_2
    309              {
    310                /*------------------------- EXTI Mode Configuration --------------------*/
    311                /* Clear the External Interrupt or Event for the current IO */
    312          
    313                tmp = EXTI->EXTICR[position >> 2u];
   \       0x26   0x....             LDR      R0,??DataTable2  ;; 0x40021860
   \       0x28   0x0894             LSRS     R4,R2,#+2
   \       0x2A   0x2504             MOVS     R5,#+4
   \       0x2C   0x436C             MULS     R4,R5,R4
   \       0x2E   0x5900             LDR      R0,[R0, R4]
    314                tmp &= (0x0FuL << (8u * (position & 0x03u)));
   \       0x30   0x2403             MOVS     R4,#+3
   \       0x32   0x250F             MOVS     R5,#+15
   \       0x34   0x0016             MOVS     R6,R2
   \       0x36   0x0027             MOVS     R7,R4
   \       0x38   0x4037             ANDS     R7,R7,R6
   \       0x3A   0x2608             MOVS     R6,#+8
   \       0x3C   0x4377             MULS     R7,R6,R7
   \       0x3E   0x002E             MOVS     R6,R5
   \       0x40   0x40BE             LSLS     R6,R6,R7
   \       0x42   0x4006             ANDS     R6,R6,R0
   \       0x44   0x9601             STR      R6,[SP, #+4]
    315                if (tmp == (GPIO_GET_INDEX(GPIOx) << (8u * (position & 0x03u))))
   \       0x46   0x20A0             MOVS     R0,#+160
   \       0x48   0x05C0             LSLS     R0,R0,#+23       ;; #+1342177280
   \       0x4A   0x4281             CMP      R1,R0
   \       0x4C   0xD101             BNE      ??HAL_GPIO_DeInit_3
   \       0x4E   0x2600             MOVS     R6,#+0
   \       0x50   0xE00F             B        ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_3: (+1)
   \       0x52   0x....             LDR      R0,??DataTable2_1  ;; 0x50000400
   \       0x54   0x4281             CMP      R1,R0
   \       0x56   0xD101             BNE      ??HAL_GPIO_DeInit_5
   \       0x58   0x001E             MOVS     R6,R3
   \       0x5A   0xE00A             B        ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_5: (+1)
   \       0x5C   0x....             LDR      R0,??DataTable2_2  ;; 0x50000800
   \       0x5E   0x4281             CMP      R1,R0
   \       0x60   0xD101             BNE      ??HAL_GPIO_DeInit_6
   \       0x62   0x2602             MOVS     R6,#+2
   \       0x64   0xE005             B        ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_6: (+1)
   \       0x66   0x....             LDR      R0,??DataTable2_3  ;; 0x50000c00
   \       0x68   0x4281             CMP      R1,R0
   \       0x6A   0xD101             BNE      ??HAL_GPIO_DeInit_7
   \       0x6C   0x0026             MOVS     R6,R4
   \       0x6E   0xE000             B        ??HAL_GPIO_DeInit_4
   \                     ??HAL_GPIO_DeInit_7: (+1)
   \       0x70   0x2605             MOVS     R6,#+5
   \                     ??HAL_GPIO_DeInit_4: (+1)
   \       0x72   0x9801             LDR      R0,[SP, #+4]
   \       0x74   0x4684             MOV      R12,R0
   \       0x76   0x0017             MOVS     R7,R2
   \       0x78   0x0020             MOVS     R0,R4
   \       0x7A   0x4038             ANDS     R0,R0,R7
   \       0x7C   0x2708             MOVS     R7,#+8
   \       0x7E   0x4378             MULS     R0,R7,R0
   \       0x80   0x4086             LSLS     R6,R6,R0
   \       0x82   0x4660             MOV      R0,R12
   \       0x84   0x42B0             CMP      R0,R6
   \       0x86   0xD128             BNE      ??HAL_GPIO_DeInit_8
    316                {
    317                  /* Clear EXTI line configuration */
    318                  EXTI->IMR1 &= ~(iocurrent);
   \       0x88   0x....             LDR      R0,??DataTable2_4  ;; 0x40021880
   \       0x8A   0x6806             LDR      R6,[R0, #+0]
   \       0x8C   0x9F00             LDR      R7,[SP, #+0]
   \       0x8E   0x43BE             BICS     R6,R6,R7
   \       0x90   0x6006             STR      R6,[R0, #+0]
    319                  EXTI->EMR1 &= ~(iocurrent);
   \       0x92   0x....             LDR      R0,??DataTable2_5  ;; 0x40021884
   \       0x94   0x6806             LDR      R6,[R0, #+0]
   \       0x96   0x9F00             LDR      R7,[SP, #+0]
   \       0x98   0x43BE             BICS     R6,R6,R7
   \       0x9A   0x6006             STR      R6,[R0, #+0]
    320          
    321                  /* Clear Rising Falling edge configuration */
    322                  EXTI->RTSR1 &= ~(iocurrent);
   \       0x9C   0x....             LDR      R0,??DataTable2_6  ;; 0x40021800
   \       0x9E   0x6806             LDR      R6,[R0, #+0]
   \       0xA0   0x9F00             LDR      R7,[SP, #+0]
   \       0xA2   0x43BE             BICS     R6,R6,R7
   \       0xA4   0x6006             STR      R6,[R0, #+0]
    323                  EXTI->FTSR1 &= ~(iocurrent);
   \       0xA6   0x....             LDR      R0,??DataTable2_7  ;; 0x40021804
   \       0xA8   0x6806             LDR      R6,[R0, #+0]
   \       0xAA   0x9F00             LDR      R7,[SP, #+0]
   \       0xAC   0x43BE             BICS     R6,R6,R7
   \       0xAE   0x6006             STR      R6,[R0, #+0]
    324          
    325                  tmp = 0x0FuL << (8u * (position & 0x03u));
   \       0xB0   0x0016             MOVS     R6,R2
   \       0xB2   0x0020             MOVS     R0,R4
   \       0xB4   0x4030             ANDS     R0,R0,R6
   \       0xB6   0x2608             MOVS     R6,#+8
   \       0xB8   0x4370             MULS     R0,R6,R0
   \       0xBA   0x002E             MOVS     R6,R5
   \       0xBC   0x4086             LSLS     R6,R6,R0
   \       0xBE   0x9601             STR      R6,[SP, #+4]
    326                  EXTI->EXTICR[position >> 2u] &= ~tmp;
   \       0xC0   0x....             LDR      R6,??DataTable2  ;; 0x40021860
   \       0xC2   0x0890             LSRS     R0,R2,#+2
   \       0xC4   0x2704             MOVS     R7,#+4
   \       0xC6   0x4378             MULS     R0,R7,R0
   \       0xC8   0x5837             LDR      R7,[R6, R0]
   \       0xCA   0x9801             LDR      R0,[SP, #+4]
   \       0xCC   0x4387             BICS     R7,R7,R0
   \       0xCE   0x46B4             MOV      R12,R6
   \       0xD0   0x0890             LSRS     R0,R2,#+2
   \       0xD2   0x2604             MOVS     R6,#+4
   \       0xD4   0x4370             MULS     R0,R6,R0
   \       0xD6   0x4666             MOV      R6,R12
   \       0xD8   0x5037             STR      R7,[R6, R0]
    327                }
    328          
    329                /*------------------------- GPIO Mode Configuration --------------------*/
    330                /* Configure IO in Analog Mode */
    331                GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2u));
   \                     ??HAL_GPIO_DeInit_8: (+1)
   \       0xDA   0x6808             LDR      R0,[R1, #+0]
   \       0xDC   0x0017             MOVS     R7,R2
   \       0xDE   0x2602             MOVS     R6,#+2
   \       0xE0   0x4377             MULS     R7,R6,R7
   \       0xE2   0x0026             MOVS     R6,R4
   \       0xE4   0x40BE             LSLS     R6,R6,R7
   \       0xE6   0x4306             ORRS     R6,R6,R0
   \       0xE8   0x600E             STR      R6,[R1, #+0]
    332          
    333                /* Configure the default Alternate Function in current IO */
    334                GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * 4u)) ;
   \       0xEA   0x08D0             LSRS     R0,R2,#+3
   \       0xEC   0x2604             MOVS     R6,#+4
   \       0xEE   0x4370             MULS     R0,R6,R0
   \       0xF0   0x180E             ADDS     R6,R1,R0
   \       0xF2   0x08D0             LSRS     R0,R2,#+3
   \       0xF4   0x2704             MOVS     R7,#+4
   \       0xF6   0x4378             MULS     R0,R7,R0
   \       0xF8   0x1808             ADDS     R0,R1,R0
   \       0xFA   0x6A00             LDR      R0,[R0, #+32]
   \       0xFC   0x46AC             MOV      R12,R5
   \       0xFE   0x0015             MOVS     R5,R2
   \      0x100   0x076F             LSLS     R7,R5,#+29       ;; ZeroExtS R7,R5,#+29,#+29
   \      0x102   0x0F7F             LSRS     R7,R7,#+29
   \      0x104   0x2504             MOVS     R5,#+4
   \      0x106   0x436F             MULS     R7,R5,R7
   \      0x108   0x4665             MOV      R5,R12
   \      0x10A   0x40BD             LSLS     R5,R5,R7
   \      0x10C   0x43A8             BICS     R0,R0,R5
   \      0x10E   0x6230             STR      R0,[R6, #+32]
    335          
    336                /* Configure the default value for IO Speed */
    337                GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
   \      0x110   0x688D             LDR      R5,[R1, #+8]
   \      0x112   0x0016             MOVS     R6,R2
   \      0x114   0x2002             MOVS     R0,#+2
   \      0x116   0x4346             MULS     R6,R0,R6
   \      0x118   0x0020             MOVS     R0,R4
   \      0x11A   0x40B0             LSLS     R0,R0,R6
   \      0x11C   0x4385             BICS     R5,R5,R0
   \      0x11E   0x608D             STR      R5,[R1, #+8]
    338          
    339                /* Configure the default value IO Output Type */
    340                GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
   \      0x120   0x6848             LDR      R0,[R1, #+4]
   \      0x122   0x4093             LSLS     R3,R3,R2
   \      0x124   0x4398             BICS     R0,R0,R3
   \      0x126   0x6048             STR      R0,[R1, #+4]
    341          
    342                /* Deactivate the Pull-up and Pull-down resistor for the current IO */
    343                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
   \      0x128   0x68C8             LDR      R0,[R1, #+12]
   \      0x12A   0x0013             MOVS     R3,R2
   \      0x12C   0x2502             MOVS     R5,#+2
   \      0x12E   0x436B             MULS     R3,R5,R3
   \      0x130   0x409C             LSLS     R4,R4,R3
   \      0x132   0x43A0             BICS     R0,R0,R4
   \      0x134   0x60C8             STR      R0,[R1, #+12]
    344              }
    345          
    346              position++;
   \                     ??HAL_GPIO_DeInit_2: (+1)
   \      0x136   0x1C52             ADDS     R2,R2,#+1
   \      0x138   0xE766             B        ??HAL_GPIO_DeInit_0
    347            }
    348          }
   \                     ??HAL_GPIO_DeInit_1: (+1)
   \      0x13A   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    349          
    350          /**
    351            * @}
    352            */
    353          
    354          /** @addtogroup GPIO_Exported_Functions_Group2
    355           *  @brief GPIO Read, Write, Toggle, Lock and EXTI management functions.
    356           *
    357          @verbatim
    358           ===============================================================================
    359                                 ##### IO operation functions #####
    360           ===============================================================================
    361          
    362          @endverbatim
    363            * @{
    364            */
    365          
    366          /**
    367            * @brief  Read the specified input port pin.
    368            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32G0xx family
    369            * @param  GPIO_Pin specifies the port bit to read.
    370            *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    371            * @retval The input port pin value.
    372            */

   \                                 In section .text, align 2, keep-with-next
    373          GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
    374          {
   \                     HAL_GPIO_ReadPin: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0002             MOVS     R2,R0
    375            GPIO_PinState bitstatus;
    376          
    377            /* Check the parameters */
    378            assert_param(IS_GPIO_PIN(GPIO_Pin));
    379          
    380            if ((GPIOx->IDR & GPIO_Pin) != 0x00u)
   \        0x4   0x6910             LDR      R0,[R2, #+16]
   \        0x6   0x000B             MOVS     R3,R1
   \        0x8   0xB29B             UXTH     R3,R3
   \        0xA   0x4018             ANDS     R0,R0,R3
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD001             BEQ      ??HAL_GPIO_ReadPin_0
    381            {
    382              bitstatus = GPIO_PIN_SET;
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xE000             B        ??HAL_GPIO_ReadPin_1
    383            }
    384            else
    385            {
    386              bitstatus = GPIO_PIN_RESET;
   \                     ??HAL_GPIO_ReadPin_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
    387            }
    388            return bitstatus;
   \                     ??HAL_GPIO_ReadPin_1: (+1)
   \       0x16   0xB2C0             UXTB     R0,R0
   \       0x18   0xBD00             POP      {PC}             ;; return
    389          }
    390          
    391          /**
    392            * @brief  Set or clear the selected data port bit.
    393            *
    394            * @note   This function uses GPIOx_BSRR and GPIOx_BRR registers to allow atomic read/modify
    395            *         accesses. In this way, there is no risk of an IRQ occurring between
    396            *         the read and the modify access.
    397            *
    398            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32G0xx family
    399            * @param  GPIO_Pin specifies the port bit to be written.
    400            *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    401            * @param  PinState specifies the value to be written to the selected bit.
    402            *         This parameter can be one of the GPIO_PinState enum values:
    403            *            @arg GPIO_PIN_RESET: to clear the port pin
    404            *            @arg GPIO_PIN_SET: to set the port pin
    405            * @retval None
    406            */

   \                                 In section .text, align 2, keep-with-next
    407          void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
    408          {
   \                     HAL_GPIO_WritePin: (+1)
   \        0x0   0xB500             PUSH     {LR}
    409            /* Check the parameters */
    410            assert_param(IS_GPIO_PIN(GPIO_Pin));
    411            assert_param(IS_GPIO_PIN_ACTION(PinState));
    412          
    413            if (PinState != GPIO_PIN_RESET)
   \        0x2   0x0013             MOVS     R3,R2
   \        0x4   0xB2DB             UXTB     R3,R3
   \        0x6   0x2B00             CMP      R3,#+0
   \        0x8   0xD003             BEQ      ??HAL_GPIO_WritePin_0
    414            {
    415              GPIOx->BSRR = (uint32_t)GPIO_Pin;
   \        0xA   0x000B             MOVS     R3,R1
   \        0xC   0xB29B             UXTH     R3,R3
   \        0xE   0x6183             STR      R3,[R0, #+24]
   \       0x10   0xE002             B        ??HAL_GPIO_WritePin_1
    416            }
    417            else
    418            {
    419              GPIOx->BRR = (uint32_t)GPIO_Pin;
   \                     ??HAL_GPIO_WritePin_0: (+1)
   \       0x12   0x000B             MOVS     R3,R1
   \       0x14   0xB29B             UXTH     R3,R3
   \       0x16   0x6283             STR      R3,[R0, #+40]
    420            }
    421          }
   \                     ??HAL_GPIO_WritePin_1: (+1)
   \       0x18   0xBD00             POP      {PC}             ;; return
    422          
    423          /**
    424            * @brief  Toggle the specified GPIO pin.
    425            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32G0xx family
    426            * @param  GPIO_Pin specifies the pin to be toggled.
    427            *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    428            * @retval None
    429            */

   \                                 In section .text, align 2, keep-with-next
    430          void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
    431          {
   \                     HAL_GPIO_TogglePin: (+1)
   \        0x0   0xB500             PUSH     {LR}
    432            /* Check the parameters */
    433            assert_param(IS_GPIO_PIN(GPIO_Pin));
    434          
    435            if ((GPIOx->ODR & GPIO_Pin) != 0x00u)
   \        0x2   0x6942             LDR      R2,[R0, #+20]
   \        0x4   0x000B             MOVS     R3,R1
   \        0x6   0xB29B             UXTH     R3,R3
   \        0x8   0x401A             ANDS     R2,R2,R3
   \        0xA   0x2A00             CMP      R2,#+0
   \        0xC   0xD003             BEQ      ??HAL_GPIO_TogglePin_0
    436            {
    437              GPIOx->BRR = (uint32_t)GPIO_Pin;
   \        0xE   0x000A             MOVS     R2,R1
   \       0x10   0xB292             UXTH     R2,R2
   \       0x12   0x6282             STR      R2,[R0, #+40]
   \       0x14   0xE002             B        ??HAL_GPIO_TogglePin_1
    438            }
    439            else
    440            {
    441              GPIOx->BSRR = (uint32_t)GPIO_Pin;
   \                     ??HAL_GPIO_TogglePin_0: (+1)
   \       0x16   0x000A             MOVS     R2,R1
   \       0x18   0xB292             UXTH     R2,R2
   \       0x1A   0x6182             STR      R2,[R0, #+24]
    442            }
    443          }
   \                     ??HAL_GPIO_TogglePin_1: (+1)
   \       0x1C   0xBD00             POP      {PC}             ;; return
    444          
    445          /**
    446          * @brief  Lock GPIO Pins configuration registers.
    447            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    448            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    449            * @note   The configuration of the locked GPIO pins can no longer be modified
    450            *         until the next reset.
    451            * @param  GPIOx where x can be (A..F) to select the GPIO peripheral for STM32G0xx family
    452            * @param  GPIO_Pin specifies the port bits to be locked.
    453            *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    454            * @retval None
    455            */

   \                                 In section .text, align 2, keep-with-next
    456          HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
    457          {
   \                     HAL_GPIO_LockPin: (+1)
   \        0x0   0xB518             PUSH     {R3,R4,LR}
   \        0x2   0x0002             MOVS     R2,R0
    458            __IO uint32_t tmp = GPIO_LCKR_LCKK;
   \        0x4   0x2080             MOVS     R0,#+128
   \        0x6   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \        0x8   0x9000             STR      R0,[SP, #+0]
    459          
    460            /* Check the parameters */
    461            assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
    462            assert_param(IS_GPIO_PIN(GPIO_Pin));
    463          
    464            /* Apply lock key write sequence */
    465            tmp |= GPIO_Pin;
   \        0xA   0x9B00             LDR      R3,[SP, #+0]
   \        0xC   0x000C             MOVS     R4,R1
   \        0xE   0xB2A4             UXTH     R4,R4
   \       0x10   0x4323             ORRS     R3,R3,R4
   \       0x12   0x9300             STR      R3,[SP, #+0]
    466            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    467            GPIOx->LCKR = tmp;
   \       0x14   0x9B00             LDR      R3,[SP, #+0]
   \       0x16   0x61D3             STR      R3,[R2, #+28]
    468            /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
    469            GPIOx->LCKR = GPIO_Pin;
   \       0x18   0x000B             MOVS     R3,R1
   \       0x1A   0xB29B             UXTH     R3,R3
   \       0x1C   0x61D3             STR      R3,[R2, #+28]
    470            /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
    471            GPIOx->LCKR = tmp;
   \       0x1E   0x9B00             LDR      R3,[SP, #+0]
   \       0x20   0x61D3             STR      R3,[R2, #+28]
    472            /* Read LCKK register. This read is mandatory to complete key lock sequence */
    473            tmp = GPIOx->LCKR;
   \       0x22   0x69D3             LDR      R3,[R2, #+28]
   \       0x24   0x9300             STR      R3,[SP, #+0]
    474          
    475            /* read again in order to confirm lock is active */
    476            if ((GPIOx->LCKR & GPIO_LCKR_LCKK) != 0x00u)
   \       0x26   0x69D3             LDR      R3,[R2, #+28]
   \       0x28   0x4018             ANDS     R0,R0,R3
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD001             BEQ      ??HAL_GPIO_LockPin_0
    477            {
    478              return HAL_OK;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xE000             B        ??HAL_GPIO_LockPin_1
    479            }
    480            else
    481            {
    482              return HAL_ERROR;
   \                     ??HAL_GPIO_LockPin_0: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   \                     ??HAL_GPIO_LockPin_1: (+1)
   \       0x34   0xBD12             POP      {R1,R4,PC}       ;; return
    483            }
    484          }
    485          
    486          /**
    487            * @brief  Handle EXTI interrupt request.
    488            * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
    489            * @retval None
    490            */

   \                                 In section .text, align 2, keep-with-next
    491          void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
    492          {
   \                     HAL_GPIO_EXTI_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    493            /* EXTI line interrupt detected */
    494            if (__HAL_GPIO_EXTI_GET_RISING_IT(GPIO_Pin) != 0x00u)
   \        0x4   0x....             LDR      R0,??DataTable2_8  ;; 0x4002180c
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x0022             MOVS     R2,R4
   \        0xA   0xB292             UXTH     R2,R2
   \        0xC   0x4011             ANDS     R1,R1,R2
   \        0xE   0x2900             CMP      R1,#+0
   \       0x10   0xD006             BEQ      ??HAL_GPIO_EXTI_IRQHandler_0
    495            {
    496              __HAL_GPIO_EXTI_CLEAR_RISING_IT(GPIO_Pin);
   \       0x12   0x0021             MOVS     R1,R4
   \       0x14   0xB289             UXTH     R1,R1
   \       0x16   0x6001             STR      R1,[R0, #+0]
    497              HAL_GPIO_EXTI_Rising_Callback(GPIO_Pin);
   \       0x18   0x0020             MOVS     R0,R4
   \       0x1A   0xB280             UXTH     R0,R0
   \       0x1C   0x....'....        BL       HAL_GPIO_EXTI_Rising_Callback
    498            }
    499          
    500            if (__HAL_GPIO_EXTI_GET_FALLING_IT(GPIO_Pin) != 0x00u)
   \                     ??HAL_GPIO_EXTI_IRQHandler_0: (+1)
   \       0x20   0x....             LDR      R0,??DataTable2_9  ;; 0x40021810
   \       0x22   0x6801             LDR      R1,[R0, #+0]
   \       0x24   0x0022             MOVS     R2,R4
   \       0x26   0xB292             UXTH     R2,R2
   \       0x28   0x4011             ANDS     R1,R1,R2
   \       0x2A   0x2900             CMP      R1,#+0
   \       0x2C   0xD006             BEQ      ??HAL_GPIO_EXTI_IRQHandler_1
    501            {
    502              __HAL_GPIO_EXTI_CLEAR_FALLING_IT(GPIO_Pin);
   \       0x2E   0x0021             MOVS     R1,R4
   \       0x30   0xB289             UXTH     R1,R1
   \       0x32   0x6001             STR      R1,[R0, #+0]
    503              HAL_GPIO_EXTI_Falling_Callback(GPIO_Pin);
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0xB280             UXTH     R0,R0
   \       0x38   0x....'....        BL       HAL_GPIO_EXTI_Falling_Callback
    504            }
    505          }
   \                     ??HAL_GPIO_EXTI_IRQHandler_1: (+1)
   \       0x3C   0xBD10             POP      {R4,PC}          ;; return
    506          
    507          /**
    508            * @brief  EXTI line detection callback.
    509            * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
    510            * @retval None
    511            */

   \                                 In section .text, align 2
    512          __weak void HAL_GPIO_EXTI_Rising_Callback(uint16_t GPIO_Pin)
    513          {
    514            /* Prevent unused argument(s) compilation warning */
    515            UNUSED(GPIO_Pin);
    516          
    517            /* NOTE: This function should not be modified, when the callback is needed,
    518                     the HAL_GPIO_EXTI_Rising_Callback could be implemented in the user file
    519             */
    520          }
   \                     HAL_GPIO_EXTI_Rising_Callback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    521          
    522          /**
    523            * @brief  EXTI line detection callback.
    524            * @param  GPIO_Pin Specifies the port pin connected to corresponding EXTI line.
    525            * @retval None
    526            */

   \                                 In section .text, align 2
    527          __weak void HAL_GPIO_EXTI_Falling_Callback(uint16_t GPIO_Pin)
    528          {
    529            /* Prevent unused argument(s) compilation warning */
    530            UNUSED(GPIO_Pin);
    531          
    532            /* NOTE: This function should not be modified, when the callback is needed,
    533                     the HAL_GPIO_EXTI_Falling_Callback could be implemented in the user file
    534             */
    535          }
   \                     HAL_GPIO_EXTI_Falling_Callback: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x4002'1860        DC32     0x40021860

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x5000'0400        DC32     0x50000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x5000'0800        DC32     0x50000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x5000'0C00        DC32     0x50000c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x4002'1880        DC32     0x40021880

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x4002'1884        DC32     0x40021884

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \        0x0   0x4002'1800        DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \        0x0   0x4002'1804        DC32     0x40021804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \        0x0   0x4002'180C        DC32     0x4002180c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \        0x0   0x4002'1810        DC32     0x40021810
    536          
    537          /**
    538            * @}
    539            */
    540          
    541          
    542          /**
    543            * @}
    544            */
    545          
    546          #endif /* HAL_GPIO_MODULE_ENABLED */
    547          /**
    548            * @}
    549            */
    550          
    551          /**
    552            * @}
    553            */
    554          
    555          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   HAL_GPIO_DeInit
       0   HAL_GPIO_EXTI_Falling_Callback
       8   HAL_GPIO_EXTI_IRQHandler
         8   -> HAL_GPIO_EXTI_Falling_Callback
         8   -> HAL_GPIO_EXTI_Rising_Callback
       0   HAL_GPIO_EXTI_Rising_Callback
      28   HAL_GPIO_Init
      12   HAL_GPIO_LockPin
       4   HAL_GPIO_ReadPin
       4   HAL_GPIO_TogglePin
       4   HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     316  HAL_GPIO_DeInit
       2  HAL_GPIO_EXTI_Falling_Callback
      62  HAL_GPIO_EXTI_IRQHandler
       2  HAL_GPIO_EXTI_Rising_Callback
     486  HAL_GPIO_Init
      54  HAL_GPIO_LockPin
      26  HAL_GPIO_ReadPin
      30  HAL_GPIO_TogglePin
      26  HAL_GPIO_WritePin

 
 1'044 bytes in section .text
 
 1'040 bytes of CODE memory (+ 4 bytes shared)

Errors: none
Warnings: none

###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         04/Feb/2022  12:58:52
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_flash.c
#    Command line      =
#        -f C:\Users\610126~1\AppData\Local\Temp\EWF834.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_flash.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\stm32g0xx_hal_flash.lst
#    Object file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\stm32g0xx_hal_flash.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32g0xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @brief   FLASH HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the internal FLASH memory:
      8            *           + Program operations functions
      9            *           + Memory Control functions
     10            *           + Peripheral Errors functions
     11            *
     12           @verbatim
     13            ==============================================================================
     14                                  ##### FLASH peripheral features #####
     15            ==============================================================================
     16          
     17            [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses
     18                 to the Flash memory. It implements the erase and program Flash memory operations
     19                 and the read and write protection mechanisms.
     20          
     21            [..] The Flash memory interface accelerates code execution with a system of instruction
     22                 prefetch and cache lines.
     23          
     24            [..] The FLASH main features are:
     25                (+) Flash memory read operations
     26                (+) Flash memory program/erase operations
     27                (+) Read / write protections
     28                (+) Option bytes programming
     29                (+) Prefetch on I-Code
     30                (+) 32 cache lines of 4*64 bits on I-Code
     31                (+) Error code correction (ECC) : Data in flash are 72-bits word
     32                    (8 bits added per double word)
     33          
     34                                  ##### How to use this driver #####
     35           ==============================================================================
     36              [..]
     37                This driver provides functions and macros to configure and program the FLASH
     38                memory of all STM32G0xx devices.
     39          
     40                (#) Flash Memory IO Programming functions:
     41                     (++) Lock and Unlock the FLASH interface using HAL_FLASH_Unlock() and
     42                          HAL_FLASH_Lock() functions
     43                     (++) Program functions: double word and fast program (full row programming)
     44                     (++) There are two modes of programming:
     45                      (+++) Polling mode using HAL_FLASH_Program() function
     46                      (+++) Interrupt mode using HAL_FLASH_Program_IT() function
     47          
     48                (#) Interrupts and flags management functions:
     49                     (++) Handle FLASH interrupts by calling HAL_FLASH_IRQHandler()
     50                     (++) Callback functions are called when the flash operations are finished :
     51                          HAL_FLASH_EndOfOperationCallback() when everything is ok, otherwise
     52                          HAL_FLASH_OperationErrorCallback()
     53                     (++) Get error flag status by calling HAL_GetError()
     54          
     55                (#) Option bytes management functions :
     56                     (++) Lock and Unlock the option bytes using HAL_FLASH_OB_Unlock() and
     57                          HAL_FLASH_OB_Lock() functions
     58                     (++) Launch the reload of the option bytes using HAL_FLASH_OB_Launch() function.
     59                          In this case, a reset is generated
     60          
     61              [..]
     62                In addition to these functions, this driver includes a set of macros allowing
     63                to handle the following operations:
     64                 (+) Set the latency
     65                 (+) Enable/Disable the prefetch buffer
     66                 (+) Enable/Disable the Instruction cache
     67                 (+) Reset the Instruction cache
     68                 (+) Enable/Disable the Flash power-down during low-power run and sleep modes
     69                 (+) Enable/Disable the Flash interrupts
     70                 (+) Monitor the Flash flags status
     71          
     72           @endverbatim
     73            ******************************************************************************
     74            * @attention
     75            *
     76            * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics.
     77            * All rights reserved.</center></h2>
     78            *
     79            * This software component is licensed by ST under BSD 3-Clause license,
     80            * the "License"; You may not use this file except in compliance with the
     81            * License. You may obtain a copy of the License at:
     82            *                        opensource.org/licenses/BSD-3-Clause
     83            *
     84            ******************************************************************************
     85            */
     86          
     87          /* Includes ------------------------------------------------------------------*/
     88          #include "stm32g0xx_hal.h"
     89          
     90          /** @addtogroup STM32G0xx_HAL_Driver
     91            * @{
     92            */
     93          
     94          /** @defgroup FLASH FLASH
     95            * @brief FLASH HAL module driver
     96            * @{
     97            */
     98          
     99          #ifdef HAL_FLASH_MODULE_ENABLED
    100          
    101          /* Private typedef -----------------------------------------------------------*/
    102          /* Private defines -----------------------------------------------------------*/
    103          /* Private macros ------------------------------------------------------------*/
    104          /* Private variables ---------------------------------------------------------*/
    105          /** @defgroup FLASH_Private_Variables FLASH Private Variables
    106           * @{
    107           */
    108          /**
    109            * @brief  Variable used for Program/Erase sectors under interruption
    110            */

   \                                 In section .bss, align 4
    111          FLASH_ProcessTypeDef pFlash  = {.Lock = HAL_UNLOCKED, \
   \                     pFlash:
   \        0x0                      DS8 24
    112                                          .ErrorCode = HAL_FLASH_ERROR_NONE, \
    113                                          .ProcedureOnGoing = FLASH_TYPENONE, \
    114                                          .Address = 0U, \
    115                                          .Page = 0U, \
    116                                          .NbPagesToErase = 0U
    117                                         };
    118          /**
    119            * @}
    120            */
    121          
    122          /* Private function prototypes -----------------------------------------------*/
    123          /** @defgroup FLASH_Private_Functions FLASH Private Functions
    124           * @{
    125           */
    126          static void          FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data);
    127          static void          FLASH_Program_Fast(uint32_t Address, uint32_t DataAddress);
    128          /**
    129            * @}
    130            */
    131          
    132          /* Exported functions --------------------------------------------------------*/
    133          /** @defgroup FLASH_Exported_Functions FLASH Exported Functions
    134            * @{
    135            */
    136          
    137          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions
    138           *  @brief   Programming operation functions
    139           *
    140          @verbatim
    141           ===============================================================================
    142                            ##### Programming operation functions #####
    143           ===============================================================================
    144              [..]
    145              This subsection provides a set of functions allowing to manage the FLASH
    146              program operations.
    147          
    148          @endverbatim
    149            * @{
    150            */
    151          
    152          /**
    153            * @brief  Program double word or fast program of a row at a specified address.
    154            * @param  TypeProgram Indicate the way to program at a specified address.
    155            *                      This parameter can be a value of @ref FLASH_Type_Program
    156            * @param  Address Specifies the address to be programmed.
    157            * @param  Data Specifies the data to be programmed
    158            *               This parameter is the data for the double word program and the address where
    159            *               are stored the data for the row fast program.
    160            *
    161            * @retval HAL_StatusTypeDef HAL Status
    162            */

   \                                 In section .text, align 2, keep-with-next
    163          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    164          {
   \                     HAL_FLASH_Program: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
   \        0x4   0xB40C             PUSH     {R2,R3}
    165            HAL_StatusTypeDef status;
    166          
    167            /* Check the parameters */
    168            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    169            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    170          
    171            /* Process Locked */
    172            __HAL_LOCK(&pFlash);
   \        0x6   0x....             LDR      R5,??DataTable8
   \        0x8   0x7828             LDRB     R0,[R5, #+0]
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xD101             BNE      ??HAL_FLASH_Program_0
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0xE029             B        ??HAL_FLASH_Program_1
   \                     ??HAL_FLASH_Program_0: (+1)
   \       0x12   0x2001             MOVS     R0,#+1
   \       0x14   0x7028             STRB     R0,[R5, #+0]
    173          
    174            /* Reset error code */
    175            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \       0x16   0x2400             MOVS     R4,#+0
   \       0x18   0x606C             STR      R4,[R5, #+4]
    176          
    177            /* Wait for last operation to be completed */
    178            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \       0x1A   0x27FA             MOVS     R7,#+250
   \       0x1C   0x00BF             LSLS     R7,R7,#+2        ;; #+1000
   \       0x1E   0x0038             MOVS     R0,R7
   \       0x20   0x....'....        BL       FLASH_WaitForLastOperation
   \       0x24   0x0006             MOVS     R6,R0
    179          
    180            if (status == HAL_OK)
   \       0x26   0x0030             MOVS     R0,R6
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xD118             BNE      ??HAL_FLASH_Program_2
    181            {
    182              if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
   \       0x2E   0x9803             LDR      R0,[SP, #+12]
   \       0x30   0x2801             CMP      R0,#+1
   \       0x32   0xD106             BNE      ??HAL_FLASH_Program_3
    183              {
    184                /* Check the parameters */
    185                assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    186          
    187                /* Program double-word (64-bit) at a specified address */
    188                FLASH_Program_DoubleWord(Address, Data);
   \       0x34   0x4668             MOV      R0,SP
   \       0x36   0xC80C             LDM      R0!,{R2,R3}
   \       0x38   0x3808             SUBS     R0,R0,#+8
   \       0x3A   0x9804             LDR      R0,[SP, #+16]
   \       0x3C   0x....'....        BL       FLASH_Program_DoubleWord
   \       0x40   0xE005             B        ??HAL_FLASH_Program_4
    189              }
    190              else
    191              {
    192                /* Check the parameters */
    193                assert_param(IS_FLASH_FAST_PROGRAM_ADDRESS(Address));
    194          
    195                /* Fast program a 32 row double-word (64-bit) at a specified address */
    196                FLASH_Program_Fast(Address, (uint32_t)Data);
   \                     ??HAL_FLASH_Program_3: (+1)
   \       0x42   0x4668             MOV      R0,SP
   \       0x44   0xC803             LDM      R0,{R0,R1}
   \       0x46   0x0001             MOVS     R1,R0
   \       0x48   0x9804             LDR      R0,[SP, #+16]
   \       0x4A   0x....'....        BL       FLASH_Program_Fast
    197              }
    198          
    199              /* Wait for last operation to be completed */
    200              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \                     ??HAL_FLASH_Program_4: (+1)
   \       0x4E   0x0038             MOVS     R0,R7
   \       0x50   0x....'....        BL       FLASH_WaitForLastOperation
   \       0x54   0x0006             MOVS     R6,R0
    201          
    202              /* If the program operation is completed, disable the PG or FSTPG Bit */
    203              CLEAR_BIT(FLASH->CR, TypeProgram);
   \       0x56   0x....             LDR      R0,??DataTable10  ;; 0x40022014
   \       0x58   0x6801             LDR      R1,[R0, #+0]
   \       0x5A   0x9A03             LDR      R2,[SP, #+12]
   \       0x5C   0x4391             BICS     R1,R1,R2
   \       0x5E   0x6001             STR      R1,[R0, #+0]
    204            }
    205          
    206            /* Process Unlocked */
    207            __HAL_UNLOCK(&pFlash);
   \                     ??HAL_FLASH_Program_2: (+1)
   \       0x60   0x702C             STRB     R4,[R5, #+0]
    208          
    209            /* return status */
    210            return status;
   \       0x62   0x0030             MOVS     R0,R6
   \       0x64   0xB2C0             UXTB     R0,R0
   \                     ??HAL_FLASH_Program_1: (+1)
   \       0x66   0xB005             ADD      SP,SP,#+20
   \       0x68   0xBDF0             POP      {R4-R7,PC}       ;; return
    211          }
    212          
    213          /**
    214            * @brief  Program double word or fast program of a row at a specified address with interrupt enabled.
    215            * @param  TypeProgram Indicate the way to program at a specified address.
    216            *                      This parameter can be a value of @ref FLASH_Type_Program
    217            * @param  Address Specifies the address to be programmed.
    218            * @param  Data Specifies the data to be programmed
    219            *               This parameter is the data for the double word program and the address where
    220            *               are stored the data for the row fast program.
    221            *
    222            * @retval HAL Status
    223            */

   \                                 In section .text, align 2, keep-with-next
    224          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    225          {
   \                     HAL_FLASH_Program_IT: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
   \        0x4   0x0016             MOVS     R6,R2
   \        0x6   0x001F             MOVS     R7,R3
    226            HAL_StatusTypeDef status;
    227          
    228            /* Check the parameters */
    229            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    230            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    231          
    232            /* Process Locked */
    233            __HAL_LOCK(&pFlash);
   \        0x8   0x....             LDR      R4,??DataTable8
   \        0xA   0x7820             LDRB     R0,[R4, #+0]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD101             BNE      ??HAL_FLASH_Program_IT_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE02E             B        ??HAL_FLASH_Program_IT_1
   \                     ??HAL_FLASH_Program_IT_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x7020             STRB     R0,[R4, #+0]
    234          
    235            /* Reset error code */
    236            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
   \       0x18   0x2500             MOVS     R5,#+0
   \       0x1A   0x6065             STR      R5,[R4, #+4]
    237          
    238            /* Wait for last operation to be completed */
    239            status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
   \       0x1C   0x20FA             MOVS     R0,#+250
   \       0x1E   0x0080             LSLS     R0,R0,#+2        ;; #+1000
   \       0x20   0x....'....        BL       FLASH_WaitForLastOperation
   \       0x24   0x4669             MOV      R1,SP
   \       0x26   0x7008             STRB     R0,[R1, #+0]
    240          
    241            if (status != HAL_OK)
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x7800             LDRB     R0,[R0, #+0]
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD001             BEQ      ??HAL_FLASH_Program_IT_2
    242            {
    243              /* Process Unlocked */
    244              __HAL_UNLOCK(&pFlash);
   \       0x30   0x7025             STRB     R5,[R4, #+0]
   \       0x32   0xE01C             B        ??HAL_FLASH_Program_IT_3
    245            }
    246            else
    247            {
    248              /* Set internal variables used by the IRQ handler */
    249              pFlash.ProcedureOnGoing = TypeProgram;
   \                     ??HAL_FLASH_Program_IT_2: (+1)
   \       0x34   0x9801             LDR      R0,[SP, #+4]
   \       0x36   0x60A0             STR      R0,[R4, #+8]
    250              pFlash.Address = Address;
   \       0x38   0x9802             LDR      R0,[SP, #+8]
   \       0x3A   0x60E0             STR      R0,[R4, #+12]
    251          
    252              /* Enable End of Operation and Error interrupts */
    253              __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_OPERR | FLASH_IT_ECCC);
   \       0x3C   0x....             LDR      R0,??DataTable10_1  ;; 0x40022018
   \       0x3E   0x6801             LDR      R1,[R0, #+0]
   \       0x40   0x2280             MOVS     R2,#+128
   \       0x42   0x0452             LSLS     R2,R2,#+17       ;; #+16777216
   \       0x44   0x430A             ORRS     R2,R2,R1
   \       0x46   0x6002             STR      R2,[R0, #+0]
   \       0x48   0x....             LDR      R0,??DataTable10  ;; 0x40022014
   \       0x4A   0x6801             LDR      R1,[R0, #+0]
   \       0x4C   0x22C0             MOVS     R2,#+192
   \       0x4E   0x0492             LSLS     R2,R2,#+18       ;; #+50331648
   \       0x50   0x430A             ORRS     R2,R2,R1
   \       0x52   0x6002             STR      R2,[R0, #+0]
    254          
    255              if (TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
   \       0x54   0x9801             LDR      R0,[SP, #+4]
   \       0x56   0x2801             CMP      R0,#+1
   \       0x58   0xD105             BNE      ??HAL_FLASH_Program_IT_4
    256              {
    257                /* Check the parameters */
    258                assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    259          
    260                /* Program double-word (64-bit) at a specified address */
    261                FLASH_Program_DoubleWord(Address, Data);
   \       0x5A   0x0032             MOVS     R2,R6
   \       0x5C   0x003B             MOVS     R3,R7
   \       0x5E   0x9802             LDR      R0,[SP, #+8]
   \       0x60   0x....'....        BL       FLASH_Program_DoubleWord
   \       0x64   0xE003             B        ??HAL_FLASH_Program_IT_3
    262              }
    263              else
    264              {
    265                /* Check the parameters */
    266                assert_param(IS_FLASH_FAST_PROGRAM_ADDRESS(Address));
    267          
    268                /* Fast program a 32 row double-word (64-bit) at a specified address */
    269                FLASH_Program_Fast(Address, (uint32_t)Data);
   \                     ??HAL_FLASH_Program_IT_4: (+1)
   \       0x66   0x0031             MOVS     R1,R6
   \       0x68   0x9802             LDR      R0,[SP, #+8]
   \       0x6A   0x....'....        BL       FLASH_Program_Fast
    270              }
    271            }
    272          
    273            /* return status */
    274            return status;
   \                     ??HAL_FLASH_Program_IT_3: (+1)
   \       0x6E   0x4668             MOV      R0,SP
   \       0x70   0x7800             LDRB     R0,[R0, #+0]
   \                     ??HAL_FLASH_Program_IT_1: (+1)
   \       0x72   0xBDFE             POP      {R1-R7,PC}       ;; return
    275          }
    276          
    277          /**
    278            * @brief Handle FLASH interrupt request.
    279            * @retval None
    280            */

   \                                 In section .text, align 2, keep-with-next
    281          void HAL_FLASH_IRQHandler(void)
    282          {
   \                     HAL_FLASH_IRQHandler: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
    283            uint32_t param = 0xFFFFFFFFU;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x43C0             MVNS     R0,R0            ;; #-1
   \        0x6   0x9001             STR      R0,[SP, #+4]
    284            uint32_t error;
    285          
    286            /* Save flash errors. Only ECC detection can be checked here as ECCC
    287               generates NMI */
    288            error = (FLASH->SR & FLASH_FLAG_SR_ERROR);
   \        0x8   0x....             LDR      R7,??DataTable10_2  ;; 0x40022010
   \        0xA   0x6839             LDR      R1,[R7, #+0]
   \        0xC   0x....             LDR      R0,??DataTable10_3  ;; 0x83fa
   \        0xE   0x4008             ANDS     R0,R0,R1
    289            error |= (FLASH->ECCR & FLASH_FLAG_ECCC);
   \       0x10   0x....             LDR      R4,??DataTable10_1  ;; 0x40022018
   \       0x12   0x6821             LDR      R1,[R4, #+0]
   \       0x14   0x2280             MOVS     R2,#+128
   \       0x16   0x05D2             LSLS     R2,R2,#+23       ;; #+1073741824
   \       0x18   0x4011             ANDS     R1,R1,R2
   \       0x1A   0x4301             ORRS     R1,R1,R0
   \       0x1C   0x9100             STR      R1,[SP, #+0]
    290          
    291            CLEAR_BIT(FLASH->CR, pFlash.ProcedureOnGoing);
   \       0x1E   0x....             LDR      R5,??DataTable8
   \       0x20   0x....             LDR      R6,??DataTable10  ;; 0x40022014
   \       0x22   0x6830             LDR      R0,[R6, #+0]
   \       0x24   0x68A9             LDR      R1,[R5, #+8]
   \       0x26   0x4388             BICS     R0,R0,R1
   \       0x28   0x6030             STR      R0,[R6, #+0]
    292          
    293            /* A] Set parameter for user or error callbacks */
    294            /* check operation was a program or erase */
    295            if ((pFlash.ProcedureOnGoing & (FLASH_TYPEPROGRAM_DOUBLEWORD | FLASH_TYPEPROGRAM_FAST)) != 0x00U)
   \       0x2A   0x68A8             LDR      R0,[R5, #+8]
   \       0x2C   0x....             LDR      R1,??DataTable10_4  ;; 0x40001
   \       0x2E   0x4001             ANDS     R1,R1,R0
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD002             BEQ      ??HAL_FLASH_IRQHandler_0
    296            {
    297              /* return adress being programmed */
    298              param = pFlash.Address;
   \       0x34   0x68E8             LDR      R0,[R5, #+12]
   \       0x36   0x9001             STR      R0,[SP, #+4]
   \       0x38   0xE006             B        ??HAL_FLASH_IRQHandler_1
    299            }
    300            else if ((pFlash.ProcedureOnGoing & (FLASH_TYPEERASE_MASS | FLASH_TYPEERASE_PAGES)) != 0x00U)
   \                     ??HAL_FLASH_IRQHandler_0: (+1)
   \       0x3A   0x7A28             LDRB     R0,[R5, #+8]
   \       0x3C   0x2106             MOVS     R1,#+6
   \       0x3E   0x4001             ANDS     R1,R1,R0
   \       0x40   0x2900             CMP      R1,#+0
   \       0x42   0xD001             BEQ      ??HAL_FLASH_IRQHandler_1
    301            {
    302              /* return page number being erased (0 for mass erase) */
    303              param = pFlash.Page;
   \       0x44   0x6928             LDR      R0,[R5, #+16]
   \       0x46   0x9001             STR      R0,[SP, #+4]
    304            }
    305            else
    306            {
    307              /* Nothing to do */
    308            }
    309          
    310            /* B] Check errors */
    311            if (error != 0x00U)
   \                     ??HAL_FLASH_IRQHandler_1: (+1)
   \       0x48   0x9800             LDR      R0,[SP, #+0]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD01C             BEQ      ??HAL_FLASH_IRQHandler_2
    312            {
    313              /*Save the error code*/
    314              pFlash.ErrorCode |= error;
   \       0x4E   0x6868             LDR      R0,[R5, #+4]
   \       0x50   0x9900             LDR      R1,[SP, #+0]
   \       0x52   0x4301             ORRS     R1,R1,R0
   \       0x54   0x6069             STR      R1,[R5, #+4]
    315          
    316              /* clear error flags */
    317              __HAL_FLASH_CLEAR_FLAG(error);
   \       0x56   0x9800             LDR      R0,[SP, #+0]
   \       0x58   0x0F80             LSRS     R0,R0,#+30
   \       0x5A   0x0780             LSLS     R0,R0,#+30
   \       0x5C   0x2800             CMP      R0,#+0
   \       0x5E   0xD005             BEQ      ??HAL_FLASH_IRQHandler_3
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x9900             LDR      R1,[SP, #+0]
   \       0x64   0x0F89             LSRS     R1,R1,#+30
   \       0x66   0x0789             LSLS     R1,R1,#+30
   \       0x68   0x4301             ORRS     R1,R1,R0
   \       0x6A   0x6021             STR      R1,[R4, #+0]
   \                     ??HAL_FLASH_IRQHandler_3: (+1)
   \       0x6C   0x9800             LDR      R0,[SP, #+0]
   \       0x6E   0x0080             LSLS     R0,R0,#+2        ;; ZeroExtS R0,R0,#+2,#+2
   \       0x70   0x0880             LSRS     R0,R0,#+2
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD003             BEQ      ??HAL_FLASH_IRQHandler_4
   \       0x76   0x9800             LDR      R0,[SP, #+0]
   \       0x78   0x0080             LSLS     R0,R0,#+2        ;; ZeroExtS R0,R0,#+2,#+2
   \       0x7A   0x0880             LSRS     R0,R0,#+2
   \       0x7C   0x6038             STR      R0,[R7, #+0]
    318          
    319              /*Stop the procedure ongoing*/
    320              pFlash.ProcedureOnGoing = FLASH_TYPENONE;
   \                     ??HAL_FLASH_IRQHandler_4: (+1)
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x60A8             STR      R0,[R5, #+8]
    321          
    322              /* Error callback */
    323              HAL_FLASH_OperationErrorCallback(param);
   \       0x82   0x9801             LDR      R0,[SP, #+4]
   \       0x84   0x....'....        BL       HAL_FLASH_OperationErrorCallback
    324            }
    325          
    326            /* C] Check FLASH End of Operation flag */
    327            if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP) != 0x00U)
   \                     ??HAL_FLASH_IRQHandler_2: (+1)
   \       0x88   0x2001             MOVS     R0,#+1
   \       0x8A   0x6839             LDR      R1,[R7, #+0]
   \       0x8C   0x4001             ANDS     R1,R1,R0
   \       0x8E   0x2900             CMP      R1,#+0
   \       0x90   0xD018             BEQ      ??HAL_FLASH_IRQHandler_5
    328            {
    329              /* Clear FLASH End of Operation pending bit */
    330              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
   \       0x92   0x6038             STR      R0,[R7, #+0]
    331          
    332              if (pFlash.ProcedureOnGoing == FLASH_TYPEERASE_PAGES)
   \       0x94   0x68A8             LDR      R0,[R5, #+8]
   \       0x96   0x2802             CMP      R0,#+2
   \       0x98   0xD10F             BNE      ??HAL_FLASH_IRQHandler_6
    333              {
    334                /* Nb of pages to erased can be decreased */
    335                pFlash.NbPagesToErase--;
   \       0x9A   0x6968             LDR      R0,[R5, #+20]
   \       0x9C   0x1E40             SUBS     R0,R0,#+1
   \       0x9E   0x6168             STR      R0,[R5, #+20]
    336          
    337                /* Check if there are still pages to erase*/
    338                if (pFlash.NbPagesToErase != 0x00U)
   \       0xA0   0x6968             LDR      R0,[R5, #+20]
   \       0xA2   0x2800             CMP      R0,#+0
   \       0xA4   0xD006             BEQ      ??HAL_FLASH_IRQHandler_7
    339                {
    340                  /* Increment page number */
    341                  pFlash.Page++;
   \       0xA6   0x6928             LDR      R0,[R5, #+16]
   \       0xA8   0x1C40             ADDS     R0,R0,#+1
   \       0xAA   0x6128             STR      R0,[R5, #+16]
    342                  FLASH_PageErase(pFlash.Page);
   \       0xAC   0x6928             LDR      R0,[R5, #+16]
   \       0xAE   0x....'....        BL       FLASH_PageErase
   \       0xB2   0xE004             B        ??HAL_FLASH_IRQHandler_8
    343                }
    344                else
    345                {
    346                  /* No more pages to erase: stop erase pages procedure */
    347                  pFlash.ProcedureOnGoing = FLASH_TYPENONE;
   \                     ??HAL_FLASH_IRQHandler_7: (+1)
   \       0xB4   0x2000             MOVS     R0,#+0
   \       0xB6   0x60A8             STR      R0,[R5, #+8]
   \       0xB8   0xE001             B        ??HAL_FLASH_IRQHandler_8
    348                }
    349              }
    350              else
    351              {
    352                /*Stop the ongoing procedure */
    353                pFlash.ProcedureOnGoing = FLASH_TYPENONE;
   \                     ??HAL_FLASH_IRQHandler_6: (+1)
   \       0xBA   0x2000             MOVS     R0,#+0
   \       0xBC   0x60A8             STR      R0,[R5, #+8]
    354              }
    355          
    356              /* User callback */
    357              HAL_FLASH_EndOfOperationCallback(param);
   \                     ??HAL_FLASH_IRQHandler_8: (+1)
   \       0xBE   0x9801             LDR      R0,[SP, #+4]
   \       0xC0   0x....'....        BL       HAL_FLASH_EndOfOperationCallback
    358            }
    359          
    360            if (pFlash.ProcedureOnGoing == FLASH_TYPENONE)
   \                     ??HAL_FLASH_IRQHandler_5: (+1)
   \       0xC4   0x68A8             LDR      R0,[R5, #+8]
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD109             BNE      ??HAL_FLASH_IRQHandler_9
    361            {
    362              /* Disable End of Operation and Error interrupts */
    363              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP | FLASH_IT_OPERR | FLASH_IT_ECCC);
   \       0xCA   0x6820             LDR      R0,[R4, #+0]
   \       0xCC   0x....             LDR      R1,??DataTable10_5  ;; 0xfeffffff
   \       0xCE   0x4001             ANDS     R1,R1,R0
   \       0xD0   0x6021             STR      R1,[R4, #+0]
   \       0xD2   0x6830             LDR      R0,[R6, #+0]
   \       0xD4   0x....             LDR      R1,??DataTable10_6  ;; 0xfcffffff
   \       0xD6   0x4001             ANDS     R1,R1,R0
   \       0xD8   0x6031             STR      R1,[R6, #+0]
    364          
    365              /* Process Unlocked */
    366              __HAL_UNLOCK(&pFlash);
   \       0xDA   0x2000             MOVS     R0,#+0
   \       0xDC   0x7028             STRB     R0,[R5, #+0]
    367            }
    368          }
   \                     ??HAL_FLASH_IRQHandler_9: (+1)
   \       0xDE   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    369          
    370          /**
    371            * @brief  FLASH end of operation interrupt callback.
    372            * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
    373            *                  Mass Erase: 0
    374            *                  Page Erase: Page which has been erased
    375            *                  Program: Address which was selected for data program
    376            * @retval None
    377            */

   \                                 In section .text, align 2
    378          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    379          {
    380            /* Prevent unused argument(s) compilation warning */
    381            UNUSED(ReturnValue);
    382          
    383            /* NOTE : This function should not be modified, when the callback is needed,
    384                      the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    385             */
    386          }
   \                     HAL_FLASH_EndOfOperationCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    387          
    388          /**
    389            * @brief  FLASH operation error interrupt callback.
    390            * @param  ReturnValue The value saved in this parameter depends on the ongoing procedure
    391            *                 Mass Erase: 0
    392            *                 Page Erase: Page number which returned an error
    393            *                 Program: Address which was selected for data program
    394            * @retval None
    395            */

   \                                 In section .text, align 2
    396          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    397          {
    398            /* Prevent unused argument(s) compilation warning */
    399            UNUSED(ReturnValue);
    400          
    401            /* NOTE : This function should not be modified, when the callback is needed,
    402                      the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    403             */
    404          }
   \                     HAL_FLASH_OperationErrorCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    405          
    406          /**
    407            * @}
    408            */
    409          
    410          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions
    411           *  @brief   Management functions
    412           *
    413          @verbatim
    414           ===============================================================================
    415                                ##### Peripheral Control functions #####
    416           ===============================================================================
    417              [..]
    418              This subsection provides a set of functions allowing to control the FLASH
    419              memory operations.
    420          
    421          @endverbatim
    422            * @{
    423            */
    424          
    425          /**
    426            * @brief  Unlock the FLASH control register access.
    427            * @retval HAL Status
    428            */

   \                                 In section .text, align 2, keep-with-next
    429          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    430          {
   \                     HAL_FLASH_Unlock: (+1)
   \        0x0   0xB500             PUSH     {LR}
    431            HAL_StatusTypeDef status = HAL_OK;
   \        0x2   0x2000             MOVS     R0,#+0
    432          
    433            if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0x00U)
   \        0x4   0x....             LDR      R1,??DataTable10  ;; 0x40022014
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x2A00             CMP      R2,#+0
   \        0xA   0xD509             BPL      ??HAL_FLASH_Unlock_0
    434            {
    435              /* Authorize the FLASH Registers access */
    436              WRITE_REG(FLASH->KEYR, FLASH_KEY1);
   \        0xC   0x....             LDR      R2,??DataTable10_7  ;; 0x40022008
   \        0xE   0x....             LDR      R3,??DataTable10_8  ;; 0x45670123
   \       0x10   0x6013             STR      R3,[R2, #+0]
    437              WRITE_REG(FLASH->KEYR, FLASH_KEY2);
   \       0x12   0x....             LDR      R3,??DataTable10_9  ;; 0xcdef89ab
   \       0x14   0x6013             STR      R3,[R2, #+0]
    438          
    439              /* verify Flash is unlock */
    440              if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0x00U)
   \       0x16   0x6809             LDR      R1,[R1, #+0]
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD501             BPL      ??HAL_FLASH_Unlock_0
    441              {
    442                status = HAL_ERROR;
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0x0008             MOVS     R0,R1
    443              }
    444            }
    445          
    446            return status;
   \                     ??HAL_FLASH_Unlock_0: (+1)
   \       0x20   0xB2C0             UXTB     R0,R0
   \       0x22   0xBD00             POP      {PC}             ;; return
    447          }
    448          
    449          /**
    450            * @brief  Lock the FLASH control register access.
    451            * @retval HAL Status
    452            */

   \                                 In section .text, align 2, keep-with-next
    453          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    454          {
   \                     HAL_FLASH_Lock: (+1)
   \        0x0   0xB500             PUSH     {LR}
    455            HAL_StatusTypeDef status = HAL_ERROR;
   \        0x2   0x2001             MOVS     R0,#+1
    456          
    457            /* Set the LOCK Bit to lock the FLASH Registers access */
    458            SET_BIT(FLASH->CR, FLASH_CR_LOCK);
   \        0x4   0x....             LDR      R1,??DataTable10  ;; 0x40022014
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x2380             MOVS     R3,#+128
   \        0xA   0x061B             LSLS     R3,R3,#+24       ;; #-2147483648
   \        0xC   0x4313             ORRS     R3,R3,R2
   \        0xE   0x600B             STR      R3,[R1, #+0]
    459          
    460            /* verify Flash is locked */
    461            if (READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0x00u)
   \       0x10   0x6809             LDR      R1,[R1, #+0]
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD501             BPL      ??HAL_FLASH_Lock_0
    462            {
    463              status = HAL_OK;
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x0008             MOVS     R0,R1
    464            }
    465          
    466            return status;
   \                     ??HAL_FLASH_Lock_0: (+1)
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0xBD00             POP      {PC}             ;; return
    467          }
    468          
    469          /**
    470            * @brief  Unlock the FLASH Option Bytes Registers access.
    471            * @retval HAL Status
    472            */

   \                                 In section .text, align 2, keep-with-next
    473          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    474          {
   \                     HAL_FLASH_OB_Unlock: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    475            HAL_StatusTypeDef status = HAL_ERROR;
   \        0x2   0x2001             MOVS     R0,#+1
    476          
    477            if (READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) != 0x00U)
   \        0x4   0x2180             MOVS     R1,#+128
   \        0x6   0x05C9             LSLS     R1,R1,#+23       ;; #+1073741824
   \        0x8   0x....             LDR      R2,??DataTable10  ;; 0x40022014
   \        0xA   0x6813             LDR      R3,[R2, #+0]
   \        0xC   0x400B             ANDS     R3,R3,R1
   \        0xE   0x2B00             CMP      R3,#+0
   \       0x10   0xD00A             BEQ      ??HAL_FLASH_OB_Unlock_0
    478            {
    479              /* Authorizes the Option Byte register programming */
    480              WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
   \       0x12   0x....             LDR      R3,??DataTable10_10  ;; 0x4002200c
   \       0x14   0x....             LDR      R4,??DataTable10_11  ;; 0x8192a3b
   \       0x16   0x601C             STR      R4,[R3, #+0]
    481              WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
   \       0x18   0x....             LDR      R4,??DataTable10_12  ;; 0x4c5d6e7f
   \       0x1A   0x601C             STR      R4,[R3, #+0]
    482          
    483              /* verify option bytes are unlocked */
    484              if (READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) == 0x00U)
   \       0x1C   0x6812             LDR      R2,[R2, #+0]
   \       0x1E   0x4011             ANDS     R1,R1,R2
   \       0x20   0x2900             CMP      R1,#+0
   \       0x22   0xD101             BNE      ??HAL_FLASH_OB_Unlock_0
    485              {
    486                status = HAL_OK;
   \       0x24   0x2100             MOVS     R1,#+0
   \       0x26   0x0008             MOVS     R0,R1
    487              }
    488            }
    489          
    490            return status;
   \                     ??HAL_FLASH_OB_Unlock_0: (+1)
   \       0x28   0xB2C0             UXTB     R0,R0
   \       0x2A   0xBD10             POP      {R4,PC}          ;; return
    491          }
    492          
    493          /**
    494            * @brief  Lock the FLASH Option Bytes Registers access.
    495            * @retval HAL Status
    496            */

   \                                 In section .text, align 2, keep-with-next
    497          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    498          {
   \                     HAL_FLASH_OB_Lock: (+1)
   \        0x0   0xB500             PUSH     {LR}
    499            HAL_StatusTypeDef status = HAL_ERROR;
   \        0x2   0x2001             MOVS     R0,#+1
    500          
    501            /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    502            SET_BIT(FLASH->CR, FLASH_CR_OPTLOCK);
   \        0x4   0x2180             MOVS     R1,#+128
   \        0x6   0x05C9             LSLS     R1,R1,#+23       ;; #+1073741824
   \        0x8   0x....             LDR      R2,??DataTable10  ;; 0x40022014
   \        0xA   0x6813             LDR      R3,[R2, #+0]
   \        0xC   0x430B             ORRS     R3,R3,R1
   \        0xE   0x6013             STR      R3,[R2, #+0]
    503          
    504            /* verify option bytes are locked */
    505            if (READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) != 0x00u)
   \       0x10   0x6812             LDR      R2,[R2, #+0]
   \       0x12   0x4011             ANDS     R1,R1,R2
   \       0x14   0x2900             CMP      R1,#+0
   \       0x16   0xD001             BEQ      ??HAL_FLASH_OB_Lock_0
    506            {
    507              status = HAL_OK;
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x0008             MOVS     R0,R1
    508            }
    509          
    510            return status;
   \                     ??HAL_FLASH_OB_Lock_0: (+1)
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0xBD00             POP      {PC}             ;; return
    511          }
    512          
    513          /**
    514            * @brief  Launch the option byte loading.
    515            * @retval HAL Status
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          HAL_StatusTypeDef HAL_FLASH_OB_Launch(void)
    518          {
    519            /* Set the bit to force the option byte reloading */
    520            SET_BIT(FLASH->CR, FLASH_CR_OBL_LAUNCH);
   \                     HAL_FLASH_OB_Launch: (+1)
   \        0x0   0x....             LDR      R0,??DataTable10  ;; 0x40022014
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x0512             LSLS     R2,R2,#+20       ;; #+134217728
   \        0x8   0x430A             ORRS     R2,R2,R1
   \        0xA   0x6002             STR      R2,[R0, #+0]
    521          
    522            /* We should not reach here : Option byte launch generates Option byte reset
    523               so return error */
    524            return HAL_ERROR;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x4770             BX       LR               ;; return
    525          }
    526          
    527          /**
    528            * @}
    529            */
    530          
    531          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral State and Errors functions
    532           *  @brief   Peripheral Errors functions
    533           *
    534          @verbatim
    535           ===============================================================================
    536                          ##### Peripheral Errors functions #####
    537           ===============================================================================
    538              [..]
    539              This subsection permits to get in run-time Errors of the FLASH peripheral.
    540          
    541          @endverbatim
    542            * @{
    543            */
    544          
    545          /**
    546            * @brief  Get the specific FLASH error flag.
    547            * @retval FLASH_ErrorCode The returned value can be
    548            *            @arg @ref HAL_FLASH_ERROR_NONE No error set
    549            *            @arg @ref HAL_FLASH_ERROR_OP FLASH Operation error
    550            *            @arg @ref HAL_FLASH_ERROR_PROG FLASH Programming error
    551            *            @arg @ref HAL_FLASH_ERROR_WRP FLASH Write protection error
    552            *            @arg @ref HAL_FLASH_ERROR_PGA FLASH Programming alignment error
    553            *            @arg @ref HAL_FLASH_ERROR_SIZ FLASH Size error
    554            *            @arg @ref HAL_FLASH_ERROR_PGS FLASH Programming sequence error
    555            *            @arg @ref HAL_FLASH_ERROR_MIS FLASH Fast programming data miss error
    556            *            @arg @ref HAL_FLASH_ERROR_FAST FLASH Fast programming error
    557            *            @arg @ref HAL_FLASH_ERROR_RD FLASH Read Protection error (PCROP)(*)
    558            *            @arg @ref HAL_FLASH_ERROR_OPTV FLASH Option validity error
    559            *            @arg @ref HAL_FLASH_ERROR_ECCD FLASH two ECC errors have been detected
    560            * @note (*) availability depends on devices
    561            */

   \                                 In section .text, align 2, keep-with-next
    562          uint32_t HAL_FLASH_GetError(void)
    563          {
    564            return pFlash.ErrorCode;
   \                     HAL_FLASH_GetError: (+1)
   \        0x0   0x....             LDR      R0,??DataTable8
   \        0x2   0x6840             LDR      R0,[R0, #+4]
   \        0x4   0x4770             BX       LR               ;; return
    565          }
    566          
    567          /**
    568            * @}
    569            */
    570          
    571          /**
    572            * @}
    573            */
    574          
    575          /* Private functions ---------------------------------------------------------*/
    576          
    577          /** @addtogroup FLASH_Private_Functions
    578            * @{
    579            */
    580          
    581          /**
    582            * @brief  Wait for a FLASH operation to complete.
    583            * @param  Timeout maximum flash operation timeout
    584            * @retval HAL_StatusTypeDef HAL Status
    585            */

   \                                 In section .text, align 2, keep-with-next
    586          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
    587          {
   \                     FLASH_WaitForLastOperation: (+1)
   \        0x0   0xB5F1             PUSH     {R0,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
    588            uint32_t error;
    589            uint32_t eccerr;
    590            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    591               Even if the FLASH operation fails, the BUSY flag will be reset and an error
    592               flag will be set */
    593            uint32_t timeout = HAL_GetTick() + Timeout;
   \        0x4   0x....'....        BL       HAL_GetTick
   \        0x8   0x9902             LDR      R1,[SP, #+8]
   \        0xA   0x1844             ADDS     R4,R0,R1
    594          
    595            /* Wait if any operation is ongoing */
    596            while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != 0x00U)
   \                     ??FLASH_WaitForLastOperation_0: (+1)
   \        0xC   0x....             LDR      R5,??DataTable10_2  ;; 0x40022010
   \        0xE   0x6828             LDR      R0,[R5, #+0]
   \       0x10   0x03C0             LSLS     R0,R0,#+15
   \       0x12   0xD505             BPL      ??FLASH_WaitForLastOperation_1
    597            {
    598              if (HAL_GetTick() >= timeout)
   \       0x14   0x....'....        BL       HAL_GetTick
   \       0x18   0x42A0             CMP      R0,R4
   \       0x1A   0xD3F7             BCC      ??FLASH_WaitForLastOperation_0
    599              {
    600                return HAL_TIMEOUT;
   \       0x1C   0x2003             MOVS     R0,#+3
   \       0x1E   0xE028             B        ??FLASH_WaitForLastOperation_2
    601              }
    602            }
    603          
    604            /* check flash errors. Only ECC correction can be checked here as ECCD
    605                generates NMI */
    606            error = (FLASH->SR & FLASH_FLAG_SR_ERROR);
   \                     ??FLASH_WaitForLastOperation_1: (+1)
   \       0x20   0x6828             LDR      R0,[R5, #+0]
   \       0x22   0x....             LDR      R7,??DataTable10_3  ;; 0x83fa
   \       0x24   0x4007             ANDS     R7,R7,R0
    607          
    608            /* Clear SR register */
    609            FLASH->SR = FLASH_FLAG_SR_CLEAR;
   \       0x26   0x....             LDR      R0,??DataTable10_13  ;; 0x83fb
   \       0x28   0x6028             STR      R0,[R5, #+0]
    610          
    611            /* Update error with ECC error value */
    612            eccerr = (FLASH->ECCR & FLASH_FLAG_ECCC);
   \       0x2A   0x....             LDR      R0,??DataTable10_1  ;; 0x40022018
   \       0x2C   0x6801             LDR      R1,[R0, #+0]
   \       0x2E   0x2280             MOVS     R2,#+128
   \       0x30   0x05D2             LSLS     R2,R2,#+23       ;; #+1073741824
   \       0x32   0x4011             ANDS     R1,R1,R2
   \       0x34   0x9100             STR      R1,[SP, #+0]
    613          
    614            if(eccerr != 0x00u)
   \       0x36   0x9900             LDR      R1,[SP, #+0]
   \       0x38   0x2900             CMP      R1,#+0
   \       0x3A   0xD006             BEQ      ??FLASH_WaitForLastOperation_3
    615            {
    616              FLASH->ECCR |= eccerr;
   \       0x3C   0x6801             LDR      R1,[R0, #+0]
   \       0x3E   0x9A00             LDR      R2,[SP, #+0]
   \       0x40   0x430A             ORRS     R2,R2,R1
   \       0x42   0x6002             STR      R2,[R0, #+0]
    617              error |= eccerr;
   \       0x44   0x0038             MOVS     R0,R7
   \       0x46   0x9F00             LDR      R7,[SP, #+0]
   \       0x48   0x4307             ORRS     R7,R7,R0
    618            }
    619          
    620            if (error != 0x00U)
   \                     ??FLASH_WaitForLastOperation_3: (+1)
   \       0x4A   0x2F00             CMP      R7,#+0
   \       0x4C   0xD003             BEQ      ??FLASH_WaitForLastOperation_4
    621            {
    622              /*Save the error code*/
    623              pFlash.ErrorCode = error;
   \       0x4E   0x....             LDR      R0,??DataTable10_14
   \       0x50   0x6047             STR      R7,[R0, #+4]
    624          
    625              return HAL_ERROR;
   \       0x52   0x2001             MOVS     R0,#+1
   \       0x54   0xE00D             B        ??FLASH_WaitForLastOperation_2
    626            }
    627          
    628            /* Wait for control register to be written */
    629            timeout = HAL_GetTick() + Timeout;
   \                     ??FLASH_WaitForLastOperation_4: (+1)
   \       0x56   0x....'....        BL       HAL_GetTick
   \       0x5A   0x9902             LDR      R1,[SP, #+8]
   \       0x5C   0x1846             ADDS     R6,R0,R1
    630          
    631            while (__HAL_FLASH_GET_FLAG(FLASH_FLAG_CFGBSY) != 0x00U)
   \                     ??FLASH_WaitForLastOperation_5: (+1)
   \       0x5E   0x6828             LDR      R0,[R5, #+0]
   \       0x60   0x0340             LSLS     R0,R0,#+13
   \       0x62   0xD505             BPL      ??FLASH_WaitForLastOperation_6
    632            {
    633              if (HAL_GetTick() >= timeout)
   \       0x64   0x....'....        BL       HAL_GetTick
   \       0x68   0x42B0             CMP      R0,R6
   \       0x6A   0xD3F8             BCC      ??FLASH_WaitForLastOperation_5
    634              {
    635                return HAL_TIMEOUT;
   \       0x6C   0x2003             MOVS     R0,#+3
   \       0x6E   0xE000             B        ??FLASH_WaitForLastOperation_2
    636              }
    637            }
    638          
    639            return HAL_OK;
   \                     ??FLASH_WaitForLastOperation_6: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \                     ??FLASH_WaitForLastOperation_2: (+1)
   \       0x72   0xBDFE             POP      {R1-R7,PC}       ;; return
    640          }
    641          
    642          /**
    643            * @brief  Program double-word (64-bit) at a specified address.
    644            * @param  Address Specifies the address to be programmed.
    645            * @param  Data Specifies the data to be programmed.
    646            * @retval None
    647            */

   \                                 In section .text, align 2, keep-with-next
    648          static void FLASH_Program_DoubleWord(uint32_t Address, uint64_t Data)
    649          {
   \                     FLASH_Program_DoubleWord: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
   \        0x2   0x0001             MOVS     R1,R0
    650            /* Set PG bit */
    651            SET_BIT(FLASH->CR, FLASH_CR_PG);
   \        0x4   0x....             LDR      R0,??DataTable10  ;; 0x40022014
   \        0x6   0x6804             LDR      R4,[R0, #+0]
   \        0x8   0x2501             MOVS     R5,#+1
   \        0xA   0x4325             ORRS     R5,R5,R4
   \        0xC   0x6005             STR      R5,[R0, #+0]
    652          
    653            /* Program first word */
    654            *(uint32_t *)Address = (uint32_t)Data;
   \        0xE   0x600A             STR      R2,[R1, #+0]
    655          
    656            /* Barrier to ensure programming is performed in 2 steps, in right order
    657              (independently of compiler optimization behavior) */
    658            __ISB();
   \       0x10   0xF3BF 0x8F6F      ISB      SY
    659          
    660            /* Program second word */
    661            *(uint32_t *)(Address + 4U) = (uint32_t)(Data >> 32U);
   \       0x14   0x0008             MOVS     R0,R1
   \       0x16   0x1D00             ADDS     R0,R0,#+4
   \       0x18   0x6003             STR      R3,[R0, #+0]
    662          }
   \       0x1A   0xBC30             POP      {R4,R5}
   \       0x1C   0x4770             BX       LR               ;; return
    663          
    664          /**
    665            * @brief  Fast program a 32 row double-word (64-bit) at a specified address.
    666            * @param  Address Specifies the address to be programmed.
    667            * @param  DataAddress Specifies the address where the data are stored.
    668            * @retval None
    669            */

   \                                 In section .textrw, align 4, keep-with-next
    670          static __RAM_FUNC void FLASH_Program_Fast(uint32_t Address, uint32_t DataAddress)
    671          {
   \                     FLASH_Program_Fast: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    672            uint8_t index = 0;
   \        0x2   0x2200             MOVS     R2,#+0
    673            uint32_t dest = Address;
   \        0x4   0x0003             MOVS     R3,R0
    674            uint32_t src = DataAddress;
   \        0x6   0x000C             MOVS     R4,R1
    675            uint32_t primask_bit;
    676          
    677            /* Set FSTPG bit */
    678            SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
   \        0x8   0x4D0C             LDR      R5,??FLASH_Program_Fast_0  ;; 0x40022014
   \        0xA   0x682E             LDR      R6,[R5, #+0]
   \        0xC   0x2780             MOVS     R7,#+128
   \        0xE   0x02FF             LSLS     R7,R7,#+11       ;; #+262144
   \       0x10   0x4337             ORRS     R7,R7,R6
   \       0x12   0x602F             STR      R7,[R5, #+0]
    679          
    680            /* Enter critical section: row programming should not be longer than 7 ms */
    681            primask_bit = __get_PRIMASK();
   \       0x14   0xF3EF 0x8510      MRS      R5,PRIMASK
    682            __disable_irq();
   \       0x18   0xB672             CPSID    I
    683          
    684            /* Fast Program : 64 words */
    685            while (index < 64U)
   \                     ??FLASH_Program_Fast_1: (+1)
   \       0x1A   0x0016             MOVS     R6,R2
   \       0x1C   0xB2F6             UXTB     R6,R6
   \       0x1E   0x2E40             CMP      R6,#+64
   \       0x20   0xD205             BCS      ??FLASH_Program_Fast_2
    686            {
    687              *(uint32_t *)dest = *(uint32_t *)src;
   \       0x22   0x6826             LDR      R6,[R4, #+0]
   \       0x24   0x601E             STR      R6,[R3, #+0]
    688              src += 4U;
   \       0x26   0x1D24             ADDS     R4,R4,#+4
    689              dest += 4U;
   \       0x28   0x1D1B             ADDS     R3,R3,#+4
    690              index++;
   \       0x2A   0x1C52             ADDS     R2,R2,#+1
   \       0x2C   0xE7F5             B        ??FLASH_Program_Fast_1
    691            }
    692          
    693            /* wait for BSY1 in order to be sure that flash operation is ended befoire
    694               allowing prefetch in flash. Timeout does not return status, as it will
    695               be anyway done later */
    696            while ((FLASH->SR & FLASH_SR_BSY1) != 0x00U)
   \                     ??FLASH_Program_Fast_2: (+1)
   \       0x2E   0x4E04             LDR      R6,??FLASH_Program_Fast_0+0x4  ;; 0x40022010
   \       0x30   0x6836             LDR      R6,[R6, #+0]
   \       0x32   0x03F6             LSLS     R6,R6,#+15
   \       0x34   0xD4FB             BMI      ??FLASH_Program_Fast_2
    697            {
    698            }
    699          
    700            /* Exit critical section: restore previous priority mask */
    701            __set_PRIMASK(primask_bit);
   \       0x36   0xF385 0x8810      MSR      PRIMASK,R5
    702          }
   \       0x3A   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??FLASH_Program_Fast_0:
   \       0x3C   0x4002'2014        DC32     0x40022014
   \       0x40   0x4002'2010        DC32     0x40022010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0x....'....        DC32     pFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x4002'2014        DC32     0x40022014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x4002'2018        DC32     0x40022018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0x4002'2010        DC32     0x40022010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0x0000'83FA        DC32     0x83fa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0x0004'0001        DC32     0x40001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \        0x0   0xFEFF'FFFF        DC32     0xfeffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \        0x0   0xFCFF'FFFF        DC32     0xfcffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \        0x0   0x4002'2008        DC32     0x40022008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \        0x0   0x4567'0123        DC32     0x45670123

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \        0x0   0xCDEF'89AB        DC32     0xcdef89ab

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \        0x0   0x4002'200C        DC32     0x4002200c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \        0x0   0x0819'2A3B        DC32     0x8192a3b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \        0x0   0x4C5D'6E7F        DC32     0x4c5d6e7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \        0x0   0x0000'83FB        DC32     0x83fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \        0x0   0x....'....        DC32     pFlash
    703          
    704          /**
    705            * @}
    706            */
    707          
    708          #endif /* HAL_FLASH_MODULE_ENABLED */
    709          
    710          /**
    711            * @}
    712            */
    713          
    714          /**
    715            * @}
    716            */
    717          
    718          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FLASH_Program_DoubleWord
      20   FLASH_Program_Fast
      32   FLASH_WaitForLastOperation
        32   -> HAL_GetTick
       0   HAL_FLASH_EndOfOperationCallback
       0   HAL_FLASH_GetError
      32   HAL_FLASH_IRQHandler
        32   -> FLASH_PageErase
        32   -> HAL_FLASH_EndOfOperationCallback
        32   -> HAL_FLASH_OperationErrorCallback
       4   HAL_FLASH_Lock
       0   HAL_FLASH_OB_Launch
       4   HAL_FLASH_OB_Lock
       8   HAL_FLASH_OB_Unlock
       0   HAL_FLASH_OperationErrorCallback
      40   HAL_FLASH_Program
        40   -> FLASH_Program_DoubleWord
        40   -> FLASH_Program_Fast
        40   -> FLASH_WaitForLastOperation
      32   HAL_FLASH_Program_IT
        32   -> FLASH_Program_DoubleWord
        32   -> FLASH_Program_Fast
        32   -> FLASH_WaitForLastOperation
       4   HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable8
      30  FLASH_Program_DoubleWord
      68  FLASH_Program_Fast
     116  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     224  HAL_FLASH_IRQHandler
      30  HAL_FLASH_Lock
      16  HAL_FLASH_OB_Launch
      32  HAL_FLASH_OB_Lock
      44  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
     106  HAL_FLASH_Program
     116  HAL_FLASH_Program_IT
      36  HAL_FLASH_Unlock
      24  pFlash

 
  24 bytes in section .bss
 824 bytes in section .text
  68 bytes in section .textrw
 
 888 bytes of CODE memory (+ 4 bytes shared)
  24 bytes of DATA memory

Errors: none
Warnings: none

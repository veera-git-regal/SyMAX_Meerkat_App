###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         04/Feb/2022  12:58:52
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_cortex.c
#    Command line      =
#        -f C:\Users\610126~1\AppData\Local\Temp\EWF784.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_cortex.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\stm32g0xx_hal_cortex.lst
#    Object file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\stm32g0xx_hal_cortex.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_cortex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32g0xx_hal_cortex.c
      4            * @author  MCD Application Team
      5            * @brief   CORTEX HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the CORTEX:
      8            *           + Initialization and Configuration functions
      9            *           + Peripheral Control functions
     10            *
     11            @verbatim
     12            ==============================================================================
     13                                  ##### How to use this driver #####
     14            ==============================================================================
     15              [..]
     16              *** How to configure Interrupts using CORTEX HAL driver ***
     17              ===========================================================
     18              [..]
     19              This section provides functions allowing to configure the NVIC interrupts (IRQ).
     20              The Cortex M0+ exceptions are managed by CMSIS functions.
     21                (#) Enable and Configure the priority of the selected IRQ Channels.
     22                       The priority can be 0..3.
     23          
     24                  -@- Lower priority values gives higher priority.
     25                  -@- Priority Order:
     26                      (#@) Lowest priority.
     27                      (#@) Lowest hardware priority (IRQn position).
     28          
     29                (#)  Configure the priority of the selected IRQ Channels using HAL_NVIC_SetPriority()
     30          
     31                (#)  Enable the selected IRQ Channels using HAL_NVIC_EnableIRQ()
     32          
     33                -@-  Negative value of IRQn_Type are not allowed.
     34          
     35              *** How to configure Systick using CORTEX HAL driver ***
     36              ========================================================
     37              [..]
     38              Setup SysTick Timer for time base.
     39          
     40             (+) The HAL_SYSTICK_Config()function calls the SysTick_Config() function which
     41                 is a CMSIS function that:
     42                  (++) Configures the SysTick Reload register with value passed as function parameter.
     43                  (++) Configures the SysTick IRQ priority to the lowest value (0x03).
     44                  (++) Resets the SysTick Counter register.
     45                  (++) Configures the SysTick Counter clock source to be Core Clock Source (HCLK).
     46                  (++) Enables the SysTick Interrupt.
     47                  (++) Starts the SysTick Counter.
     48          
     49             (+) You can change the SysTick Clock source to be HCLK_Div8 by calling the macro
     50                 __HAL_CORTEX_SYSTICKCLK_CONFIG(SYSTICK_CLKSOURCE_HCLK_DIV8) just after the
     51                 HAL_SYSTICK_Config() function call. The __HAL_CORTEX_SYSTICKCLK_CONFIG() macro is defined
     52                 inside the stm32g0xx_hal_cortex.h file.
     53          
     54             (+) You can change the SysTick IRQ priority by calling the
     55                 HAL_NVIC_SetPriority(SysTick_IRQn,...) function just after the HAL_SYSTICK_Config() function
     56                 call. The HAL_NVIC_SetPriority() call the NVIC_SetPriority() function which is a CMSIS function.
     57          
     58             (+) To adjust the SysTick time base, use the following formula:
     59          
     60                 Reload Value = SysTick Counter Clock (Hz) x  Desired Time base (s)
     61                 (++) Reload Value is the parameter to be passed for HAL_SYSTICK_Config() function
     62                 (++) Reload Value should not exceed 0xFFFFFF
     63          
     64            @endverbatim
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics. 
     69            * All rights reserved.</center></h2>
     70            *
     71            * This software component is licensed by ST under BSD 3-Clause license,
     72            * the "License"; You may not use this file except in compliance with the 
     73            * License. You may obtain a copy of the License at:
     74            *                        opensource.org/licenses/BSD-3-Clause
     75            *
     76            ******************************************************************************
     77            */
     78          
     79          /* Includes ------------------------------------------------------------------*/
     80          #include "stm32g0xx_hal.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
   \        0x4   0xB249             SXTB     R1,R1
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD405             BMI      ??__NVIC_EnableIRQ_0
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x06C2             LSLS     R2,R0,#+27       ;; ZeroExtS R2,R0,#+27,#+27
   \        0xE   0x0ED2             LSRS     R2,R2,#+27
   \       0x10   0x4091             LSLS     R1,R1,R2
   \       0x12   0x....             LDR      R2,??DataTable12  ;; 0xe000e100
   \       0x14   0x6011             STR      R1,[R2, #+0]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x16   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_DisableIRQ(IRQn_Type)
   \                     __NVIC_DisableIRQ: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
   \        0x4   0xB249             SXTB     R1,R1
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD409             BMI      ??__NVIC_DisableIRQ_0
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x06C2             LSLS     R2,R0,#+27       ;; ZeroExtS R2,R0,#+27,#+27
   \        0xE   0x0ED2             LSRS     R2,R2,#+27
   \       0x10   0x4091             LSLS     R1,R1,R2
   \       0x12   0x....             LDR      R2,??DataTable12_1  ;; 0xe000e180
   \       0x14   0x6011             STR      R1,[R2, #+0]
   \       0x16   0xF3BF 0x8F4F      DSB      SY
   \       0x1A   0xF3BF 0x8F6F      ISB      SY
   \                     ??__NVIC_DisableIRQ_0: (+1)
   \       0x1E   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t __NVIC_GetPendingIRQ(IRQn_Type)
   \                     __NVIC_GetPendingIRQ: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
   \        0x4   0x0008             MOVS     R0,R1
   \        0x6   0xB240             SXTB     R0,R0
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD408             BMI      ??__NVIC_GetPendingIRQ_0
   \        0xC   0x....             LDR      R0,??DataTable12_2  ;; 0xe000e200
   \        0xE   0x6802             LDR      R2,[R0, #+0]
   \       0x10   0x06C8             LSLS     R0,R1,#+27       ;; ZeroExtS R0,R1,#+27,#+27
   \       0x12   0x0EC0             LSRS     R0,R0,#+27
   \       0x14   0x40C2             LSRS     R2,R2,R0
   \       0x16   0x0010             MOVS     R0,R2
   \       0x18   0x07C0             LSLS     R0,R0,#+31       ;; ZeroExtS R0,R0,#+31,#+31
   \       0x1A   0x0FC0             LSRS     R0,R0,#+31
   \       0x1C   0xE000             B        ??__NVIC_GetPendingIRQ_1
   \                     ??__NVIC_GetPendingIRQ_0: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \                     ??__NVIC_GetPendingIRQ_1: (+1)
   \       0x20   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_SetPendingIRQ(IRQn_Type)
   \                     __NVIC_SetPendingIRQ: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
   \        0x4   0xB249             SXTB     R1,R1
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD405             BMI      ??__NVIC_SetPendingIRQ_0
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x06C2             LSLS     R2,R0,#+27       ;; ZeroExtS R2,R0,#+27,#+27
   \        0xE   0x0ED2             LSRS     R2,R2,#+27
   \       0x10   0x4091             LSLS     R1,R1,R2
   \       0x12   0x....             LDR      R2,??DataTable12_2  ;; 0xe000e200
   \       0x14   0x6011             STR      R1,[R2, #+0]
   \                     ??__NVIC_SetPendingIRQ_0: (+1)
   \       0x16   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_ClearPendingIRQ(IRQn_Type)
   \                     __NVIC_ClearPendingIRQ: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
   \        0x4   0xB249             SXTB     R1,R1
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD405             BMI      ??__NVIC_ClearPendingIRQ_0
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x06C2             LSLS     R2,R0,#+27       ;; ZeroExtS R2,R0,#+27,#+27
   \        0xE   0x0ED2             LSRS     R2,R2,#+27
   \       0x10   0x4091             LSLS     R1,R1,R2
   \       0x12   0x....             LDR      R2,??DataTable12_3  ;; 0xe000e280
   \       0x14   0x6011             STR      R1,[R2, #+0]
   \                     ??__NVIC_ClearPendingIRQ_0: (+1)
   \       0x16   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     __NVIC_SetPriority: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x0002             MOVS     R2,R0
   \        0x4   0xB252             SXTB     R2,R2
   \        0x6   0x2A00             CMP      R2,#+0
   \        0x8   0xD41C             BMI      ??__NVIC_SetPriority_0
   \        0xA   0x2203             MOVS     R2,#+3
   \        0xC   0x....             LDR      R3,??DataTable12_4  ;; 0xe000e400
   \        0xE   0x0004             MOVS     R4,R0
   \       0x10   0xB264             SXTB     R4,R4
   \       0x12   0x08A4             LSRS     R4,R4,#+2
   \       0x14   0x2504             MOVS     R5,#+4
   \       0x16   0x436C             MULS     R4,R5,R4
   \       0x18   0x591C             LDR      R4,[R3, R4]
   \       0x1A   0x25FF             MOVS     R5,#+255
   \       0x1C   0x0016             MOVS     R6,R2
   \       0x1E   0x4006             ANDS     R6,R6,R0
   \       0x20   0x2708             MOVS     R7,#+8
   \       0x22   0x437E             MULS     R6,R7,R6
   \       0x24   0x40B5             LSLS     R5,R5,R6
   \       0x26   0x43AC             BICS     R4,R4,R5
   \       0x28   0x018D             LSLS     R5,R1,#+6
   \       0x2A   0xB2ED             UXTB     R5,R5
   \       0x2C   0x4002             ANDS     R2,R2,R0
   \       0x2E   0x2608             MOVS     R6,#+8
   \       0x30   0x4372             MULS     R2,R6,R2
   \       0x32   0x4095             LSLS     R5,R5,R2
   \       0x34   0x4325             ORRS     R5,R5,R4
   \       0x36   0x0002             MOVS     R2,R0
   \       0x38   0xB252             SXTB     R2,R2
   \       0x3A   0x0892             LSRS     R2,R2,#+2
   \       0x3C   0x2404             MOVS     R4,#+4
   \       0x3E   0x4362             MULS     R2,R4,R2
   \       0x40   0x509D             STR      R5,[R3, R2]
   \       0x42   0xE022             B        ??__NVIC_SetPriority_1
   \                     ??__NVIC_SetPriority_0: (+1)
   \       0x44   0x240F             MOVS     R4,#+15
   \       0x46   0x....             LDR      R2,??DataTable12_5  ;; 0xe000ed1c
   \       0x48   0x2303             MOVS     R3,#+3
   \       0x4A   0x0005             MOVS     R5,R0
   \       0x4C   0xB26D             SXTB     R5,R5
   \       0x4E   0x4025             ANDS     R5,R5,R4
   \       0x50   0x3D08             SUBS     R5,R5,#+8
   \       0x52   0x08AD             LSRS     R5,R5,#+2
   \       0x54   0x2604             MOVS     R6,#+4
   \       0x56   0x4375             MULS     R5,R6,R5
   \       0x58   0x0006             MOVS     R6,R0
   \       0x5A   0xB276             SXTB     R6,R6
   \       0x5C   0x4034             ANDS     R4,R4,R6
   \       0x5E   0x3C08             SUBS     R4,R4,#+8
   \       0x60   0x08A4             LSRS     R4,R4,#+2
   \       0x62   0x2604             MOVS     R6,#+4
   \       0x64   0x4374             MULS     R4,R6,R4
   \       0x66   0x5916             LDR      R6,[R2, R4]
   \       0x68   0x27FF             MOVS     R7,#+255
   \       0x6A   0x46BC             MOV      R12,R7
   \       0x6C   0x001C             MOVS     R4,R3
   \       0x6E   0x4004             ANDS     R4,R4,R0
   \       0x70   0x2708             MOVS     R7,#+8
   \       0x72   0x437C             MULS     R4,R7,R4
   \       0x74   0x4667             MOV      R7,R12
   \       0x76   0x40A7             LSLS     R7,R7,R4
   \       0x78   0x43BE             BICS     R6,R6,R7
   \       0x7A   0x018C             LSLS     R4,R1,#+6
   \       0x7C   0xB2E4             UXTB     R4,R4
   \       0x7E   0x4003             ANDS     R3,R3,R0
   \       0x80   0x2708             MOVS     R7,#+8
   \       0x82   0x437B             MULS     R3,R7,R3
   \       0x84   0x409C             LSLS     R4,R4,R3
   \       0x86   0x4334             ORRS     R4,R4,R6
   \       0x88   0x5154             STR      R4,[R2, R5]
   \                     ??__NVIC_SetPriority_1: (+1)
   \       0x8A   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t __NVIC_GetPriority(IRQn_Type)
   \                     __NVIC_GetPriority: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0001             MOVS     R1,R0
   \        0x4   0x0008             MOVS     R0,R1
   \        0x6   0xB240             SXTB     R0,R0
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD40F             BMI      ??__NVIC_GetPriority_0
   \        0xC   0x2003             MOVS     R0,#+3
   \        0xE   0x....             LDR      R2,??DataTable12_4  ;; 0xe000e400
   \       0x10   0x000B             MOVS     R3,R1
   \       0x12   0xB25B             SXTB     R3,R3
   \       0x14   0x089B             LSRS     R3,R3,#+2
   \       0x16   0x2404             MOVS     R4,#+4
   \       0x18   0x4363             MULS     R3,R4,R3
   \       0x1A   0x58D2             LDR      R2,[R2, R3]
   \       0x1C   0x0003             MOVS     R3,R0
   \       0x1E   0x400B             ANDS     R3,R3,R1
   \       0x20   0x2108             MOVS     R1,#+8
   \       0x22   0x434B             MULS     R3,R1,R3
   \       0x24   0x40DA             LSRS     R2,R2,R3
   \       0x26   0x0991             LSRS     R1,R2,#+6
   \       0x28   0x4008             ANDS     R0,R0,R1
   \       0x2A   0xE011             B        ??__NVIC_GetPriority_1
   \                     ??__NVIC_GetPriority_0: (+1)
   \       0x2C   0x2003             MOVS     R0,#+3
   \       0x2E   0x....             LDR      R2,??DataTable12_5  ;; 0xe000ed1c
   \       0x30   0x000B             MOVS     R3,R1
   \       0x32   0xB25B             SXTB     R3,R3
   \       0x34   0x071B             LSLS     R3,R3,#+28       ;; ZeroExtS R3,R3,#+28,#+28
   \       0x36   0x0F1B             LSRS     R3,R3,#+28
   \       0x38   0x3B08             SUBS     R3,R3,#+8
   \       0x3A   0x089B             LSRS     R3,R3,#+2
   \       0x3C   0x2404             MOVS     R4,#+4
   \       0x3E   0x4363             MULS     R3,R4,R3
   \       0x40   0x58D2             LDR      R2,[R2, R3]
   \       0x42   0x0003             MOVS     R3,R0
   \       0x44   0x400B             ANDS     R3,R3,R1
   \       0x46   0x2108             MOVS     R1,#+8
   \       0x48   0x434B             MULS     R3,R1,R3
   \       0x4A   0x40DA             LSRS     R2,R2,R3
   \       0x4C   0x0991             LSRS     R1,R2,#+6
   \       0x4E   0x4008             ANDS     R0,R0,R1
   \                     ??__NVIC_GetPriority_1: (+1)
   \       0x50   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_SystemReset(void)
   \                     __NVIC_SystemReset: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0xF3BF 0x8F4F      DSB      SY
   \        0x6   0x....             LDR      R0,??DataTable12_6  ;; 0x5fa0004
   \        0x8   0x....             LDR      R1,??DataTable12_7  ;; 0xe000ed0c
   \        0xA   0x6008             STR      R0,[R1, #+0]
   \        0xC   0xF3BF 0x8F4F      DSB      SY
   \                     ??__NVIC_SystemReset_0: (+1)
   \       0x10   0xBF00             Nop
   \       0x12   0xE7FD             B        ??__NVIC_SystemReset_0

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t SysTick_Config(uint32_t)
   \                     SysTick_Config: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x1E60             SUBS     R0,R4,#+1
   \        0x6   0x2180             MOVS     R1,#+128
   \        0x8   0x0449             LSLS     R1,R1,#+17       ;; #+16777216
   \        0xA   0x4288             CMP      R0,R1
   \        0xC   0xD301             BCC      ??SysTick_Config_0
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE00E             B        ??SysTick_Config_1
   \                     ??SysTick_Config_0: (+1)
   \       0x12   0x1E60             SUBS     R0,R4,#+1
   \       0x14   0x....             LDR      R1,??DataTable12_8  ;; 0xe000e014
   \       0x16   0x6008             STR      R0,[R1, #+0]
   \       0x18   0x2103             MOVS     R1,#+3
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x1E   0x....'....        BL       __NVIC_SetPriority
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x....             LDR      R1,??DataTable12_9  ;; 0xe000e018
   \       0x26   0x6008             STR      R0,[R1, #+0]
   \       0x28   0x2007             MOVS     R0,#+7
   \       0x2A   0x....             LDR      R1,??DataTable12_10  ;; 0xe000e010
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   \       0x2E   0x2000             MOVS     R0,#+0
   \                     ??SysTick_Config_1: (+1)
   \       0x30   0xBD10             POP      {R4,PC}          ;; return
     81          
     82          /** @addtogroup STM32G0xx_HAL_Driver
     83            * @{
     84            */
     85          
     86          /** @addtogroup CORTEX
     87            * @{
     88            */
     89          
     90          #ifdef HAL_CORTEX_MODULE_ENABLED
     91          
     92          /* Private types -------------------------------------------------------------*/
     93          /* Private variables ---------------------------------------------------------*/
     94          /* Private constants ---------------------------------------------------------*/
     95          /* Private macros ------------------------------------------------------------*/
     96          /* Private function prototypes -----------------------------------------------*/
     97          /* Exported functions --------------------------------------------------------*/
     98          
     99          /** @addtogroup CORTEX_Exported_Functions
    100            * @{
    101            */
    102          
    103          
    104          /** @addtogroup CORTEX_Exported_Functions_Group1
    105           *  @brief    Initialization and Configuration functions
    106           *
    107          @verbatim
    108            ==============================================================================
    109                        ##### Initialization and Configuration functions #####
    110            ==============================================================================
    111              [..]
    112                This section provides the CORTEX HAL driver functions allowing to configure Interrupts
    113                Systick functionalities
    114          
    115          @endverbatim
    116            * @{
    117            */
    118          
    119          /**
    120            * @brief Sets the priority of an interrupt.
    121            * @param IRQn External interrupt number .
    122            *         This parameter can be an enumerator of IRQn_Type enumeration
    123            *         (For the complete STM32 Devices IRQ Channels list, please refer to stm32g0xx.h file)
    124            * @param PreemptPriority The preemption priority for the IRQn channel.
    125            *         This parameter can be a value between 0 and 3.
    126            *         A lower priority value indicates a higher priority
    127            * @param SubPriority the subpriority level for the IRQ channel.
    128            *         with stm32g0xx devices, this parameter is a dummy value and it is ignored, because
    129            *         no subpriority supported in Cortex M0+ based products.
    130            * @retval None
    131            */

   \                                 In section .text, align 2, keep-with-next
    132          void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
    133          {
   \                     HAL_NVIC_SetPriority: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   \        0x6   0x0016             MOVS     R6,R2
    134            /* Check the parameters */
    135            assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
    136            NVIC_SetPriority(IRQn,PreemptPriority);
   \        0x8   0x0021             MOVS     R1,R4
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0xB240             SXTB     R0,R0
   \        0xE   0x....'....        BL       __NVIC_SetPriority
    137          }
   \       0x12   0xBD70             POP      {R4-R6,PC}       ;; return
    138          
    139          /**
    140            * @brief  Enable a device specific interrupt in the NVIC interrupt controller.
    141            * @param  IRQn External interrupt number.
    142            *         This parameter can be an enumerator of IRQn_Type enumeration
    143            *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g0xxxx.h))
    144            * @retval None
    145            */

   \                                 In section .text, align 2, keep-with-next
    146          void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
    147          {
   \                     HAL_NVIC_EnableIRQ: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    148            /* Check the parameters */
    149            assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    150          
    151            /* Enable interrupt */
    152            NVIC_EnableIRQ(IRQn);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB240             SXTB     R0,R0
   \        0x8   0x....'....        BL       __NVIC_EnableIRQ
    153          }
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    154          
    155          /**
    156            * @brief  Disable a device specific interrupt in the NVIC interrupt controller.
    157            * @param  IRQn External interrupt number.
    158            *         This parameter can be an enumerator of IRQn_Type enumeration
    159            *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g0xxxx.h))
    160            * @retval None
    161            */

   \                                 In section .text, align 2, keep-with-next
    162          void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
    163          {
   \                     HAL_NVIC_DisableIRQ: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    164            /* Check the parameters */
    165            assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    166          
    167            /* Disable interrupt */
    168            NVIC_DisableIRQ(IRQn);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB240             SXTB     R0,R0
   \        0x8   0x....'....        BL       __NVIC_DisableIRQ
    169          }
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    170          
    171          /**
    172            * @brief  Initiate a system reset request to reset the MCU.
    173            * @retval None
    174            */

   \                                 In section .text, align 2, keep-with-next
    175          void HAL_NVIC_SystemReset(void)
    176          {
   \                     HAL_NVIC_SystemReset: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    177            /* System Reset */
    178            NVIC_SystemReset();
   \        0x2   0x....'....        BL       __NVIC_SystemReset
    179          }
   \        0x6   0xBD01             POP      {R0,PC}          ;; return
    180          
    181          /**
    182            * @brief  Initialize the System Timer with interrupt enabled and start the System Tick Timer (SysTick):
    183            *         Counter is in free running mode to generate periodic interrupts.
    184            * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
    185            * @retval status:  - 0  Function succeeded.
    186            *                  - 1  Function failed.
    187            */

   \                                 In section .text, align 2, keep-with-next
    188          uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
    189          {
   \                     HAL_SYSTICK_Config: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    190            return SysTick_Config(TicksNumb);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0x....'....        BL       SysTick_Config
   \        0xA   0xBD10             POP      {R4,PC}          ;; return
    191          }
    192          /**
    193            * @}
    194            */
    195          
    196          /** @addtogroup CORTEX_Exported_Functions_Group2
    197           *  @brief   Cortex control functions
    198           *
    199          @verbatim
    200            ==============================================================================
    201                                ##### Peripheral Control functions #####
    202            ==============================================================================
    203              [..]
    204                This subsection provides a set of functions allowing to control the CORTEX
    205                (NVIC, SYSTICK, MPU) functionalities.
    206          
    207          
    208          @endverbatim
    209            * @{
    210            */
    211          
    212          /**
    213            * @brief  Get the priority of an interrupt.
    214            * @param  IRQn External interrupt number.
    215            *         This parameter can be an enumerator of IRQn_Type enumeration
    216            *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g0xxxx.h))
    217            * @retval None
    218            */

   \                                 In section .text, align 2, keep-with-next
    219          uint32_t HAL_NVIC_GetPriority(IRQn_Type IRQn)
    220          {
   \                     HAL_NVIC_GetPriority: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    221            /* Get priority for Cortex-M system or device specific interrupts */
    222            return NVIC_GetPriority(IRQn);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB240             SXTB     R0,R0
   \        0x8   0x....'....        BL       __NVIC_GetPriority
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    223          }
    224          
    225          /**
    226            * @brief  Set Pending bit of an external interrupt.
    227            * @param  IRQn External interrupt number
    228            *         This parameter can be an enumerator of IRQn_Type enumeration
    229            *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g0xxxx.h))
    230            * @retval None
    231            */

   \                                 In section .text, align 2, keep-with-next
    232          void HAL_NVIC_SetPendingIRQ(IRQn_Type IRQn)
    233          {
   \                     HAL_NVIC_SetPendingIRQ: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    234            /* Check the parameters */
    235            assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    236          
    237            /* Set interrupt pending */
    238            NVIC_SetPendingIRQ(IRQn);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB240             SXTB     R0,R0
   \        0x8   0x....'....        BL       __NVIC_SetPendingIRQ
    239          }
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    240          
    241          /**
    242            * @brief  Get Pending Interrupt (read the pending register in the NVIC
    243            *         and return the pending bit for the specified interrupt).
    244            * @param  IRQn External interrupt number.
    245            *         This parameter can be an enumerator of IRQn_Type enumeration
    246            *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g0xxxx.h))
    247            * @retval status: - 0  Interrupt status is not pending.
    248            *                 - 1  Interrupt status is pending.
    249            */

   \                                 In section .text, align 2, keep-with-next
    250          uint32_t HAL_NVIC_GetPendingIRQ(IRQn_Type IRQn)
    251          {
   \                     HAL_NVIC_GetPendingIRQ: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    252            /* Check the parameters */
    253            assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    254          
    255            /* Return 1 if pending else 0 */
    256            return NVIC_GetPendingIRQ(IRQn);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB240             SXTB     R0,R0
   \        0x8   0x....'....        BL       __NVIC_GetPendingIRQ
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    257          }
    258          
    259          /**
    260            * @brief  Clear the pending bit of an external interrupt.
    261            * @param  IRQn External interrupt number.
    262            *         This parameter can be an enumerator of IRQn_Type enumeration
    263            *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32g0xxxx.h))
    264            * @retval None
    265            */

   \                                 In section .text, align 2, keep-with-next
    266          void HAL_NVIC_ClearPendingIRQ(IRQn_Type IRQn)
    267          {
   \                     HAL_NVIC_ClearPendingIRQ: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    268            /* Check the parameters */
    269            assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
    270          
    271            /* Clear pending interrupt */
    272            NVIC_ClearPendingIRQ(IRQn);
   \        0x4   0x0020             MOVS     R0,R4
   \        0x6   0xB240             SXTB     R0,R0
   \        0x8   0x....'....        BL       __NVIC_ClearPendingIRQ
    273          }
   \        0xC   0xBD10             POP      {R4,PC}          ;; return
    274          
    275          /**
    276            * @brief  Configure the SysTick clock source.
    277            * @param CLKSource specifies the SysTick clock source.
    278            *         This parameter can be one of the following values:
    279            *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
    280            *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
    281            * @retval None
    282            */

   \                                 In section .text, align 2, keep-with-next
    283          void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
    284          {
   \                     HAL_SYSTICK_CLKSourceConfig: (+1)
   \        0x0   0xB500             PUSH     {LR}
    285            /* Check the parameters */
    286            assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
    287            if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
   \        0x2   0x2804             CMP      R0,#+4
   \        0x4   0xD105             BNE      ??HAL_SYSTICK_CLKSourceConfig_0
    288            {
    289              SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
   \        0x6   0x....             LDR      R1,??DataTable12_10  ;; 0xe000e010
   \        0x8   0x680A             LDR      R2,[R1, #+0]
   \        0xA   0x2304             MOVS     R3,#+4
   \        0xC   0x4313             ORRS     R3,R3,R2
   \        0xE   0x600B             STR      R3,[R1, #+0]
   \       0x10   0xE004             B        ??HAL_SYSTICK_CLKSourceConfig_1
    290            }
    291            else
    292            {
    293              SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
   \                     ??HAL_SYSTICK_CLKSourceConfig_0: (+1)
   \       0x12   0x....             LDR      R1,??DataTable12_10  ;; 0xe000e010
   \       0x14   0x680A             LDR      R2,[R1, #+0]
   \       0x16   0x2304             MOVS     R3,#+4
   \       0x18   0x439A             BICS     R2,R2,R3
   \       0x1A   0x600A             STR      R2,[R1, #+0]
    294            }
    295          }
   \                     ??HAL_SYSTICK_CLKSourceConfig_1: (+1)
   \       0x1C   0xBD00             POP      {PC}             ;; return
    296          
    297          /**
    298            * @brief  Handle SYSTICK interrupt request.
    299            * @retval None
    300            */

   \                                 In section .text, align 2, keep-with-next
    301          void HAL_SYSTICK_IRQHandler(void)
    302          {
   \                     HAL_SYSTICK_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    303            HAL_SYSTICK_Callback();
   \        0x2   0x....'....        BL       HAL_SYSTICK_Callback
    304          }
   \        0x6   0xBD01             POP      {R0,PC}          ;; return
    305          
    306          /**
    307            * @brief  SYSTICK callback.
    308            * @retval None
    309            */

   \                                 In section .text, align 2
    310          __weak void HAL_SYSTICK_Callback(void)
    311          {
    312            /* NOTE : This function should not be modified, when the callback is needed,
    313                      the HAL_SYSTICK_Callback could be implemented in the user file
    314             */
    315          }
   \                     HAL_SYSTICK_Callback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    316          
    317          #if (__MPU_PRESENT == 1U)
    318          /**
    319            * @brief  Enable the MPU.
    320            * @param  MPU_Control Specifies the control mode of the MPU during hard fault,
    321            *          NMI, FAULTMASK and privileged access to the default memory
    322            *          This parameter can be one of the following values:
    323            *            @arg MPU_HFNMI_PRIVDEF_NONE
    324            *            @arg MPU_HARDFAULT_NMI
    325            *            @arg MPU_PRIVILEGED_DEFAULT
    326            *            @arg MPU_HFNMI_PRIVDEF
    327            * @retval None
    328            */

   \                                 In section .text, align 2, keep-with-next
    329          void HAL_MPU_Enable(uint32_t MPU_Control)
    330          {
    331            /* Enable the MPU */
    332            MPU->CTRL = (MPU_Control | MPU_CTRL_ENABLE_Msk);
   \                     HAL_MPU_Enable: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x4301             ORRS     R1,R1,R0
   \        0x4   0x....             LDR      R2,??DataTable12_11  ;; 0xe000ed94
   \        0x6   0x6011             STR      R1,[R2, #+0]
    333          
    334            /* Ensure MPU setting take effects */
    335            __DSB();
   \        0x8   0xF3BF 0x8F4F      DSB      SY
    336            __ISB();
   \        0xC   0xF3BF 0x8F6F      ISB      SY
    337          }
   \       0x10   0x4770             BX       LR               ;; return
    338          
    339          
    340          /**
    341            * @brief  Disable the MPU.
    342            * @retval None
    343            */

   \                                 In section .text, align 2, keep-with-next
    344          void HAL_MPU_Disable(void)
    345          {
    346            /* Make sure outstanding transfers are done */
    347            __DMB();
   \                     HAL_MPU_Disable: (+1)
   \        0x0   0xF3BF 0x8F5F      DMB      SY
    348          
    349            /* Disable the MPU and clear the control register*/
    350            MPU->CTRL  = 0;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x....             LDR      R1,??DataTable12_11  ;; 0xe000ed94
   \        0x8   0x6008             STR      R0,[R1, #+0]
    351          }
   \        0xA   0x4770             BX       LR               ;; return
    352          
    353          
    354          /**
    355            * @brief  Initialize and configure the Region and the memory to be protected.
    356            * @param MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
    357            *                the initialization and configuration information.
    358            * @retval None
    359            */

   \                                 In section .text, align 2, keep-with-next
    360          void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
    361          {
   \                     HAL_MPU_ConfigRegion: (+1)
   \        0x0   0xB500             PUSH     {LR}
    362            /* Check the parameters */
    363            assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
    364            assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
    365          
    366            /* Set the Region number */
    367            MPU->RNR = MPU_Init->Number;
   \        0x2   0x7841             LDRB     R1,[R0, #+1]
   \        0x4   0x....             LDR      R2,??DataTable12_12  ;; 0xe000ed98
   \        0x6   0x6011             STR      R1,[R2, #+0]
    368          
    369            if ((MPU_Init->Enable) != 0U)
   \        0x8   0x7801             LDRB     R1,[R0, #+0]
   \        0xA   0x2900             CMP      R1,#+0
   \        0xC   0xD01E             BEQ      ??HAL_MPU_ConfigRegion_0
    370            {
    371              /* Check the parameters */
    372              assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
    373              assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
    374              assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
    375              assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
    376              assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    377              assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    378              assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    379              assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    380          
    381              MPU->RBAR = MPU_Init->BaseAddress;
   \        0xE   0x6841             LDR      R1,[R0, #+4]
   \       0x10   0x....             LDR      R2,??DataTable12_13  ;; 0xe000ed9c
   \       0x12   0x6011             STR      R1,[R2, #+0]
    382              MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
    383                          ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
    384                          ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
    385                          ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
    386                          ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
    387                          ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
    388                          ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
    389                          ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
    390                          ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
   \       0x14   0x7B01             LDRB     R1,[R0, #+12]
   \       0x16   0x0709             LSLS     R1,R1,#+28
   \       0x18   0x7AC2             LDRB     R2,[R0, #+11]
   \       0x1A   0x0612             LSLS     R2,R2,#+24
   \       0x1C   0x430A             ORRS     R2,R2,R1
   \       0x1E   0x7A81             LDRB     R1,[R0, #+10]
   \       0x20   0x04C9             LSLS     R1,R1,#+19
   \       0x22   0x4311             ORRS     R1,R1,R2
   \       0x24   0x7B42             LDRB     R2,[R0, #+13]
   \       0x26   0x0492             LSLS     R2,R2,#+18
   \       0x28   0x430A             ORRS     R2,R2,R1
   \       0x2A   0x7B81             LDRB     R1,[R0, #+14]
   \       0x2C   0x0449             LSLS     R1,R1,#+17
   \       0x2E   0x4311             ORRS     R1,R1,R2
   \       0x30   0x7BC2             LDRB     R2,[R0, #+15]
   \       0x32   0x0412             LSLS     R2,R2,#+16
   \       0x34   0x430A             ORRS     R2,R2,R1
   \       0x36   0x7A41             LDRB     R1,[R0, #+9]
   \       0x38   0x0209             LSLS     R1,R1,#+8
   \       0x3A   0x4311             ORRS     R1,R1,R2
   \       0x3C   0x7A02             LDRB     R2,[R0, #+8]
   \       0x3E   0x0052             LSLS     R2,R2,#+1
   \       0x40   0x430A             ORRS     R2,R2,R1
   \       0x42   0x7801             LDRB     R1,[R0, #+0]
   \       0x44   0x4311             ORRS     R1,R1,R2
   \       0x46   0x....             LDR      R2,??DataTable12_14  ;; 0xe000eda0
   \       0x48   0x6011             STR      R1,[R2, #+0]
   \       0x4A   0xE004             B        ??HAL_MPU_ConfigRegion_1
    391            }
    392            else
    393            {
    394              MPU->RBAR = 0x00U;
   \                     ??HAL_MPU_ConfigRegion_0: (+1)
   \       0x4C   0x2100             MOVS     R1,#+0
   \       0x4E   0x....             LDR      R2,??DataTable12_13  ;; 0xe000ed9c
   \       0x50   0x6011             STR      R1,[R2, #+0]
    395              MPU->RASR = 0x00U;
   \       0x52   0x....             LDR      R2,??DataTable12_14  ;; 0xe000eda0
   \       0x54   0x6011             STR      R1,[R2, #+0]
    396            }
    397          }
   \                     ??HAL_MPU_ConfigRegion_1: (+1)
   \       0x56   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0xE000'E180        DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0xE000'E200        DC32     0xe000e200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0xE000'E280        DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0xE000'E400        DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0xE000'ED1C        DC32     0xe000ed1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x05FA'0004        DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0xE000'ED0C        DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \        0x0   0xE000'E014        DC32     0xe000e014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \        0x0   0xE000'E018        DC32     0xe000e018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \        0x0   0xE000'E010        DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \        0x0   0xE000'ED94        DC32     0xe000ed94

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \        0x0   0xE000'ED98        DC32     0xe000ed98

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \        0x0   0xE000'ED9C        DC32     0xe000ed9c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \        0x0   0xE000'EDA0        DC32     0xe000eda0
    398          #endif /* __MPU_PRESENT */
    399          
    400          /**
    401            * @}
    402            */
    403          
    404          /**
    405            * @}
    406            */
    407          
    408          #endif /* HAL_CORTEX_MODULE_ENABLED */
    409          /**
    410            * @}
    411            */
    412          
    413          /**
    414            * @}
    415            */
    416          
    417          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   HAL_MPU_ConfigRegion
       0   HAL_MPU_Disable
       0   HAL_MPU_Enable
       8   HAL_NVIC_ClearPendingIRQ
         8   -> __NVIC_ClearPendingIRQ
       8   HAL_NVIC_DisableIRQ
         8   -> __NVIC_DisableIRQ
       8   HAL_NVIC_EnableIRQ
         8   -> __NVIC_EnableIRQ
       8   HAL_NVIC_GetPendingIRQ
         8   -> __NVIC_GetPendingIRQ
       8   HAL_NVIC_GetPriority
         8   -> __NVIC_GetPriority
       8   HAL_NVIC_SetPendingIRQ
         8   -> __NVIC_SetPendingIRQ
      16   HAL_NVIC_SetPriority
        16   -> __NVIC_SetPriority
       8   HAL_NVIC_SystemReset
         8   -> __NVIC_SystemReset
       4   HAL_SYSTICK_CLKSourceConfig
       0   HAL_SYSTICK_Callback
       8   HAL_SYSTICK_Config
         8   -> SysTick_Config
       8   HAL_SYSTICK_IRQHandler
         8   -> HAL_SYSTICK_Callback
       8   SysTick_Config
         8   -> __NVIC_SetPriority
       4   __NVIC_ClearPendingIRQ
       4   __NVIC_DisableIRQ
       4   __NVIC_EnableIRQ
       4   __NVIC_GetPendingIRQ
       8   __NVIC_GetPriority
       4   __NVIC_SetPendingIRQ
      20   __NVIC_SetPriority
       4   __NVIC_SystemReset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      88  HAL_MPU_ConfigRegion
      12  HAL_MPU_Disable
      18  HAL_MPU_Enable
      14  HAL_NVIC_ClearPendingIRQ
      14  HAL_NVIC_DisableIRQ
      14  HAL_NVIC_EnableIRQ
      14  HAL_NVIC_GetPendingIRQ
      14  HAL_NVIC_GetPriority
      14  HAL_NVIC_SetPendingIRQ
      20  HAL_NVIC_SetPriority
       8  HAL_NVIC_SystemReset
      30  HAL_SYSTICK_CLKSourceConfig
       2  HAL_SYSTICK_Callback
      12  HAL_SYSTICK_Config
       8  HAL_SYSTICK_IRQHandler
      50  SysTick_Config
      24  __NVIC_ClearPendingIRQ
      32  __NVIC_DisableIRQ
      24  __NVIC_EnableIRQ
      34  __NVIC_GetPendingIRQ
      82  __NVIC_GetPriority
      24  __NVIC_SetPendingIRQ
     140  __NVIC_SetPriority
      20  __NVIC_SystemReset

 
 772 bytes in section .text
 
 770 bytes of CODE memory (+ 2 bytes shared)

Errors: none
Warnings: none

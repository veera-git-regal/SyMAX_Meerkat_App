###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         04/Feb/2022  12:58:50
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal.c
#    Command line      =
#        -f C:\Users\610126~1\AppData\Local\Temp\EWEEC9.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\stm32g0xx_hal.lst
#    Object file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\stm32g0xx_hal.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32g0xx_hal.c
      4            * @author  MCD Application Team
      5            * @brief   HAL module driver.
      6            *          This is the common part of the HAL initialization
      7            *
      8            @verbatim
      9            ==============================================================================
     10                               ##### How to use this driver #####
     11            ==============================================================================
     12              [..]
     13              The common HAL driver contains a set of generic and common APIs that can be
     14              used by the PPP peripheral drivers and the user to start using the HAL.
     15              [..]
     16              The HAL contains two APIs categories:
     17                   (+) Common HAL APIs
     18                   (+) Services HAL APIs
     19          
     20            @endverbatim
     21            ******************************************************************************
     22            * @attention
     23            *
     24            * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics. 
     25            * All rights reserved.</center></h2>
     26            *
     27            * This software component is licensed by ST under BSD 3-Clause license,
     28            * the "License"; You may not use this file except in compliance with the 
     29            * License. You may obtain a copy of the License at:
     30            *                        opensource.org/licenses/BSD-3-Clause
     31            *
     32            ******************************************************************************
     33            */
     34          
     35          /* Includes ------------------------------------------------------------------*/
     36          #include "stm32g0xx_hal.h"
     37          
     38          /** @addtogroup STM32G0xx_HAL_Driver
     39            * @{
     40            */
     41          
     42          /** @addtogroup HAL
     43            * @brief HAL module driver
     44            * @{
     45            */
     46          
     47          #ifdef HAL_MODULE_ENABLED
     48          
     49          /* Private typedef -----------------------------------------------------------*/
     50          /* Private define ------------------------------------------------------------*/
     51          
     52          /** @defgroup HAL_Private_Constants HAL Private Constants
     53            * @{
     54            */
     55          /**
     56           * @brief STM32G0xx HAL Driver version number
     57             */
     58          #define __STM32G0xx_HAL_VERSION_MAIN   (0x01U) /*!< [31:24] main version */
     59          #define __STM32G0xx_HAL_VERSION_SUB1   (0x03U) /*!< [23:16] sub1 version */
     60          #define __STM32G0xx_HAL_VERSION_SUB2   (0x00U) /*!< [15:8]  sub2 version */
     61          #define __STM32G0xx_HAL_VERSION_RC     (0x00U) /*!< [7:0]  release candidate */
     62          #define __STM32G0xx_HAL_VERSION         ((__STM32G0xx_HAL_VERSION_MAIN << 24U)\
     63                                                  |(__STM32G0xx_HAL_VERSION_SUB1 << 16U)\
     64                                                  |(__STM32G0xx_HAL_VERSION_SUB2 << 8U )\
     65                                                  |(__STM32G0xx_HAL_VERSION_RC))
     66          
     67          #if defined(VREFBUF)
     68          #define VREFBUF_TIMEOUT_VALUE     10U   /*!<  10 ms */
     69          #endif /* VREFBUF */
     70          
     71          /**
     72            * @}
     73            */
     74          
     75          /* Private macro -------------------------------------------------------------*/
     76          /* Exported variables ---------------------------------------------------------*/
     77          /** @defgroup HAL_Exported_Variables HAL Exported Variables
     78            * @{
     79            */

   \                                 In section .bss, align 4
     80          __IO uint32_t uwTick;
   \                     uwTick:
   \        0x0                      DS8 4

   \                                 In section .data, align 4
     81          uint32_t uwTickPrio = (1UL << __NVIC_PRIO_BITS); /* Invalid PRIO */
   \                     uwTickPrio:
   \        0x0   0x0000'0004        DC32 4

   \                                 In section .data, align 4
     82          uint32_t uwTickFreq = HAL_TICK_FREQ_DEFAULT;  /* 1KHz */
   \                     uwTickFreq:
   \        0x0   0x0000'0001        DC32 1
     83          /**
     84            * @}
     85            */
     86          
     87          /* Private function prototypes -----------------------------------------------*/
     88          /* Exported functions --------------------------------------------------------*/
     89          
     90          /** @addtogroup HAL_Exported_Functions
     91            * @{
     92            */
     93          
     94          /** @addtogroup HAL_Exported_Functions_Group1
     95           *  @brief    HAL Initialization and Configuration functions
     96           *
     97          @verbatim
     98           ===============================================================================
     99                     ##### HAL Initialization and Configuration functions #####
    100           ===============================================================================
    101              [..]  This section provides functions allowing to:
    102                (+) Initialize the Flash interface the NVIC allocation and initial time base
    103                    clock configuration.
    104                (+) De-initialize common part of the HAL.
    105                (+) Configure the time base source to have 1ms time base with a dedicated
    106                    Tick interrupt priority.
    107                  (++) SysTick timer is used by default as source of time base, but user
    108                       can eventually implement his proper time base source (a general purpose
    109                       timer for example or other time source), keeping in mind that Time base
    110                       duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and
    111                       handled in milliseconds basis.
    112                  (++) Time base configuration function (HAL_InitTick ()) is called automatically
    113                       at the beginning of the program after reset by HAL_Init() or at any time
    114                       when clock is configured, by HAL_RCC_ClockConfig().
    115                  (++) Source of time base is configured  to generate interrupts at regular
    116                       time intervals. Care must be taken if HAL_Delay() is called from a
    117                       peripheral ISR process, the Tick interrupt line must have higher priority
    118                      (numerically lower) than the peripheral interrupt. Otherwise the caller
    119                      ISR process will be blocked.
    120                 (++) functions affecting time base configurations are declared as __weak
    121                       to make  override possible  in case of other  implementations in user file.
    122          @endverbatim
    123            * @{
    124            */
    125          
    126          /**
    127            * @brief  Configure the Flash prefetch and the Instruction cache,
    128            *         the time base source, NVIC and any required global low level hardware
    129            *         by calling the HAL_MspInit() callback function to be optionally defined in user file
    130            *         stm32g0xx_hal_msp.c.
    131            *
    132            * @note   HAL_Init() function is called at the beginning of program after reset and before
    133            *         the clock configuration.
    134            *
    135            * @note   In the default implementation the System Timer (Systick) is used as source of time base.
    136            *         The Systick configuration is based on HSI clock, as HSI is the clock
    137            *         used after a system Reset.
    138            *         Once done, time base tick starts incrementing: the tick variable counter is incremented
    139            *         each 1ms in the SysTick_Handler() interrupt handler.
    140            *
    141            * @retval HAL status
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          HAL_StatusTypeDef HAL_Init(void)
    144          {
   \                     HAL_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    145            HAL_StatusTypeDef  status = HAL_OK;
   \        0x2   0x2400             MOVS     R4,#+0
    146          
    147            /* Configure Flash prefetch, Instruction cache             */
    148            /* Default configuration at reset is:                      */
    149            /* - Prefetch disabled                                     */
    150            /* - Instruction cache enabled                             */
    151          
    152          #if (INSTRUCTION_CACHE_ENABLE == 0U)
    153            __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
    154          #endif /* INSTRUCTION_CACHE_ENABLE */
    155          
    156          #if (PREFETCH_ENABLE != 0U)
    157            __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
   \        0x4   0x....             LDR      R0,??DataTable20  ;; 0x40022000
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x2280             MOVS     R2,#+128
   \        0xA   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \        0xC   0x430A             ORRS     R2,R2,R1
   \        0xE   0x6002             STR      R2,[R0, #+0]
    158          #endif /* PREFETCH_ENABLE */
    159          
    160            /* Use SysTick as time base source and configure 1ms tick (default clock after Reset is HSI) */
    161            if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x....'....        BL       HAL_InitTick
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD002             BEQ      ??HAL_Init_0
    162            {
    163              status = HAL_ERROR;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0x0004             MOVS     R4,R0
   \       0x1E   0xE001             B        ??HAL_Init_1
    164            }
    165            else
    166            {
    167            /* Init the low level hardware */
    168            HAL_MspInit();
   \                     ??HAL_Init_0: (+1)
   \       0x20   0x....'....        BL       HAL_MspInit
    169            }
    170          
    171            /* Return function status */
    172            return status;
   \                     ??HAL_Init_1: (+1)
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0xB2C0             UXTB     R0,R0
   \       0x28   0xBD10             POP      {R4,PC}          ;; return
    173          }
    174          
    175          /**
    176            * @brief  This function de-Initializes common part of the HAL and stops the source of time base.
    177            * @note   This function is optional.
    178            * @retval HAL status
    179            */

   \                                 In section .text, align 2, keep-with-next
    180          HAL_StatusTypeDef HAL_DeInit(void)
    181          {
   \                     HAL_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    182            /* Reset of all peripherals */
    183            __HAL_RCC_APB1_FORCE_RESET();
   \        0x2   0x....             LDR      R0,??DataTable20_1  ;; 0x4002102c
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x43C9             MVNS     R1,R1            ;; #-1
   \        0x8   0x6001             STR      R1,[R0, #+0]
    184            __HAL_RCC_APB1_RELEASE_RESET();
   \        0xA   0x2200             MOVS     R2,#+0
   \        0xC   0x6002             STR      R2,[R0, #+0]
    185          
    186            __HAL_RCC_APB2_FORCE_RESET();
   \        0xE   0x....             LDR      R0,??DataTable20_2  ;; 0x40021030
   \       0x10   0x6001             STR      R1,[R0, #+0]
    187            __HAL_RCC_APB2_RELEASE_RESET();
   \       0x12   0x6002             STR      R2,[R0, #+0]
    188          
    189            __HAL_RCC_AHB_FORCE_RESET();
   \       0x14   0x....             LDR      R0,??DataTable20_3  ;; 0x40021028
   \       0x16   0x6001             STR      R1,[R0, #+0]
    190            __HAL_RCC_AHB_RELEASE_RESET();
   \       0x18   0x6002             STR      R2,[R0, #+0]
    191          
    192            __HAL_RCC_IOP_FORCE_RESET();
   \       0x1A   0x....             LDR      R0,??DataTable20_4  ;; 0x40021024
   \       0x1C   0x6001             STR      R1,[R0, #+0]
    193            __HAL_RCC_IOP_RELEASE_RESET();
   \       0x1E   0x6002             STR      R2,[R0, #+0]
    194          
    195            /* De-Init the low level hardware */
    196            HAL_MspDeInit();
   \       0x20   0x....'....        BL       HAL_MspDeInit
    197          
    198            /* Return function status */
    199            return HAL_OK;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xBD02             POP      {R1,PC}          ;; return
    200          }
    201          
    202          /**
    203            * @brief  Initialize the MSP.
    204            * @retval None
    205            */

   \                                 In section .text, align 2
    206          __weak void HAL_MspInit(void)
    207          {
    208            /* NOTE : This function should not be modified, when the callback is needed,
    209                      the HAL_MspInit could be implemented in the user file
    210             */
    211          }
   \                     HAL_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    212          
    213          /**
    214            * @brief  DeInitializes the MSP.
    215            * @retval None
    216            */

   \                                 In section .text, align 2
    217          __weak void HAL_MspDeInit(void)
    218          {
    219            /* NOTE : This function should not be modified, when the callback is needed,
    220                      the HAL_MspDeInit could be implemented in the user file
    221             */
    222          }
   \                     HAL_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    223          
    224          /**
    225            * @brief This function configures the source of the time base:
    226            *        The time source is configured  to have 1ms time base with a dedicated
    227            *        Tick interrupt priority.
    228            * @note This function is called  automatically at the beginning of program after
    229            *       reset by HAL_Init() or at any time when clock is reconfigured  by HAL_RCC_ClockConfig().
    230            * @note In the default implementation, SysTick timer is the source of time base.
    231            *       It is used to generate interrupts at regular time intervals.
    232            *       Care must be taken if HAL_Delay() is called from a peripheral ISR process,
    233            *       The SysTick interrupt must have higher priority (numerically lower)
    234            *       than the peripheral interrupt. Otherwise the caller ISR process will be blocked.
    235            *       The function is declared as __weak  to be overwritten  in case of other
    236            *       implementation  in user file.
    237            * @param TickPriority Tick interrupt priority.
    238            * @retval HAL status
    239            */

   \                                 In section .text, align 4
    240          __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
    241          {
   \                     HAL_InitTick: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0005             MOVS     R5,R0
    242            HAL_StatusTypeDef  status = HAL_OK;
   \        0x4   0x2400             MOVS     R4,#+0
    243          
    244            if (uwTickFreq != 0U)
   \        0x6   0x4914             LDR      R1,??HAL_InitTick_0
   \        0x8   0x6808             LDR      R0,[R1, #+0]
   \        0xA   0x2800             CMP      R0,#+0
   \        0xC   0xD01E             BEQ      ??HAL_InitTick_1
    245            {
    246              /*Configure the SysTick to have interrupt in 1ms time basis*/
    247              if (HAL_SYSTICK_Config(SystemCoreClock / (1000U /uwTickFreq)) == 0U)
   \        0xE   0x20FA             MOVS     R0,#+250
   \       0x10   0x0080             LSLS     R0,R0,#+2        ;; #+1000
   \       0x12   0x6809             LDR      R1,[R1, #+0]
   \       0x14   0x....'....        BL       __aeabi_uidiv
   \       0x18   0x0001             MOVS     R1,R0
   \       0x1A   0x4810             LDR      R0,??HAL_InitTick_0+0x4
   \       0x1C   0x6800             LDR      R0,[R0, #+0]
   \       0x1E   0x....'....        BL       __aeabi_uidiv
   \       0x22   0x....'....        BL       HAL_SYSTICK_Config
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD10D             BNE      ??HAL_InitTick_2
    248              {
    249                /* Configure the SysTick IRQ priority */
    250                if (TickPriority < (1UL << __NVIC_PRIO_BITS))
   \       0x2A   0x2D04             CMP      R5,#+4
   \       0x2C   0xD208             BCS      ??HAL_InitTick_3
    251                {
    252                  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
   \       0x2E   0x2200             MOVS     R2,#+0
   \       0x30   0x0029             MOVS     R1,R5
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x36   0x....'....        BL       HAL_NVIC_SetPriority
    253                  uwTickPrio = TickPriority;
   \       0x3A   0x4809             LDR      R0,??HAL_InitTick_0+0x8
   \       0x3C   0x6005             STR      R5,[R0, #+0]
   \       0x3E   0xE007             B        ??HAL_InitTick_4
    254                }
    255                else
    256                {
    257                  status = HAL_ERROR;
   \                     ??HAL_InitTick_3: (+1)
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0x0004             MOVS     R4,R0
   \       0x44   0xE004             B        ??HAL_InitTick_4
    258                }
    259              }
    260              else
    261              {
    262                status = HAL_ERROR;
   \                     ??HAL_InitTick_2: (+1)
   \       0x46   0x2001             MOVS     R0,#+1
   \       0x48   0x0004             MOVS     R4,R0
   \       0x4A   0xE001             B        ??HAL_InitTick_4
    263              }
    264            }
    265            else
    266            {
    267              status = HAL_ERROR;
   \                     ??HAL_InitTick_1: (+1)
   \       0x4C   0x2001             MOVS     R0,#+1
   \       0x4E   0x0004             MOVS     R4,R0
    268            }
    269          
    270            /* Return function status */
    271            return status;
   \                     ??HAL_InitTick_4: (+1)
   \       0x50   0x0020             MOVS     R0,R4
   \       0x52   0xB2C0             UXTB     R0,R0
   \       0x54   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \       0x56   0xBF00             Nop
   \                     ??HAL_InitTick_0:
   \       0x58   0x....'....        DC32     uwTickFreq
   \       0x5C   0x....'....        DC32     SystemCoreClock
   \       0x60   0x....'....        DC32     uwTickPrio
    272          }
    273          
    274          /**
    275            * @}
    276            */
    277          
    278          /** @addtogroup HAL_Exported_Functions_Group2
    279           *  @brief    HAL Control functions
    280           *
    281          @verbatim
    282           ===============================================================================
    283                                ##### HAL Control functions #####
    284           ===============================================================================
    285              [..]  This section provides functions allowing to:
    286                (+) Provide a tick value in millisecond
    287                (+) Provide a blocking delay in millisecond
    288                (+) Suspend the time base source interrupt
    289                (+) Resume the time base source interrupt
    290                (+) Get the HAL API driver version
    291                (+) Get the device identifier
    292                (+) Get the device revision identifier
    293          
    294          @endverbatim
    295            * @{
    296            */
    297          
    298          /**
    299            * @brief This function is called to increment  a global variable "uwTick"
    300            *        used as application time base.
    301            * @note In the default implementation, this variable is incremented each 1ms
    302            *       in SysTick ISR.
    303            * @note This function is declared as __weak to be overwritten in case of other
    304            *      implementations in user file.
    305            * @retval None
    306            */

   \                                 In section .text, align 4
    307          __weak void HAL_IncTick(void)
    308          {
    309            uwTick += uwTickFreq;
   \                     HAL_IncTick: (+1)
   \        0x0   0x4803             LDR      R0,??HAL_IncTick_0
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x4A03             LDR      R2,??HAL_IncTick_0+0x4
   \        0x6   0x6812             LDR      R2,[R2, #+0]
   \        0x8   0x1889             ADDS     R1,R1,R2
   \        0xA   0x6001             STR      R1,[R0, #+0]
    310          }
   \        0xC   0x4770             BX       LR               ;; return
   \        0xE   0xBF00             Nop
   \                     ??HAL_IncTick_0:
   \       0x10   0x....'....        DC32     uwTick
   \       0x14   0x....'....        DC32     uwTickFreq
    311          
    312          /**
    313            * @brief Provides a tick value in millisecond.
    314            * @note This function is declared as __weak to be overwritten in case of other
    315            *       implementations in user file.
    316            * @retval tick value
    317            */

   \                                 In section .text, align 4
    318          __weak uint32_t HAL_GetTick(void)
    319          {
    320            return uwTick;
   \                     HAL_GetTick: (+1)
   \        0x0   0x4801             LDR      R0,??HAL_GetTick_0
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
   \        0x6   0xBF00             Nop
   \                     ??HAL_GetTick_0:
   \        0x8   0x....'....        DC32     uwTick
    321          }
    322          
    323          /**
    324            * @brief This function returns a tick priority.
    325            * @retval tick priority
    326            */

   \                                 In section .text, align 2, keep-with-next
    327          uint32_t HAL_GetTickPrio(void)
    328          {
    329            return uwTickPrio;
   \                     HAL_GetTickPrio: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_5
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    330          }
    331          
    332          /**
    333            * @brief Set new tick Freq.
    334            * @retval status
    335            */

   \                                 In section .text, align 2, keep-with-next
    336          HAL_StatusTypeDef HAL_SetTickFreq(uint32_t Freq)
    337          {
   \                     HAL_SetTickFreq: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    338            HAL_StatusTypeDef status  = HAL_OK;
   \        0x4   0x2500             MOVS     R5,#+0
    339            assert_param(IS_TICKFREQ(Freq));
    340          
    341            if (uwTickFreq != Freq)
   \        0x6   0x....             LDR      R6,??DataTable20_6
   \        0x8   0x6830             LDR      R0,[R6, #+0]
   \        0xA   0x42A0             CMP      R0,R4
   \        0xC   0xD009             BEQ      ??HAL_SetTickFreq_0
    342            {
    343              /* Apply the new tick Freq  */
    344              status = HAL_InitTick(uwTickPrio);
   \        0xE   0x....             LDR      R0,??DataTable20_5
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x....'....        BL       HAL_InitTick
   \       0x16   0x0005             MOVS     R5,R0
    345              if (status == HAL_OK)
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD100             BNE      ??HAL_SetTickFreq_0
    346              {
    347                uwTickFreq = Freq;
   \       0x20   0x6034             STR      R4,[R6, #+0]
    348              }
    349            }
    350          
    351            return status;
   \                     ??HAL_SetTickFreq_0: (+1)
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0xBD70             POP      {R4-R6,PC}       ;; return
    352          }
    353          
    354          /**
    355            * @brief return tick frequency.
    356            * @retval tick period in Hz
    357            */

   \                                 In section .text, align 2, keep-with-next
    358          uint32_t HAL_GetTickFreq(void)
    359          {
    360            return uwTickFreq;
   \                     HAL_GetTickFreq: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_6
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    361          }
    362          
    363          /**
    364            * @brief This function provides minimum delay (in milliseconds) based
    365            *        on variable incremented.
    366            * @note In the default implementation , SysTick timer is the source of time base.
    367            *       It is used to generate interrupts at regular time intervals where uwTick
    368            *       is incremented.
    369            * @note This function is declared as __weak to be overwritten in case of other
    370            *       implementations in user file.
    371            * @param Delay  specifies the delay time length, in milliseconds.
    372            * @retval None
    373            */

   \                                 In section .text, align 4
    374          __weak void HAL_Delay(uint32_t Delay)
    375          {
   \                     HAL_Delay: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    376            uint32_t tickstart = HAL_GetTick();
   \        0x4   0x....'....        BL       HAL_GetTick
   \        0x8   0x0005             MOVS     R5,R0
    377            uint32_t wait = Delay;
   \        0xA   0x0026             MOVS     R6,R4
    378          
    379            /* Add a freq to guarantee minimum wait */
    380            if (wait < HAL_MAX_DELAY)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x10   0x4286             CMP      R6,R0
   \       0x12   0xD002             BEQ      ??HAL_Delay_1
    381            {
    382              wait += (uint32_t)(uwTickFreq);
   \       0x14   0x4804             LDR      R0,??HAL_Delay_0
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x1836             ADDS     R6,R6,R0
    383            }
    384          
    385            while ((HAL_GetTick() - tickstart) < wait)
   \                     ??HAL_Delay_1: (+1)
   \       0x1A   0x....'....        BL       HAL_GetTick
   \       0x1E   0x1B40             SUBS     R0,R0,R5
   \       0x20   0x42B0             CMP      R0,R6
   \       0x22   0xD3FA             BCC      ??HAL_Delay_1
    386            {
    387            }
    388          }
   \       0x24   0xBD70             POP      {R4-R6,PC}       ;; return
   \       0x26   0xBF00             Nop
   \                     ??HAL_Delay_0:
   \       0x28   0x....'....        DC32     uwTickFreq
    389          
    390          /**
    391            * @brief Suspend Tick increment.
    392            * @note In the default implementation , SysTick timer is the source of time base. It is
    393            *       used to generate interrupts at regular time intervals. Once HAL_SuspendTick()
    394            *       is called, the SysTick interrupt will be disabled and so Tick increment
    395            *       is suspended.
    396            * @note This function is declared as __weak to be overwritten in case of other
    397            *       implementations in user file.
    398            * @retval None
    399            */

   \                                 In section .text, align 4
    400          __weak void HAL_SuspendTick(void)
    401          {
    402            /* Disable SysTick Interrupt */
    403            CLEAR_BIT(SysTick->CTRL,SysTick_CTRL_TICKINT_Msk);
   \                     HAL_SuspendTick: (+1)
   \        0x0   0x4802             LDR      R0,??HAL_SuspendTick_0  ;; 0xe000e010
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x4391             BICS     R1,R1,R2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    404          }
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??HAL_SuspendTick_0:
   \        0xC   0xE000'E010        DC32     0xe000e010
    405          
    406          /**
    407            * @brief Resume Tick increment.
    408            * @note In the default implementation , SysTick timer is the source of time base. It is
    409            *       used to generate interrupts at regular time intervals. Once HAL_ResumeTick()
    410            *       is called, the SysTick interrupt will be enabled and so Tick increment
    411            *       is resumed.
    412            * @note This function is declared as __weak to be overwritten in case of other
    413            *       implementations in user file.
    414            * @retval None
    415            */

   \                                 In section .text, align 4
    416          __weak void HAL_ResumeTick(void)
    417          {
    418            /* Enable SysTick Interrupt */
    419            SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
   \                     HAL_ResumeTick: (+1)
   \        0x0   0x4802             LDR      R0,??HAL_ResumeTick_0  ;; 0xe000e010
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6002             STR      R2,[R0, #+0]
    420          }
   \        0xA   0x4770             BX       LR               ;; return
   \                     ??HAL_ResumeTick_0:
   \        0xC   0xE000'E010        DC32     0xe000e010
    421          
    422          /**
    423            * @brief  Returns the HAL revision
    424            * @retval version : 0xXYZR (8bits for each decimal, R for RC)
    425            */

   \                                 In section .text, align 2, keep-with-next
    426          uint32_t HAL_GetHalVersion(void)
    427          {
    428            return __STM32G0xx_HAL_VERSION;
   \                     HAL_GetHalVersion: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_7  ;; 0x1030000
   \        0x2   0x4770             BX       LR               ;; return
    429          }
    430          
    431          /**
    432            * @brief  Returns the device revision identifier.
    433            * @retval Device revision identifier
    434            */

   \                                 In section .text, align 2, keep-with-next
    435          uint32_t HAL_GetREVID(void)
    436          {
    437            return ((DBG->IDCODE & DBG_IDCODE_REV_ID) >> 16U);
   \                     HAL_GetREVID: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_8  ;; 0x40015800
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0C00             LSRS     R0,R0,#+16
   \        0x6   0x4770             BX       LR               ;; return
    438          }
    439          
    440          /**
    441            * @brief  Returns the device identifier.
    442            * @retval Device identifier
    443            */

   \                                 In section .text, align 2, keep-with-next
    444          uint32_t HAL_GetDEVID(void)
    445          {
    446            return ((DBG->IDCODE) & DBG_IDCODE_DEV_ID);
   \                     HAL_GetDEVID: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_8  ;; 0x40015800
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0500             LSLS     R0,R0,#+20       ;; ZeroExtS R0,R0,#+20,#+20
   \        0x6   0x0D00             LSRS     R0,R0,#+20
   \        0x8   0x4770             BX       LR               ;; return
    447          }
    448          
    449          /**
    450            * @brief  Returns first word of the unique device identifier (UID based on 96 bits)
    451            * @retval Device identifier
    452            */

   \                                 In section .text, align 2, keep-with-next
    453          uint32_t HAL_GetUIDw0(void)
    454          {
    455            return (READ_REG(*((uint32_t *)UID_BASE)));
   \                     HAL_GetUIDw0: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_9  ;; 0x1fff7590
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    456          }
    457          
    458          /**
    459            * @brief  Returns second word of the unique device identifier (UID based on 96 bits)
    460            * @retval Device identifier
    461            */

   \                                 In section .text, align 2, keep-with-next
    462          uint32_t HAL_GetUIDw1(void)
    463          {
    464            return (READ_REG(*((uint32_t *)(UID_BASE + 4U))));
   \                     HAL_GetUIDw1: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_10  ;; 0x1fff7594
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    465          }
    466          
    467          /**
    468            * @brief  Returns third word of the unique device identifier (UID based on 96 bits)
    469            * @retval Device identifier
    470            */

   \                                 In section .text, align 2, keep-with-next
    471          uint32_t HAL_GetUIDw2(void)
    472          {
    473            return (READ_REG(*((uint32_t *)(UID_BASE + 8U))));
   \                     HAL_GetUIDw2: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_11  ;; 0x1fff7598
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return
    474          }
    475          
    476          /**
    477            * @}
    478            */
    479          
    480          /** @addtogroup HAL_Exported_Functions_Group3
    481           *  @brief    HAL Debug functions
    482           *
    483          @verbatim
    484           ===============================================================================
    485                                ##### HAL Debug functions #####
    486           ===============================================================================
    487              [..]  This section provides functions allowing to:
    488                (+) Enable/Disable Debug module during STOP mode
    489                (+) Enable/Disable Debug module during STANDBY mode
    490          
    491          @endverbatim
    492            * @{
    493            */
    494          
    495          /**
    496            * @brief  Enable the Debug Module during STOP mode
    497            * @retval None
    498            */

   \                                 In section .text, align 2, keep-with-next
    499          void HAL_DBGMCU_EnableDBGStopMode(void)
    500          {
    501            SET_BIT(DBG->CR, DBG_CR_DBG_STOP);
   \                     HAL_DBGMCU_EnableDBGStopMode: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_12  ;; 0x40015804
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6002             STR      R2,[R0, #+0]
    502          }
   \        0xA   0x4770             BX       LR               ;; return
    503          
    504          /**
    505            * @brief  Disable the Debug Module during STOP mode
    506            * @retval None
    507            */

   \                                 In section .text, align 2, keep-with-next
    508          void HAL_DBGMCU_DisableDBGStopMode(void)
    509          {
    510            CLEAR_BIT(DBG->CR, DBG_CR_DBG_STOP);
   \                     HAL_DBGMCU_DisableDBGStopMode: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_12  ;; 0x40015804
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x4391             BICS     R1,R1,R2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    511          }
   \        0xA   0x4770             BX       LR               ;; return
    512          
    513          /**
    514            * @brief  Enable the Debug Module during STANDBY mode
    515            * @retval None
    516            */

   \                                 In section .text, align 2, keep-with-next
    517          void HAL_DBGMCU_EnableDBGStandbyMode(void)
    518          {
    519            SET_BIT(DBG->CR, DBG_CR_DBG_STANDBY);
   \                     HAL_DBGMCU_EnableDBGStandbyMode: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_12  ;; 0x40015804
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2204             MOVS     R2,#+4
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6002             STR      R2,[R0, #+0]
    520          }
   \        0xA   0x4770             BX       LR               ;; return
    521          
    522          /**
    523            * @brief  Disable the Debug Module during STANDBY mode
    524            * @retval None
    525            */

   \                                 In section .text, align 2, keep-with-next
    526          void HAL_DBGMCU_DisableDBGStandbyMode(void)
    527          {
    528            CLEAR_BIT(DBG->CR, DBG_CR_DBG_STANDBY);
   \                     HAL_DBGMCU_DisableDBGStandbyMode: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_12  ;; 0x40015804
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2204             MOVS     R2,#+4
   \        0x6   0x4391             BICS     R1,R1,R2
   \        0x8   0x6001             STR      R1,[R0, #+0]
    529          }
   \        0xA   0x4770             BX       LR               ;; return
    530          
    531          /**
    532            * @}
    533            */
    534          
    535          /** @addtogroup HAL_Exported_Functions_Group4
    536           *  @brief    SYSCFG configuration functions
    537           *
    538          @verbatim
    539           ===============================================================================
    540                                ##### HAL SYSCFG configuration functions #####
    541           ===============================================================================
    542              [..]  This section provides functions allowing to:
    543                (+) Enable/Disable Pin remap
    544                (+) Configure the Voltage reference buffer
    545                (+) Enable/Disable the Voltage reference buffer
    546                (+) Enable/Disable the I/O analog switch voltage booster
    547                (+) Enable/Disable dead battery behavior(*)
    548                (+) Configure Clamping Diode on specific pins(*)
    549             (*) Feature not available on all devices
    550          
    551          @endverbatim
    552            * @{
    553            */
    554          #if defined(VREFBUF)
    555          /**
    556            * @brief Configure the internal voltage reference buffer voltage scale.
    557            * @param  VoltageScaling specifies the output voltage to achieve
    558            *         This parameter can be one of the following values:
    559            *         @arg @ref SYSCFG_VREFBUF_VoltageScale
    560            * @retval None
    561            */
    562          void HAL_SYSCFG_VREFBUF_VoltageScalingConfig(uint32_t VoltageScaling)
    563          {
    564            /* Check the parameters */
    565            assert_param(IS_SYSCFG_VREFBUF_VOLTAGE_SCALE(VoltageScaling));
    566          
    567            MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_VRS, VoltageScaling);
    568          }
    569          
    570          /**
    571            * @brief Configure the internal voltage reference buffer high impedance mode.
    572            * @param  Mode specifies the high impedance mode
    573            *          This parameter can be one of the following values:
    574            *          @arg @ref SYSCFG_VREFBUF_HighImpedance
    575            * @retval None
    576            */
    577          void HAL_SYSCFG_VREFBUF_HighImpedanceConfig(uint32_t Mode)
    578          {
    579            /* Check the parameters */
    580            assert_param(IS_SYSCFG_VREFBUF_HIGH_IMPEDANCE(Mode));
    581          
    582            MODIFY_REG(VREFBUF->CSR, VREFBUF_CSR_HIZ, Mode);
    583          }
    584          
    585          /**
    586            * @brief  Tune the Internal Voltage Reference buffer (VREFBUF).
    587            * @retval None
    588            */
    589          void HAL_SYSCFG_VREFBUF_TrimmingConfig(uint32_t TrimmingValue)
    590          {
    591            /* Check the parameters */
    592            assert_param(IS_SYSCFG_VREFBUF_TRIMMING(TrimmingValue));
    593          
    594            MODIFY_REG(VREFBUF->CCR, VREFBUF_CCR_TRIM, TrimmingValue);
    595          }
    596          
    597          /**
    598            * @brief  Enable the Internal Voltage Reference buffer (VREFBUF).
    599            * @retval HAL_OK/HAL_TIMEOUT
    600            */
    601          HAL_StatusTypeDef HAL_SYSCFG_EnableVREFBUF(void)
    602          {
    603            uint32_t  tickstart;
    604          
    605            SET_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
    606          
    607            /* Get Start Tick*/
    608            tickstart = HAL_GetTick();
    609          
    610            /* Wait for VRR bit  */
    611            while (READ_BIT(VREFBUF->CSR, VREFBUF_CSR_VRR) == 0x00U)
    612            {
    613              if ((HAL_GetTick() - tickstart) > VREFBUF_TIMEOUT_VALUE)
    614              {
    615                return HAL_TIMEOUT;
    616              }
    617            }
    618          
    619            return HAL_OK;
    620          }
    621          
    622          /**
    623            * @brief  Disable the Internal Voltage Reference buffer (VREFBUF).
    624            *
    625            * @retval None
    626            */
    627          void HAL_SYSCFG_DisableVREFBUF(void)
    628          {
    629            CLEAR_BIT(VREFBUF->CSR, VREFBUF_CSR_ENVR);
    630          }
    631          #endif /* VREFBUF */
    632          
    633          /**
    634            * @brief  Enable the I/O analog switch voltage booster
    635            * @retval None
    636            */

   \                                 In section .text, align 2, keep-with-next
    637          void HAL_SYSCFG_EnableIOAnalogSwitchBooster(void)
    638          {
    639            SET_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_BOOSTEN);
   \                     HAL_SYSCFG_EnableIOAnalogSwitchBooster: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_13  ;; 0x40010000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \        0x8   0x430A             ORRS     R2,R2,R1
   \        0xA   0x6002             STR      R2,[R0, #+0]
    640          }
   \        0xC   0x4770             BX       LR               ;; return
    641          
    642          /**
    643            * @brief  Disable the I/O analog switch voltage booster
    644            * @retval None
    645            */

   \                                 In section .text, align 2, keep-with-next
    646          void HAL_SYSCFG_DisableIOAnalogSwitchBooster(void)
    647          {
    648            CLEAR_BIT(SYSCFG->CFGR1, SYSCFG_CFGR1_BOOSTEN);
   \                     HAL_SYSCFG_DisableIOAnalogSwitchBooster: (+1)
   \        0x0   0x....             LDR      R0,??DataTable20_13  ;; 0x40010000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x....             LDR      R2,??DataTable20_14  ;; 0xfffffeff
   \        0x6   0x400A             ANDS     R2,R2,R1
   \        0x8   0x6002             STR      R2,[R0, #+0]
    649          }
   \        0xA   0x4770             BX       LR               ;; return
    650          
    651          /**
    652            * @brief  Enable the remap on PA11_PA12
    653            * @param  PinRemap specifies which pins have to be remapped
    654            *         This parameter can be any combination of the following values:
    655            *         @arg @ref SYSCFG_REMAP_PA11
    656            *         @arg @ref SYSCFG_REMAP_PA12
    657            * @retval None
    658            */

   \                                 In section .text, align 2, keep-with-next
    659          void HAL_SYSCFG_EnableRemap(uint32_t PinRemap)
    660          {
    661            /* Check the parameter */
    662            assert_param(IS_HAL_REMAP_PIN(PinRemap));
    663            SET_BIT(SYSCFG->CFGR1, PinRemap);
   \                     HAL_SYSCFG_EnableRemap: (+1)
   \        0x0   0x....             LDR      R1,??DataTable20_13  ;; 0x40010000
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x4302             ORRS     R2,R2,R0
   \        0x6   0x600A             STR      R2,[R1, #+0]
    664          }
   \        0x8   0x4770             BX       LR               ;; return
    665          
    666          /**
    667            * @brief  Disable the remap on PA11_PA12
    668            * @param  PinRemap specifies which pins will behave normally
    669            *         This parameter can be any combination of the following values:
    670            *         @arg @ref SYSCFG_REMAP_PA11
    671            *         @arg @ref SYSCFG_REMAP_PA12
    672            * @retval None
    673            */

   \                                 In section .text, align 2, keep-with-next
    674          void HAL_SYSCFG_DisableRemap(uint32_t PinRemap)
    675          {
    676            /* Check the parameter */
    677            assert_param(IS_HAL_REMAP_PIN(PinRemap));
    678            CLEAR_BIT(SYSCFG->CFGR1, PinRemap);
   \                     HAL_SYSCFG_DisableRemap: (+1)
   \        0x0   0x....             LDR      R1,??DataTable20_13  ;; 0x40010000
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x4382             BICS     R2,R2,R0
   \        0x6   0x600A             STR      R2,[R1, #+0]
    679          }
   \        0x8   0x4770             BX       LR               ;; return
    680          
    681          #if defined(STM32G041xx) || defined(STM32G031xx) || defined(STM32G030xx)
    682          /**
    683            * @brief  Enable Clamping Diode on specified IO
    684            * @param  PinConfig specifies on which pins clamping Diode has to be enabled
    685            *         This parameter can be any combination of the following values:
    686            *         @arg @ref SYSCFG_ClampingDiode
    687            * @retval None
    688            */

   \                                 In section .text, align 2, keep-with-next
    689          void HAL_SYSCFG_EnableClampingDiode(uint32_t PinConfig)
    690          {
    691            /* Check the parameter */
    692            assert_param(IS_SYSCFG_CLAMPINGDIODE(PinConfig));
    693            SET_BIT(SYSCFG->CFGR2, PinConfig);
   \                     HAL_SYSCFG_EnableClampingDiode: (+1)
   \        0x0   0x....             LDR      R1,??DataTable20_15  ;; 0x40010018
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x4302             ORRS     R2,R2,R0
   \        0x6   0x600A             STR      R2,[R1, #+0]
    694          }
   \        0x8   0x4770             BX       LR               ;; return
    695          
    696          /**
    697            * @brief  Disable Clamping Diode on specified IO
    698            * @param  PinConfig specifies on which pins clamping Diode has to be disabled
    699            *         This parameter can be any combination of the following values:
    700            *         @arg @ref SYSCFG_ClampingDiode
    701            * @retval None
    702            */

   \                                 In section .text, align 2, keep-with-next
    703          void HAL_SYSCFG_DisableClampingDiode(uint32_t PinConfig)
    704          {
    705            /* Check the parameter */
    706            assert_param(IS_SYSCFG_CLAMPINGDIODE(PinConfig));
    707            CLEAR_BIT(SYSCFG->CFGR2, PinConfig);
   \                     HAL_SYSCFG_DisableClampingDiode: (+1)
   \        0x0   0x....             LDR      R1,??DataTable20_15  ;; 0x40010018
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x4382             BICS     R2,R2,R0
   \        0x6   0x600A             STR      R2,[R1, #+0]
    708          }
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0x4002'2000        DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \        0x0   0x4002'102C        DC32     0x4002102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \        0x0   0x4002'1030        DC32     0x40021030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \        0x0   0x4002'1028        DC32     0x40021028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \        0x0   0x4002'1024        DC32     0x40021024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \        0x0   0x....'....        DC32     uwTickPrio

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \        0x0   0x....'....        DC32     uwTickFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \        0x0   0x0103'0000        DC32     0x1030000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \        0x0   0x4001'5800        DC32     0x40015800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \        0x0   0x1FFF'7590        DC32     0x1fff7590

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \        0x0   0x1FFF'7594        DC32     0x1fff7594

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \        0x0   0x1FFF'7598        DC32     0x1fff7598

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_12:
   \        0x0   0x4001'5804        DC32     0x40015804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_13:
   \        0x0   0x4001'0000        DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_14:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_15:
   \        0x0   0x4001'0018        DC32     0x40010018
    709          #endif
    710          
    711          #if defined (SYSCFG_CFGR1_UCPD1_STROBE) || defined (SYSCFG_CFGR1_UCPD2_STROBE)
    712          /**
    713            * @brief  Strobe configuration of GPIO depending on UCPDx dead battery settings
    714            * @param  ConfigDeadBattery specifies on which pins to make effective or not Dead Battery sw configuration
    715            *         This parameter can be any combination of the following values:
    716            *         @arg @ref SYSCFG_UCPD1_STROBE
    717            *         @arg @ref SYSCFG_UCPD2_STROBE
    718            * @retval None
    719            */
    720          void HAL_SYSCFG_StrobeDBattpinsConfig(uint32_t ConfigDeadBattery)
    721          {
    722            assert_param(IS_SYSCFG_DBATT_CONFIG(ConfigDeadBattery));
    723          
    724            /* Change strobe configuration of GPIO depending on UCPDx dead battery settings */
    725            MODIFY_REG(SYSCFG->CFGR1, (SYSCFG_CFGR1_UCPD1_STROBE | SYSCFG_CFGR1_UCPD2_STROBE), ConfigDeadBattery);
    726          }
    727          #endif /* SYSCFG_CFGR1_UCPD1_STROBE || SYSCFG_CFGR1_UCPD2_STROBE */
    728          /**
    729            * @}
    730            */
    731          
    732          /**
    733            * @}
    734            */
    735          
    736          #endif /* HAL_MODULE_ENABLED */
    737          /**
    738            * @}
    739            */
    740          
    741          /**
    742            * @}
    743            */
    744          
    745          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_DBGMCU_DisableDBGStandbyMode
       0   HAL_DBGMCU_DisableDBGStopMode
       0   HAL_DBGMCU_EnableDBGStandbyMode
       0   HAL_DBGMCU_EnableDBGStopMode
       8   HAL_DeInit
         8   -> HAL_MspDeInit
      16   HAL_Delay
        16   -> HAL_GetTick
       0   HAL_GetDEVID
       0   HAL_GetHalVersion
       0   HAL_GetREVID
       0   HAL_GetTick
       0   HAL_GetTickFreq
       0   HAL_GetTickPrio
       0   HAL_GetUIDw0
       0   HAL_GetUIDw1
       0   HAL_GetUIDw2
       0   HAL_IncTick
       8   HAL_Init
         8   -> HAL_InitTick
         8   -> HAL_MspInit
      16   HAL_InitTick
        16   -> HAL_NVIC_SetPriority
        16   -> HAL_SYSTICK_Config
        16 __aeabi_uidiv
       0   HAL_MspDeInit
       0   HAL_MspInit
       0   HAL_ResumeTick
       0   HAL_SYSCFG_DisableClampingDiode
       0   HAL_SYSCFG_DisableIOAnalogSwitchBooster
       0   HAL_SYSCFG_DisableRemap
       0   HAL_SYSCFG_EnableClampingDiode
       0   HAL_SYSCFG_EnableIOAnalogSwitchBooster
       0   HAL_SYSCFG_EnableRemap
      16   HAL_SetTickFreq
        16   -> HAL_InitTick
       0   HAL_SuspendTick


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_14
       4  ??DataTable20_15
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
      12  HAL_DBGMCU_DisableDBGStandbyMode
      12  HAL_DBGMCU_DisableDBGStopMode
      12  HAL_DBGMCU_EnableDBGStandbyMode
      12  HAL_DBGMCU_EnableDBGStopMode
      40  HAL_DeInit
      44  HAL_Delay
      10  HAL_GetDEVID
       4  HAL_GetHalVersion
       8  HAL_GetREVID
      12  HAL_GetTick
       6  HAL_GetTickFreq
       6  HAL_GetTickPrio
       6  HAL_GetUIDw0
       6  HAL_GetUIDw1
       6  HAL_GetUIDw2
      24  HAL_IncTick
      42  HAL_Init
     100  HAL_InitTick
       2  HAL_MspDeInit
       2  HAL_MspInit
      16  HAL_ResumeTick
      10  HAL_SYSCFG_DisableClampingDiode
      12  HAL_SYSCFG_DisableIOAnalogSwitchBooster
      10  HAL_SYSCFG_DisableRemap
      10  HAL_SYSCFG_EnableClampingDiode
      14  HAL_SYSCFG_EnableIOAnalogSwitchBooster
      10  HAL_SYSCFG_EnableRemap
      40  HAL_SetTickFreq
      16  HAL_SuspendTick
       4  uwTick
       4  uwTickFreq
       4  uwTickPrio

 
   4 bytes in section .bss
   8 bytes in section .data
 568 bytes in section .text
 
 352 bytes of CODE memory (+ 216 bytes shared)
  12 bytes of DATA memory

Errors: none
Warnings: none

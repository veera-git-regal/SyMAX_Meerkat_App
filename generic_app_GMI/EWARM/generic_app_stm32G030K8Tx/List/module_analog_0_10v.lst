###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         04/Feb/2022  12:58:42
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Features\module_analog_0_10v.c
#    Command line                 =
#        -f C:\Users\610126~1\AppData\Local\Temp\EWCE7A.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Features\module_analog_0_10v.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale                       =  C
#    List file                    =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\module_analog_0_10v.lst
#    Object file                  =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\module_analog_0_10v.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Features\module_analog_0_10v.c
      1          /**
      2          *************************************************************************************
      3          * @file    module_analog_0_10v.c 
      4          * @author  Regal, Satya Akkina
      5          * @version V1.0
      6          * @date    17-Aug-2020
      7          * @brief   module for Analog 0-10V input
      8          * @note    Provide structures to access Analog setting and Analog volts, demand
      9          *************************************************************************************
     10          */
     11          
     12          // Includes -------------------------------------------------------------------
     13          #include "module_analog_0_10v.h"
     14          
     15          //#include <stdio.h>
     16          #include <math.h>
     17          
     18          #include "driver_usart2.h"
     19          #include "module_usart2.h"
     20          
     21          #include "macros.h"
     22          
     23          // Content --------------------------------------------------------------------
     24          // Function Prototypes
     25          void AssignModuleMemAnalog_0_10V(void);
     26          void Init_Analog_Setting(void);
     27          void InitAnalogVoltsInputParameters(void);
     28          void DebounceAnalogVolts(void);
     29          uint16_t GetAnalogDemand(void);
     30          
     31          // Constants ------------------------------------------------------------------
     32          // Module States
     33          enum 
     34          {
     35            MEMORY_INIT_MODULE,
     36            INIT_MODULE,
     37            RUN_MODULE,
     38            // Ddditional states to be added here as necessary.
     39            IRQ_MODULE = DEFAULT_IRQ_STATE,
     40            KILL_MODULE = KILL_APP
     41          };
     42          
     43          // External Variables ---------------------------------------------------------
     44          extern Ram_Buf sharedMemArray[TOTAL_NUM_OF_STRUCT_MEM_INSTANCES];
     45          extern ProcessInfo processInfoTable[];

   \                                 In section .bss, align 4
     46          static  Ram_Buf_Handle analog_0_10v_StructMem_u32;
   \                     analog_0_10v_StructMem_u32:
   \        0x0                      DS8 4
     47          
     48          // Global variables specific to this module ---------------------------------

   \                                 In section .bss, align 8
     49          uint64_t module_analog_0_10v_poll_time_u64;      // Delay time between init and run module
   \                     module_analog_0_10v_poll_time_u64:
   \        0x0                      DS8 8

   \                                 In section .bss, align 2
     50          uint16_t analog_increasing_debounce_count_u16 = 0; // Count to check if analog volts is above debounce value
   \                     analog_increasing_debounce_count_u16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
     51          uint16_t analog_decreasing_debounce_count_u16 = 0; // Count to check if analog volts is below debounce value
   \                     analog_decreasing_debounce_count_u16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
     52          uint16_t analog_volts_counts_u16 = 0;            // Temporary storage for ADC value
   \                     analog_volts_counts_u16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
     53          uint16_t analog_low_alarm_enable_count_u16 = 0;    // Time when analog module init is complete
   \                     analog_low_alarm_enable_count_u16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 1
     54          uint8_t is_volts_above_loss_analog = FALSE;      // Time when analog module init is complete
   \                     is_volts_above_loss_analog:
   \        0x0                      DS8 1
     55          

   \                                 In section .bss, align 4
     56          int32_t temperature_degc_s16=0;
   \                     temperature_degc_s16:
   \        0x0                      DS8 4
     57          
     58          // Define Pointers that will be used as References to other Modules, where applicable

   \                                 In section .bss, align 4
     59          ADC1_Control*  adc1_LocalControl;
   \                     adc1_LocalControl:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     60          AnalogVolts_Control analogVolts_Control;
   \                     analogVolts_Control:
   \        0x0                      DS8 76
     61          
     62          
     63          /**
     64          ********************************************************************************************************************************
     65          * @brief   State machine for Analog 0-10V module
     66          * @details
     67          * @param   drv_identifier_u8, previous_state_u8, next_stat_u8, irq_identfier_u8
     68          * @retval  return_state_u8
     69          ********************************************************************************************************************************
     70          */

   \                                 In section .text, align 2, keep-with-next
     71          uint8_t moduleAnalog_0_10V(uint8_t drv_identifier_u8, uint8_t previous_state_u8, uint8_t next_state_u8,
     72                                     uint8_t irq_identifier_u8)
     73          {
   \                     moduleAnalog_0_10V: (+1)
   \        0x0   0xB5FF             PUSH     {R0-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
     74            uint8_t return_state_u8 = MEMORY_INIT_MODULE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4669             MOV      R1,SP
   \        0x8   0x7208             STRB     R0,[R1, #+8]
     75            switch (next_state_u8)
   \        0xA   0xA809             ADD      R0,SP,#+36
   \        0xC   0x7800             LDRB     R0,[R0, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD00A             BEQ      ??moduleAnalog_0_10V_0
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD00C             BEQ      ??moduleAnalog_0_10V_1
   \       0x16   0x2802             CMP      R0,#+2
   \       0x18   0xD02D             BEQ      ??moduleAnalog_0_10V_2
   \       0x1A   0x28C8             CMP      R0,#+200
   \       0x1C   0xD100             BNE      .+4
   \       0x1E   0xE0CA             B        ??moduleAnalog_0_10V_3
   \       0x20   0x28FF             CMP      R0,#+255
   \       0x22   0xD100             BNE      .+4
   \       0x24   0xE0C9             B        ??moduleAnalog_0_10V_4
   \       0x26   0xE0DB             B        ??moduleAnalog_0_10V_5
     76            {
     77            case MEMORY_INIT_MODULE:
     78              {
     79                AssignModuleMemAnalog_0_10V(); // Assign structured memory to Analog 0-10V setting and data 
   \                     ??moduleAnalog_0_10V_0: (+1)
   \       0x28   0x....'....        BL       AssignModuleMemAnalog_0_10V
     80                return_state_u8 = INIT_MODULE;
   \       0x2C   0x2001             MOVS     R0,#+1
     81                break;
   \       0x2E   0xE0D8             B        ??moduleAnalog_0_10V_6
     82              }
     83            case INIT_MODULE:
     84              {     
     85                //AssignModuleMemAnalog_0_10V(); // Assign structured memory to Analog 0-10V setting and data      
     86                Init_Analog_Setting(); // Initilize analog 0-10V settings   
   \                     ??moduleAnalog_0_10V_1: (+1)
   \       0x30   0x....'....        BL       Init_Analog_Setting
     87                InitAnalogVoltsInputParameters(); // Init local parameters and metering data
   \       0x34   0x....'....        BL       InitAnalogVoltsInputParameters
     88                
     89                // Get structured memory for ADC1 data
     90                uint8_t module_ADC1_Index = getProcessInfoIndex(MODULE_ADC1);
   \       0x38   0x2004             MOVS     R0,#+4
   \       0x3A   0x....'....        BL       getProcessInfoIndex
   \       0x3E   0x0004             MOVS     R4,R0
     91                adc1_LocalControl = (ADC1_Control*)((*(processInfoTable[module_ADC1_Index].Sched_DrvData.p_masterSharedMem_u32)).p_ramBuf_u8);
   \       0x40   0x....             LDR      R0,??DataTable2
   \       0x42   0x0021             MOVS     R1,R4
   \       0x44   0xB2C9             UXTB     R1,R1
   \       0x46   0x2216             MOVS     R2,#+22
   \       0x48   0x4351             MULS     R1,R2,R1
   \       0x4A   0x1840             ADDS     R0,R0,R1
   \       0x4C   0x300B             ADDS     R0,R0,#+11
   \       0x4E   0x....'....        BL       __aeabi_uread4
   \       0x52   0x6800             LDR      R0,[R0, #+0]
   \       0x54   0x....             LDR      R1,??DataTable2_1
   \       0x56   0x6008             STR      R0,[R1, #+0]
     92                
     93                analog_low_alarm_enable_count_u16 = analogVolts_Control.analogVolts_Setting.analogLowAlarmEnableCount_u16; // delay before analog low voltage alarm can be triggered
   \       0x58   0x....             LDR      R5,??DataTable3
   \       0x5A   0x8CA8             LDRH     R0,[R5, #+36]
   \       0x5C   0x....             LDR      R1,??DataTable3_1
   \       0x5E   0x8008             STRH     R0,[R1, #+0]
     94                module_analog_0_10v_poll_time_u64 = getSysCount() + analogVolts_Control.analogVolts_Setting.analogPeriod_u16; //AnalogPeriod;    // Store time tick value
   \       0x60   0x....'....        BL       getSysCount
   \       0x64   0x8BEA             LDRH     R2,[R5, #+30]
   \       0x66   0x2300             MOVS     R3,#+0
   \       0x68   0x1812             ADDS     R2,R2,R0
   \       0x6A   0x414B             ADCS     R3,R3,R1
   \       0x6C   0x....             LDR      R0,??DataTable2_2
   \       0x6E   0xC00C             STM      R0!,{R2,R3}
   \       0x70   0x3808             SUBS     R0,R0,#+8
     95                
     96                //return_state_u8 = INIT_MODULE;
     97                return_state_u8 = RUN_MODULE;
   \       0x72   0x2002             MOVS     R0,#+2
     98                break;
   \       0x74   0xE0B5             B        ??moduleAnalog_0_10V_6
     99                
    100              }   
    101            case RUN_MODULE:                                                             
    102              {      
    103                // Process analog input every "analogPeriod_u16" mSec
    104                if (getSysCount() >= module_analog_0_10v_poll_time_u64) 
   \                     ??moduleAnalog_0_10V_2: (+1)
   \       0x76   0x....'....        BL       getSysCount
   \       0x7A   0x....             LDR      R5,??DataTable2_2
   \       0x7C   0xCD0C             LDM      R5!,{R2,R3}
   \       0x7E   0x3D08             SUBS     R5,R5,#+8
   \       0x80   0x4299             CMP      R1,R3
   \       0x82   0xD200             BCS      .+4
   \       0x84   0xE095             B        ??moduleAnalog_0_10V_7
   \       0x86   0xD802             BHI      ??moduleAnalog_0_10V_8
   \       0x88   0x4290             CMP      R0,R2
   \       0x8A   0xD200             BCS      .+4
   \       0x8C   0xE091             B        ??moduleAnalog_0_10V_7
    105                {
    106                  module_analog_0_10v_poll_time_u64 = getSysCount() + analogVolts_Control.analogVolts_Setting.analogPeriod_u16; //AnalogPeriod;   // Update time tick value
   \                     ??moduleAnalog_0_10V_8: (+1)
   \       0x8E   0x....'....        BL       getSysCount
   \       0x92   0x0002             MOVS     R2,R0
   \       0x94   0x000B             MOVS     R3,R1
   \       0x96   0x....             LDR      R4,??DataTable3
   \       0x98   0x8BE0             LDRH     R0,[R4, #+30]
   \       0x9A   0x2100             MOVS     R1,#+0
   \       0x9C   0x1880             ADDS     R0,R0,R2
   \       0x9E   0x4159             ADCS     R1,R1,R3
   \       0xA0   0xC503             STM      R5!,{R0,R1}
   \       0xA2   0x3D08             SUBS     R5,R5,#+8
    107                  if(analog_low_alarm_enable_count_u16 > 0){
   \       0xA4   0x....             LDR      R0,??DataTable3_1
   \       0xA6   0x8801             LDRH     R1,[R0, #+0]
   \       0xA8   0x2900             CMP      R1,#+0
   \       0xAA   0xD002             BEQ      ??moduleAnalog_0_10V_9
    108                    analog_low_alarm_enable_count_u16--;
   \       0xAC   0x8801             LDRH     R1,[R0, #+0]
   \       0xAE   0x1E49             SUBS     R1,R1,#+1
   \       0xB0   0x8001             STRH     R1,[R0, #+0]
    109                  } 
    110                  if(analog_low_alarm_enable_count_u16 == 0) // On power up wait for few sec to detect correct analog input
   \                     ??moduleAnalog_0_10V_9: (+1)
   \       0xB2   0x8800             LDRH     R0,[R0, #+0]
   \       0xB4   0x2800             CMP      R0,#+0
   \       0xB6   0xD17C             BNE      ??moduleAnalog_0_10V_7
    111                    {
    112                  // Convert ADC1 value into 100.00%. analogVoltsPercent_u16 value is stored in xxxyy format = xxx.yy% 
    113                  analogVolts_Control.analogVolts_Data.analogVoltsPercent_u16 = DECIMAL_RIGHT_SHIFT_U16(CALCULATE_PERCENT((*adc1_LocalControl).adc1_ResultAvg.adc1_0_10V_Avg_u16, ADC_12_BIT_FULL_SCALE),2);
   \       0xB8   0x....             LDR      R5,??DataTable2_1
   \       0xBA   0x6828             LDR      R0,[R5, #+0]
   \       0xBC   0x88C1             LDRH     R1,[R0, #+6]
   \       0xBE   0x2064             MOVS     R0,#+100
   \       0xC0   0x4348             MULS     R0,R1,R0
   \       0xC2   0x....'....        BL       __aeabi_i2f
   \       0xC6   0x218B             MOVS     R1,#+139
   \       0xC8   0x05C9             LSLS     R1,R1,#+23       ;; #+1166016512
   \       0xCA   0x....'....        BL       __aeabi_fdiv
   \       0xCE   0x2600             MOVS     R6,#+0
   \       0xD0   0x....             LDR      R7,??DataTable2_3  ;; 0x40240000
   \       0xD2   0xA904             ADD      R1,SP,#+16
   \       0xD4   0xC1C0             STM      R1!,{R6,R7}
   \       0xD6   0x3908             SUBS     R1,R1,#+8
   \       0xD8   0x....'....        BL       __aeabi_f2d
   \       0xDC   0x9000             STR      R0,[SP, #+0]
   \       0xDE   0x9101             STR      R1,[SP, #+4]
   \       0xE0   0xA804             ADD      R0,SP,#+16
   \       0xE2   0xC80C             LDM      R0!,{R2,R3}
   \       0xE4   0x3808             SUBS     R0,R0,#+8
   \       0xE6   0xA804             ADD      R0,SP,#+16
   \       0xE8   0xC803             LDM      R0,{R0,R1}
   \       0xEA   0x....'....        BL       __aeabi_dmul
   \       0xEE   0x9A00             LDR      R2,[SP, #+0]
   \       0xF0   0x9B01             LDR      R3,[SP, #+4]
   \       0xF2   0x....'....        BL       __aeabi_dmul
   \       0xF6   0x....'....        BL       __aeabi_d2iz
   \       0xFA   0x2144             MOVS     R1,#+68
   \       0xFC   0x5260             STRH     R0,[R4, R1]
    114                  analog_volts_counts_u16 = (*adc1_LocalControl).adc1_ResultAvg.adc1_0_10V_Avg_u16; // Get result from ADC module into analog 0-10V module
   \       0xFE   0x6828             LDR      R0,[R5, #+0]
   \      0x100   0x88C0             LDRH     R0,[R0, #+6]
   \      0x102   0x....             LDR      R1,??DebounceAnalogVolts_0
   \      0x104   0x8008             STRH     R0,[R1, #+0]
    115                  analogVolts_Control.analogVolts_Data.analogErrorCode_u16 = (uint16_t) ((*adc1_LocalControl).adc1_ResultAvg.errorCode_u8); // Get any error codes
   \      0x106   0x6828             LDR      R0,[R5, #+0]
   \      0x108   0x7B00             LDRB     R0,[R0, #+12]
   \      0x10A   0x2148             MOVS     R1,#+72
   \      0x10C   0x5260             STRH     R0,[R4, R1]
    116                  DebounceAnalogVolts(); // Process the analog voltage
   \      0x10E   0x....'....        BL       DebounceAnalogVolts
    117                  
    118                  // Check if analog is low. If enabled and analog is low, demand is "0"
    119                  if( ((analogVolts_Control.analogVolts_Data.discretes_u16.is_analogLow == TRUE) && \
    120          			 (analogVolts_Control.analogVolts_Setting.flags_u16.is_analogLowEnable == TRUE) && \
    121          			 (analogVolts_Control.analogVolts_Setting.flags_u16.is_analogFailSafeEnable == FALSE)) || \
    122          		     (analogVolts_Control.analogVolts_Setting.inputMode_u16 == DISABLE_INPUT)|| \
    123                                 (analogVolts_Control.analogVolts_Setting.flags_u16.is_enableAnalog == FALSE))
   \      0x112   0x2001             MOVS     R0,#+1
   \      0x114   0x214A             MOVS     R1,#+74
   \      0x116   0x5A61             LDRH     R1,[R4, R1]
   \      0x118   0x4001             ANDS     R1,R1,R0
   \      0x11A   0xB289             UXTH     R1,R1
   \      0x11C   0x2900             CMP      R1,#+0
   \      0x11E   0xD005             BEQ      ??moduleAnalog_0_10V_10
   \      0x120   0x212A             MOVS     R1,#+42
   \      0x122   0x5C61             LDRB     R1,[R4, R1]
   \      0x124   0x220C             MOVS     R2,#+12
   \      0x126   0x400A             ANDS     R2,R2,R1
   \      0x128   0x2A04             CMP      R2,#+4
   \      0x12A   0xD007             BEQ      ??moduleAnalog_0_10V_11
   \                     ??moduleAnalog_0_10V_10: (+1)
   \      0x12C   0x8D21             LDRH     R1,[R4, #+40]
   \      0x12E   0x2900             CMP      R1,#+0
   \      0x130   0xD004             BEQ      ??moduleAnalog_0_10V_11
   \      0x132   0x8D61             LDRH     R1,[R4, #+42]
   \      0x134   0x4008             ANDS     R0,R0,R1
   \      0x136   0xB280             UXTH     R0,R0
   \      0x138   0x2800             CMP      R0,#+0
   \      0x13A   0xD117             BNE      ??moduleAnalog_0_10V_12
    124                  {
    125                    analogVolts_Control.analogVolts_Data.analogDemand_u16 = 0;
   \                     ??moduleAnalog_0_10V_11: (+1)
   \      0x13C   0x2000             MOVS     R0,#+0
   \      0x13E   0x0001             MOVS     R1,R0
   \      0x140   0x2242             MOVS     R2,#+66
   \      0x142   0x52A1             STRH     R1,[R4, R2]
    126                    analogVolts_Control.analogVolts_Data.analogDemandPercent_u16 = 0;
   \      0x144   0x2146             MOVS     R1,#+70
   \      0x146   0x5260             STRH     R0,[R4, R1]
    127                    analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn = FALSE;
   \      0x148   0x0020             MOVS     R0,R4
   \      0x14A   0x304A             ADDS     R0,R0,#+74
   \      0x14C   0x214A             MOVS     R1,#+74
   \      0x14E   0x5A61             LDRH     R1,[R4, R1]
   \      0x150   0x....             LDR      R2,??DataTable3_2  ;; 0xffef
   \      0x152   0x400A             ANDS     R2,R2,R1
   \      0x154   0x8002             STRH     R2,[R0, #+0]
    128                    analogVolts_Control.analogVolts_Data.discretes_u16.is_lowerHysteresisEnable = FALSE;
   \      0x156   0x214A             MOVS     R1,#+74
   \      0x158   0x5A61             LDRH     R1,[R4, R1]
   \      0x15A   0x....             LDR      R2,??DataTable3_3  ;; 0xfffb
   \      0x15C   0x400A             ANDS     R2,R2,R1
   \      0x15E   0x8002             STRH     R2,[R0, #+0]
    129                    analogVolts_Control.analogVolts_Data.discretes_u16.is_upperHysteresisEnable = FALSE;
   \      0x160   0x214A             MOVS     R1,#+74
   \      0x162   0x5A61             LDRH     R1,[R4, R1]
   \      0x164   0x....             LDR      R2,??DataTable3_4  ;; 0xfff7
   \      0x166   0x400A             ANDS     R2,R2,R1
   \      0x168   0x8002             STRH     R2,[R0, #+0]
   \      0x16A   0xE003             B        ??moduleAnalog_0_10V_13
    130                  } else { // Analog low is not detected or analog low is not enabled          
    131                      analogVolts_Control.analogVolts_Data.analogDemand_u16 = GetAnalogDemand(); // Convert analog voltage into demand 0 - 0xFFFF
   \                     ??moduleAnalog_0_10V_12: (+1)
   \      0x16C   0x....'....        BL       GetAnalogDemand
   \      0x170   0x2142             MOVS     R1,#+66
   \      0x172   0x5260             STRH     R0,[R4, R1]
    132                    }
    133                    // Convert demand value into 0 to 100.00%. Value is stored in xxxyy format = xxx.yy% 
    134                    analogVolts_Control.analogVolts_Data.analogDemandPercent_u16 = DECIMAL_RIGHT_SHIFT_U16(CALCULATE_PERCENT(analogVolts_Control.analogVolts_Data.analogDemand_u16, 65536),2);
   \                     ??moduleAnalog_0_10V_13: (+1)
   \      0x174   0x2042             MOVS     R0,#+66
   \      0x176   0x5A21             LDRH     R1,[R4, R0]
   \      0x178   0x2064             MOVS     R0,#+100
   \      0x17A   0x4348             MULS     R0,R1,R0
   \      0x17C   0x....'....        BL       __aeabi_i2f
   \      0x180   0x218F             MOVS     R1,#+143
   \      0x182   0x05C9             LSLS     R1,R1,#+23       ;; #+1199570944
   \      0x184   0x....'....        BL       __aeabi_fdiv
   \      0x188   0x4669             MOV      R1,SP
   \      0x18A   0xC1C0             STM      R1!,{R6,R7}
   \      0x18C   0x3908             SUBS     R1,R1,#+8
   \      0x18E   0x....'....        BL       __aeabi_f2d
   \      0x192   0x0006             MOVS     R6,R0
   \      0x194   0x000F             MOVS     R7,R1
   \      0x196   0x4668             MOV      R0,SP
   \      0x198   0xC803             LDM      R0,{R0,R1}
   \      0x19A   0x466A             MOV      R2,SP
   \      0x19C   0xCA0C             LDM      R2,{R2,R3}
   \      0x19E   0x....'....        BL       __aeabi_dmul
   \      0x1A2   0x0032             MOVS     R2,R6
   \      0x1A4   0x003B             MOVS     R3,R7
   \      0x1A6   0x....'....        BL       __aeabi_dmul
   \      0x1AA   0x....'....        BL       __aeabi_d2iz
   \      0x1AE   0x2146             MOVS     R1,#+70
   \      0x1B0   0x5260             STRH     R0,[R4, R1]
    135                  }
    136                }     
    137                return_state_u8 = RUN_MODULE;
   \                     ??moduleAnalog_0_10V_7: (+1)
   \      0x1B2   0x2002             MOVS     R0,#+2
    138                break;
   \      0x1B4   0xE015             B        ??moduleAnalog_0_10V_6
    139              }
    140            case IRQ_MODULE: 
    141              {
    142                // If there are more than one interrupts, from different drivers, you can identify each individually by:
    143                // tableIndex_u8 = getProcessInfoIndex(irq_identifier_u8);
    144                // Then use processInfoTable[tableIndex_u8] to tailor your response appropriately.
    145                return_state_u8 = RUN_MODULE;
   \                     ??moduleAnalog_0_10V_3: (+1)
   \      0x1B6   0x2002             MOVS     R0,#+2
    146                break;
   \      0x1B8   0xE013             B        ??moduleAnalog_0_10V_6
    147              }
    148              
    149            case KILL_MODULE: 
    150              {
    151                // Setting processStatus_u8 to PROCESS_STATUS_KILLED prevents the scheduler main loop from calling this module again.
    152                uint8_t table_index_u8 = getProcessInfoIndex(drv_identifier_u8);
   \                     ??moduleAnalog_0_10V_4: (+1)
   \      0x1BA   0x4668             MOV      R0,SP
   \      0x1BC   0x7F00             LDRB     R0,[R0, #+28]
   \      0x1BE   0x....'....        BL       getProcessInfoIndex
   \      0x1C2   0x0001             MOVS     R1,R0
    153                if (table_index_u8 != INDEX_NOT_FOUND) {
   \      0x1C4   0x0008             MOVS     R0,R1
   \      0x1C6   0xB2C0             UXTB     R0,R0
   \      0x1C8   0x28FF             CMP      R0,#+255
   \      0x1CA   0xD007             BEQ      ??moduleAnalog_0_10V_14
    154                  processInfoTable[table_index_u8].Sched_DrvData.processStatus_u8 = PROCESS_STATUS_KILLED;
   \      0x1CC   0x20FF             MOVS     R0,#+255
   \      0x1CE   0x....             LDR      R2,??DataTable2
   \      0x1D0   0x000B             MOVS     R3,R1
   \      0x1D2   0xB2DB             UXTB     R3,R3
   \      0x1D4   0x2416             MOVS     R4,#+22
   \      0x1D6   0x4363             MULS     R3,R4,R3
   \      0x1D8   0x18D2             ADDS     R2,R2,R3
   \      0x1DA   0x7290             STRB     R0,[R2, #+10]
    155                }
    156                return_state_u8 = INIT_MODULE;
   \                     ??moduleAnalog_0_10V_14: (+1)
   \      0x1DC   0x2001             MOVS     R0,#+1
    157                break;
   \      0x1DE   0xE000             B        ??moduleAnalog_0_10V_6
    158              }
    159            default:
    160              {
    161                return_state_u8 = KILL_MODULE; //10; 
   \                     ??moduleAnalog_0_10V_5: (+1)
   \      0x1E0   0x20FF             MOVS     R0,#+255
    162                break;
    163              }
    164            }
    165            return return_state_u8;
   \                     ??moduleAnalog_0_10V_6: (+1)
   \      0x1E2   0xB2C0             UXTB     R0,R0
   \      0x1E4   0xB00B             ADD      SP,SP,#+44
   \      0x1E6   0xBDF0             POP      {R4-R7,PC}       ;; return
    166          }
    167          
    168          
    169          /**
    170          ********************************************************************************************************************************
    171          * @brief   Assign structured memory
    172          * @details Assign structured memory for Analog 0-10V control
    173          * @param   None
    174          * @retval  None
    175          ********************************************************************************************************************************
    176          */
    177          //

   \                                 In section .text, align 2, keep-with-next
    178          void AssignModuleMemAnalog_0_10V(void){   
   \                     AssignModuleMemAnalog_0_10V: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    179            analog_0_10v_StructMem_u32 =  StructMem_CreateInstance(MODULE_ANALOG_0_10V, sizeof(AnalogVolts_Control), ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);
   \        0x2   0x....             LDR      R4,??DataTable3_5
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x2202             MOVS     R2,#+2
   \        0xC   0x214C             MOVS     R1,#+76
   \        0xE   0x2005             MOVS     R0,#+5
   \       0x10   0x....'....        BL       StructMem_CreateInstance
   \       0x14   0x6020             STR      R0,[R4, #+0]
    180            (*analog_0_10v_StructMem_u32).p_ramBuf_u8 = (uint8_t *)&analogVolts_Control ;    // Map the ADC1 memory into the structured memory
   \       0x16   0x....             LDR      R0,??DataTable3
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6008             STR      R0,[R1, #+0]
    181            uint8_t Module_Analog_0_10v_Index = getProcessInfoIndex(MODULE_ANALOG_0_10V);
   \       0x1C   0x2005             MOVS     R0,#+5
   \       0x1E   0x....'....        BL       getProcessInfoIndex
   \       0x22   0x0005             MOVS     R5,R0
    182            processInfoTable[Module_Analog_0_10v_Index].Sched_ModuleData.p_masterSharedMem_u32 = (Ram_Buf_Handle)analog_0_10v_StructMem_u32;
   \       0x24   0x....             LDR      R0,??DataTable2
   \       0x26   0x0029             MOVS     R1,R5
   \       0x28   0xB2C9             UXTB     R1,R1
   \       0x2A   0x2216             MOVS     R2,#+22
   \       0x2C   0x4351             MULS     R1,R2,R1
   \       0x2E   0x1840             ADDS     R0,R0,R1
   \       0x30   0x0001             MOVS     R1,R0
   \       0x32   0x310B             ADDS     R1,R1,#+11
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x....'....        BL       __aeabi_uwrite4
    183          }
   \       0x3A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    184          
    185          /**
    186          ********************************************************************************************************************************
    187          * @brief   Initilize all analog settings and live data
    188          * @details Read settings from the RAM and initilize the settings
    189          * @retval  None
    190          ********************************************************************************************************************************
    191          */

   \                                 In section .text, align 2, keep-with-next
    192          void Init_Analog_Setting(void){  
   \                     Init_Analog_Setting: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    193            analogVolts_Control.analogVolts_Setting.onVolts_u16 = 621;//205;               // Demand turn ON volts in counts of ADC
   \        0x2   0x....             LDR      R0,??DataTable3
   \        0x4   0x....             LDR      R1,??DataTable3_6  ;; 0x26d
   \        0x6   0x8081             STRH     R1,[R0, #+4]
    194            analogVolts_Control.analogVolts_Setting.offVolts_u16 = 310;//164;              // Demand turn OFF volts in counts of ADC. Acts as Hysteresis
   \        0x8   0x219B             MOVS     R1,#+155
   \        0xA   0x0049             LSLS     R1,R1,#+1        ;; #+310
   \        0xC   0x80C1             STRH     R1,[R0, #+6]
    195            analogVolts_Control.analogVolts_Setting.minVolts_u16 = 931;//300;              // Min volts correspodning to min demand
   \        0xE   0x....             LDR      R1,??DataTable3_7  ;; 0x3a3
   \       0x10   0x8101             STRH     R1,[R0, #+8]
    196            analogVolts_Control.analogVolts_Setting.maxVolts_u16 = 2793;//1284;             // Max volts corresponding to max demand  
   \       0x12   0x....             LDR      R1,??DataTable3_8  ;; 0xae9
   \       0x14   0x8141             STRH     R1,[R0, #+10]
    197            analogVolts_Control.analogVolts_Setting.maxAdcCounts_u16 = 4095;         // Max output of ADC. 12 bit ADC left sifted by 4
   \       0x16   0x....             LDR      R1,??DataTable4  ;; 0xfff
   \       0x18   0x8181             STRH     R1,[R0, #+12]
    198            analogVolts_Control.analogVolts_Setting.debounceThresholdCounts_u16 = 10;//21;// Change demand if the change in analog is outside this threshold. In ADC counts
   \       0x1A   0x220A             MOVS     R2,#+10
   \       0x1C   0x0011             MOVS     R1,R2
   \       0x1E   0x81C1             STRH     R1,[R0, #+14]
    199            analogVolts_Control.analogVolts_Setting.calibratonFactor_s16 = 0;        // Add/Delete this form measured for calibration. In ADC counts
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x8201             STRH     R1,[R0, #+16]
    200            analogVolts_Control.analogVolts_Setting.voltsHysteresis_u16 = 10 ;       // Hys volts at the top end of demand. In ADC counts
   \       0x24   0x8242             STRH     R2,[R0, #+18]
    201            analogVolts_Control.analogVolts_Setting.minDemand_u16 = 10922;//21845;//13107;           // Min allowed demand. 20%
   \       0x26   0x....             LDR      R2,??DataTable4_1  ;; 0x2aaa
   \       0x28   0x8282             STRH     R2,[R0, #+20]
    202            analogVolts_Control.analogVolts_Setting.maxDemand_u16 = 0xFFFF;          // Maximum allowed demand
   \       0x2A   0x....             LDR      R2,??DataTable4_2  ;; 0xffff
   \       0x2C   0x82C2             STRH     R2,[R0, #+22]
    203            analogVolts_Control.analogVolts_Setting.minDemandHysteresis_u16 = 21;   // Lower end hysteresis if Min_Demand > Off_Volts demand. Counts 
   \       0x2E   0x2215             MOVS     R2,#+21
   \       0x30   0x8302             STRH     R2,[R0, #+24]
    204            analogVolts_Control.analogVolts_Setting.analogLowVolts_u16 = 125;//250;        // Volts below which the bAnalog_Loss_Enable is set. In ADC counts
   \       0x32   0x227D             MOVS     R2,#+125
   \       0x34   0x8342             STRH     R2,[R0, #+26]
    205            analogVolts_Control.analogVolts_Setting.failSafeDemand_u16  = 0x7FFF;    // If set to "1" use Fail safe demand when low analog input is detected //50%
   \       0x36   0x....             LDR      R2,??DataTable4_3  ;; 0x7fff
   \       0x38   0x8382             STRH     R2,[R0, #+28]
    206            analogVolts_Control.analogVolts_Setting.analogPeriod_u16 = 50;           // Update rate in mSec for the analog voltage
   \       0x3A   0x2232             MOVS     R2,#+50
   \       0x3C   0x83C2             STRH     R2,[R0, #+30]
    207            analogVolts_Control.analogVolts_Setting.analogLowAlarmEnableCount_u16 = 0;//5;//100;   // analogPeriod*count delay before analog low volts alarm is detected in mSec. 
   \       0x3E   0x8481             STRH     R1,[R0, #+36]
    208            analogVolts_Control.analogVolts_Setting.debounceLoopCount_u16 = 4;             // Debounce count
   \       0x40   0x2104             MOVS     R1,#+4
   \       0x42   0x000A             MOVS     R2,R1
   \       0x44   0x84C2             STRH     R2,[R0, #+38]
    209            analogVolts_Control.analogVolts_Setting.analogGain_f = 0.08056640625;         // Convert ADC coutns to volts 100*3.3/4096
   \       0x46   0x....             LDR      R2,??DataTable4_4  ;; 0x3da50000
   \       0x48   0x6002             STR      R2,[R0, #+0]
    210            
    211            analogVolts_Control.analogVolts_Setting.flags_u16.is_enableAnalog = TRUE;          // If set to "0", 0V = Max demand 10V= 0 Demand
   \       0x4A   0x0002             MOVS     R2,R0
   \       0x4C   0x322A             ADDS     R2,R2,#+42
   \       0x4E   0x2301             MOVS     R3,#+1
   \       0x50   0x8D44             LDRH     R4,[R0, #+42]
   \       0x52   0x431C             ORRS     R4,R4,R3
   \       0x54   0x8014             STRH     R4,[R2, #+0]
    212            analogVolts_Control.analogVolts_Setting.flags_u16.is_invertAnalog = FALSE;         // If set to "0", 0V = Max demand 10V= 0 Demand
   \       0x56   0x8D44             LDRH     R4,[R0, #+42]
   \       0x58   0x....             LDR      R5,??DataTable4_5  ;; 0xfffd
   \       0x5A   0x4025             ANDS     R5,R5,R4
   \       0x5C   0x8015             STRH     R5,[R2, #+0]
    213            analogVolts_Control.analogVolts_Setting.flags_u16.is_analogLowEnable = TRUE;//FALSE;       // Enable analog low detect if set to "1"
   \       0x5E   0x8D44             LDRH     R4,[R0, #+42]
   \       0x60   0x4321             ORRS     R1,R1,R4
   \       0x62   0x8011             STRH     R1,[R2, #+0]
    214            analogVolts_Control.analogVolts_Setting.flags_u16.is_analogFailSafeEnable = FALSE; // If set to "1", switch to fail safe demand when anlaog low is detected  
   \       0x64   0x8D41             LDRH     R1,[R0, #+42]
   \       0x66   0x....             LDR      R4,??DataTable3_4  ;; 0xfff7
   \       0x68   0x400C             ANDS     R4,R4,R1
   \       0x6A   0x8014             STRH     R4,[R2, #+0]
    215            analogVolts_Control.analogVolts_Setting.flags_u16.is_analogMinDemandEnable = TRUE;//FALSE;// If "True", min demand is maintaned when volts is below minVolts and above onVolts
   \       0x6C   0x8D41             LDRH     R1,[R0, #+42]
   \       0x6E   0x2410             MOVS     R4,#+16
   \       0x70   0x430C             ORRS     R4,R4,R1
   \       0x72   0x8014             STRH     R4,[R2, #+0]
    216            
    217            analogVolts_Control.analogVolts_Setting.inputMode_u16 = ANALOG_MODE;//DISABLE_INPUT;//  // 0 = Analog input; 1 = digital input; 
   \       0x74   0x8503             STRH     R3,[R0, #+40]
    218            analogVolts_Control.analogVolts_Setting.digitalOnVolts_u16 = 1000;   // On volts above which for digitial input high
   \       0x76   0x21FA             MOVS     R1,#+250
   \       0x78   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \       0x7A   0x8401             STRH     R1,[R0, #+32]
    219            analogVolts_Control.analogVolts_Setting.digtialOffVolts_u16 = 800;   // Off volts below which digital input is low  
   \       0x7C   0x21C8             MOVS     R1,#+200
   \       0x7E   0x0089             LSLS     R1,R1,#+2        ;; #+800
   \       0x80   0x8441             STRH     R1,[R0, #+34]
    220          }
   \       0x82   0xBC30             POP      {R4,R5}
   \       0x84   0x4770             BX       LR               ;; return
    221          

   \                                 In section .text, align 2, keep-with-next
    222          void InitAnalogVoltsInputParameters(void)
    223          {
   \                     InitAnalogVoltsInputParameters: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
    224            // Initilize live data                                                   // Flag indicates when the analog module is first initlized
    225            analogVolts_Control.analogVolts_Data.analogVoltsCounts_u16 = 0;        // Current Filtered Analog ADC Counts, 0 to 4096
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x....             LDR      R4,??DataTable3
   \        0x6   0x0001             MOVS     R1,R0
   \        0x8   0x87A1             STRH     R1,[R4, #+60]
    226            analogVolts_Control.analogVolts_Data.analogVolts_u16 = 0;              // Current Filtered Analog Volts, 0.00V
   \        0xA   0x0001             MOVS     R1,R0
   \        0xC   0x87E1             STRH     R1,[R4, #+62]
    227            analogVolts_Control.analogVolts_Data.analogVoltsCountsStable_u16 = 0;  // Previous measured analog volts used for debounce check
   \        0xE   0x0001             MOVS     R1,R0
   \       0x10   0x2240             MOVS     R2,#+64
   \       0x12   0x52A1             STRH     R1,[R4, R2]
    228            analogVolts_Control.analogVolts_Data.analogDemand_u16 = 0;             // Calculated analog demand
   \       0x14   0x0001             MOVS     R1,R0
   \       0x16   0x2242             MOVS     R2,#+66
   \       0x18   0x52A1             STRH     R1,[R4, R2]
    229            analogVolts_Control.analogVolts_Data.analogVoltsPercent_u16 = 0;       // Analog Volts scalled 0 to 100%
   \       0x1A   0x0001             MOVS     R1,R0
   \       0x1C   0x2244             MOVS     R2,#+68
   \       0x1E   0x52A1             STRH     R1,[R4, R2]
    230            analogVolts_Control.analogVolts_Data.analogDemandPercent_u16 = 0;      // Analog Demand scalled 0 to 100%  
   \       0x20   0x0001             MOVS     R1,R0
   \       0x22   0x2246             MOVS     R2,#+70
   \       0x24   0x52A1             STRH     R1,[R4, R2]
    231            analogVolts_Control.analogVolts_Data.increasingIntercept_f = 0;    // Intercept used to calculate demand when analog is increasing
   \       0x26   0x0025             MOVS     R5,R4
   \       0x28   0x3534             ADDS     R5,R5,#+52
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x6029             STR      R1,[R5, #+0]
    232            analogVolts_Control.analogVolts_Data.decreasingIntercept_f = 0;    // Intercept used to calcualte demand when analog is decreasing
   \       0x2E   0x....             LDR      R6,??DataTable4_6
   \       0x30   0x6031             STR      R1,[R6, #+0]
    233            
    234            analog_low_alarm_enable_count_u16 = analogVolts_Control.analogVolts_Setting.analogLowAlarmEnableCount_u16;
   \       0x32   0x8CA1             LDRH     R1,[R4, #+36]
   \       0x34   0x....             LDR      R2,??DataTable3_1
   \       0x36   0x8011             STRH     R1,[R2, #+0]
    235            uint16_t demand_range_u16 = 0;
   \       0x38   0x0007             MOVS     R7,R0
    236            uint16_t analog_range_u16 = 0;
   \       0x3A   0x4669             MOV      R1,SP
   \       0x3C   0x8088             STRH     R0,[R1, #+4]
    237            
    238          //  demand_range_u16 = analogVolts_Control.analogVolts_Setting.maxDemand_u16 - analogVolts_Control.analogVolts_Setting.minDemand_u16;
    239          //  analog_range_u16 = (analogVolts_Control.analogVolts_Setting.maxVolts_u16 - analogVolts_Control.analogVolts_Setting.voltsHysteresis_u16) - (analogVolts_Control.analogVolts_Setting.minVolts_u16 - analogVolts_Control.analogVolts_Setting.voltsHysteresis_u16);                                                                 
    240          //  analogVolts_Control.analogVolts_Data.decreasingSlope_f = (float)(demand_range_u16 / ((float)analog_range_u16));                                                                                                                                                                                                                           // Slope used to calculate demand when analog is decreasing
    241          //  analogVolts_Control.analogVolts_Data.decreasingIntercept_u16 = (float)(analogVolts_Control.analogVolts_Setting.minDemand_u16 - (float)((analogVolts_Control.analogVolts_Data.decreasingSlope_f) * (analogVolts_Control.analogVolts_Setting.minVolts_u16 - analogVolts_Control.analogVolts_Setting.voltsHysteresis_u16))); // Intercept used to calcualte demand when analog is decreasing
    242          //  
    243          //  demand_range_u16 = analogVolts_Control.analogVolts_Setting.maxDemand_u16 - analogVolts_Control.analogVolts_Setting.minDemand_u16;
    244          //  analog_range_u16 = analogVolts_Control.analogVolts_Setting.maxVolts_u16 - analogVolts_Control.analogVolts_Setting.minVolts_u16; 
    245          //  analogVolts_Control.analogVolts_Data.increasingSlope_f = (float)(demand_range_u16 / ((float)analog_range_u16));                       // Slope used to calculate demand when analog is increasing
    246          //  analogVolts_Control.analogVolts_Data.increasingIntercept_f = (float)(analogVolts_Control.analogVolts_Setting.minDemand_u16 - (float)((analogVolts_Control.analogVolts_Data.increasingSlope_f) * (analogVolts_Control.analogVolts_Setting.minVolts_u16))); // Interecept used to calculate demand when analog is increasing
    247            
    248            demand_range_u16 = analogVolts_Control.analogVolts_Setting.maxDemand_u16 - analogVolts_Control.analogVolts_Setting.minDemand_u16;
   \       0x3E   0x8AE0             LDRH     R0,[R4, #+22]
   \       0x40   0x8AA1             LDRH     R1,[R4, #+20]
   \       0x42   0x1A40             SUBS     R0,R0,R1
   \       0x44   0x4669             MOV      R1,SP
   \       0x46   0x80C8             STRH     R0,[R1, #+6]
    249            analog_range_u16 = analogVolts_Control.analogVolts_Setting.maxVolts_u16 - analogVolts_Control.analogVolts_Setting.minVolts_u16; 
   \       0x48   0x8960             LDRH     R0,[R4, #+10]
   \       0x4A   0x8921             LDRH     R1,[R4, #+8]
   \       0x4C   0x1A40             SUBS     R0,R0,R1
   \       0x4E   0x4669             MOV      R1,SP
   \       0x50   0x8088             STRH     R0,[R1, #+4]
    250            analogVolts_Control.analogVolts_Data.increasingSlope_f = (float)(demand_range_u16 / ((float)analog_range_u16)); // Slope used to calculate demand when analog is increasing
   \       0x52   0x4668             MOV      R0,SP
   \       0x54   0x88C0             LDRH     R0,[R0, #+6]
   \       0x56   0x....'....        BL       __aeabi_ui2f
   \       0x5A   0x9000             STR      R0,[SP, #+0]
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x8880             LDRH     R0,[R0, #+4]
   \       0x60   0x....'....        BL       __aeabi_ui2f
   \       0x64   0x0001             MOVS     R1,R0
   \       0x66   0x9800             LDR      R0,[SP, #+0]
   \       0x68   0x....'....        BL       __aeabi_fdiv
   \       0x6C   0x6320             STR      R0,[R4, #+48]
    251            
    252            if(analogVolts_Control.analogVolts_Setting.flags_u16.is_invertAnalog == TRUE)
   \       0x6E   0x8D60             LDRH     R0,[R4, #+42]
   \       0x70   0xB280             UXTH     R0,R0
   \       0x72   0x0840             LSRS     R0,R0,#+1
   \       0x74   0x0001             MOVS     R1,R0
   \       0x76   0x07C9             LSLS     R1,R1,#+31       ;; ZeroExtS R1,R1,#+31,#+31
   \       0x78   0x0FC9             LSRS     R1,R1,#+31
   \       0x7A   0x2900             CMP      R1,#+0
   \       0x7C   0xD015             BEQ      ??InitAnalogVoltsInputParameters_0
    253            {
    254              analogVolts_Control.analogVolts_Data.increasingSlope_f = analogVolts_Control.analogVolts_Data.increasingSlope_f * -1;
   \       0x7E   0x6B21             LDR      R1,[R4, #+48]
   \       0x80   0x....             LDR      R0,??DataTable4_7  ;; 0xbf800000
   \       0x82   0x....'....        BL       __aeabi_fmul
   \       0x86   0x6320             STR      R0,[R4, #+48]
    255              analogVolts_Control.analogVolts_Data.increasingIntercept_f = (float)(analogVolts_Control.analogVolts_Setting.minDemand_u16 - (float)((analogVolts_Control.analogVolts_Data.increasingSlope_f) * (analogVolts_Control.analogVolts_Setting.maxVolts_u16))); // Interecept used to calculate demand when analog is increasing
   \       0x88   0x8AA0             LDRH     R0,[R4, #+20]
   \       0x8A   0x....'....        BL       __aeabi_ui2f
   \       0x8E   0x0007             MOVS     R7,R0
   \       0x90   0x8960             LDRH     R0,[R4, #+10]
   \       0x92   0x....'....        BL       __aeabi_ui2f
   \       0x96   0x0001             MOVS     R1,R0
   \       0x98   0x6B20             LDR      R0,[R4, #+48]
   \       0x9A   0x....'....        BL       __aeabi_fmul
   \       0x9E   0x0001             MOVS     R1,R0
   \       0xA0   0x0038             MOVS     R0,R7
   \       0xA2   0x....'....        BL       __aeabi_fsub
   \       0xA6   0x6028             STR      R0,[R5, #+0]
   \       0xA8   0xE00F             B        ??InitAnalogVoltsInputParameters_1
    256            }else
    257            {
    258              analogVolts_Control.analogVolts_Data.increasingIntercept_f = (float)(analogVolts_Control.analogVolts_Setting.minDemand_u16 - (float)((analogVolts_Control.analogVolts_Data.increasingSlope_f) * (analogVolts_Control.analogVolts_Setting.minVolts_u16))); // Interecept used to calculate demand when analog is increasing
   \                     ??InitAnalogVoltsInputParameters_0: (+1)
   \       0xAA   0x8AA0             LDRH     R0,[R4, #+20]
   \       0xAC   0x....'....        BL       __aeabi_ui2f
   \       0xB0   0x0007             MOVS     R7,R0
   \       0xB2   0x8920             LDRH     R0,[R4, #+8]
   \       0xB4   0x....'....        BL       __aeabi_ui2f
   \       0xB8   0x0001             MOVS     R1,R0
   \       0xBA   0x6B20             LDR      R0,[R4, #+48]
   \       0xBC   0x....'....        BL       __aeabi_fmul
   \       0xC0   0x0001             MOVS     R1,R0
   \       0xC2   0x0038             MOVS     R0,R7
   \       0xC4   0x....'....        BL       __aeabi_fsub
   \       0xC8   0x6028             STR      R0,[R5, #+0]
    259            }
    260            analogVolts_Control.analogVolts_Data.decreasingSlope_f = analogVolts_Control.analogVolts_Data.increasingSlope_f;
   \                     ??InitAnalogVoltsInputParameters_1: (+1)
   \       0xCA   0x6B20             LDR      R0,[R4, #+48]
   \       0xCC   0x62E0             STR      R0,[R4, #+44]
    261            analogVolts_Control.analogVolts_Data.decreasingIntercept_f = analogVolts_Control.analogVolts_Data.increasingIntercept_f; 
   \       0xCE   0x6B60             LDR      R0,[R4, #+52]
   \       0xD0   0x6030             STR      R0,[R6, #+0]
    262            
    263            
    264            // Assumes 0 V = 0 demand; Max volts = Max demand  
    265            analogVolts_Control.analogVolts_Data.discretes_u16.is_analogLow = FALSE;             // Set to "TRUE", if analog low is detected
   \       0xD2   0x0020             MOVS     R0,R4
   \       0xD4   0x304A             ADDS     R0,R0,#+74
   \       0xD6   0x214A             MOVS     R1,#+74
   \       0xD8   0x5A61             LDRH     R1,[R4, R1]
   \       0xDA   0x....             LDR      R2,??DataTable4_8  ;; 0xfffe
   \       0xDC   0x400A             ANDS     R2,R2,R1
   \       0xDE   0x8002             STRH     R2,[R0, #+0]
    266            analogVolts_Control.analogVolts_Data.discretes_u16.is_decreasingAnalog = FALSE;       // Set to "TRUE", if analog voltage is decresing
   \       0xE0   0x214A             MOVS     R1,#+74
   \       0xE2   0x5A61             LDRH     R1,[R4, R1]
   \       0xE4   0x....             LDR      R2,??DataTable4_5  ;; 0xfffd
   \       0xE6   0x400A             ANDS     R2,R2,R1
   \       0xE8   0x8002             STRH     R2,[R0, #+0]
    267            analogVolts_Control.analogVolts_Data.discretes_u16.is_lowerHysteresisEnable = FALSE;  // Set to "TRUE", if lower end hys is enabled
   \       0xEA   0x214A             MOVS     R1,#+74
   \       0xEC   0x5A61             LDRH     R1,[R4, R1]
   \       0xEE   0x....             LDR      R2,??DataTable3_3  ;; 0xfffb
   \       0xF0   0x400A             ANDS     R2,R2,R1
   \       0xF2   0x8002             STRH     R2,[R0, #+0]
    268            analogVolts_Control.analogVolts_Data.discretes_u16.is_upperHysteresisEnable = FALSE;  // Set to "TRUE", if upper end hys is enabled 
   \       0xF4   0x214A             MOVS     R1,#+74
   \       0xF6   0x5A61             LDRH     R1,[R4, R1]
   \       0xF8   0x....             LDR      R2,??DataTable3_4  ;; 0xfff7
   \       0xFA   0x400A             ANDS     R2,R2,R1
   \       0xFC   0x8002             STRH     R2,[R0, #+0]
    269            analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn = FALSE;               // Set to"TRUE", if demand goes from 0 to above min_Demand_u16.  
   \       0xFE   0x214A             MOVS     R1,#+74
   \      0x100   0x5A61             LDRH     R1,[R4, R1]
   \      0x102   0x....             LDR      R2,??DataTable3_2  ;; 0xffef
   \      0x104   0x400A             ANDS     R2,R2,R1
   \      0x106   0x8002             STRH     R2,[R0, #+0]
    270          }
   \      0x108   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    271          
    272          /**
    273          ********************************************************************************************************************************
    274          * @brief   Check if Analog is increasing or decresing
    275          * @details Check for debounce. Only update Analog if change is greater than debounce
    276          debounce. Check for Low Analog Volts. 
    277          * @param   None
    278          * @retval  None
    279          ********************************************************************************************************************************
    280          */

   \                                 In section .text, align 4, keep-with-next
    281          void DebounceAnalogVolts(void){
   \                     DebounceAnalogVolts: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    282            uint16_t abs_volts_diff_u16=0;
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x002F             MOVS     R7,R5
    283            abs_volts_diff_u16 = abs(analogVolts_Control.analogVolts_Data.analogVoltsCountsStable_u16  - analog_volts_counts_u16);
   \        0x6   0x4E0D             LDR      R6,??DebounceAnalogVolts_0
   \        0x8   0x....             LDR      R4,??DataTable4_9
   \        0xA   0x2040             MOVS     R0,#+64
   \        0xC   0x5A20             LDRH     R0,[R4, R0]
   \        0xE   0x8831             LDRH     R1,[R6, #+0]
   \       0x10   0x1A40             SUBS     R0,R0,R1
   \       0x12   0x....'....        BL       abs
   \       0x16   0x4669             MOV      R1,SP
   \       0x18   0x8008             STRH     R0,[R1, #+0]
    284            
    285            // Check debounce threshold
    286            if(abs_volts_diff_u16 > analogVolts_Control.analogVolts_Setting.debounceThresholdCounts_u16)
   \       0x1A   0x89E0             LDRH     R0,[R4, #+14]
   \       0x1C   0x4669             MOV      R1,SP
   \       0x1E   0x8809             LDRH     R1,[R1, #+0]
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD27B             BCS      ??DebounceAnalogVolts_1
    287            {  // Change is analog is above debounce
    288              if (analogVolts_Control.analogVolts_Data.analogVoltsCountsStable_u16  >  analog_volts_counts_u16)
   \       0x24   0x8830             LDRH     R0,[R6, #+0]
   \       0x26   0x2140             MOVS     R1,#+64
   \       0x28   0x5A61             LDRH     R1,[R4, R1]
   \       0x2A   0x4288             CMP      R0,R1
   \       0x2C   0xD208             BCS      ??DebounceAnalogVolts_2
    289              { // Analog is decreasing
    290                analog_decreasing_debounce_count_u16++;
   \       0x2E   0x....             LDR      R0,??DataTable4_10
   \       0x30   0x8801             LDRH     R1,[R0, #+0]
   \       0x32   0x1C49             ADDS     R1,R1,#+1
   \       0x34   0x8001             STRH     R1,[R0, #+0]
    291                analog_increasing_debounce_count_u16 = 0;
   \       0x36   0x....             LDR      R0,??DataTable4_11
   \       0x38   0x8005             STRH     R5,[R0, #+0]
   \       0x3A   0xE00C             B        ??DebounceAnalogVolts_3
   \                     ??DebounceAnalogVolts_0:
   \       0x3C   0x....'....        DC32     analog_volts_counts_u16
    292              } else if (analogVolts_Control.analogVolts_Data.analogVoltsCountsStable_u16  <  analog_volts_counts_u16)
   \                     ??DebounceAnalogVolts_2: (+1)
   \       0x40   0x2040             MOVS     R0,#+64
   \       0x42   0x5A20             LDRH     R0,[R4, R0]
   \       0x44   0x8831             LDRH     R1,[R6, #+0]
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xD205             BCS      ??DebounceAnalogVolts_3
    293              { // Analog is increasing
    294                analog_increasing_debounce_count_u16++;
   \       0x4A   0x....             LDR      R0,??DataTable4_11
   \       0x4C   0x8801             LDRH     R1,[R0, #+0]
   \       0x4E   0x1C49             ADDS     R1,R1,#+1
   \       0x50   0x8001             STRH     R1,[R0, #+0]
    295                analog_decreasing_debounce_count_u16 = 0;
   \       0x52   0x....             LDR      R0,??DataTable4_10
   \       0x54   0x8005             STRH     R5,[R0, #+0]
    296              } 
    297              
    298              // Check debounce loop count
    299              if ( (analog_increasing_debounce_count_u16 > analogVolts_Control.analogVolts_Setting.debounceLoopCount_u16) || (analog_decreasing_debounce_count_u16 > analogVolts_Control.analogVolts_Setting.debounceLoopCount_u16)  )
   \                     ??DebounceAnalogVolts_3: (+1)
   \       0x56   0x....             LDR      R7,??DataTable4_11
   \       0x58   0x8CE0             LDRH     R0,[R4, #+38]
   \       0x5A   0x8839             LDRH     R1,[R7, #+0]
   \       0x5C   0x4288             CMP      R0,R1
   \       0x5E   0xD304             BCC      ??DebounceAnalogVolts_4
   \       0x60   0x8CE0             LDRH     R0,[R4, #+38]
   \       0x62   0x....             LDR      R1,??DataTable4_10
   \       0x64   0x8809             LDRH     R1,[R1, #+0]
   \       0x66   0x4288             CMP      R0,R1
   \       0x68   0xD226             BCS      ??DebounceAnalogVolts_5
    300              {
    301                analogVolts_Control.analogVolts_Data.analogVoltsCountsStable_u16 = analogVolts_Control.analogVolts_Data.analogVoltsCounts_u16 + analogVolts_Control.analogVolts_Setting.calibratonFactor_s16; // Update only when debounce count is satisfied and calibrate
   \                     ??DebounceAnalogVolts_4: (+1)
   \       0x6A   0x8FA0             LDRH     R0,[R4, #+60]
   \       0x6C   0x2110             MOVS     R1,#+16
   \       0x6E   0x5E61             LDRSH    R1,[R4, R1]
   \       0x70   0x1840             ADDS     R0,R0,R1
   \       0x72   0x2140             MOVS     R1,#+64
   \       0x74   0x5260             STRH     R0,[R4, R1]
    302                analogVolts_Control.analogVolts_Data.analogVolts_u16 = (uint16_t)(analogVolts_Control.analogVolts_Setting.analogGain_f* analogVolts_Control.analogVolts_Data.analogVoltsCountsStable_u16); // Convert ADC count to volts // No need to right shift since gain is adjusted by factor of 100
   \       0x76   0x2040             MOVS     R0,#+64
   \       0x78   0x5A20             LDRH     R0,[R4, R0]
   \       0x7A   0x....'....        BL       __aeabi_ui2f
   \       0x7E   0x0001             MOVS     R1,R0
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x....'....        BL       __aeabi_fmul
   \       0x86   0x....'....        BL       __aeabi_f2iz
   \       0x8A   0x87E0             STRH     R0,[R4, #+62]
    303                
    304                analogVolts_Control.analogVolts_Data.analogVoltsCounts_u16 = analog_volts_counts_u16; // Update only when debounce count is satisfied  
   \       0x8C   0x8830             LDRH     R0,[R6, #+0]
   \       0x8E   0x87A0             STRH     R0,[R4, #+60]
    305                
    306                // Determine if volts are increasing or decreasing
    307                if(analog_decreasing_debounce_count_u16 > analogVolts_Control.analogVolts_Setting.debounceLoopCount_u16) 
   \       0x90   0x....             LDR      R0,??DataTable4_10
   \       0x92   0x8CE1             LDRH     R1,[R4, #+38]
   \       0x94   0x8802             LDRH     R2,[R0, #+0]
   \       0x96   0x4291             CMP      R1,R2
   \       0x98   0xD206             BCS      ??DebounceAnalogVolts_6
    308                {
    309                  analogVolts_Control.analogVolts_Data.discretes_u16.is_decreasingAnalog = TRUE;
   \       0x9A   0x214A             MOVS     R1,#+74
   \       0x9C   0x5A61             LDRH     R1,[R4, R1]
   \       0x9E   0x2202             MOVS     R2,#+2
   \       0xA0   0x430A             ORRS     R2,R2,R1
   \       0xA2   0x214A             MOVS     R1,#+74
   \       0xA4   0x5262             STRH     R2,[R4, R1]
   \       0xA6   0xE005             B        ??DebounceAnalogVolts_7
    310                } else
    311                {
    312                  analogVolts_Control.analogVolts_Data.discretes_u16.is_decreasingAnalog = FALSE;
   \                     ??DebounceAnalogVolts_6: (+1)
   \       0xA8   0x214A             MOVS     R1,#+74
   \       0xAA   0x5A61             LDRH     R1,[R4, R1]
   \       0xAC   0x....             LDR      R2,??DataTable4_5  ;; 0xfffd
   \       0xAE   0x400A             ANDS     R2,R2,R1
   \       0xB0   0x214A             MOVS     R1,#+74
   \       0xB2   0x5262             STRH     R2,[R4, R1]
    313                }
    314                analog_decreasing_debounce_count_u16 = 0;
   \                     ??DebounceAnalogVolts_7: (+1)
   \       0xB4   0x8005             STRH     R5,[R0, #+0]
    315                analog_increasing_debounce_count_u16 = 0;
   \       0xB6   0x803D             STRH     R5,[R7, #+0]
    316              }
    317              
    318              // Set Digital input flag
    319              if(analogVolts_Control.analogVolts_Data.analogVoltsCountsStable_u16 < analogVolts_Control.analogVolts_Setting.digtialOffVolts_u16)
   \                     ??DebounceAnalogVolts_5: (+1)
   \       0xB8   0x2040             MOVS     R0,#+64
   \       0xBA   0x5A20             LDRH     R0,[R4, R0]
   \       0xBC   0x8C61             LDRH     R1,[R4, #+34]
   \       0xBE   0x4288             CMP      R0,R1
   \       0xC0   0xD206             BCS      ??DebounceAnalogVolts_8
    320              {
    321                analogVolts_Control.analogVolts_Data.discretes_u16.is_digitalInputON = FALSE;
   \       0xC2   0x204A             MOVS     R0,#+74
   \       0xC4   0x5A20             LDRH     R0,[R4, R0]
   \       0xC6   0x....             LDR      R1,??DataTable4_12  ;; 0xffdf
   \       0xC8   0x4001             ANDS     R1,R1,R0
   \       0xCA   0x204A             MOVS     R0,#+74
   \       0xCC   0x5221             STRH     R1,[R4, R0]
   \       0xCE   0xE005             B        ??DebounceAnalogVolts_9
    322              } else{
    323                analogVolts_Control.analogVolts_Data.discretes_u16.is_digitalInputON = TRUE;
   \                     ??DebounceAnalogVolts_8: (+1)
   \       0xD0   0x204A             MOVS     R0,#+74
   \       0xD2   0x5A20             LDRH     R0,[R4, R0]
   \       0xD4   0x2120             MOVS     R1,#+32
   \       0xD6   0x4301             ORRS     R1,R1,R0
   \       0xD8   0x204A             MOVS     R0,#+74
   \       0xDA   0x5221             STRH     R1,[R4, R0]
    324              }
    325              
    326              // Delay low analog detection. Need when power up
    327              if(analog_low_alarm_enable_count_u16 == 0) 
   \                     ??DebounceAnalogVolts_9: (+1)
   \       0xDC   0x....             LDR      R0,??DataTable4_13
   \       0xDE   0x8800             LDRH     R0,[R0, #+0]
   \       0xE0   0x2800             CMP      R0,#+0
   \       0xE2   0xD111             BNE      ??DebounceAnalogVolts_10
    328              { // Check if analog volts is low
    329                if (analogVolts_Control.analogVolts_Data.analogVoltsCounts_u16 < analogVolts_Control.analogVolts_Setting.analogLowVolts_u16)
   \       0xE4   0x8FA0             LDRH     R0,[R4, #+60]
   \       0xE6   0x8B61             LDRH     R1,[R4, #+26]
   \       0xE8   0x4288             CMP      R0,R1
   \       0xEA   0xD206             BCS      ??DebounceAnalogVolts_11
    330                {
    331                  analogVolts_Control.analogVolts_Data.discretes_u16.is_analogLow = TRUE;
   \       0xEC   0x204A             MOVS     R0,#+74
   \       0xEE   0x5A20             LDRH     R0,[R4, R0]
   \       0xF0   0x2101             MOVS     R1,#+1
   \       0xF2   0x4301             ORRS     R1,R1,R0
   \       0xF4   0x204A             MOVS     R0,#+74
   \       0xF6   0x5221             STRH     R1,[R4, R0]
   \       0xF8   0xE014             B        ??DebounceAnalogVolts_12
    332                } else {
    333                  analogVolts_Control.analogVolts_Data.discretes_u16.is_analogLow = FALSE;
   \                     ??DebounceAnalogVolts_11: (+1)
   \       0xFA   0x204A             MOVS     R0,#+74
   \       0xFC   0x5A20             LDRH     R0,[R4, R0]
   \       0xFE   0x....             LDR      R1,??DataTable4_8  ;; 0xfffe
   \      0x100   0x4001             ANDS     R1,R1,R0
   \      0x102   0x204A             MOVS     R0,#+74
   \      0x104   0x5221             STRH     R1,[R4, R0]
   \      0x106   0xE00D             B        ??DebounceAnalogVolts_12
    334                }
    335              } else{
    336                is_volts_above_loss_analog = TRUE;
   \                     ??DebounceAnalogVolts_10: (+1)
   \      0x108   0x2001             MOVS     R0,#+1
   \      0x10A   0x....             LDR      R1,??DataTable4_14
   \      0x10C   0x7008             STRB     R0,[R1, #+0]
    337                analogVolts_Control.analogVolts_Data.discretes_u16.is_analogLow = FALSE;
   \      0x10E   0x204A             MOVS     R0,#+74
   \      0x110   0x5A20             LDRH     R0,[R4, R0]
   \      0x112   0x....             LDR      R1,??DataTable4_8  ;; 0xfffe
   \      0x114   0x4001             ANDS     R1,R1,R0
   \      0x116   0x204A             MOVS     R0,#+74
   \      0x118   0x5221             STRH     R1,[R4, R0]
   \      0x11A   0xE003             B        ??DebounceAnalogVolts_12
    338              }
    339              
    340            } else
    341            { // debounce threshold not satisified
    342              analog_increasing_debounce_count_u16 = 0;
   \                     ??DebounceAnalogVolts_1: (+1)
   \      0x11C   0x....             LDR      R0,??DataTable4_11
   \      0x11E   0x8005             STRH     R5,[R0, #+0]
    343              analog_decreasing_debounce_count_u16 = 0;
   \      0x120   0x....             LDR      R0,??DataTable4_10
   \      0x122   0x8005             STRH     R5,[R0, #+0]
    344            }
    345          }
   \                     ??DebounceAnalogVolts_12: (+1)
   \      0x124   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    346          
    347          /**
    348          ********************************************************************************************************************************
    349          * @brief   Convert Analog volts to Demand ( min_Demand_u16 to max_Demand_u16)
    350          * @details Check for hysteresis, turn ON/OFF and calculate demand 
    351          * @retval  None
    352          ********************************************************************************************************************************
    353          */

   \                                 In section .text, align 4, keep-with-next
    354          uint16_t GetAnalogDemand(void){
   \                     GetAnalogDemand: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
    355            uint32_t analog_demand_u32 = 0;
   \        0x2   0x2700             MOVS     R7,#+0
   \        0x4   0x003C             MOVS     R4,R7
    356            float slope_f;
    357            float intercept_f;
    358            uint16_t analog_volts_u16 = 0; 
   \        0x6   0x0038             MOVS     R0,R7
    359            
    360            analog_volts_u16 = analogVolts_Control.analogVolts_Data.analogVoltsCountsStable_u16; // Used in case analog demand is inverted
   \        0x8   0x4D84             LDR      R5,??GetAnalogDemand_0
   \        0xA   0x2140             MOVS     R1,#+64
   \        0xC   0x5A6E             LDRH     R6,[R5, R1]
    361            // Check if input mode is enabled (ANALOG_MODE)
    362            if (analogVolts_Control.analogVolts_Setting.inputMode_u16 != ANALOG_MODE)
   \        0xE   0x8D29             LDRH     R1,[R5, #+40]
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD007             BEQ      ??GetAnalogDemand_1
    363            {
    364              analog_demand_u32 = 0;
   \       0x14   0x003C             MOVS     R4,R7
    365              analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn = FALSE;
   \       0x16   0x204A             MOVS     R0,#+74
   \       0x18   0x5A28             LDRH     R0,[R5, R0]
   \       0x1A   0x4981             LDR      R1,??GetAnalogDemand_0+0x4  ;; 0xffef
   \       0x1C   0x4001             ANDS     R1,R1,R0
   \       0x1E   0x204A             MOVS     R0,#+74
   \       0x20   0x5229             STRH     R1,[R5, R0]
   \       0x22   0xE1A1             B        ??GetAnalogDemand_2
    366            } else if( (analogVolts_Control.analogVolts_Setting.flags_u16.is_analogLowEnable == TRUE) && (analogVolts_Control.analogVolts_Setting.flags_u16.is_analogFailSafeEnable == TRUE ) && (analogVolts_Control.analogVolts_Data.discretes_u16.is_analogLow == TRUE)) { 
   \                     ??GetAnalogDemand_1: (+1)
   \       0x24   0x202A             MOVS     R0,#+42
   \       0x26   0x5C28             LDRB     R0,[R5, R0]
   \       0x28   0x210C             MOVS     R1,#+12
   \       0x2A   0x4001             ANDS     R1,R1,R0
   \       0x2C   0x290C             CMP      R1,#+12
   \       0x2E   0xD120             BNE      ??GetAnalogDemand_3
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x214A             MOVS     R1,#+74
   \       0x34   0x5A69             LDRH     R1,[R5, R1]
   \       0x36   0x0002             MOVS     R2,R0
   \       0x38   0x400A             ANDS     R2,R2,R1
   \       0x3A   0xB292             UXTH     R2,R2
   \       0x3C   0x2A00             CMP      R2,#+0
   \       0x3E   0xD018             BEQ      ??GetAnalogDemand_3
    367              // Check if Loss of analog 
    368              if((analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn == FALSE))//{ && (is_volts_above_loss_analog == FALSE))//demand is never gone above min demand. 
   \       0x40   0x214A             MOVS     R1,#+74
   \       0x42   0x5A69             LDRH     R1,[R5, R1]
   \       0x44   0xB289             UXTH     R1,R1
   \       0x46   0x0909             LSRS     R1,R1,#+4
   \       0x48   0x4008             ANDS     R0,R0,R1
   \       0x4A   0xB280             UXTH     R0,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD101             BNE      ??GetAnalogDemand_4
    369              {  // Analog never crossed turned ON volts
    370                analog_demand_u32 = 0;
   \       0x50   0x003C             MOVS     R4,R7
   \       0x52   0xE189             B        ??GetAnalogDemand_2
    371                //analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn = FALSE;
    372              } else{// if (is_volts_above_loss_analog == TRUE){ 
    373                // Use fail safe demand if low analog volts is detected  //If volatge suddenly drops from woking range to below failsafe set voltage
    374                analog_demand_u32 = analogVolts_Control.analogVolts_Setting.failSafeDemand_u16;
   \                     ??GetAnalogDemand_4: (+1)
   \       0x54   0x8BA8             LDRH     R0,[R5, #+28]
   \       0x56   0x0004             MOVS     R4,R0
    375                analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn = TRUE;
   \       0x58   0x0028             MOVS     R0,R5
   \       0x5A   0x304A             ADDS     R0,R0,#+74
   \       0x5C   0x214A             MOVS     R1,#+74
   \       0x5E   0x5A69             LDRH     R1,[R5, R1]
   \       0x60   0x2210             MOVS     R2,#+16
   \       0x62   0x430A             ORRS     R2,R2,R1
   \       0x64   0x8002             STRH     R2,[R0, #+0]
    376                analogVolts_Control.analogVolts_Data.discretes_u16.is_upperHysteresisEnable = FALSE;
   \       0x66   0x214A             MOVS     R1,#+74
   \       0x68   0x5A69             LDRH     R1,[R5, R1]
   \       0x6A   0x....             LDR      R2,??DataTable5  ;; 0xfff7
   \       0x6C   0x400A             ANDS     R2,R2,R1
   \       0x6E   0x8002             STRH     R2,[R0, #+0]
   \       0x70   0xE17A             B        ??GetAnalogDemand_2
    377              }
    378            } else {
    379              // If invert is enabled invert measured value
    380              //if (analogVolts_Control.analogVolts_Setting.flags_u16.is_invertAnalog == TRUE) 
    381              //{
    382                //analog_volts_u16 = analogVolts_Control.analogVolts_Setting.maxAdcCounts_u16 - analogVolts_Control.analogVolts_Data.analogVoltsCountsStable_u16;
    383              //}
    384              
    385              if (analogVolts_Control.analogVolts_Data.discretes_u16.is_decreasingAnalog == FALSE)
   \                     ??GetAnalogDemand_3: (+1)
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x214A             MOVS     R1,#+74
   \       0x76   0x5A69             LDRH     R1,[R5, R1]
   \       0x78   0xB289             UXTH     R1,R1
   \       0x7A   0x0849             LSRS     R1,R1,#+1
   \       0x7C   0x0002             MOVS     R2,R0
   \       0x7E   0x400A             ANDS     R2,R2,R1
   \       0x80   0xB292             UXTH     R2,R2
   \       0x82   0x2A00             CMP      R2,#+0
   \       0x84   0xD104             BNE      ??GetAnalogDemand_5
    386              { // Slope used when analog value is increasing
    387                slope_f = analogVolts_Control.analogVolts_Data.increasingSlope_f;
   \       0x86   0x6B29             LDR      R1,[R5, #+48]
   \       0x88   0x9101             STR      R1,[SP, #+4]
    388                intercept_f = analogVolts_Control.analogVolts_Data.increasingIntercept_f;
   \       0x8A   0x6B69             LDR      R1,[R5, #+52]
   \       0x8C   0x9100             STR      R1,[SP, #+0]
   \       0x8E   0xE003             B        ??GetAnalogDemand_6
    389              } else {
    390                // Slope used when analog value is decreasing
    391                slope_f = analogVolts_Control.analogVolts_Data.decreasingSlope_f;
   \                     ??GetAnalogDemand_5: (+1)
   \       0x90   0x6AE9             LDR      R1,[R5, #+44]
   \       0x92   0x9101             STR      R1,[SP, #+4]
    392                intercept_f = analogVolts_Control.analogVolts_Data.decreasingIntercept_f;
   \       0x94   0x6BA9             LDR      R1,[R5, #+56]
   \       0x96   0x9100             STR      R1,[SP, #+0]
    393              }
    394              
    395              // Analog volts is divided up into three parts
    396              // Part 1: 0v to off volts
    397              // Part 2: off volts to upper hysteresis volts
    398              // Part 3: Upper hysteresis volts to max volts
    399              
    400              // Part 1, 2 : Analog input between OFF volts and upper hysteresis
    401              if ((analog_volts_u16 >= analogVolts_Control.analogVolts_Setting.offVolts_u16) && (analog_volts_u16 < (analogVolts_Control.analogVolts_Setting.maxVolts_u16 - analogVolts_Control.analogVolts_Setting.voltsHysteresis_u16)))
   \                     ??GetAnalogDemand_6: (+1)
   \       0x98   0x0031             MOVS     R1,R6
   \       0x9A   0x88EA             LDRH     R2,[R5, #+6]
   \       0x9C   0xB289             UXTH     R1,R1
   \       0x9E   0x4291             CMP      R1,R2
   \       0xA0   0xD200             BCS      .+4
   \       0xA2   0xE0BF             B        ??GetAnalogDemand_7
   \       0xA4   0x0031             MOVS     R1,R6
   \       0xA6   0xB289             UXTH     R1,R1
   \       0xA8   0x896A             LDRH     R2,[R5, #+10]
   \       0xAA   0x8A6B             LDRH     R3,[R5, #+18]
   \       0xAC   0x1AD2             SUBS     R2,R2,R3
   \       0xAE   0x4291             CMP      R1,R2
   \       0xB0   0xDB00             BLT      .+4
   \       0xB2   0xE0B7             B        ??GetAnalogDemand_7
    402              {
    403                // If analog is between ON and OFF volts. Hysteresis part
    404                analogVolts_Control.analogVolts_Data.discretes_u16.is_upperHysteresisEnable = FALSE;
   \       0xB4   0x0029             MOVS     R1,R5
   \       0xB6   0x314A             ADDS     R1,R1,#+74
   \       0xB8   0x224A             MOVS     R2,#+74
   \       0xBA   0x5AAA             LDRH     R2,[R5, R2]
   \       0xBC   0x....             LDR      R3,??DataTable5  ;; 0xfff7
   \       0xBE   0x4013             ANDS     R3,R3,R2
   \       0xC0   0x800B             STRH     R3,[R1, #+0]
    405                
    406                // Part 2
    407                // onVolts till upperHysteresis
    408                if (analog_volts_u16 >= analogVolts_Control.analogVolts_Setting.onVolts_u16) {
   \       0xC2   0x0032             MOVS     R2,R6
   \       0xC4   0x88AB             LDRH     R3,[R5, #+4]
   \       0xC6   0xB292             UXTH     R2,R2
   \       0xC8   0x429A             CMP      R2,R3
   \       0xCA   0xD36A             BCC      ??GetAnalogDemand_8
    409                  if (analog_volts_u16 >= analogVolts_Control.analogVolts_Setting.minVolts_u16)
   \       0xCC   0x0032             MOVS     R2,R6
   \       0xCE   0x892B             LDRH     R3,[R5, #+8]
   \       0xD0   0xB292             UXTH     R2,R2
   \       0xD2   0x429A             CMP      R2,R3
   \       0xD4   0xD314             BCC      ??GetAnalogDemand_9
    410                  {          
    411                    // Analog voltage is above ON volts for first time
    412                    analogVolts_Control.analogVolts_Data.discretes_u16.is_lowerHysteresisEnable = TRUE;
   \       0xD6   0x204A             MOVS     R0,#+74
   \       0xD8   0x5A28             LDRH     R0,[R5, R0]
   \       0xDA   0x2204             MOVS     R2,#+4
   \       0xDC   0x4302             ORRS     R2,R2,R0
   \       0xDE   0x800A             STRH     R2,[R1, #+0]
    413                    analog_demand_u32 = (uint32_t)((float)(slope_f * analog_volts_u16) + intercept_f);
   \       0xE0   0x0030             MOVS     R0,R6
   \       0xE2   0xB280             UXTH     R0,R0
   \       0xE4   0x....'....        BL       __aeabi_ui2f
   \       0xE8   0x0001             MOVS     R1,R0
   \       0xEA   0x9801             LDR      R0,[SP, #+4]
   \       0xEC   0x....'....        BL       __aeabi_fmul
   \       0xF0   0x0001             MOVS     R1,R0
   \       0xF2   0x9800             LDR      R0,[SP, #+0]
   \       0xF4   0x....'....        BL       __aeabi_fadd
   \       0xF8   0x....'....        BL       __aeabi_f2uiz
   \       0xFC   0x0004             MOVS     R4,R0
   \       0xFE   0xE10C             B        ??GetAnalogDemand_10
    414                  } else if (analog_volts_u16 < analogVolts_Control.analogVolts_Setting.minVolts_u16){
   \                     ??GetAnalogDemand_9: (+1)
   \      0x100   0x0032             MOVS     R2,R6
   \      0x102   0x892B             LDRH     R3,[R5, #+8]
   \      0x104   0xB292             UXTH     R2,R2
   \      0x106   0x429A             CMP      R2,R3
   \      0x108   0xD300             BCC      .+4
   \      0x10A   0xE106             B        ??GetAnalogDemand_10
    415                    // Analog voltage below minVolts limit
    416                    if((analogVolts_Control.analogVolts_Setting.flags_u16.is_analogMinDemandEnable) == TRUE ){//&& ( analogVolts_Control.analogVolts_Data.discretes_u16.is_lowerHysteresisEnable == TRUE)){
   \      0x10C   0x8D6A             LDRH     R2,[R5, #+42]
   \      0x10E   0xB292             UXTH     R2,R2
   \      0x110   0x0912             LSRS     R2,R2,#+4
   \      0x112   0x0003             MOVS     R3,R0
   \      0x114   0x4013             ANDS     R3,R3,R2
   \      0x116   0xB29B             UXTH     R3,R3
   \      0x118   0x2B00             CMP      R3,#+0
   \      0x11A   0xD00C             BEQ      ??GetAnalogDemand_11
    417                      // Default to min demand when is_analogMinDemandEn is TRUE
    418                      //analog_demand_u32 = analogVolts_Control.analogVolts_Setting.minDemand_u16;
    419                      if(analogVolts_Control.analogVolts_Setting.flags_u16.is_invertAnalog == FALSE)
   \      0x11C   0x8D69             LDRH     R1,[R5, #+42]
   \      0x11E   0xB289             UXTH     R1,R1
   \      0x120   0x0849             LSRS     R1,R1,#+1
   \      0x122   0x4008             ANDS     R0,R0,R1
   \      0x124   0xB280             UXTH     R0,R0
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD102             BNE      ??GetAnalogDemand_12
    420                      {
    421                        analog_demand_u32 = analogVolts_Control.analogVolts_Setting.minDemand_u16;
   \      0x12A   0x8AA8             LDRH     R0,[R5, #+20]
   \      0x12C   0x0004             MOVS     R4,R0
   \      0x12E   0xE0F4             B        ??GetAnalogDemand_10
    422                      } else
    423                      {
    424                        analog_demand_u32 = analogVolts_Control.analogVolts_Setting.maxDemand_u16;
   \                     ??GetAnalogDemand_12: (+1)
   \      0x130   0x8AE8             LDRH     R0,[R5, #+22]
   \      0x132   0x0004             MOVS     R4,R0
   \      0x134   0xE0F1             B        ??GetAnalogDemand_10
    425                      }
    426                    } else if( (analog_volts_u16 >= (analogVolts_Control.analogVolts_Setting.minVolts_u16 - analogVolts_Control.analogVolts_Setting.voltsHysteresis_u16)) && ( analogVolts_Control.analogVolts_Data.discretes_u16.is_lowerHysteresisEnable == TRUE)){
   \                     ??GetAnalogDemand_11: (+1)
   \      0x136   0x0033             MOVS     R3,R6
   \      0x138   0xB29B             UXTH     R3,R3
   \      0x13A   0x469C             MOV      R12,R3
   \      0x13C   0x892B             LDRH     R3,[R5, #+8]
   \      0x13E   0x8A6A             LDRH     R2,[R5, #+18]
   \      0x140   0x1A9A             SUBS     R2,R3,R2
   \      0x142   0x4663             MOV      R3,R12
   \      0x144   0x4293             CMP      R3,R2
   \      0x146   0xDB17             BLT      ??GetAnalogDemand_13
   \      0x148   0x224A             MOVS     R2,#+74
   \      0x14A   0x5AAA             LDRH     R2,[R5, R2]
   \      0x14C   0xB292             UXTH     R2,R2
   \      0x14E   0x0892             LSRS     R2,R2,#+2
   \      0x150   0x4010             ANDS     R0,R0,R2
   \      0x152   0xB280             UXTH     R0,R0
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xD00F             BEQ      ??GetAnalogDemand_13
    427                      // Apply lower end hysteresis
    428                      analog_demand_u32 = (uint32_t)((float)(slope_f * analog_volts_u16) + intercept_f);
   \      0x158   0x0030             MOVS     R0,R6
   \      0x15A   0xB280             UXTH     R0,R0
   \      0x15C   0x....'....        BL       __aeabi_ui2f
   \      0x160   0x0001             MOVS     R1,R0
   \      0x162   0x9801             LDR      R0,[SP, #+4]
   \      0x164   0x....'....        BL       __aeabi_fmul
   \      0x168   0x0001             MOVS     R1,R0
   \      0x16A   0x9800             LDR      R0,[SP, #+0]
   \      0x16C   0x....'....        BL       __aeabi_fadd
   \      0x170   0x....'....        BL       __aeabi_f2uiz
   \      0x174   0x0004             MOVS     R4,R0
   \      0x176   0xE0D0             B        ??GetAnalogDemand_10
    429                    } else{
    430                      if ((analogVolts_Control.analogVolts_Setting.flags_u16.is_invertAnalog == TRUE) && (analogVolts_Control.analogVolts_Setting.flags_u16.is_analogMinDemandEnable == TRUE))
   \                     ??GetAnalogDemand_13: (+1)
   \      0x178   0x202A             MOVS     R0,#+42
   \      0x17A   0x5C28             LDRB     R0,[R5, R0]
   \      0x17C   0x2212             MOVS     R2,#+18
   \      0x17E   0x4002             ANDS     R2,R2,R0
   \      0x180   0x2A12             CMP      R2,#+18
   \      0x182   0xD102             BNE      ??GetAnalogDemand_14
    431                      {
    432                        analog_demand_u32 = analogVolts_Control.analogVolts_Setting.minDemand_u16;
   \      0x184   0x8AA8             LDRH     R0,[R5, #+20]
   \      0x186   0x0004             MOVS     R4,R0
   \      0x188   0xE0C7             B        ??GetAnalogDemand_10
    433                      } else{
    434                        // Analog volts below hysteresis value
    435                        analog_demand_u32 = 0;
   \                     ??GetAnalogDemand_14: (+1)
   \      0x18A   0x003C             MOVS     R4,R7
    436                        analogVolts_Control.analogVolts_Data.discretes_u16.is_lowerHysteresisEnable = FALSE;
   \      0x18C   0x204A             MOVS     R0,#+74
   \      0x18E   0x5A28             LDRH     R0,[R5, R0]
   \      0x190   0x....             LDR      R2,??DataTable5_1  ;; 0xfffb
   \      0x192   0x4002             ANDS     R2,R2,R0
   \      0x194   0x800A             STRH     R2,[R1, #+0]
    437                        analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn = FALSE;  
   \      0x196   0x204A             MOVS     R0,#+74
   \      0x198   0x5A28             LDRH     R0,[R5, R0]
   \      0x19A   0x4A21             LDR      R2,??GetAnalogDemand_0+0x4  ;; 0xffef
   \      0x19C   0x4002             ANDS     R2,R2,R0
   \      0x19E   0x800A             STRH     R2,[R1, #+0]
   \      0x1A0   0xE0BB             B        ??GetAnalogDemand_10
    438                      }
    439                    }          
    440                  }
    441                }else if (analog_volts_u16 >= analogVolts_Control.analogVolts_Setting.offVolts_u16) {
   \                     ??GetAnalogDemand_8: (+1)
   \      0x1A2   0x0032             MOVS     R2,R6
   \      0x1A4   0x88EB             LDRH     R3,[R5, #+6]
   \      0x1A6   0xB292             UXTH     R2,R2
   \      0x1A8   0x429A             CMP      R2,R3
   \      0x1AA   0xD324             BCC      ??GetAnalogDemand_15
    442                  // Part 1
    443                  // upper hysteresisdown to off volatge
    444                  
    445                  // Demand is minimum until analog reaches below off volatge
    446                  if((analogVolts_Control.analogVolts_Setting.flags_u16.is_analogMinDemandEnable) == TRUE && ( analogVolts_Control.analogVolts_Data.discretes_u16.is_lowerHysteresisEnable == TRUE)){
   \      0x1AC   0x8D6A             LDRH     R2,[R5, #+42]
   \      0x1AE   0xB292             UXTH     R2,R2
   \      0x1B0   0x0912             LSRS     R2,R2,#+4
   \      0x1B2   0x0003             MOVS     R3,R0
   \      0x1B4   0x4013             ANDS     R3,R3,R2
   \      0x1B6   0xB29B             UXTH     R3,R3
   \      0x1B8   0x2B00             CMP      R3,#+0
   \      0x1BA   0xD015             BEQ      ??GetAnalogDemand_16
   \      0x1BC   0x224A             MOVS     R2,#+74
   \      0x1BE   0x5AAA             LDRH     R2,[R5, R2]
   \      0x1C0   0xB292             UXTH     R2,R2
   \      0x1C2   0x0892             LSRS     R2,R2,#+2
   \      0x1C4   0x0003             MOVS     R3,R0
   \      0x1C6   0x4013             ANDS     R3,R3,R2
   \      0x1C8   0xB29B             UXTH     R3,R3
   \      0x1CA   0x2B00             CMP      R3,#+0
   \      0x1CC   0xD00C             BEQ      ??GetAnalogDemand_16
    447                      // Default to min demand when is_analogMinDemandEn is TRUE
    448                      //analog_demand_u32 = analogVolts_Control.analogVolts_Setting.minDemand_u16;
    449                      if(analogVolts_Control.analogVolts_Setting.flags_u16.is_invertAnalog == FALSE)
   \      0x1CE   0x8D69             LDRH     R1,[R5, #+42]
   \      0x1D0   0xB289             UXTH     R1,R1
   \      0x1D2   0x0849             LSRS     R1,R1,#+1
   \      0x1D4   0x4008             ANDS     R0,R0,R1
   \      0x1D6   0xB280             UXTH     R0,R0
   \      0x1D8   0x2800             CMP      R0,#+0
   \      0x1DA   0xD102             BNE      ??GetAnalogDemand_17
    450                      {
    451                        analog_demand_u32 = analogVolts_Control.analogVolts_Setting.minDemand_u16;
   \      0x1DC   0x8AA8             LDRH     R0,[R5, #+20]
   \      0x1DE   0x0004             MOVS     R4,R0
   \      0x1E0   0xE09B             B        ??GetAnalogDemand_10
    452                      } else
    453                      {
    454                        analog_demand_u32 = analogVolts_Control.analogVolts_Setting.maxDemand_u16;
   \                     ??GetAnalogDemand_17: (+1)
   \      0x1E2   0x8AE8             LDRH     R0,[R5, #+22]
   \      0x1E4   0x0004             MOVS     R4,R0
   \      0x1E6   0xE098             B        ??GetAnalogDemand_10
    455                      }
    456                  }else{
    457                    analog_demand_u32 = 0;
   \                     ??GetAnalogDemand_16: (+1)
   \      0x1E8   0x003C             MOVS     R4,R7
    458                    analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn = FALSE;
   \      0x1EA   0x204A             MOVS     R0,#+74
   \      0x1EC   0x5A28             LDRH     R0,[R5, R0]
   \      0x1EE   0x4A0C             LDR      R2,??GetAnalogDemand_0+0x4  ;; 0xffef
   \      0x1F0   0x4002             ANDS     R2,R2,R0
   \      0x1F2   0x800A             STRH     R2,[R1, #+0]
   \      0x1F4   0xE091             B        ??GetAnalogDemand_10
    459                  }
    460                } else if (analog_volts_u16 < analogVolts_Control.analogVolts_Setting.onVolts_u16) {
   \                     ??GetAnalogDemand_15: (+1)
   \      0x1F6   0x0030             MOVS     R0,R6
   \      0x1F8   0x88AA             LDRH     R2,[R5, #+4]
   \      0x1FA   0xB280             UXTH     R0,R0
   \      0x1FC   0x4290             CMP      R0,R2
   \      0x1FE   0xD206             BCS      ??GetAnalogDemand_18
    461                  // Part 1
    462                  // 0V till onVolts
    463                  
    464                  // Demand is zero when analog never crossed ON volts
    465                  analog_demand_u32 = 0;
   \      0x200   0x003C             MOVS     R4,R7
    466                  analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn = FALSE;
   \      0x202   0x204A             MOVS     R0,#+74
   \      0x204   0x5A28             LDRH     R0,[R5, R0]
   \      0x206   0x4A06             LDR      R2,??GetAnalogDemand_0+0x4  ;; 0xffef
   \      0x208   0x4002             ANDS     R2,R2,R0
   \      0x20A   0x800A             STRH     R2,[R1, #+0]
   \      0x20C   0xE085             B        ??GetAnalogDemand_10
    467                } else {
    468                  analog_demand_u32 = 0;
   \                     ??GetAnalogDemand_18: (+1)
   \      0x20E   0x003C             MOVS     R4,R7
    469                  analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn = FALSE;
   \      0x210   0x204A             MOVS     R0,#+74
   \      0x212   0x5A28             LDRH     R0,[R5, R0]
   \      0x214   0x4A02             LDR      R2,??GetAnalogDemand_0+0x4  ;; 0xffef
   \      0x216   0x4002             ANDS     R2,R2,R0
   \      0x218   0x800A             STRH     R2,[R1, #+0]
   \      0x21A   0xE07E             B        ??GetAnalogDemand_10
   \                     ??GetAnalogDemand_0:
   \      0x21C   0x....'....        DC32     analogVolts_Control
   \      0x220   0x0000'FFEF        DC32     0xffef
    470                }
    471              } 
    472          	else if ( (analog_volts_u16 >= (analogVolts_Control.analogVolts_Setting.maxVolts_u16 - analogVolts_Control.analogVolts_Setting.voltsHysteresis_u16)) && (analog_volts_u16 < analogVolts_Control.analogVolts_Setting.maxVolts_u16) ){
   \                     ??GetAnalogDemand_7: (+1)
   \      0x224   0x0031             MOVS     R1,R6
   \      0x226   0xB289             UXTH     R1,R1
   \      0x228   0x896A             LDRH     R2,[R5, #+10]
   \      0x22A   0x8A6B             LDRH     R3,[R5, #+18]
   \      0x22C   0x1AD2             SUBS     R2,R2,R3
   \      0x22E   0x4291             CMP      R1,R2
   \      0x230   0xDB4E             BLT      ??GetAnalogDemand_19
   \      0x232   0x0031             MOVS     R1,R6
   \      0x234   0x896A             LDRH     R2,[R5, #+10]
   \      0x236   0xB289             UXTH     R1,R1
   \      0x238   0x4291             CMP      R1,R2
   \      0x23A   0xD249             BCS      ??GetAnalogDemand_19
    473               // Part 3: 
    474                // upperHysteresis till maxVolts
    475                
    476                // Analog voltage above upper hysteresis voltage      
    477                if (analogVolts_Control.analogVolts_Data.discretes_u16.is_upperHysteresisEnable  == TRUE)
   \      0x23C   0x214A             MOVS     R1,#+74
   \      0x23E   0x5A69             LDRH     R1,[R5, R1]
   \      0x240   0xB289             UXTH     R1,R1
   \      0x242   0x08C9             LSRS     R1,R1,#+3
   \      0x244   0x0002             MOVS     R2,R0
   \      0x246   0x400A             ANDS     R2,R2,R1
   \      0x248   0xB292             UXTH     R2,R2
   \      0x24A   0x2A00             CMP      R2,#+0
   \      0x24C   0xD025             BEQ      ??GetAnalogDemand_20
    478                { // Analog already crossed hysteresis point
    479                  if (analogVolts_Control.analogVolts_Data.discretes_u16.is_decreasingAnalog == TRUE)
   \      0x24E   0x214A             MOVS     R1,#+74
   \      0x250   0x5A69             LDRH     R1,[R5, R1]
   \      0x252   0xB289             UXTH     R1,R1
   \      0x254   0x0849             LSRS     R1,R1,#+1
   \      0x256   0x0002             MOVS     R2,R0
   \      0x258   0x400A             ANDS     R2,R2,R1
   \      0x25A   0xB292             UXTH     R2,R2
   \      0x25C   0x2A00             CMP      R2,#+0
   \      0x25E   0xD00C             BEQ      ??GetAnalogDemand_21
    480                  { // Output demand = max demand till below hysteresis value
    481                    if(analogVolts_Control.analogVolts_Setting.flags_u16.is_invertAnalog == FALSE)
   \      0x260   0x8D69             LDRH     R1,[R5, #+42]
   \      0x262   0xB289             UXTH     R1,R1
   \      0x264   0x0849             LSRS     R1,R1,#+1
   \      0x266   0x4008             ANDS     R0,R0,R1
   \      0x268   0xB280             UXTH     R0,R0
   \      0x26A   0x2800             CMP      R0,#+0
   \      0x26C   0xD102             BNE      ??GetAnalogDemand_22
    482                    {
    483                      analog_demand_u32 = analogVolts_Control.analogVolts_Setting.maxDemand_u16;
   \      0x26E   0x8AE8             LDRH     R0,[R5, #+22]
   \      0x270   0x0004             MOVS     R4,R0
   \      0x272   0xE052             B        ??GetAnalogDemand_10
    484                    } else
    485                    {
    486                      analog_demand_u32 = analogVolts_Control.analogVolts_Setting.minDemand_u16;
   \                     ??GetAnalogDemand_22: (+1)
   \      0x274   0x8AA8             LDRH     R0,[R5, #+20]
   \      0x276   0x0004             MOVS     R4,R0
   \      0x278   0xE04F             B        ??GetAnalogDemand_10
    487                    }
    488                  } else {
    489                    // Analog volts never when above hysteresis voltage
    490                    analog_demand_u32 = (uint32_t)((float)(slope_f * analog_volts_u16) + intercept_f);
   \                     ??GetAnalogDemand_21: (+1)
   \      0x27A   0x0030             MOVS     R0,R6
   \      0x27C   0xB280             UXTH     R0,R0
   \      0x27E   0x....'....        BL       __aeabi_ui2f
   \      0x282   0x0001             MOVS     R1,R0
   \      0x284   0x9801             LDR      R0,[SP, #+4]
   \      0x286   0x....'....        BL       __aeabi_fmul
   \      0x28A   0x0001             MOVS     R1,R0
   \      0x28C   0x9800             LDR      R0,[SP, #+0]
   \      0x28E   0x....'....        BL       __aeabi_fadd
   \      0x292   0x....'....        BL       __aeabi_f2uiz
   \      0x296   0x0004             MOVS     R4,R0
   \      0x298   0xE03F             B        ??GetAnalogDemand_10
    491                  }
    492                } else if (analog_volts_u16 <= analogVolts_Control.analogVolts_Setting.maxVolts_u16) {
   \                     ??GetAnalogDemand_20: (+1)
   \      0x29A   0x8968             LDRH     R0,[R5, #+10]
   \      0x29C   0x0031             MOVS     R1,R6
   \      0x29E   0xB289             UXTH     R1,R1
   \      0x2A0   0x4288             CMP      R0,R1
   \      0x2A2   0xD33A             BCC      ??GetAnalogDemand_10
    493                  // Analog went above Upper Hysteresis value for the first time
    494                  analogVolts_Control.analogVolts_Data.discretes_u16.is_upperHysteresisEnable  = TRUE;
   \      0x2A4   0x204A             MOVS     R0,#+74
   \      0x2A6   0x5A28             LDRH     R0,[R5, R0]
   \      0x2A8   0x2108             MOVS     R1,#+8
   \      0x2AA   0x4301             ORRS     R1,R1,R0
   \      0x2AC   0x204A             MOVS     R0,#+74
   \      0x2AE   0x5229             STRH     R1,[R5, R0]
    495                  analog_demand_u32 = (uint32_t)((float)(slope_f * analog_volts_u16) + intercept_f);
   \      0x2B0   0x0030             MOVS     R0,R6
   \      0x2B2   0xB280             UXTH     R0,R0
   \      0x2B4   0x....'....        BL       __aeabi_ui2f
   \      0x2B8   0x0001             MOVS     R1,R0
   \      0x2BA   0x9801             LDR      R0,[SP, #+4]
   \      0x2BC   0x....'....        BL       __aeabi_fmul
   \      0x2C0   0x0001             MOVS     R1,R0
   \      0x2C2   0x9800             LDR      R0,[SP, #+0]
   \      0x2C4   0x....'....        BL       __aeabi_fadd
   \      0x2C8   0x....'....        BL       __aeabi_f2uiz
   \      0x2CC   0x0004             MOVS     R4,R0
   \      0x2CE   0xE024             B        ??GetAnalogDemand_10
    496                } 
    497          	  //else if (analog_volts_u16 > analogVolts_Control.analogVolts_Setting.maxVolts_u16) {
    498          //        if(analogVolts_Control.analogVolts_Setting.is_invertAnalog == FALSE)
    499          //        {
    500          //          // Saturate demand value
    501          //          analogVolts_Control.analogVolts_Data.is_upperHysteresisEnable  = TRUE;
    502          //          analog_demand_u32 = analogVolts_Control.analogVolts_Setting.maxDemand_u16;
    503          //        } else
    504          //        {
    505          //          // Saturate demand value for inverted input
    506          //          //if( analog_volts_u16 > (analogVolts_Control.analogVolts_Setting.maxVolts_u16) )
    507          //          analogVolts_Control.analogVolts_Data.is_upperHysteresisEnable  = FALSE;
    508          //          analog_demand_u32 = 0;
    509          //        }
    510          //        
    511          //      }
    512          	} else if(analog_volts_u16 >= analogVolts_Control.analogVolts_Setting.maxVolts_u16) 
   \                     ??GetAnalogDemand_19: (+1)
   \      0x2D0   0x0031             MOVS     R1,R6
   \      0x2D2   0x896A             LDRH     R2,[R5, #+10]
   \      0x2D4   0xB289             UXTH     R1,R1
   \      0x2D6   0x4291             CMP      R1,R2
   \      0x2D8   0xD318             BCC      ??GetAnalogDemand_23
    513              {
    514                if(analogVolts_Control.analogVolts_Setting.flags_u16.is_invertAnalog == FALSE)
   \      0x2DA   0x8D69             LDRH     R1,[R5, #+42]
   \      0x2DC   0xB289             UXTH     R1,R1
   \      0x2DE   0x0849             LSRS     R1,R1,#+1
   \      0x2E0   0x4008             ANDS     R0,R0,R1
   \      0x2E2   0xB280             UXTH     R0,R0
   \      0x2E4   0x2800             CMP      R0,#+0
   \      0x2E6   0xD108             BNE      ??GetAnalogDemand_24
    515                {
    516                  // Saturate demand value
    517                  analogVolts_Control.analogVolts_Data.discretes_u16.is_upperHysteresisEnable  = TRUE;
   \      0x2E8   0x204A             MOVS     R0,#+74
   \      0x2EA   0x5A28             LDRH     R0,[R5, R0]
   \      0x2EC   0x2108             MOVS     R1,#+8
   \      0x2EE   0x4301             ORRS     R1,R1,R0
   \      0x2F0   0x204A             MOVS     R0,#+74
   \      0x2F2   0x5229             STRH     R1,[R5, R0]
    518                  analog_demand_u32 = analogVolts_Control.analogVolts_Setting.maxDemand_u16;
   \      0x2F4   0x8AE8             LDRH     R0,[R5, #+22]
   \      0x2F6   0x0004             MOVS     R4,R0
   \      0x2F8   0xE00F             B        ??GetAnalogDemand_10
    519                } else
    520                {
    521                  // Saturate demand value for inverted input
    522                  //if( analog_volts_u16 > (analogVolts_Control.analogVolts_Setting.maxVolts_u16) )
    523                 // analogVolts_Control.analogVolts_Data.discretes_u16.is_upperHysteresisEnable  = FALSE;
    524                  //analog_demand_u32 = 0;
    525                  analogVolts_Control.analogVolts_Data.discretes_u16.is_upperHysteresisEnable  = TRUE;
   \                     ??GetAnalogDemand_24: (+1)
   \      0x2FA   0x204A             MOVS     R0,#+74
   \      0x2FC   0x5A28             LDRH     R0,[R5, R0]
   \      0x2FE   0x2108             MOVS     R1,#+8
   \      0x300   0x4301             ORRS     R1,R1,R0
   \      0x302   0x204A             MOVS     R0,#+74
   \      0x304   0x5229             STRH     R1,[R5, R0]
    526                  analog_demand_u32 = analogVolts_Control.analogVolts_Setting.minDemand_u16;
   \      0x306   0x8AA8             LDRH     R0,[R5, #+20]
   \      0x308   0x0004             MOVS     R4,R0
   \      0x30A   0xE006             B        ??GetAnalogDemand_10
    527                }      
    528              }else{// lessthan OFF volatge
    529                 analog_demand_u32 = 0;
   \                     ??GetAnalogDemand_23: (+1)
   \      0x30C   0x003C             MOVS     R4,R7
    530                 analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn = FALSE;
   \      0x30E   0x204A             MOVS     R0,#+74
   \      0x310   0x5A28             LDRH     R0,[R5, R0]
   \      0x312   0x....             LDR      R1,??DataTable5_2  ;; 0xffef
   \      0x314   0x4001             ANDS     R1,R1,R0
   \      0x316   0x204A             MOVS     R0,#+74
   \      0x318   0x5229             STRH     R1,[R5, R0]
    531              }
    532              
    533              
    534              // Min demand is min_Demand_u16.
    535              if (analog_demand_u32 < analogVolts_Control.analogVolts_Setting.minDemand_u16)
   \                     ??GetAnalogDemand_10: (+1)
   \      0x31A   0x8AA8             LDRH     R0,[R5, #+20]
   \      0x31C   0x4284             CMP      R4,R0
   \      0x31E   0xD212             BCS      ??GetAnalogDemand_25
    536              {
    537                // Check if low end demand hysteresis
    538                if (analog_demand_u32 < (analogVolts_Control.analogVolts_Setting.minDemand_u16 - analogVolts_Control.analogVolts_Setting.minDemandHysteresis_u16))
   \      0x320   0x8AA8             LDRH     R0,[R5, #+20]
   \      0x322   0x8B29             LDRH     R1,[R5, #+24]
   \      0x324   0x1A40             SUBS     R0,R0,R1
   \      0x326   0x4284             CMP      R4,R0
   \      0x328   0xD219             BCS      ??GetAnalogDemand_26
    539                {
    540                  analog_demand_u32 = 0;
   \      0x32A   0x003C             MOVS     R4,R7
    541                  analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn = FALSE;
   \      0x32C   0x0028             MOVS     R0,R5
   \      0x32E   0x304A             ADDS     R0,R0,#+74
   \      0x330   0x214A             MOVS     R1,#+74
   \      0x332   0x5A69             LDRH     R1,[R5, R1]
   \      0x334   0x....             LDR      R2,??DataTable5_2  ;; 0xffef
   \      0x336   0x400A             ANDS     R2,R2,R1
   \      0x338   0x8002             STRH     R2,[R0, #+0]
    542                  analogVolts_Control.analogVolts_Data.discretes_u16.is_lowerHysteresisEnable = FALSE;
   \      0x33A   0x214A             MOVS     R1,#+74
   \      0x33C   0x5A69             LDRH     R1,[R5, R1]
   \      0x33E   0x....             LDR      R2,??DataTable5_1  ;; 0xfffb
   \      0x340   0x400A             ANDS     R2,R2,R1
   \      0x342   0x8002             STRH     R2,[R0, #+0]
   \      0x344   0xE00B             B        ??GetAnalogDemand_26
    543                }
    544              } else {
    545                analogVolts_Control.analogVolts_Data.discretes_u16.is_demandOn = TRUE; // Demand greater than min demand.  
   \                     ??GetAnalogDemand_25: (+1)
   \      0x346   0x0028             MOVS     R0,R5
   \      0x348   0x304A             ADDS     R0,R0,#+74
   \      0x34A   0x214A             MOVS     R1,#+74
   \      0x34C   0x5A69             LDRH     R1,[R5, R1]
   \      0x34E   0x2210             MOVS     R2,#+16
   \      0x350   0x430A             ORRS     R2,R2,R1
   \      0x352   0x8002             STRH     R2,[R0, #+0]
    546                analogVolts_Control.analogVolts_Data.discretes_u16.is_lowerHysteresisEnable = TRUE; // Enable Hysteresis
   \      0x354   0x214A             MOVS     R1,#+74
   \      0x356   0x5A69             LDRH     R1,[R5, R1]
   \      0x358   0x2204             MOVS     R2,#+4
   \      0x35A   0x430A             ORRS     R2,R2,R1
   \      0x35C   0x8002             STRH     R2,[R0, #+0]
    547              }
    548              
    549              // Demand can't exceed max_Demand_u16
    550              if (analog_demand_u32 > analogVolts_Control.analogVolts_Setting.maxDemand_u16)
   \                     ??GetAnalogDemand_26: (+1)
   \      0x35E   0x8AE8             LDRH     R0,[R5, #+22]
   \      0x360   0x42A0             CMP      R0,R4
   \      0x362   0xD201             BCS      ??GetAnalogDemand_2
    551              {
    552                analog_demand_u32 = (uint16_t)analogVolts_Control.analogVolts_Setting.maxDemand_u16;
   \      0x364   0x8AE8             LDRH     R0,[R5, #+22]
   \      0x366   0x0004             MOVS     R4,R0
    553              }      
    554            }
    555            analogVolts_Control.analogVolts_Data.analogDemand_u16 = analog_demand_u32;
   \                     ??GetAnalogDemand_2: (+1)
   \      0x368   0x0020             MOVS     R0,R4
   \      0x36A   0x2142             MOVS     R1,#+66
   \      0x36C   0x5268             STRH     R0,[R5, R1]
    556            return ((uint16_t)analog_demand_u32);  
   \      0x36E   0x0020             MOVS     R0,R4
   \      0x370   0xB280             UXTH     R0,R0
   \      0x372   0xBDFE             POP      {R1-R7,PC}       ;; return
    557          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     processInfoTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     adc1_LocalControl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     module_analog_0_10v_poll_time_u64

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x4024'0000        DC32     0x40240000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     analogVolts_Control

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     analog_low_alarm_enable_count_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x0000'FFEF        DC32     0xffef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x0000'FFFB        DC32     0xfffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x0000'FFF7        DC32     0xfff7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x....'....        DC32     analog_0_10v_StructMem_u32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \        0x0   0x0000'026D        DC32     0x26d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \        0x0   0x0000'03A3        DC32     0x3a3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \        0x0   0x0000'0AE9        DC32     0xae9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x0000'0FFF        DC32     0xfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x0000'2AAA        DC32     0x2aaa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x0000'FFFF        DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x0000'7FFF        DC32     0x7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x3DA5'0000        DC32     0x3da50000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0x0000'FFFD        DC32     0xfffd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \        0x0   0x....'....        DC32     analogVolts_Control+0x38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \        0x0   0xBF80'0000        DC32     0xbf800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \        0x0   0x0000'FFFE        DC32     0xfffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \        0x0   0x....'....        DC32     analogVolts_Control

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \        0x0   0x....'....        DC32     analog_decreasing_debounce_count_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \        0x0   0x....'....        DC32     analog_increasing_debounce_count_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \        0x0   0x0000'FFDF        DC32     0xffdf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \        0x0   0x....'....        DC32     analog_low_alarm_enable_count_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \        0x0   0x....'....        DC32     is_volts_above_loss_analog

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x0000'FFF7        DC32     0xfff7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x0000'FFFB        DC32     0xfffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x0000'FFEF        DC32     0xffef

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   AssignModuleMemAnalog_0_10V
        16   -> StructMem_CreateInstance
        16   -> getProcessInfoIndex
        16 __aeabi_uwrite4
      24   DebounceAnalogVolts
        24   -> __aeabi_f2iz
        24   -> __aeabi_fmul
        24   -> __aeabi_ui2f
        24   -> abs
      32   GetAnalogDemand
        32   -> __aeabi_f2uiz
        32   -> __aeabi_fadd
        32   -> __aeabi_fmul
        32   -> __aeabi_ui2f
      32   InitAnalogVoltsInputParameters
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> __aeabi_ui2f
       8   Init_Analog_Setting
      64   moduleAnalog_0_10V
        64   -> AssignModuleMemAnalog_0_10V
        64   -> DebounceAnalogVolts
        64   -> GetAnalogDemand
        64   -> InitAnalogVoltsInputParameters
        64   -> Init_Analog_Setting
        64   -> __aeabi_d2iz
        64   -> __aeabi_dmul
        64   -> __aeabi_f2d
        64   -> __aeabi_fdiv
        64   -> __aeabi_i2f
        64   -> getProcessInfoIndex
        64   -> getSysCount
        64 __aeabi_uread4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
      60  AssignModuleMemAnalog_0_10V
     294  DebounceAnalogVolts
     884  GetAnalogDemand
     266  InitAnalogVoltsInputParameters
     134  Init_Analog_Setting
       4  adc1_LocalControl
      76  analogVolts_Control
       4  analog_0_10v_StructMem_u32
       2  analog_decreasing_debounce_count_u16
       2  analog_increasing_debounce_count_u16
       2  analog_low_alarm_enable_count_u16
       2  analog_volts_counts_u16
       1  is_volts_above_loss_analog
     488  moduleAnalog_0_10V
       8  module_analog_0_10v_poll_time_u64
       4  temperature_degc_s16

 
   105 bytes in section .bss
 2'250 bytes in section .text
 
 2'250 bytes of CODE memory
   105 bytes of DATA memory

Errors: none
Warnings: none

###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         04/Feb/2022  12:58:42
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Src\main.c
#    Command line                 =
#        -f C:\Users\610126~1\AppData\Local\Temp\EWCE58.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Src\main.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale                       =  C
#    List file                    =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\main.lst
#    Object file                  =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\main.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Src\main.c
      1          /* USER CODE BEGIN Header */
      2          /**
      3            ******************************************************************************
      4            * @file           : main.c
      5            * @brief          : Main program body
      6            ******************************************************************************
      7            * @attention
      8            *
      9            * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
     10            * All rights reserved.</center></h2>
     11            *
     12            * This software component is licensed by ST under BSD 3-Clause license,
     13            * the "License"; You may not use this file except in compliance with the
     14            * License. You may obtain a copy of the License at:
     15            *                        opensource.org/licenses/BSD-3-Clause
     16            *
     17            ******************************************************************************
     18            */
     19          /* USER CODE END Header */
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "main.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
   \        0x4   0xB249             SXTB     R1,R1
   \        0x6   0x2900             CMP      R1,#+0
   \        0x8   0xD405             BMI      ??__NVIC_EnableIRQ_0
   \        0xA   0x2101             MOVS     R1,#+1
   \        0xC   0x06C2             LSLS     R2,R0,#+27       ;; ZeroExtS R2,R0,#+27,#+27
   \        0xE   0x0ED2             LSRS     R2,R2,#+27
   \       0x10   0x4091             LSLS     R1,R1,R2
   \       0x12   0x....             LDR      R2,??DataTable23  ;; 0xe000e100
   \       0x14   0x6011             STR      R1,[R2, #+0]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \       0x16   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_SetPriority(IRQn_Type, uint32_t)
   \                     __NVIC_SetPriority: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x0002             MOVS     R2,R0
   \        0x4   0xB252             SXTB     R2,R2
   \        0x6   0x2A00             CMP      R2,#+0
   \        0x8   0xD41C             BMI      ??__NVIC_SetPriority_0
   \        0xA   0x2203             MOVS     R2,#+3
   \        0xC   0x....             LDR      R3,??DataTable23_1  ;; 0xe000e400
   \        0xE   0x0004             MOVS     R4,R0
   \       0x10   0xB264             SXTB     R4,R4
   \       0x12   0x08A4             LSRS     R4,R4,#+2
   \       0x14   0x2504             MOVS     R5,#+4
   \       0x16   0x436C             MULS     R4,R5,R4
   \       0x18   0x591C             LDR      R4,[R3, R4]
   \       0x1A   0x25FF             MOVS     R5,#+255
   \       0x1C   0x0016             MOVS     R6,R2
   \       0x1E   0x4006             ANDS     R6,R6,R0
   \       0x20   0x2708             MOVS     R7,#+8
   \       0x22   0x437E             MULS     R6,R7,R6
   \       0x24   0x40B5             LSLS     R5,R5,R6
   \       0x26   0x43AC             BICS     R4,R4,R5
   \       0x28   0x018D             LSLS     R5,R1,#+6
   \       0x2A   0xB2ED             UXTB     R5,R5
   \       0x2C   0x4002             ANDS     R2,R2,R0
   \       0x2E   0x2608             MOVS     R6,#+8
   \       0x30   0x4372             MULS     R2,R6,R2
   \       0x32   0x4095             LSLS     R5,R5,R2
   \       0x34   0x4325             ORRS     R5,R5,R4
   \       0x36   0x0002             MOVS     R2,R0
   \       0x38   0xB252             SXTB     R2,R2
   \       0x3A   0x0892             LSRS     R2,R2,#+2
   \       0x3C   0x2404             MOVS     R4,#+4
   \       0x3E   0x4362             MULS     R2,R4,R2
   \       0x40   0x509D             STR      R5,[R3, R2]
   \       0x42   0xE022             B        ??__NVIC_SetPriority_1
   \                     ??__NVIC_SetPriority_0: (+1)
   \       0x44   0x240F             MOVS     R4,#+15
   \       0x46   0x....             LDR      R2,??DataTable24  ;; 0xe000ed1c
   \       0x48   0x2303             MOVS     R3,#+3
   \       0x4A   0x0005             MOVS     R5,R0
   \       0x4C   0xB26D             SXTB     R5,R5
   \       0x4E   0x4025             ANDS     R5,R5,R4
   \       0x50   0x3D08             SUBS     R5,R5,#+8
   \       0x52   0x08AD             LSRS     R5,R5,#+2
   \       0x54   0x2604             MOVS     R6,#+4
   \       0x56   0x4375             MULS     R5,R6,R5
   \       0x58   0x0006             MOVS     R6,R0
   \       0x5A   0xB276             SXTB     R6,R6
   \       0x5C   0x4034             ANDS     R4,R4,R6
   \       0x5E   0x3C08             SUBS     R4,R4,#+8
   \       0x60   0x08A4             LSRS     R4,R4,#+2
   \       0x62   0x2604             MOVS     R6,#+4
   \       0x64   0x4374             MULS     R4,R6,R4
   \       0x66   0x5916             LDR      R6,[R2, R4]
   \       0x68   0x27FF             MOVS     R7,#+255
   \       0x6A   0x46BC             MOV      R12,R7
   \       0x6C   0x001C             MOVS     R4,R3
   \       0x6E   0x4004             ANDS     R4,R4,R0
   \       0x70   0x2708             MOVS     R7,#+8
   \       0x72   0x437C             MULS     R4,R7,R4
   \       0x74   0x4667             MOV      R7,R12
   \       0x76   0x40A7             LSLS     R7,R7,R4
   \       0x78   0x43BE             BICS     R6,R6,R7
   \       0x7A   0x018C             LSLS     R4,R1,#+6
   \       0x7C   0xB2E4             UXTB     R4,R4
   \       0x7E   0x4003             ANDS     R3,R3,R0
   \       0x80   0x2708             MOVS     R7,#+8
   \       0x82   0x437B             MULS     R3,R7,R3
   \       0x84   0x409C             LSLS     R4,R4,R3
   \       0x86   0x4334             ORRS     R4,R4,R6
   \       0x88   0x5154             STR      R4,[R2, R5]
   \                     ??__NVIC_SetPriority_1: (+1)
   \       0x8A   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t SysTick_Config(uint32_t)
   \                     SysTick_Config: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x1E60             SUBS     R0,R4,#+1
   \        0x6   0x2180             MOVS     R1,#+128
   \        0x8   0x0449             LSLS     R1,R1,#+17       ;; #+16777216
   \        0xA   0x4288             CMP      R0,R1
   \        0xC   0xD301             BCC      ??SysTick_Config_0
   \        0xE   0x2001             MOVS     R0,#+1
   \       0x10   0xE00E             B        ??SysTick_Config_1
   \                     ??SysTick_Config_0: (+1)
   \       0x12   0x1E60             SUBS     R0,R4,#+1
   \       0x14   0x....             LDR      R1,??DataTable24_1  ;; 0xe000e014
   \       0x16   0x6008             STR      R0,[R1, #+0]
   \       0x18   0x2103             MOVS     R1,#+3
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x43C0             MVNS     R0,R0            ;; #-1
   \       0x1E   0x....'....        BL       __NVIC_SetPriority
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x....             LDR      R1,??DataTable24_2  ;; 0xe000e018
   \       0x26   0x6008             STR      R0,[R1, #+0]
   \       0x28   0x2007             MOVS     R0,#+7
   \       0x2A   0x....             LDR      R1,??DataTable24_3  ;; 0xe000e010
   \       0x2C   0x6008             STR      R0,[R1, #+0]
   \       0x2E   0x2000             MOVS     R0,#+0
   \                     ??SysTick_Config_1: (+1)
   \       0x30   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_RCC_HSI_Enable(void)
   \                     LL_RCC_HSI_Enable: (+1)
   \        0x0   0x....             LDR      R0,??DataTable24_4  ;; 0x40021000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \        0x8   0x430A             ORRS     R2,R2,R1
   \        0xA   0x6002             STR      R2,[R0, #+0]
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t LL_RCC_HSI_IsReady(void)
   \                     LL_RCC_HSI_IsReady: (+1)
   \        0x0   0x....             LDR      R0,??DataTable24_4  ;; 0x40021000
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0A81             LSRS     R1,R0,#+10
   \        0x6   0x0008             MOVS     R0,R1
   \        0x8   0x07C0             LSLS     R0,R0,#+31       ;; ZeroExtS R0,R0,#+31,#+31
   \        0xA   0x0FC0             LSRS     R0,R0,#+31
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_RCC_SetSysClkSource(uint32_t)
   \                     LL_RCC_SetSysClkSource: (+1)
   \        0x0   0x....             LDR      R1,??DataTable24_5  ;; 0x40021008
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x2307             MOVS     R3,#+7
   \        0x6   0x439A             BICS     R2,R2,R3
   \        0x8   0x4302             ORRS     R2,R2,R0
   \        0xA   0x600A             STR      R2,[R1, #+0]
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t LL_RCC_GetSysClkSource(void)
   \                     LL_RCC_GetSysClkSource: (+1)
   \        0x0   0x....             LDR      R0,??DataTable24_5  ;; 0x40021008
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2038             MOVS     R0,#+56
   \        0x6   0x4008             ANDS     R0,R0,R1
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_RCC_SetAHBPrescaler(uint32_t)
   \                     LL_RCC_SetAHBPrescaler: (+1)
   \        0x0   0x....             LDR      R1,??DataTable24_5  ;; 0x40021008
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x....             LDR      R3,??DataTable24_6  ;; 0xfffff0ff
   \        0x6   0x4013             ANDS     R3,R3,R2
   \        0x8   0x4303             ORRS     R3,R3,R0
   \        0xA   0x600B             STR      R3,[R1, #+0]
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_RCC_SetAPB1Prescaler(uint32_t)
   \                     LL_RCC_SetAPB1Prescaler: (+1)
   \        0x0   0x....             LDR      R1,??DataTable24_5  ;; 0x40021008
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x....             LDR      R3,??DataTable24_7  ;; 0xffff8fff
   \        0x6   0x4013             ANDS     R3,R3,R2
   \        0x8   0x4303             ORRS     R3,R3,R0
   \        0xA   0x600B             STR      R3,[R1, #+0]
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_RCC_SetUSARTClockSource(uint32_t)
   \                     LL_RCC_SetUSARTClockSource: (+1)
   \        0x0   0x....             LDR      R1,??DataTable24_8  ;; 0x40021054
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x0C03             LSRS     R3,R0,#+16
   \        0x6   0x439A             BICS     R2,R2,R3
   \        0x8   0xB283             UXTH     R3,R0
   \        0xA   0x4313             ORRS     R3,R3,R2
   \        0xC   0x600B             STR      R3,[R1, #+0]
   \        0xE   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_RCC_SetADCClockSource(uint32_t)
   \                     LL_RCC_SetADCClockSource: (+1)
   \        0x0   0x....             LDR      R1,??DataTable24_8  ;; 0x40021054
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x0092             LSLS     R2,R2,#+2        ;; ZeroExtS R2,R2,#+2,#+2
   \        0x6   0x0892             LSRS     R2,R2,#+2
   \        0x8   0x4302             ORRS     R2,R2,R0
   \        0xA   0x600A             STR      R2,[R1, #+0]
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_RCC_PLL_Enable(void)
   \                     LL_RCC_PLL_Enable: (+1)
   \        0x0   0x....             LDR      R0,??DataTable24_4  ;; 0x40021000
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x0452             LSLS     R2,R2,#+17       ;; #+16777216
   \        0x8   0x430A             ORRS     R2,R2,R1
   \        0xA   0x6002             STR      R2,[R0, #+0]
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t LL_RCC_PLL_IsReady(void)
   \                     LL_RCC_PLL_IsReady: (+1)
   \        0x0   0x....             LDR      R0,??DataTable24_4  ;; 0x40021000
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0E41             LSRS     R1,R0,#+25
   \        0x6   0x0008             MOVS     R0,R1
   \        0x8   0x07C0             LSLS     R0,R0,#+31       ;; ZeroExtS R0,R0,#+31,#+31
   \        0xA   0x0FC0             LSRS     R0,R0,#+31
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_RCC_PLL_ConfigDomain_SYS(uint32_t, uint32_t, uint32_t, uint32_t)
   \                     LL_RCC_PLL_ConfigDomain_SYS: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   \        0x2   0x....             LDR      R4,??DataTable24_9  ;; 0x4002100c
   \        0x4   0x6825             LDR      R5,[R4, #+0]
   \        0x6   0x....             LDR      R6,??DataTable24_10  ;; 0x1fff808c
   \        0x8   0x402E             ANDS     R6,R6,R5
   \        0xA   0x4306             ORRS     R6,R6,R0
   \        0xC   0x430E             ORRS     R6,R6,R1
   \        0xE   0x0215             LSLS     R5,R2,#+8
   \       0x10   0x4335             ORRS     R5,R5,R6
   \       0x12   0x431D             ORRS     R5,R5,R3
   \       0x14   0x6025             STR      R5,[R4, #+0]
   \       0x16   0xBC70             POP      {R4-R6}
   \       0x18   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_RCC_PLL_EnableDomain_SYS(void)
   \                     LL_RCC_PLL_EnableDomain_SYS: (+1)
   \        0x0   0x....             LDR      R0,??DataTable24_9  ;; 0x4002100c
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x0552             LSLS     R2,R2,#+21       ;; #+268435456
   \        0x8   0x430A             ORRS     R2,R2,R1
   \        0xA   0x6002             STR      R2,[R0, #+0]
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_AHB1_GRP1_EnableClock(uint32_t)
   \                     LL_AHB1_GRP1_EnableClock: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x....             LDR      R1,??DataTable24_11  ;; 0x40021038
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x4302             ORRS     R2,R2,R0
   \        0x8   0x600A             STR      R2,[R1, #+0]
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   \        0xC   0x4001             ANDS     R1,R1,R0
   \        0xE   0x9100             STR      R1,[SP, #+0]
   \       0x10   0x9900             LDR      R1,[SP, #+0]
   \       0x12   0xB001             ADD      SP,SP,#+4
   \       0x14   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_APB1_GRP1_EnableClock(uint32_t)
   \                     LL_APB1_GRP1_EnableClock: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x....             LDR      R1,??DataTable24_12  ;; 0x4002103c
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x4302             ORRS     R2,R2,R0
   \        0x8   0x600A             STR      R2,[R1, #+0]
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   \        0xC   0x4001             ANDS     R1,R1,R0
   \        0xE   0x9100             STR      R1,[SP, #+0]
   \       0x10   0x9900             LDR      R1,[SP, #+0]
   \       0x12   0xB001             ADD      SP,SP,#+4
   \       0x14   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_APB2_GRP1_EnableClock(uint32_t)
   \                     LL_APB2_GRP1_EnableClock: (+1)
   \        0x0   0xB081             SUB      SP,SP,#+4
   \        0x2   0x....             LDR      R1,??DataTable24_13  ;; 0x40021040
   \        0x4   0x680A             LDR      R2,[R1, #+0]
   \        0x6   0x4302             ORRS     R2,R2,R0
   \        0x8   0x600A             STR      R2,[R1, #+0]
   \        0xA   0x6809             LDR      R1,[R1, #+0]
   \        0xC   0x4001             ANDS     R1,R1,R0
   \        0xE   0x9100             STR      R1,[SP, #+0]
   \       0x10   0x9900             LDR      R1,[SP, #+0]
   \       0x12   0xB001             ADD      SP,SP,#+4
   \       0x14   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_FLASH_SetLatency(uint32_t)
   \                     LL_FLASH_SetLatency: (+1)
   \        0x0   0x....             LDR      R1,??DataTable24_14  ;; 0x40022000
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x2307             MOVS     R3,#+7
   \        0x6   0x439A             BICS     R2,R2,R3
   \        0x8   0x4302             ORRS     R2,R2,R0
   \        0xA   0x600A             STR      R2,[R1, #+0]
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t LL_FLASH_GetLatency(void)
   \                     LL_FLASH_GetLatency: (+1)
   \        0x0   0x....             LDR      R0,??DataTable24_14  ;; 0x40022000
   \        0x2   0x6800             LDR      R0,[R0, #+0]
   \        0x4   0x0740             LSLS     R0,R0,#+29       ;; ZeroExtS R0,R0,#+29,#+29
   \        0x6   0x0F40             LSRS     R0,R0,#+29
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_SYSTICK_EnableIT(void)
   \                     LL_SYSTICK_EnableIT: (+1)
   \        0x0   0x....             LDR      R0,??DataTable24_3  ;; 0xe000e010
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x2202             MOVS     R2,#+2
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6002             STR      R2,[R0, #+0]
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_CRC_SetPolynomialSize(CRC_TypeDef *, uint32_t)
   \                     LL_CRC_SetPolynomialSize: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   \        0x2   0x2318             MOVS     R3,#+24
   \        0x4   0x439A             BICS     R2,R2,R3
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6082             STR      R2,[R0, #+8]
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_CRC_SetInputDataReverseMode(CRC_TypeDef *, uint32_t)
   \                     LL_CRC_SetInputDataReverseMode: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   \        0x2   0x2360             MOVS     R3,#+96
   \        0x4   0x439A             BICS     R2,R2,R3
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6082             STR      R2,[R0, #+8]
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_CRC_SetOutputDataReverseMode(CRC_TypeDef *, uint32_t)
   \                     LL_CRC_SetOutputDataReverseMode: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   \        0x2   0x2380             MOVS     R3,#+128
   \        0x4   0x439A             BICS     R2,R2,R3
   \        0x6   0x430A             ORRS     R2,R2,R1
   \        0x8   0x6082             STR      R2,[R0, #+8]
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_CRC_SetInitialData(CRC_TypeDef *, uint32_t)
   \                     LL_CRC_SetInitialData: (+1)
   \        0x0   0x6101             STR      R1,[R0, #+16]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_CRC_SetPolynomialCoef(CRC_TypeDef *, uint32_t)
   \                     LL_CRC_SetPolynomialCoef: (+1)
   \        0x0   0x6141             STR      R1,[R0, #+20]
   \        0x2   0x4770             BX       LR               ;; return
     23          
     24          /* Private includes ----------------------------------------------------------*/
     25          /* USER CODE BEGIN Includes */
     26          
     27          /* USER CODE END Includes */
     28          
     29          /* Private typedef -----------------------------------------------------------*/
     30          /* USER CODE BEGIN PTD */
     31          
     32          /* USER CODE END PTD */
     33          
     34          /* Private define ------------------------------------------------------------*/
     35          /* USER CODE BEGIN PD */
     36          /* USER CODE END PD */
     37          
     38          /* Private macro -------------------------------------------------------------*/
     39          /* USER CODE BEGIN PM */
     40          
     41          /* USER CODE END PM */
     42          
     43          /* Private variables ---------------------------------------------------------*/
     44          
     45          /* USER CODE BEGIN PV */
     46          
     47          /* USER CODE END PV */
     48          
     49          /* Private function prototypes -----------------------------------------------*/
     50          void SystemClock_Config(void);
     51          static void MX_CRC_Init(void);
     52          //static void MX_GPIO_Init(void);
     53          static void MX_DMA_Init(void);
     54          //static void MX_USART2_UART_Init(void);
     55          //static void MX_ADC1_Init(void); //SPA
     56          //static void MX_USART1_UART_Init(void);
     57          /* USER CODE BEGIN PFP */
     58          
     59          /* USER CODE END PFP */
     60          
     61          /* Private user code ---------------------------------------------------------*/
     62          /* USER CODE BEGIN 0 */
     63          
     64          /* USER CODE END 0 */
     65          
     66          /**
     67            * @brief  The application entry point.
     68            * @retval int
     69            */

   \                                 In section .text, align 2, keep-with-next
     70          int main(void)
     71          {
   \                     main: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     72            /* USER CODE BEGIN 1 */
     73            if (SysTick_Config(SystemCoreClock/1000))
   \        0x2   0x....             LDR      R0,??DataTable24_15
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x21FA             MOVS     R1,#+250
   \        0x8   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \        0xA   0x....'....        BL       __aeabi_uidiv
   \        0xE   0x....'....        BL       SysTick_Config
   \       0x12   0x2800             CMP      R0,#+0
   \       0x14   0xD000             BEQ      ??main_0
     74            { 
     75              /* Capture error */ 
     76              while (1);
   \                     ??main_1: (+1)
   \       0x16   0xE7FE             B        ??main_1
     77            }
     78          
     79            /* USER CODE END 1 */
     80          
     81            /* MCU Configuration--------------------------------------------------------*/
     82          
     83            /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
     84            HAL_Init();
   \                     ??main_0: (+1)
   \       0x18   0x....'....        BL       HAL_Init
     85            LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0x....'....        BL       LL_APB2_GRP1_EnableClock
     86            LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
   \       0x22   0x2080             MOVS     R0,#+128
   \       0x24   0x0540             LSLS     R0,R0,#+21       ;; #+268435456
   \       0x26   0x....'....        BL       LL_APB1_GRP1_EnableClock
     87          
     88            /* USER CODE BEGIN Init */
     89          
     90            /* USER CODE END Init */
     91          
     92            /* Configure the system clock */
     93            SystemClock_Config();
   \       0x2A   0x....'....        BL       SystemClock_Config
     94            MX_CRC_Init();
   \       0x2E   0x....'....        BL       MX_CRC_Init
     95            /* USER CODE BEGIN SysInit */
     96          
     97            /* USER CODE END SysInit */
     98          
     99            /* Initialize all configured peripherals */
    100            //MX_GPIO_Init();
    101            MX_DMA_Init();
   \       0x32   0x....'....        BL       MX_DMA_Init
    102            //MX_USART2_UART_Init();
    103            //MX_ADC1_Init(); //SPA
    104            //MX_USART1_UART_Init(); //SPA
    105            /* USER CODE BEGIN 2 */
    106            LL_SYSTICK_EnableIT();
   \       0x36   0x....'....        BL       LL_SYSTICK_EnableIT
    107            Sched_Initialize();
   \       0x3A   0x....'....        BL       Sched_Initialize
    108            Sched_Run();
   \       0x3E   0x....'....        BL       Sched_Run
    109            /* USER CODE END 2 */
    110          
    111            /* Infinite loop */
    112            /* USER CODE BEGIN WHILE */
    113            while (1)
   \                     ??main_2: (+1)
   \       0x42   0xE7FE             B        ??main_2
    114            {
    115              /* USER CODE END WHILE */
    116          
    117              /* USER CODE BEGIN 3 */
    118            }
    119            /* USER CODE END 3 */
    120          }
    121          
    122          /**
    123            * @brief System Clock Configuration
    124            * @retval None
    125            */

   \                                 In section .text, align 2, keep-with-next
    126          void SystemClock_Config(void)
    127          {
   \                     SystemClock_Config: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    128            LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
   \        0x2   0x2002             MOVS     R0,#+2
   \        0x4   0x....'....        BL       LL_FLASH_SetLatency
    129            if(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2)
   \        0x8   0x....'....        BL       LL_FLASH_GetLatency
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD001             BEQ      ??SystemClock_Config_0
    130            {
    131              Error_Handler();  
   \       0x10   0x....'....        BL       Error_Handler
    132            };
    133          
    134            /* HSI configuration and activation */
    135            LL_RCC_HSI_Enable();
   \                     ??SystemClock_Config_0: (+1)
   \       0x14   0x....'....        BL       LL_RCC_HSI_Enable
    136            while(LL_RCC_HSI_IsReady() != 1)
   \                     ??SystemClock_Config_1: (+1)
   \       0x18   0x....'....        BL       LL_RCC_HSI_IsReady
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD1FB             BNE      ??SystemClock_Config_1
    137            {
    138            };
    139          
    140            /* Main PLL configuration and activation */
    141            LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, LL_RCC_PLLM_DIV_1, 8, LL_RCC_PLLR_DIV_2);
   \       0x20   0x2380             MOVS     R3,#+128
   \       0x22   0x059B             LSLS     R3,R3,#+22       ;; #+536870912
   \       0x24   0x2208             MOVS     R2,#+8
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0x2002             MOVS     R0,#+2
   \       0x2A   0x....'....        BL       LL_RCC_PLL_ConfigDomain_SYS
    142            LL_RCC_PLL_Enable();
   \       0x2E   0x....'....        BL       LL_RCC_PLL_Enable
    143            LL_RCC_PLL_EnableDomain_SYS();
   \       0x32   0x....'....        BL       LL_RCC_PLL_EnableDomain_SYS
    144            while(LL_RCC_PLL_IsReady() != 1)
   \                     ??SystemClock_Config_2: (+1)
   \       0x36   0x....'....        BL       LL_RCC_PLL_IsReady
   \       0x3A   0x2801             CMP      R0,#+1
   \       0x3C   0xD1FB             BNE      ??SystemClock_Config_2
    145            {
    146            };
    147          
    148            /* Set AHB prescaler*/
    149            LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x....'....        BL       LL_RCC_SetAHBPrescaler
    150          
    151            /* Sysclk activation on the main PLL */
    152            LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
   \       0x44   0x2002             MOVS     R0,#+2
   \       0x46   0x....'....        BL       LL_RCC_SetSysClkSource
    153            while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
   \                     ??SystemClock_Config_3: (+1)
   \       0x4A   0x....'....        BL       LL_RCC_GetSysClkSource
   \       0x4E   0x2810             CMP      R0,#+16
   \       0x50   0xD1FB             BNE      ??SystemClock_Config_3
    154            {
    155            };
    156          
    157            /* Set APB1 prescaler*/
    158            LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0x....'....        BL       LL_RCC_SetAPB1Prescaler
    159            
    160            LL_Init1msTick(64000000); //SPA
   \       0x58   0x....             LDR      R4,??DataTable24_16  ;; 0x3d09000
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x....'....        BL       LL_Init1msTick
    161            
    162            /* Update CMSIS variable (which can be updated also through SystemCoreClockUpdate function) */
    163            LL_SetSystemCoreClock(64000000);
   \       0x60   0x0020             MOVS     R0,R4
   \       0x62   0x....'....        BL       LL_SetSystemCoreClock
    164          
    165          //   /* Update the time base */
    166          //  if (HAL_InitTick (TICK_INT_PRIORITY) != HAL_OK)
    167          //  {
    168          //    Error_Handler();  
    169          //  };
    170            LL_RCC_SetUSARTClockSource(LL_RCC_USART1_CLKSOURCE_PCLK1);
   \       0x66   0x20C0             MOVS     R0,#+192
   \       0x68   0x0280             LSLS     R0,R0,#+10       ;; #+196608
   \       0x6A   0x....'....        BL       LL_RCC_SetUSARTClockSource
    171            LL_RCC_SetADCClockSource(LL_RCC_ADC_CLKSOURCE_SYSCLK);
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0x....'....        BL       LL_RCC_SetADCClockSource
    172          }
   \       0x74   0xBD10             POP      {R4,PC}          ;; return
    173          
    174          /**
    175            * @brief ADC1 Initialization Function
    176            * @param None
    177            * @retval None
    178            */
    179          //static void MX_ADC1_Init(void)
    180          //{
    181          //
    182          //  /* USER CODE BEGIN ADC1_Init 0 */
    183          //
    184          //  /* USER CODE END ADC1_Init 0 */
    185          //
    186          //  LL_ADC_REG_InitTypeDef ADC_REG_InitStruct = {0};
    187          //  LL_ADC_InitTypeDef ADC_InitStruct = {0};
    188          //
    189          //  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
    190          //
    191          //  /* Peripheral clock enable */
    192          //  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_ADC);
    193          //  
    194          //  LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);
    195          //  /**ADC1 GPIO Configuration  
    196          //  PA0   ------> ADC1_IN0
    197          //  PA1   ------> ADC1_IN1 
    198          //  */
    199          //  GPIO_InitStruct.Pin = ANALOG_0_10V_Pin;
    200          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
    201          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    202          //  LL_GPIO_Init(ANALOG_0_10V_GPIO_Port, &GPIO_InitStruct);
    203          //
    204          //  GPIO_InitStruct.Pin = ANALOG_4_20MA_Pin;
    205          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_ANALOG;
    206          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    207          //  LL_GPIO_Init(ANALOG_4_20MA_GPIO_Port, &GPIO_InitStruct);
    208          //
    209          //  /* ADC1 DMA Init */
    210          //  
    211          //  /* ADC1 Init */
    212          //  LL_DMA_SetPeriphRequest(DMA1, LL_DMA_CHANNEL_1, LL_DMAMUX_REQ_ADC1);
    213          //
    214          //  LL_DMA_SetDataTransferDirection(DMA1, LL_DMA_CHANNEL_1, LL_DMA_DIRECTION_PERIPH_TO_MEMORY);
    215          //
    216          //  LL_DMA_SetChannelPriorityLevel(DMA1, LL_DMA_CHANNEL_1, LL_DMA_PRIORITY_LOW);
    217          //
    218          //  LL_DMA_SetMode(DMA1, LL_DMA_CHANNEL_1, LL_DMA_MODE_CIRCULAR);
    219          //
    220          //  LL_DMA_SetPeriphIncMode(DMA1, LL_DMA_CHANNEL_1, LL_DMA_PERIPH_NOINCREMENT);
    221          //
    222          //  LL_DMA_SetMemoryIncMode(DMA1, LL_DMA_CHANNEL_1, LL_DMA_MEMORY_INCREMENT);
    223          //
    224          //  LL_DMA_SetPeriphSize(DMA1, LL_DMA_CHANNEL_1, LL_DMA_PDATAALIGN_HALFWORD);
    225          //
    226          //  LL_DMA_SetMemorySize(DMA1, LL_DMA_CHANNEL_1, LL_DMA_MDATAALIGN_HALFWORD);
    227          //
    228          //  /* ADC1 interrupt Init */
    229          //  NVIC_SetPriority(ADC1_IRQn, 2);
    230          //  NVIC_EnableIRQ(ADC1_IRQn);
    231          //
    232          //  /* USER CODE BEGIN ADC1_Init 1 */
    233          //
    234          //  /* USER CODE END ADC1_Init 1 */
    235          //  /** Configure Regular Channel 
    236          //  */
    237          //  LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(ADC1), LL_ADC_CHANNEL_TEMPSENSOR
    238          //                              );
    239          //  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
    240          //  */
    241          //  ADC_REG_InitStruct.TriggerSource = LL_ADC_REG_TRIG_SOFTWARE;
    242          //  ADC_REG_InitStruct.SequencerLength = LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS;
    243          //  ADC_REG_InitStruct.SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;
    244          //  ADC_REG_InitStruct.ContinuousMode = LL_ADC_REG_CONV_CONTINUOUS;
    245          //  ADC_REG_InitStruct.DMATransfer = LL_ADC_REG_DMA_TRANSFER_LIMITED;
    246          //  ADC_REG_InitStruct.Overrun = LL_ADC_REG_OVR_DATA_PRESERVED;
    247          //  LL_ADC_REG_Init(ADC1, &ADC_REG_InitStruct);
    248          //  LL_ADC_SetOverSamplingScope(ADC1, LL_ADC_OVS_DISABLE);
    249          //  LL_ADC_SetTriggerFrequencyMode(ADC1, LL_ADC_CLOCK_FREQ_MODE_LOW);
    250          //  LL_ADC_REG_SetSequencerConfigurable(ADC1, LL_ADC_REG_SEQ_CONFIGURABLE);
    251          //  LL_ADC_SetSamplingTimeCommonChannels(ADC1, LL_ADC_SAMPLINGTIME_COMMON_1, LL_ADC_SAMPLINGTIME_160CYCLES_5);
    252          //  LL_ADC_SetSamplingTimeCommonChannels(ADC1, LL_ADC_SAMPLINGTIME_COMMON_2, LL_ADC_SAMPLINGTIME_160CYCLES_5);
    253          //  LL_ADC_DisableIT_EOC(ADC1);
    254          //  LL_ADC_DisableIT_EOS(ADC1);
    255          //  ADC_InitStruct.Clock = LL_ADC_CLOCK_SYNC_PCLK_DIV4;
    256          //  ADC_InitStruct.Resolution = LL_ADC_RESOLUTION_12B;
    257          //  ADC_InitStruct.DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;
    258          //  ADC_InitStruct.LowPowerMode = LL_ADC_LP_MODE_NONE;
    259          //  LL_ADC_Init(ADC1, &ADC_InitStruct);
    260          //  /** Configure Regular Channel 
    261          //  */
    262          //  LL_ADC_REG_SetSequencerRanks(ADC1, LL_ADC_REG_RANK_1, LL_ADC_CHANNEL_0);
    263          //  LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_0, LL_ADC_SAMPLINGTIME_COMMON_1);
    264          //  /** Configure Regular Channel 
    265          //  */
    266          //  LL_ADC_REG_SetSequencerRanks(ADC1, LL_ADC_REG_RANK_2, LL_ADC_CHANNEL_1);
    267          //  LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_1, LL_ADC_SAMPLINGTIME_COMMON_1);
    268          //  /** Configure Regular Channel 
    269          //  */
    270          //  LL_ADC_REG_SetSequencerRanks(ADC1, LL_ADC_REG_RANK_3, LL_ADC_CHANNEL_TEMPSENSOR);
    271          //  LL_ADC_SetChannelSamplingTime(ADC1, LL_ADC_CHANNEL_TEMPSENSOR, LL_ADC_SAMPLINGTIME_COMMON_1);
    272          //  /* USER CODE BEGIN ADC1_Init 2 */
    273          // //LL_DMA_SetMemoryAddress(DMA1, LL_DMA_CHANNEL_1, (uint32_t)adc1Result); //SPA
    274          // //LL_DMA_EnableChannel(DMA_TypeDef *DMA1, uint32_t LL_DMA_CHANNEL_1 ) //SPA
    275          //  /* USER CODE END ADC1_Init 2 */
    276          //
    277          //}
    278          
    279          ///**
    280          //  * @brief USART1 Initialization Function
    281          //  * @param None
    282          //  * @retval None
    283          //  */
    284          //static void MX_USART1_UART_Init(void)
    285          //{
    286          //
    287          //  /* USER CODE BEGIN USART1_Init 0 */
    288          //
    289          //  /* USER CODE END USART1_Init 0 */
    290          //
    291          //  LL_USART_InitTypeDef USART_InitStruct = {0};
    292          //
    293          //  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
    294          //
    295          //  /* Peripheral clock enable */
    296          //  LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_USART1);
    297          //  
    298          //  LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);
    299          //  /**USART1 GPIO Configuration  
    300          //  PA9   ------> USART1_TX
    301          //  PA10   ------> USART1_RX
    302          //  PA12 [PA10]   ------> USART1_DE 
    303          //  */
    304          //  GPIO_InitStruct.Pin = MODBUS_TX_Pin;
    305          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
    306          //  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
    307          //  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
    308          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    309          //  GPIO_InitStruct.Alternate = LL_GPIO_AF_1;
    310          //  LL_GPIO_Init(MODBUS_TX_GPIO_Port, &GPIO_InitStruct);
    311          //
    312          //  GPIO_InitStruct.Pin = MODBUS_RX_Pin;
    313          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
    314          //  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
    315          //  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
    316          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    317          //  GPIO_InitStruct.Alternate = LL_GPIO_AF_1;
    318          //  LL_GPIO_Init(MODBUS_RX_GPIO_Port, &GPIO_InitStruct);
    319          //
    320          //  GPIO_InitStruct.Pin = MODBUS_EN_Pin;
    321          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
    322          //  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
    323          //  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
    324          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    325          //  GPIO_InitStruct.Alternate = LL_GPIO_AF_1;
    326          //  LL_GPIO_Init(MODBUS_EN_GPIO_Port, &GPIO_InitStruct);
    327          //
    328          //  /* USART1 interrupt Init */
    329          //  NVIC_SetPriority(USART1_IRQn, 0);
    330          //  NVIC_EnableIRQ(USART1_IRQn);
    331          //
    332          //  /* USER CODE BEGIN USART1_Init 1 */
    333          //
    334          //  /* USER CODE END USART1_Init 1 */
    335          //  USART_InitStruct.PrescalerValue = LL_USART_PRESCALER_DIV1;
    336          //  USART_InitStruct.BaudRate = 115200;
    337          //  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
    338          //  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
    339          //  USART_InitStruct.Parity = LL_USART_PARITY_NONE;
    340          //  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
    341          //  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
    342          //  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
    343          //  LL_USART_Init(USART1, &USART_InitStruct);
    344          //  LL_USART_SetTXFIFOThreshold(USART1, LL_USART_FIFOTHRESHOLD_1_8);
    345          //  LL_USART_SetRXFIFOThreshold(USART1, LL_USART_FIFOTHRESHOLD_1_8);
    346          //  LL_USART_EnableDEMode(USART1);
    347          //  LL_USART_SetDESignalPolarity(USART1, LL_USART_DE_POLARITY_HIGH);
    348          //  LL_USART_SetDEAssertionTime(USART1, 0);
    349          //  LL_USART_SetDEDeassertionTime(USART1, 0);
    350          //  LL_USART_DisableFIFO(USART1);
    351          //  LL_USART_ConfigAsyncMode(USART1);
    352          //
    353          //  /* USER CODE BEGIN WKUPType USART1 */
    354          //
    355          //  /* USER CODE END WKUPType USART1 */
    356          //
    357          //  LL_USART_Enable(USART1);
    358          //
    359          //  /* Polling USART1 initialisation */
    360          //  while((!(LL_USART_IsActiveFlag_TEACK(USART1))) || (!(LL_USART_IsActiveFlag_REACK(USART1))))
    361          //  {
    362          //  }
    363          //  /* USER CODE BEGIN USART1_Init 2 */
    364          //
    365          //  /* USER CODE END USART1_Init 2 */
    366          //
    367          //}
    368          
    369          
    370          /** 
    371            * Enable DMA controller clock
    372            */

   \                                 In section .text, align 2, keep-with-next
    373          static void MX_DMA_Init(void) 
    374          {
   \                     MX_DMA_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    375          
    376            /* DMA controller clock enable */
    377            __HAL_RCC_DMA1_CLK_ENABLE();
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x....             LDR      R1,??DataTable24_11  ;; 0x40021038
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0x4302             ORRS     R2,R2,R0
   \        0xA   0x600A             STR      R2,[R1, #+0]
   \        0xC   0x6809             LDR      R1,[R1, #+0]
   \        0xE   0x4008             ANDS     R0,R0,R1
   \       0x10   0x9000             STR      R0,[SP, #+0]
   \       0x12   0x9800             LDR      R0,[SP, #+0]
    378          
    379            /* DMA interrupt init */
    380            /* DMA1_Channel1_IRQn interrupt configuration */
    381            NVIC_SetPriority(DMA1_Channel1_IRQn, 0);
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x2009             MOVS     R0,#+9
   \       0x18   0x....'....        BL       __NVIC_SetPriority
    382            NVIC_EnableIRQ(DMA1_Channel1_IRQn);
   \       0x1C   0x2009             MOVS     R0,#+9
   \       0x1E   0x....'....        BL       __NVIC_EnableIRQ
    383          
    384          }
   \       0x22   0xBD01             POP      {R0,PC}          ;; return
    385          

   \                                 In section .text, align 2, keep-with-next
    386          static void MX_CRC_Init(void)
    387          {
   \                     MX_CRC_Init: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    388          
    389            /* USER CODE BEGIN CRC_Init 0 */
    390          
    391            /* USER CODE END CRC_Init 0 */
    392          
    393            /* Peripheral clock enable */
    394            LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_CRC);
   \        0x2   0x2080             MOVS     R0,#+128
   \        0x4   0x0140             LSLS     R0,R0,#+5        ;; #+4096
   \        0x6   0x....'....        BL       LL_AHB1_GRP1_EnableClock
    395          
    396            /* USER CODE BEGIN CRC_Init 1 */
    397          
    398            /* USER CODE END CRC_Init 1 */
    399            //CRC-16/CCITT-FALSE 
    400            LL_CRC_SetInputDataReverseMode(CRC, LL_CRC_INDATA_REVERSE_NONE);
   \        0xA   0x....             LDR      R4,??DataTable24_17  ;; 0x40023000
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x0020             MOVS     R0,R4
   \       0x10   0x....'....        BL       LL_CRC_SetInputDataReverseMode
    401            LL_CRC_SetOutputDataReverseMode(CRC, LL_CRC_OUTDATA_REVERSE_NONE);
   \       0x14   0x2100             MOVS     R1,#+0
   \       0x16   0x0020             MOVS     R0,R4
   \       0x18   0x....'....        BL       LL_CRC_SetOutputDataReverseMode
    402            LL_CRC_SetPolynomialCoef(CRC, 0x1021);                                              //LL_CRC_DEFAULT_CRC32_POLY);
   \       0x1C   0x....             LDR      R1,??DataTable24_18  ;; 0x1021
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x....'....        BL       LL_CRC_SetPolynomialCoef
    403            LL_CRC_SetPolynomialSize(CRC, LL_CRC_POLYLENGTH_16B);                                //LL_CRC_POLYLENGTH_32B);
   \       0x24   0x2108             MOVS     R1,#+8
   \       0x26   0x0020             MOVS     R0,R4
   \       0x28   0x....'....        BL       LL_CRC_SetPolynomialSize
    404            LL_CRC_SetInitialData(CRC, 0xFFFF);                                                  //LL_CRC_DEFAULT_CRC_INITVALUE);
   \       0x2C   0x....             LDR      R1,??DataTable24_19  ;; 0xffff
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x....'....        BL       LL_CRC_SetInitialData
    405            /* USER CODE BEGIN CRC_Init 2 */
    406          
    407            /* USER CODE END CRC_Init 2 */
    408          
    409          }
   \       0x34   0xBD10             POP      {R4,PC}          ;; return
    410          
    411          ///**
    412          //  * @brief GPIO Initialization Function
    413          //  * @param None
    414          //  * @retval None
    415          //  */
    416          //static void MX_GPIO_Init(void)
    417          //{
    418          //  LL_EXTI_InitTypeDef EXTI_InitStruct = {0};
    419          //  LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
    420          //
    421          //  /* GPIO Ports Clock Enable */
    422          //  LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOB);
    423          //  LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOC);
    424          //  LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);
    425          //
    426          //  /**/
    427          //  LL_GPIO_ResetOutputPin(DOUT1_GPIO_Port, DOUT1_Pin);
    428          //
    429          //  /**/
    430          //  LL_GPIO_ResetOutputPin(LED_ONBOARD_GPIO_Port, LED_ONBOARD_Pin);
    431          //
    432          //  /**/
    433          //  LL_GPIO_ResetOutputPin(LED_OUT_GPIO_Port, LED_OUT_Pin);
    434          //
    435          //  /**/
    436          //  LL_GPIO_ResetOutputPin(RELAY_OUT_GPIO_Port, RELAY_OUT_Pin);
    437          //
    438          //  /**/
    439          //  GPIO_InitStruct.Pin = DOUT1_Pin;
    440          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
    441          //  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
    442          //  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
    443          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    444          //  LL_GPIO_Init(DOUT1_GPIO_Port, &GPIO_InitStruct);
    445          //
    446          //  /**/
    447          //  GPIO_InitStruct.Pin = LL_GPIO_PIN_6;
    448          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
    449          //  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
    450          //  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
    451          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    452          //  GPIO_InitStruct.Alternate = LL_GPIO_AF_0;
    453          //  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    454          //
    455          //  /**/
    456          //  GPIO_InitStruct.Pin = LL_GPIO_PIN_7;
    457          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
    458          //  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
    459          //  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
    460          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    461          //  GPIO_InitStruct.Alternate = LL_GPIO_AF_0;
    462          //  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
    463          //
    464          //  /**/
    465          //  GPIO_InitStruct.Pin = DIN1_Pin;
    466          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
    467          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    468          //  LL_GPIO_Init(DIN1_GPIO_Port, &GPIO_InitStruct);
    469          //
    470          //  /**/
    471          //  GPIO_InitStruct.Pin = DIN2_Pin;
    472          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
    473          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    474          //  LL_GPIO_Init(DIN2_GPIO_Port, &GPIO_InitStruct);
    475          //
    476          //  /**/
    477          //  GPIO_InitStruct.Pin = DIN3_Pin;
    478          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_INPUT;
    479          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    480          //  LL_GPIO_Init(DIN3_GPIO_Port, &GPIO_InitStruct);
    481          //
    482          //  /**/
    483          //  GPIO_InitStruct.Pin = LED_ONBOARD_Pin;
    484          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
    485          //  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
    486          //  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
    487          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    488          //  LL_GPIO_Init(LED_ONBOARD_GPIO_Port, &GPIO_InitStruct);
    489          //
    490          //  /**/
    491          //  GPIO_InitStruct.Pin = LL_GPIO_PIN_3;
    492          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
    493          //  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
    494          //  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
    495          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    496          //  GPIO_InitStruct.Alternate = LL_GPIO_AF_0;
    497          //  LL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    498          //
    499          //  /**/
    500          //  GPIO_InitStruct.Pin = LED_OUT_Pin;
    501          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
    502          //  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
    503          //  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
    504          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    505          //  LL_GPIO_Init(LED_OUT_GPIO_Port, &GPIO_InitStruct);
    506          //
    507          //  /**/
    508          //  GPIO_InitStruct.Pin = RELAY_OUT_Pin;
    509          //  GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
    510          //  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
    511          //  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
    512          //  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
    513          //  LL_GPIO_Init(RELAY_OUT_GPIO_Port, &GPIO_InitStruct);
    514          //
    515          //  /**/
    516          //  LL_EXTI_SetEXTISource(LL_EXTI_CONFIG_PORTA, LL_EXTI_CONFIG_LINE8);
    517          //
    518          //  /**/
    519          //  EXTI_InitStruct.Line_0_31 = LL_EXTI_LINE_8;
    520          //  EXTI_InitStruct.LineCommand = ENABLE;
    521          //  EXTI_InitStruct.Mode = LL_EXTI_MODE_IT;
    522          //  EXTI_InitStruct.Trigger = LL_EXTI_TRIGGER_RISING;
    523          //  LL_EXTI_Init(&EXTI_InitStruct);
    524          //
    525          //  /**/
    526          //  LL_GPIO_SetPinPull(PWM_IN_GPIO_Port, PWM_IN_Pin, LL_GPIO_PULL_NO);
    527          //
    528          //  /**/
    529          //  LL_GPIO_SetPinMode(PWM_IN_GPIO_Port, PWM_IN_Pin, LL_GPIO_MODE_INPUT);
    530          //
    531          //}
    532          
    533          /* USER CODE BEGIN 4 */
    534          
    535          /* USER CODE END 4 */
    536          
    537          /**
    538            * @brief  This function is executed in case of error occurrence.
    539            * @retval None
    540            */

   \                                 In section .text, align 2, keep-with-next
    541          void Error_Handler(void)
    542          {
    543            /* USER CODE BEGIN Error_Handler_Debug */
    544            /* User can add his own implementation to report the HAL error return state */
    545          
    546            /* USER CODE END Error_Handler_Debug */
    547          }
   \                     Error_Handler: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \        0x0   0xE000'E400        DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0xE000'ED1C        DC32     0xe000ed1c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_1:
   \        0x0   0xE000'E014        DC32     0xe000e014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_2:
   \        0x0   0xE000'E018        DC32     0xe000e018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_3:
   \        0x0   0xE000'E010        DC32     0xe000e010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_4:
   \        0x0   0x4002'1000        DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_5:
   \        0x0   0x4002'1008        DC32     0x40021008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_6:
   \        0x0   0xFFFF'F0FF        DC32     0xfffff0ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_7:
   \        0x0   0xFFFF'8FFF        DC32     0xffff8fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_8:
   \        0x0   0x4002'1054        DC32     0x40021054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_9:
   \        0x0   0x4002'100C        DC32     0x4002100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_10:
   \        0x0   0x1FFF'808C        DC32     0x1fff808c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_11:
   \        0x0   0x4002'1038        DC32     0x40021038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_12:
   \        0x0   0x4002'103C        DC32     0x4002103c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_13:
   \        0x0   0x4002'1040        DC32     0x40021040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_14:
   \        0x0   0x4002'2000        DC32     0x40022000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_15:
   \        0x0   0x....'....        DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_16:
   \        0x0   0x03D0'9000        DC32     0x3d09000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_17:
   \        0x0   0x4002'3000        DC32     0x40023000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_18:
   \        0x0   0x0000'1021        DC32     0x1021

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24_19:
   \        0x0   0x0000'FFFF        DC32     0xffff
    548          
    549          #ifdef  USE_FULL_ASSERT
    550          /**
    551            * @brief  Reports the name of the source file and the source line number
    552            *         where the assert_param error has occurred.
    553            * @param  file: pointer to the source file name
    554            * @param  line: assert_param error line source number
    555            * @retval None
    556            */
    557          void assert_failed(uint8_t *file, uint32_t line)
    558          { 
    559            /* USER CODE BEGIN 6 */
    560            /* User can add his own implementation to report the file name and line number,
    561               tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
    562            /* USER CODE END 6 */
    563          }
    564          #endif /* USE_FULL_ASSERT */
    565          
    566          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   Error_Handler
       4   LL_AHB1_GRP1_EnableClock
       4   LL_APB1_GRP1_EnableClock
       4   LL_APB2_GRP1_EnableClock
       0   LL_CRC_SetInitialData
       0   LL_CRC_SetInputDataReverseMode
       0   LL_CRC_SetOutputDataReverseMode
       0   LL_CRC_SetPolynomialCoef
       0   LL_CRC_SetPolynomialSize
       0   LL_FLASH_GetLatency
       0   LL_FLASH_SetLatency
       0   LL_RCC_GetSysClkSource
       0   LL_RCC_HSI_Enable
       0   LL_RCC_HSI_IsReady
      12   LL_RCC_PLL_ConfigDomain_SYS
       0   LL_RCC_PLL_Enable
       0   LL_RCC_PLL_EnableDomain_SYS
       0   LL_RCC_PLL_IsReady
       0   LL_RCC_SetADCClockSource
       0   LL_RCC_SetAHBPrescaler
       0   LL_RCC_SetAPB1Prescaler
       0   LL_RCC_SetSysClkSource
       0   LL_RCC_SetUSARTClockSource
       0   LL_SYSTICK_EnableIT
       8   MX_CRC_Init
         8   -> LL_AHB1_GRP1_EnableClock
         8   -> LL_CRC_SetInitialData
         8   -> LL_CRC_SetInputDataReverseMode
         8   -> LL_CRC_SetOutputDataReverseMode
         8   -> LL_CRC_SetPolynomialCoef
         8   -> LL_CRC_SetPolynomialSize
       8   MX_DMA_Init
         8   -> __NVIC_EnableIRQ
         8   -> __NVIC_SetPriority
       8   SysTick_Config
         8   -> __NVIC_SetPriority
       8   SystemClock_Config
         8   -> Error_Handler
         8   -> LL_FLASH_GetLatency
         8   -> LL_FLASH_SetLatency
         8   -> LL_Init1msTick
         8   -> LL_RCC_GetSysClkSource
         8   -> LL_RCC_HSI_Enable
         8   -> LL_RCC_HSI_IsReady
         8   -> LL_RCC_PLL_ConfigDomain_SYS
         8   -> LL_RCC_PLL_Enable
         8   -> LL_RCC_PLL_EnableDomain_SYS
         8   -> LL_RCC_PLL_IsReady
         8   -> LL_RCC_SetADCClockSource
         8   -> LL_RCC_SetAHBPrescaler
         8   -> LL_RCC_SetAPB1Prescaler
         8   -> LL_RCC_SetSysClkSource
         8   -> LL_RCC_SetUSARTClockSource
         8   -> LL_SetSystemCoreClock
       4   __NVIC_EnableIRQ
      20   __NVIC_SetPriority
       8   main
         8   -> HAL_Init
         8   -> LL_APB1_GRP1_EnableClock
         8   -> LL_APB2_GRP1_EnableClock
         8   -> LL_SYSTICK_EnableIT
         8   -> MX_CRC_Init
         8   -> MX_DMA_Init
         8   -> Sched_Initialize
         8   -> Sched_Run
         8   -> SysTick_Config
         8   -> SystemClock_Config
         8 __aeabi_uidiv


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_10
       4  ??DataTable24_11
       4  ??DataTable24_12
       4  ??DataTable24_13
       4  ??DataTable24_14
       4  ??DataTable24_15
       4  ??DataTable24_16
       4  ??DataTable24_17
       4  ??DataTable24_18
       4  ??DataTable24_19
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable24_6
       4  ??DataTable24_7
       4  ??DataTable24_8
       4  ??DataTable24_9
       2  Error_Handler
      22  LL_AHB1_GRP1_EnableClock
      22  LL_APB1_GRP1_EnableClock
      22  LL_APB2_GRP1_EnableClock
       4  LL_CRC_SetInitialData
      12  LL_CRC_SetInputDataReverseMode
      12  LL_CRC_SetOutputDataReverseMode
       4  LL_CRC_SetPolynomialCoef
      12  LL_CRC_SetPolynomialSize
      10  LL_FLASH_GetLatency
      14  LL_FLASH_SetLatency
      10  LL_RCC_GetSysClkSource
      14  LL_RCC_HSI_Enable
      14  LL_RCC_HSI_IsReady
      26  LL_RCC_PLL_ConfigDomain_SYS
      14  LL_RCC_PLL_Enable
      14  LL_RCC_PLL_EnableDomain_SYS
      14  LL_RCC_PLL_IsReady
      14  LL_RCC_SetADCClockSource
      14  LL_RCC_SetAHBPrescaler
      14  LL_RCC_SetAPB1Prescaler
      14  LL_RCC_SetSysClkSource
      16  LL_RCC_SetUSARTClockSource
      12  LL_SYSTICK_EnableIT
      54  MX_CRC_Init
      36  MX_DMA_Init
      50  SysTick_Config
     118  SystemClock_Config
      24  __NVIC_EnableIRQ
     140  __NVIC_SetPriority
      68  main

 
 904 bytes in section .text
 
 904 bytes of CODE memory

Errors: none
Warnings: none

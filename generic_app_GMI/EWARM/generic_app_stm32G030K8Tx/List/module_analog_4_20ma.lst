###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         04/Feb/2022  12:58:42
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Features\module_analog_4_20ma.c
#    Command line                 =
#        -f C:\Users\610126~1\AppData\Local\Temp\EWCE7B.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Features\module_analog_4_20ma.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale                       =  C
#    List file                    =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\module_analog_4_20ma.lst
#    Object file                  =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\module_analog_4_20ma.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Features\module_analog_4_20ma.c
      1          /**
      2          *************************************************************************************
      3          * @file    module_analog_4_20ma.c 
      4          * @author  Regal, Satya Akkina
      5          * @version V1.0
      6          * @date    04-Dec-2020
      7          * @brief   module for Analog 4-20mA input
      8          * @note    Provide structures to access Analog setting and Analog volts, demand
      9          *************************************************************************************
     10          */
     11          
     12          // Includes -------------------------------------------------------------------
     13          #include "module_analog_4_20ma.h"
     14          
     15          //#include <stdio.h>
     16          #include <math.h>
     17          #include "macros.h"
     18          
     19          // Content --------------------------------------------------------------------
     20          // Function Prototypes
     21          void AssignModuleMemAnalog_4_20mA(void);
     22          void Init_Analog_4_20mA_Setting(void);
     23          void InitAnalogAmpsInputParameters(void);
     24          void DebounceAnalogAmps(void);
     25          uint16_t GetAnalogAmpsDemand(void);
     26          
     27          // Constants ------------------------------------------------------------------
     28          // Module States
     29          enum {
     30            MEMORY_INIT_MODULE,
     31            INIT_MODULE,
     32            RUN_MODULE,
     33            // Ddditional states to be added here as necessary.
     34            IRQ_MODULE = DEFAULT_IRQ_STATE,
     35            KILL_MODULE = KILL_APP
     36          };
     37          
     38          enum {
     39            DISABLE_INPUT = 0,
     40            ANALOG_MODE = 1,
     41            DIGITAL_MODE = 2
     42          };
     43          
     44          // External Variables ---------------------------------------------------------
     45          extern Ram_Buf sharedMemArray[TOTAL_NUM_OF_STRUCT_MEM_INSTANCES];
     46          extern ProcessInfo processInfoTable[];

   \                                 In section .bss, align 4
     47          static  Ram_Buf_Handle analog_4_20ma_StructMem_u32;
   \                     analog_4_20ma_StructMem_u32:
   \        0x0                      DS8 4
     48          
     49          // Global variables specific to this module ---------------------------------

   \                                 In section .bss, align 8
     50          uint64_t module_analog_4_20ma_poll_time_u64; // Delay time between init and run module
   \                     module_analog_4_20ma_poll_time_u64:
   \        0x0                      DS8 8

   \                                 In section .bss, align 1
     51          uint8_t analog_amps_increasing_debounce_count_u16 = 0; // Count to check if analog volts is above debounce value
   \                     analog_amps_increasing_debounce_count_u16:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
     52          uint8_t analog_amps_decreasing_debounce_count_u16 = 0; // Count to check if analog volts is below debounce value
   \                     analog_amps_decreasing_debounce_count_u16:
   \        0x0                      DS8 1

   \                                 In section .bss, align 2
     53          uint16_t analog_amps_counts_u16 = 0;         // Temporary storage for ADC value
   \                     analog_amps_counts_u16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 1
     54          uint8_t analog_amps_low_alarm_enable_count_u16 = 0;    // Time when analog module init is complete
   \                     analog_amps_low_alarm_enable_count_u16:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
     55          uint8_t is_amps_above_loss_analog = FALSE;   // Time when analog module init is complete
   \                     is_amps_above_loss_analog:
   \        0x0                      DS8 1
     56          
     57          // Define Pointers that will be used as References to other Modules, where applicable

   \                                 In section .bss, align 4
     58          ADC1_Control*  adc1_LocalAnalogAmpsControl_ptr;
   \                     adc1_LocalAnalogAmpsControl_ptr:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     59          Analog_4_20ma_Control analog_4_20ma_Control_ptr;
   \                     analog_4_20ma_Control_ptr:
   \        0x0                      DS8 84
     60          
     61          /**
     62          ********************************************************************************************************************************
     63          * @brief   State machine for Analog 4-20mA module
     64          * @details
     65          * @param   drv_identifier_u8, previous_state_u8, next_stat_u8, irq_identfier_u8
     66          * @retval  return_state_u8
     67          ********************************************************************************************************************************
     68          */

   \                                 In section .text, align 2, keep-with-next
     69          uint8_t moduleAnalog_4_20mA(uint8_t drv_identifier_u8, uint8_t previous_state_u8, uint8_t next_state_u8,
     70                                      uint8_t irq_identifier_u8)
     71          {
   \                     moduleAnalog_4_20mA: (+1)
   \        0x0   0xB5FF             PUSH     {R0-R7,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
     72            uint8_t return_state_u8 = MEMORY_INIT_MODULE;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x4669             MOV      R1,SP
   \        0x8   0x7208             STRB     R0,[R1, #+8]
     73            switch (next_state_u8)
   \        0xA   0xA809             ADD      R0,SP,#+36
   \        0xC   0x7800             LDRB     R0,[R0, #+0]
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD00A             BEQ      ??moduleAnalog_4_20mA_0
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD00C             BEQ      ??moduleAnalog_4_20mA_1
   \       0x16   0x2802             CMP      R0,#+2
   \       0x18   0xD02D             BEQ      ??moduleAnalog_4_20mA_2
   \       0x1A   0x28C8             CMP      R0,#+200
   \       0x1C   0xD100             BNE      .+4
   \       0x1E   0xE0C2             B        ??moduleAnalog_4_20mA_3
   \       0x20   0x28FF             CMP      R0,#+255
   \       0x22   0xD100             BNE      .+4
   \       0x24   0xE0C1             B        ??moduleAnalog_4_20mA_4
   \       0x26   0xE0D3             B        ??moduleAnalog_4_20mA_5
     74            {
     75            case MEMORY_INIT_MODULE:
     76              {
     77                AssignModuleMemAnalog_4_20mA(); // Assign structured memory to Analog 0-10V setting and data 
   \                     ??moduleAnalog_4_20mA_0: (+1)
   \       0x28   0x....'....        BL       AssignModuleMemAnalog_4_20mA
     78                return_state_u8 = INIT_MODULE;
   \       0x2C   0x2001             MOVS     R0,#+1
     79                break;
   \       0x2E   0xE0D0             B        ??moduleAnalog_4_20mA_6
     80              }
     81            case INIT_MODULE:
     82              {     
     83                //AssignModuleMemAnalog_4_20mA(); // Assign structured memory to Analog 4-20mA setting and data      
     84                Init_Analog_4_20mA_Setting(); // Initilize analog 4-20mA settings      
   \                     ??moduleAnalog_4_20mA_1: (+1)
   \       0x30   0x....'....        BL       Init_Analog_4_20mA_Setting
     85                InitAnalogAmpsInputParameters(); // Init local parameters and metering data
   \       0x34   0x....'....        BL       InitAnalogAmpsInputParameters
     86                
     87                // Get structured memory for ADC1 data
     88                uint8_t module_ADC1_Index = getProcessInfoIndex(MODULE_ADC1);
   \       0x38   0x2004             MOVS     R0,#+4
   \       0x3A   0x....'....        BL       getProcessInfoIndex
   \       0x3E   0x0004             MOVS     R4,R0
     89                adc1_LocalAnalogAmpsControl_ptr = (ADC1_Control*)((*(processInfoTable[module_ADC1_Index].Sched_DrvData.p_masterSharedMem_u32)).p_ramBuf_u8);
   \       0x40   0x....             LDR      R0,??DataTable2
   \       0x42   0x0021             MOVS     R1,R4
   \       0x44   0xB2C9             UXTB     R1,R1
   \       0x46   0x2216             MOVS     R2,#+22
   \       0x48   0x4351             MULS     R1,R2,R1
   \       0x4A   0x1840             ADDS     R0,R0,R1
   \       0x4C   0x300B             ADDS     R0,R0,#+11
   \       0x4E   0x....'....        BL       __aeabi_uread4
   \       0x52   0x6800             LDR      R0,[R0, #+0]
   \       0x54   0x....             LDR      R1,??DataTable2_1
   \       0x56   0x6008             STR      R0,[R1, #+0]
     90                
     91                analog_amps_low_alarm_enable_count_u16 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.analogLowAlarmEnableCount_u16; // delay before analog low voltage alarm can be triggered
   \       0x58   0x....             LDR      R5,??DataTable3
   \       0x5A   0x8D28             LDRH     R0,[R5, #+40]
   \       0x5C   0x....             LDR      R1,??DataTable3_1
   \       0x5E   0x7008             STRB     R0,[R1, #+0]
     92                module_analog_4_20ma_poll_time_u64 = getSysCount() + analog_4_20ma_Control_ptr.analog_4_20mA_Setting.analogPeriod_u16; //AnalogPeriod;    // Store time tick value
   \       0x60   0x....'....        BL       getSysCount
   \       0x64   0x8C6A             LDRH     R2,[R5, #+34]
   \       0x66   0x2300             MOVS     R3,#+0
   \       0x68   0x1812             ADDS     R2,R2,R0
   \       0x6A   0x414B             ADCS     R3,R3,R1
   \       0x6C   0x....             LDR      R0,??DataTable2_2
   \       0x6E   0xC00C             STM      R0!,{R2,R3}
   \       0x70   0x3808             SUBS     R0,R0,#+8
     93                
     94                return_state_u8 = RUN_MODULE;
   \       0x72   0x2002             MOVS     R0,#+2
     95                break;
   \       0x74   0xE0AD             B        ??moduleAnalog_4_20mA_6
     96                
     97              }   
     98            case RUN_MODULE:                                                             
     99              {      
    100                // Process analog input every "analogPeriod_u16" mSec
    101                if (getSysCount() >= module_analog_4_20ma_poll_time_u64) 
   \                     ??moduleAnalog_4_20mA_2: (+1)
   \       0x76   0x....'....        BL       getSysCount
   \       0x7A   0x....             LDR      R5,??DataTable2_2
   \       0x7C   0xCD0C             LDM      R5!,{R2,R3}
   \       0x7E   0x3D08             SUBS     R5,R5,#+8
   \       0x80   0x4299             CMP      R1,R3
   \       0x82   0xD200             BCS      .+4
   \       0x84   0xE08D             B        ??moduleAnalog_4_20mA_7
   \       0x86   0xD802             BHI      ??moduleAnalog_4_20mA_8
   \       0x88   0x4290             CMP      R0,R2
   \       0x8A   0xD200             BCS      .+4
   \       0x8C   0xE089             B        ??moduleAnalog_4_20mA_7
    102                {
    103                  module_analog_4_20ma_poll_time_u64 = getSysCount() + analog_4_20ma_Control_ptr.analog_4_20mA_Setting.analogPeriod_u16; //AnalogPeriod;   // Update time tick value
   \                     ??moduleAnalog_4_20mA_8: (+1)
   \       0x8E   0x....'....        BL       getSysCount
   \       0x92   0x0002             MOVS     R2,R0
   \       0x94   0x000B             MOVS     R3,R1
   \       0x96   0x....             LDR      R4,??DataTable3
   \       0x98   0x8C60             LDRH     R0,[R4, #+34]
   \       0x9A   0x2100             MOVS     R1,#+0
   \       0x9C   0x1880             ADDS     R0,R0,R2
   \       0x9E   0x4159             ADCS     R1,R1,R3
   \       0xA0   0xC503             STM      R5!,{R0,R1}
   \       0xA2   0x3D08             SUBS     R5,R5,#+8
    104                  if(analog_amps_low_alarm_enable_count_u16 > 0){
   \       0xA4   0x....             LDR      R0,??DataTable3_1
   \       0xA6   0x7801             LDRB     R1,[R0, #+0]
   \       0xA8   0x2900             CMP      R1,#+0
   \       0xAA   0xD002             BEQ      ??moduleAnalog_4_20mA_9
    105                    analog_amps_low_alarm_enable_count_u16--;
   \       0xAC   0x7801             LDRB     R1,[R0, #+0]
   \       0xAE   0x1E49             SUBS     R1,R1,#+1
   \       0xB0   0x7001             STRB     R1,[R0, #+0]
    106                  }      
    107                  // Convert ADC1 value into 100.00%. analogVoltsPercent_u16 value is stored in xxxyy format = xxx.yy% 
    108                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsPercent_u16 = DECIMAL_RIGHT_SHIFT_U16(CALCULATE_PERCENT((*adc1_LocalAnalogAmpsControl_ptr).adc1_ResultAvg.adc1_4_20mA_Avg_u16, ADC_12_BIT_FULL_SCALE),2);
   \                     ??moduleAnalog_4_20mA_9: (+1)
   \       0xB2   0x....             LDR      R5,??DataTable2_1
   \       0xB4   0x6828             LDR      R0,[R5, #+0]
   \       0xB6   0x8901             LDRH     R1,[R0, #+8]
   \       0xB8   0x2064             MOVS     R0,#+100
   \       0xBA   0x4348             MULS     R0,R1,R0
   \       0xBC   0x....'....        BL       __aeabi_i2f
   \       0xC0   0x218B             MOVS     R1,#+139
   \       0xC2   0x05C9             LSLS     R1,R1,#+23       ;; #+1166016512
   \       0xC4   0x....'....        BL       __aeabi_fdiv
   \       0xC8   0x2600             MOVS     R6,#+0
   \       0xCA   0x....             LDR      R7,??DataTable2_3  ;; 0x40240000
   \       0xCC   0xA904             ADD      R1,SP,#+16
   \       0xCE   0xC1C0             STM      R1!,{R6,R7}
   \       0xD0   0x3908             SUBS     R1,R1,#+8
   \       0xD2   0x....'....        BL       __aeabi_f2d
   \       0xD6   0x9000             STR      R0,[SP, #+0]
   \       0xD8   0x9101             STR      R1,[SP, #+4]
   \       0xDA   0xA804             ADD      R0,SP,#+16
   \       0xDC   0xC80C             LDM      R0!,{R2,R3}
   \       0xDE   0x3808             SUBS     R0,R0,#+8
   \       0xE0   0xA804             ADD      R0,SP,#+16
   \       0xE2   0xC803             LDM      R0,{R0,R1}
   \       0xE4   0x....'....        BL       __aeabi_dmul
   \       0xE8   0x9A00             LDR      R2,[SP, #+0]
   \       0xEA   0x9B01             LDR      R3,[SP, #+4]
   \       0xEC   0x....'....        BL       __aeabi_dmul
   \       0xF0   0x....'....        BL       __aeabi_d2iz
   \       0xF4   0x214A             MOVS     R1,#+74
   \       0xF6   0x5260             STRH     R0,[R4, R1]
    109                  analog_amps_counts_u16 = (*adc1_LocalAnalogAmpsControl_ptr).adc1_ResultAvg.adc1_4_20mA_Avg_u16; // Get result from ADC module into analog 4-20mA module
   \       0xF8   0x6828             LDR      R0,[R5, #+0]
   \       0xFA   0x8900             LDRH     R0,[R0, #+8]
   \       0xFC   0x....             LDR      R1,??DataTable3_2
   \       0xFE   0x8008             STRH     R0,[R1, #+0]
    110                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogErrorCode_u16 = (uint16_t) ((*adc1_LocalAnalogAmpsControl_ptr).adc1_ResultAvg.errorCode_u8); // Get any error codes
   \      0x100   0x6828             LDR      R0,[R5, #+0]
   \      0x102   0x7B00             LDRB     R0,[R0, #+12]
   \      0x104   0x214E             MOVS     R1,#+78
   \      0x106   0x5260             STRH     R0,[R4, R1]
    111                  DebounceAnalogAmps(); // Process the analog voltage
   \      0x108   0x....'....        BL       DebounceAnalogAmps
    112                  //analog_4_20ma_Control_ptr.analog_4_20mA_Data analogVoltsToAmpsGain_f
    113                  
    114                  // Check if analog is low. If enabled and analog is low, demand is "0"
    115                  if (((analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_analogLow == TRUE) && (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_analogLowEnable == TRUE) && (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_analogFailSafeEnable == FALSE))
    116                    ||(analog_4_20ma_Control_ptr.analog_4_20mA_Setting.inputMode_u16!=ANALOG_MODE))
   \      0x10C   0x2050             MOVS     R0,#+80
   \      0x10E   0x5C20             LDRB     R0,[R4, R0]
   \      0x110   0x0001             MOVS     R1,R0
   \      0x112   0x07C9             LSLS     R1,R1,#+31       ;; ZeroExtS R1,R1,#+31,#+31
   \      0x114   0x0FC9             LSRS     R1,R1,#+31
   \      0x116   0x2900             CMP      R1,#+0
   \      0x118   0xD005             BEQ      ??moduleAnalog_4_20mA_10
   \      0x11A   0x202E             MOVS     R0,#+46
   \      0x11C   0x5C20             LDRB     R0,[R4, R0]
   \      0x11E   0x210C             MOVS     R1,#+12
   \      0x120   0x4001             ANDS     R1,R1,R0
   \      0x122   0x2904             CMP      R1,#+4
   \      0x124   0xD002             BEQ      ??moduleAnalog_4_20mA_11
   \                     ??moduleAnalog_4_20mA_10: (+1)
   \      0x126   0x8DA0             LDRH     R0,[R4, #+44]
   \      0x128   0x2801             CMP      R0,#+1
   \      0x12A   0xD017             BEQ      ??moduleAnalog_4_20mA_12
    117                  {
    118                    analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogDemand_u16 = 0;
   \                     ??moduleAnalog_4_20mA_11: (+1)
   \      0x12C   0x2000             MOVS     R0,#+0
   \      0x12E   0x0001             MOVS     R1,R0
   \      0x130   0x2248             MOVS     R2,#+72
   \      0x132   0x52A1             STRH     R1,[R4, R2]
    119                    analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogDemandPercent_u16 = 0;
   \      0x134   0x214C             MOVS     R1,#+76
   \      0x136   0x5260             STRH     R0,[R4, R1]
    120                    analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_demandOn = FALSE;
   \      0x138   0x0020             MOVS     R0,R4
   \      0x13A   0x3050             ADDS     R0,R0,#+80
   \      0x13C   0x2150             MOVS     R1,#+80
   \      0x13E   0x5A61             LDRH     R1,[R4, R1]
   \      0x140   0x....             LDR      R2,??DataTable3_3  ;; 0xffef
   \      0x142   0x400A             ANDS     R2,R2,R1
   \      0x144   0x8002             STRH     R2,[R0, #+0]
    121                    analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_lowerHysteresisEnable = FALSE;
   \      0x146   0x2150             MOVS     R1,#+80
   \      0x148   0x5A61             LDRH     R1,[R4, R1]
   \      0x14A   0x....             LDR      R2,??DataTable3_4  ;; 0xfffb
   \      0x14C   0x400A             ANDS     R2,R2,R1
   \      0x14E   0x8002             STRH     R2,[R0, #+0]
    122                    analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_upperHysteresisEnable = FALSE;
   \      0x150   0x2150             MOVS     R1,#+80
   \      0x152   0x5A61             LDRH     R1,[R4, R1]
   \      0x154   0x....             LDR      R2,??DataTable3_5  ;; 0xfff7
   \      0x156   0x400A             ANDS     R2,R2,R1
   \      0x158   0x8002             STRH     R2,[R0, #+0]
   \      0x15A   0xE022             B        ??moduleAnalog_4_20mA_7
    123                  } else { // Analog low is not detected or analog low is not enabled
    124                    
    125                    analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogDemand_u16 = GetAnalogAmpsDemand(); // Convert analog voltage into demand 0 - 0xFFFF
   \                     ??moduleAnalog_4_20mA_12: (+1)
   \      0x15C   0x....'....        BL       GetAnalogAmpsDemand
   \      0x160   0x2148             MOVS     R1,#+72
   \      0x162   0x5260             STRH     R0,[R4, R1]
    126                    
    127                    // Convert demand value into 0 to 100.00%. Value is stored in xxxyy format = xxx.yy% 
    128                    analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogDemandPercent_u16 = DECIMAL_RIGHT_SHIFT_U16(CALCULATE_PERCENT(analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogDemand_u16, 65536),2);
   \      0x164   0x2048             MOVS     R0,#+72
   \      0x166   0x5A21             LDRH     R1,[R4, R0]
   \      0x168   0x2064             MOVS     R0,#+100
   \      0x16A   0x4348             MULS     R0,R1,R0
   \      0x16C   0x....'....        BL       __aeabi_i2f
   \      0x170   0x218F             MOVS     R1,#+143
   \      0x172   0x05C9             LSLS     R1,R1,#+23       ;; #+1199570944
   \      0x174   0x....'....        BL       __aeabi_fdiv
   \      0x178   0x4669             MOV      R1,SP
   \      0x17A   0xC1C0             STM      R1!,{R6,R7}
   \      0x17C   0x3908             SUBS     R1,R1,#+8
   \      0x17E   0x....'....        BL       __aeabi_f2d
   \      0x182   0x0006             MOVS     R6,R0
   \      0x184   0x000F             MOVS     R7,R1
   \      0x186   0x4668             MOV      R0,SP
   \      0x188   0xC803             LDM      R0,{R0,R1}
   \      0x18A   0x466A             MOV      R2,SP
   \      0x18C   0xCA0C             LDM      R2,{R2,R3}
   \      0x18E   0x....'....        BL       __aeabi_dmul
   \      0x192   0x0032             MOVS     R2,R6
   \      0x194   0x003B             MOVS     R3,R7
   \      0x196   0x....'....        BL       __aeabi_dmul
   \      0x19A   0x....'....        BL       __aeabi_d2iz
   \      0x19E   0x214C             MOVS     R1,#+76
   \      0x1A0   0x5260             STRH     R0,[R4, R1]
    129                  }
    130                }     
    131                return_state_u8 = RUN_MODULE;
   \                     ??moduleAnalog_4_20mA_7: (+1)
   \      0x1A2   0x2002             MOVS     R0,#+2
    132                break;
   \      0x1A4   0xE015             B        ??moduleAnalog_4_20mA_6
    133              }
    134            case IRQ_MODULE: 
    135              {
    136                // If there are more than one interrupts, from different drivers, you can identify each individually by:
    137                // tableIndex_u8 = getProcessInfoIndex(irq_identifier_u8);
    138                // Then use processInfoTable[tableIndex_u8] to tailor your response appropriately.
    139                return_state_u8 = RUN_MODULE;
   \                     ??moduleAnalog_4_20mA_3: (+1)
   \      0x1A6   0x2002             MOVS     R0,#+2
    140                break;
   \      0x1A8   0xE013             B        ??moduleAnalog_4_20mA_6
    141              }
    142              
    143            case KILL_MODULE: 
    144              {
    145                // Setting processStatus_u8 to PROCESS_STATUS_KILLED prevents the scheduler main loop from calling this module again.
    146                uint8_t table_index_u8 = getProcessInfoIndex(drv_identifier_u8);
   \                     ??moduleAnalog_4_20mA_4: (+1)
   \      0x1AA   0x4668             MOV      R0,SP
   \      0x1AC   0x7F00             LDRB     R0,[R0, #+28]
   \      0x1AE   0x....'....        BL       getProcessInfoIndex
   \      0x1B2   0x0001             MOVS     R1,R0
    147                if (table_index_u8 != INDEX_NOT_FOUND) {
   \      0x1B4   0x0008             MOVS     R0,R1
   \      0x1B6   0xB2C0             UXTB     R0,R0
   \      0x1B8   0x28FF             CMP      R0,#+255
   \      0x1BA   0xD007             BEQ      ??moduleAnalog_4_20mA_13
    148                  processInfoTable[table_index_u8].Sched_DrvData.processStatus_u8 = PROCESS_STATUS_KILLED;
   \      0x1BC   0x20FF             MOVS     R0,#+255
   \      0x1BE   0x....             LDR      R2,??DataTable2
   \      0x1C0   0x000B             MOVS     R3,R1
   \      0x1C2   0xB2DB             UXTB     R3,R3
   \      0x1C4   0x2416             MOVS     R4,#+22
   \      0x1C6   0x4363             MULS     R3,R4,R3
   \      0x1C8   0x18D2             ADDS     R2,R2,R3
   \      0x1CA   0x7290             STRB     R0,[R2, #+10]
    149                }
    150                return_state_u8 = INIT_MODULE;
   \                     ??moduleAnalog_4_20mA_13: (+1)
   \      0x1CC   0x2001             MOVS     R0,#+1
    151                break;
   \      0x1CE   0xE000             B        ??moduleAnalog_4_20mA_6
    152              }
    153            default:
    154              {
    155                return_state_u8 = KILL_MODULE; //10; 
   \                     ??moduleAnalog_4_20mA_5: (+1)
   \      0x1D0   0x20FF             MOVS     R0,#+255
    156                break;
    157              }
    158            }
    159            return return_state_u8;
   \                     ??moduleAnalog_4_20mA_6: (+1)
   \      0x1D2   0xB2C0             UXTB     R0,R0
   \      0x1D4   0xB00B             ADD      SP,SP,#+44
   \      0x1D6   0xBDF0             POP      {R4-R7,PC}       ;; return
    160          } 
    161          
    162          /**
    163          ********************************************************************************************************************************
    164          * @brief   Assign structured memory
    165          * @details Assign structured memory for Analog 0-10V control
    166          * @retval  None
    167          ********************************************************************************************************************************
    168          */

   \                                 In section .text, align 2, keep-with-next
    169          void AssignModuleMemAnalog_4_20mA(void){   
   \                     AssignModuleMemAnalog_4_20mA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    170            analog_4_20ma_StructMem_u32 =  StructMem_CreateInstance(MODULE_ANALOG_4_20MA, sizeof(Analog_4_20ma_Control), ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);
   \        0x2   0x....             LDR      R4,??DataTable3_6
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x2202             MOVS     R2,#+2
   \        0xC   0x2154             MOVS     R1,#+84
   \        0xE   0x2006             MOVS     R0,#+6
   \       0x10   0x....'....        BL       StructMem_CreateInstance
   \       0x14   0x6020             STR      R0,[R4, #+0]
    171            (*analog_4_20ma_StructMem_u32).p_ramBuf_u8 = (uint8_t *)&analog_4_20ma_Control_ptr ;    // Map the ADC1 memory into the structured memory
   \       0x16   0x....             LDR      R0,??DataTable3
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6008             STR      R0,[R1, #+0]
    172            uint8_t Module_Analog_4_20mA_Index = getProcessInfoIndex(MODULE_ANALOG_4_20MA);
   \       0x1C   0x2006             MOVS     R0,#+6
   \       0x1E   0x....'....        BL       getProcessInfoIndex
   \       0x22   0x0005             MOVS     R5,R0
    173            processInfoTable[Module_Analog_4_20mA_Index].Sched_ModuleData.p_masterSharedMem_u32 = (Ram_Buf_Handle)analog_4_20ma_StructMem_u32;
   \       0x24   0x....             LDR      R0,??DataTable2
   \       0x26   0x0029             MOVS     R1,R5
   \       0x28   0xB2C9             UXTB     R1,R1
   \       0x2A   0x2216             MOVS     R2,#+22
   \       0x2C   0x4351             MULS     R1,R2,R1
   \       0x2E   0x1840             ADDS     R0,R0,R1
   \       0x30   0x0001             MOVS     R1,R0
   \       0x32   0x310B             ADDS     R1,R1,#+11
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x....'....        BL       __aeabi_uwrite4
    174          }
   \       0x3A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    175          
    176          /**
    177          ********************************************************************************************************************************
    178          * @brief   Initilize all analog settings and live data
    179          * @details Read settings from the RAM and initilize the settings
    180          * @param   None
    181          * @retval  None
    182          ********************************************************************************************************************************
    183          */

   \                                 In section .text, align 2, keep-with-next
    184          void Init_Analog_4_20mA_Setting(void){  
   \                     Init_Analog_4_20mA_Setting: (+1)
   \        0x0   0xB430             PUSH     {R4,R5}
    185            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.onVolts_u16 = 621;//205;             // Demand turn ON volts in counts of ADC
   \        0x2   0x....             LDR      R0,??DataTable3
   \        0x4   0x....             LDR      R1,??DataTable3_7  ;; 0x26d
   \        0x6   0x8101             STRH     R1,[R0, #+8]
    186            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.offVolts_u16 = 310;//164;            // Demand turn OFF volts in counts of ADC. Acts as Hysteresis
   \        0x8   0x219B             MOVS     R1,#+155
   \        0xA   0x0049             LSLS     R1,R1,#+1        ;; #+310
   \        0xC   0x8141             STRH     R1,[R0, #+10]
    187            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minVolts_u16 = 931;//500;            // Min volts correspodning to min demand
   \        0xE   0x....             LDR      R1,??DataTable3_8  ;; 0x3a3
   \       0x10   0x8181             STRH     R1,[R0, #+12]
    188            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxVolts_u16 = 2793;//3800;           // Max volts corresponding to max demand  
   \       0x12   0x....             LDR      R1,??DataTable3_9  ;; 0xae9
   \       0x14   0x81C1             STRH     R1,[R0, #+14]
    189            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxAdcCounts_u16 = 4095;       // Max output of ADC. 12 bit ADC left sifted by 4
   \       0x16   0x....             LDR      R1,??DataTable3_10  ;; 0xfff
   \       0x18   0x8201             STRH     R1,[R0, #+16]
    190            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.debounceThresholdCounts_u16 = 10;//41;    // Change demand if the change in analog is outside this threshold. In ADC counts
   \       0x1A   0x220A             MOVS     R2,#+10
   \       0x1C   0x0011             MOVS     R1,R2
   \       0x1E   0x8241             STRH     R1,[R0, #+18]
    191            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.calibratonFactor_s16 = 0;      // Add/Delete this form measured for calibration. In ADC counts
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x8281             STRH     R1,[R0, #+20]
    192            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.voltsHysteresis_u16 = 10;//41 ;     // Hys volts at the top end of demand. In ADC counts
   \       0x24   0x82C2             STRH     R2,[R0, #+22]
    193            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16 = 21845;//13107;         // Min allowed demand. 20%
   \       0x26   0x....             LDR      R2,??DataTable3_11  ;; 0x5555
   \       0x28   0x8302             STRH     R2,[R0, #+24]
    194            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxDemand_u16 = 0xFFFF;        // Maximum allowed demand
   \       0x2A   0x....             LDR      R2,??DataTable3_12  ;; 0xffff
   \       0x2C   0x8342             STRH     R2,[R0, #+26]
    195            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemandHysteresis_u16 = 21;//500; // Lower end hysteresis if Min_Demand > Off_Volts demand. Counts 
   \       0x2E   0x2215             MOVS     R2,#+21
   \       0x30   0x8382             STRH     R2,[R0, #+28]
    196            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.analogLowVolts_u16 = 125;//820;     // Volts below which the bAnalog_Loss_Enable is set. In ADC counts
   \       0x32   0x227D             MOVS     R2,#+125
   \       0x34   0x83C2             STRH     R2,[R0, #+30]
    197            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.failSafeDemand_u16  = 0x7FFF;  // If set to "1" use Fail safe demand when low analog input is detected //50%
   \       0x36   0x....             LDR      R2,??DataTable3_13  ;; 0x7fff
   \       0x38   0x8402             STRH     R2,[R0, #+32]
    198            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.analogPeriod_u16 = 50;               // Update rate in mSec for the analog voltage
   \       0x3A   0x2232             MOVS     R2,#+50
   \       0x3C   0x8442             STRH     R2,[R0, #+34]
    199            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.analogLowAlarmEnableCount_u16 = 0;//100;  // analogPeriod*count delay before analog low volts alarm is detected in mSec. 
   \       0x3E   0x8501             STRH     R1,[R0, #+40]
    200            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.debounceLoopCount_u16 = 4;            // Debounce count
   \       0x40   0x2104             MOVS     R1,#+4
   \       0x42   0x000A             MOVS     R2,R1
   \       0x44   0x8542             STRH     R2,[R0, #+42]
    201            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.analogGain_f = 0.08056640625;            // Convert ADC coutns to volts 3.3/4096*100
   \       0x46   0x....             LDR      R2,??DataTable4  ;; 0x3da50000
   \       0x48   0x6002             STR      R2,[R0, #+0]
    202            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.analogVoltsToAmpsGain_f = 7.976470588;//1.994117647;//6.329114; // Convert analog volts to mAmps 1000*1/158ohms
   \       0x4A   0x....             LDR      R2,??DataTable4_1  ;; 0x40ff3f3f
   \       0x4C   0x6042             STR      R2,[R0, #+4]
    203            
    204            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_enableAnalog = TRUE;          // If set to "0", 0V = Max demand 10V= 0 Demand
   \       0x4E   0x0002             MOVS     R2,R0
   \       0x50   0x322E             ADDS     R2,R2,#+46
   \       0x52   0x2301             MOVS     R3,#+1
   \       0x54   0x8DC4             LDRH     R4,[R0, #+46]
   \       0x56   0x431C             ORRS     R4,R4,R3
   \       0x58   0x8014             STRH     R4,[R2, #+0]
    205            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_invertAnalog = FALSE;         // If set to "0", 0V = Max demand 10V= 0 Demand
   \       0x5A   0x8DC4             LDRH     R4,[R0, #+46]
   \       0x5C   0x....             LDR      R5,??DataTable4_2  ;; 0xfffd
   \       0x5E   0x4025             ANDS     R5,R5,R4
   \       0x60   0x8015             STRH     R5,[R2, #+0]
    206            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_analogLowEnable = TRUE;       // Enable analog low detect if set to "1"
   \       0x62   0x8DC4             LDRH     R4,[R0, #+46]
   \       0x64   0x4321             ORRS     R1,R1,R4
   \       0x66   0x8011             STRH     R1,[R2, #+0]
    207            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_analogFailSafeEnable = FALSE; // If set to "1", switch to fail safe demand when anlaog low is detected  
   \       0x68   0x8DC1             LDRH     R1,[R0, #+46]
   \       0x6A   0x....             LDR      R4,??DataTable3_5  ;; 0xfff7
   \       0x6C   0x400C             ANDS     R4,R4,R1
   \       0x6E   0x8014             STRH     R4,[R2, #+0]
    208            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_analogMinDemandEnable = FALSE;// If "True", min demand is maintaned when volts is below minVolts and above onVolts
   \       0x70   0x8DC1             LDRH     R1,[R0, #+46]
   \       0x72   0x....             LDR      R4,??DataTable3_3  ;; 0xffef
   \       0x74   0x400C             ANDS     R4,R4,R1
   \       0x76   0x8014             STRH     R4,[R2, #+0]
    209            
    210            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.inputMode_u16 = ANALOG_MODE;    // 0 = Analog input; 1 = digital input; 
   \       0x78   0x8583             STRH     R3,[R0, #+44]
    211            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.digitalOnVolts_u16 = 1000;     // On volts above which for digitial input high
   \       0x7A   0x21FA             MOVS     R1,#+250
   \       0x7C   0x0089             LSLS     R1,R1,#+2        ;; #+1000
   \       0x7E   0x8481             STRH     R1,[R0, #+36]
    212            analog_4_20ma_Control_ptr.analog_4_20mA_Setting.digtialOffVolts_u16 = 800;     // Off volts below which digital input is low
   \       0x80   0x21C8             MOVS     R1,#+200
   \       0x82   0x0089             LSLS     R1,R1,#+2        ;; #+800
   \       0x84   0x84C1             STRH     R1,[R0, #+38]
    213            
    214          }
   \       0x86   0xBC30             POP      {R4,R5}
   \       0x88   0x4770             BX       LR               ;; return
    215          

   \                                 In section .text, align 2, keep-with-next
    216          void InitAnalogAmpsInputParameters(void) // Init local parameters and metering data
    217          {
   \                     InitAnalogAmpsInputParameters: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
    218            // Initilize live data                                                     // Flag indicates when the analog module is first initlized
    219            analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCounts_u16 = 0;        // Current Filtered Analog ADC Counts, 
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x....             LDR      R4,??DataTable3
   \        0x6   0x0001             MOVS     R1,R0
   \        0x8   0x2240             MOVS     R2,#+64
   \        0xA   0x52A1             STRH     R1,[R4, R2]
    220            analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogAmps_u16 = 0;              // Current Filtered Analog amps, 0.00V
   \        0xC   0x0001             MOVS     R1,R0
   \        0xE   0x2242             MOVS     R2,#+66
   \       0x10   0x52A1             STRH     R1,[R4, R2]
    221            analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVolts_u16 = 0;             // Current Filtered Analog volts
   \       0x12   0x0001             MOVS     R1,R0
   \       0x14   0x2244             MOVS     R2,#+68
   \       0x16   0x52A1             STRH     R1,[R4, R2]
    222            analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCountsStable_u16 = 0;  // Previous measured analog volts used for debounce check
   \       0x18   0x0001             MOVS     R1,R0
   \       0x1A   0x2246             MOVS     R2,#+70
   \       0x1C   0x52A1             STRH     R1,[R4, R2]
    223            analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogDemand_u16 = 0;             // Calculated analog demand
   \       0x1E   0x0001             MOVS     R1,R0
   \       0x20   0x2248             MOVS     R2,#+72
   \       0x22   0x52A1             STRH     R1,[R4, R2]
    224            analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsPercent_u16 = 0;       // Analog Volts scalled 0 to 100%
   \       0x24   0x0001             MOVS     R1,R0
   \       0x26   0x224A             MOVS     R2,#+74
   \       0x28   0x52A1             STRH     R1,[R4, R2]
    225            analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogDemandPercent_u16 = 0;      // Analog Demand scalled 0 to 100%  
   \       0x2A   0x0001             MOVS     R1,R0
   \       0x2C   0x224C             MOVS     R2,#+76
   \       0x2E   0x52A1             STRH     R1,[R4, R2]
    226            analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingIntercept_f = 0;      // Intercept used to calculate demand when analog is increasing
   \       0x30   0x0025             MOVS     R5,R4
   \       0x32   0x3538             ADDS     R5,R5,#+56
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x6029             STR      R1,[R5, #+0]
    227            analog_4_20ma_Control_ptr.analog_4_20mA_Data.decreasingIntercept_f = 0;      // Intercept used to calcualte demand when analog is decreasing
   \       0x38   0x....             LDR      R6,??DataTable4_3
   \       0x3A   0x6031             STR      R1,[R6, #+0]
    228            
    229            analog_amps_low_alarm_enable_count_u16 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.analogLowAlarmEnableCount_u16;
   \       0x3C   0x8D21             LDRH     R1,[R4, #+40]
   \       0x3E   0x....             LDR      R2,??DataTable3_1
   \       0x40   0x7011             STRB     R1,[R2, #+0]
    230            uint16_t demand_range_u16 = 0;
   \       0x42   0x0007             MOVS     R7,R0
    231            uint16_t analog_range_u16 = 0;
   \       0x44   0x4669             MOV      R1,SP
   \       0x46   0x8088             STRH     R0,[R1, #+4]
    232            
    233          //  demand_range_u16 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxDemand_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16;
    234          //  analog_range_u16 = (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxVolts_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Setting.voltsHysteresis_u16) - (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minVolts_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Setting.voltsHysteresis_u16);                                                                 
    235          //  analog_4_20ma_Control_ptr.analog_4_20mA_Data.decreasingSlope_f = (float)(demand_range_u16 / ((float)analog_range_u16));                                                                                                                                                                                                                           // Slope used to calculate demand when analog is decreasing
    236          //  analog_4_20ma_Control_ptr.analog_4_20mA_Data.decreasingIntercept_f = (float)(analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16 - (float)((analog_4_20ma_Control_ptr.analog_4_20mA_Data.decreasingSlope_f) * (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minVolts_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Setting.voltsHysteresis_u16))); // Intercept used to calcualte demand when analog is decreasing
    237          //  
    238          //  demand_range_u16 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxDemand_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16;
    239          //  analog_range_u16 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxVolts_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minVolts_u16; 
    240          //  analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingSlope_f = (float)(demand_range_u16 / ((float)analog_range_u16));                       // Slope used to calculate demand when analog is increasing
    241          //  analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingIntercept_f = (float)(analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16 - (float)((analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingSlope_f) * (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minVolts_u16))); // Interecept used to calculate demand when analog is increasing
    242            
    243            demand_range_u16 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxDemand_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16;
   \       0x48   0x8B60             LDRH     R0,[R4, #+26]
   \       0x4A   0x8B21             LDRH     R1,[R4, #+24]
   \       0x4C   0x1A40             SUBS     R0,R0,R1
   \       0x4E   0x4669             MOV      R1,SP
   \       0x50   0x80C8             STRH     R0,[R1, #+6]
    244            analog_range_u16 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxVolts_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Setting.voltsHysteresis_u16; 
   \       0x52   0x89E0             LDRH     R0,[R4, #+14]
   \       0x54   0x8AE1             LDRH     R1,[R4, #+22]
   \       0x56   0x1A40             SUBS     R0,R0,R1
   \       0x58   0x4669             MOV      R1,SP
   \       0x5A   0x8088             STRH     R0,[R1, #+4]
    245            analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingSlope_f = (float)(demand_range_u16 / ((float)analog_range_u16)); // Slope used to calculate demand when analog is increasing
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x88C0             LDRH     R0,[R0, #+6]
   \       0x60   0x....'....        BL       __aeabi_ui2f
   \       0x64   0x9000             STR      R0,[SP, #+0]
   \       0x66   0x4668             MOV      R0,SP
   \       0x68   0x8880             LDRH     R0,[R0, #+4]
   \       0x6A   0x....'....        BL       __aeabi_ui2f
   \       0x6E   0x0001             MOVS     R1,R0
   \       0x70   0x9800             LDR      R0,[SP, #+0]
   \       0x72   0x....'....        BL       __aeabi_fdiv
   \       0x76   0x6360             STR      R0,[R4, #+52]
    246            
    247            if(analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_invertAnalog == TRUE)
   \       0x78   0x8DE0             LDRH     R0,[R4, #+46]
   \       0x7A   0xB280             UXTH     R0,R0
   \       0x7C   0x0840             LSRS     R0,R0,#+1
   \       0x7E   0x0001             MOVS     R1,R0
   \       0x80   0x07C9             LSLS     R1,R1,#+31       ;; ZeroExtS R1,R1,#+31,#+31
   \       0x82   0x0FC9             LSRS     R1,R1,#+31
   \       0x84   0x2900             CMP      R1,#+0
   \       0x86   0xD015             BEQ      ??InitAnalogAmpsInputParameters_0
    248            {
    249              analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingSlope_f = analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingSlope_f * -1;
   \       0x88   0x6B61             LDR      R1,[R4, #+52]
   \       0x8A   0x....             LDR      R0,??DataTable4_4  ;; 0xbf800000
   \       0x8C   0x....'....        BL       __aeabi_fmul
   \       0x90   0x6360             STR      R0,[R4, #+52]
    250              analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingIntercept_f = (float)(analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16 - (float)((analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingSlope_f) * (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxVolts_u16))); // Interecept used to calculate demand when analog is increasing
   \       0x92   0x8B20             LDRH     R0,[R4, #+24]
   \       0x94   0x....'....        BL       __aeabi_ui2f
   \       0x98   0x0007             MOVS     R7,R0
   \       0x9A   0x89E0             LDRH     R0,[R4, #+14]
   \       0x9C   0x....'....        BL       __aeabi_ui2f
   \       0xA0   0x0001             MOVS     R1,R0
   \       0xA2   0x6B60             LDR      R0,[R4, #+52]
   \       0xA4   0x....'....        BL       __aeabi_fmul
   \       0xA8   0x0001             MOVS     R1,R0
   \       0xAA   0x0038             MOVS     R0,R7
   \       0xAC   0x....'....        BL       __aeabi_fsub
   \       0xB0   0x6028             STR      R0,[R5, #+0]
   \       0xB2   0xE00F             B        ??InitAnalogAmpsInputParameters_1
    251            }else
    252            {
    253              analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingIntercept_f = (float)(analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16 - (float)((analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingSlope_f) * (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minVolts_u16))); // Interecept used to calculate demand when analog is increasing
   \                     ??InitAnalogAmpsInputParameters_0: (+1)
   \       0xB4   0x8B20             LDRH     R0,[R4, #+24]
   \       0xB6   0x....'....        BL       __aeabi_ui2f
   \       0xBA   0x0007             MOVS     R7,R0
   \       0xBC   0x89A0             LDRH     R0,[R4, #+12]
   \       0xBE   0x....'....        BL       __aeabi_ui2f
   \       0xC2   0x0001             MOVS     R1,R0
   \       0xC4   0x6B60             LDR      R0,[R4, #+52]
   \       0xC6   0x....'....        BL       __aeabi_fmul
   \       0xCA   0x0001             MOVS     R1,R0
   \       0xCC   0x0038             MOVS     R0,R7
   \       0xCE   0x....'....        BL       __aeabi_fsub
   \       0xD2   0x6028             STR      R0,[R5, #+0]
    254            }
    255            analog_4_20ma_Control_ptr.analog_4_20mA_Data.decreasingSlope_f = analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingSlope_f;
   \                     ??InitAnalogAmpsInputParameters_1: (+1)
   \       0xD4   0x6B60             LDR      R0,[R4, #+52]
   \       0xD6   0x6320             STR      R0,[R4, #+48]
    256            analog_4_20ma_Control_ptr.analog_4_20mA_Data.decreasingIntercept_f = analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingIntercept_f; 
   \       0xD8   0x6BA0             LDR      R0,[R4, #+56]
   \       0xDA   0x6030             STR      R0,[R6, #+0]
    257            
    258            
    259            // Assumes 0 V = 0 demand; Max volts = Max demand  
    260            analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_analogLow = FALSE;             // Set to "TRUE", if analog low is detected
   \       0xDC   0x0020             MOVS     R0,R4
   \       0xDE   0x3050             ADDS     R0,R0,#+80
   \       0xE0   0x2150             MOVS     R1,#+80
   \       0xE2   0x5A61             LDRH     R1,[R4, R1]
   \       0xE4   0x....             LDR      R2,??DataTable4_5  ;; 0xfffe
   \       0xE6   0x400A             ANDS     R2,R2,R1
   \       0xE8   0x8002             STRH     R2,[R0, #+0]
    261            analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_decreasingAnalog = FALSE;       // Set to "TRUE", if analog voltage is decresing
   \       0xEA   0x2150             MOVS     R1,#+80
   \       0xEC   0x5A61             LDRH     R1,[R4, R1]
   \       0xEE   0x....             LDR      R2,??DataTable4_2  ;; 0xfffd
   \       0xF0   0x400A             ANDS     R2,R2,R1
   \       0xF2   0x8002             STRH     R2,[R0, #+0]
    262            analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_lowerHysteresisEnable = FALSE;  // Set to "TRUE", if lower end hys is enabled
   \       0xF4   0x2150             MOVS     R1,#+80
   \       0xF6   0x5A61             LDRH     R1,[R4, R1]
   \       0xF8   0x....             LDR      R2,??DataTable3_4  ;; 0xfffb
   \       0xFA   0x400A             ANDS     R2,R2,R1
   \       0xFC   0x8002             STRH     R2,[R0, #+0]
    263            analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_upperHysteresisEnable = FALSE;  // Set to "TRUE", if upper end hys is enabled 
   \       0xFE   0x2150             MOVS     R1,#+80
   \      0x100   0x5A61             LDRH     R1,[R4, R1]
   \      0x102   0x....             LDR      R2,??DataTable3_5  ;; 0xfff7
   \      0x104   0x400A             ANDS     R2,R2,R1
   \      0x106   0x8002             STRH     R2,[R0, #+0]
    264            analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_demandOn = FALSE;               // Set to"TRUE", if demand goes from 0 to above min_Demand_u16.
   \      0x108   0x2150             MOVS     R1,#+80
   \      0x10A   0x5A61             LDRH     R1,[R4, R1]
   \      0x10C   0x....             LDR      R2,??DataTable3_3  ;; 0xffef
   \      0x10E   0x400A             ANDS     R2,R2,R1
   \      0x110   0x8002             STRH     R2,[R0, #+0]
    265            
    266          }
   \      0x112   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    267          /**
    268          ********************************************************************************************************************************
    269          * @brief   Check if Analog is increasing or decresing
    270          * @details Check for debounce. Only update Analog if change is greater than debounce
    271          debounce. Check for Low Analog Volts. 
    272          * @retval  None
    273          ********************************************************************************************************************************
    274          */

   \                                 In section .text, align 2, keep-with-next
    275          void DebounceAnalogAmps(void){
   \                     DebounceAnalogAmps: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    276            uint16_t abs_volts_diff_u16=0;
   \        0x2   0x2500             MOVS     R5,#+0
   \        0x4   0x002F             MOVS     R7,R5
    277            abs_volts_diff_u16 = abs(analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCountsStable_u16  - analog_amps_counts_u16);
   \        0x6   0x....             LDR      R6,??DataTable4_6
   \        0x8   0x....             LDR      R4,??DataTable4_7
   \        0xA   0x2046             MOVS     R0,#+70
   \        0xC   0x5A20             LDRH     R0,[R4, R0]
   \        0xE   0x8831             LDRH     R1,[R6, #+0]
   \       0x10   0x1A40             SUBS     R0,R0,R1
   \       0x12   0x....'....        BL       abs
   \       0x16   0x4669             MOV      R1,SP
   \       0x18   0x8008             STRH     R0,[R1, #+0]
    278            
    279            // Check debounce threshold
    280            if(abs_volts_diff_u16 > analog_4_20ma_Control_ptr.analog_4_20mA_Setting.debounceThresholdCounts_u16)
   \       0x1A   0x8A60             LDRH     R0,[R4, #+18]
   \       0x1C   0x4669             MOV      R1,SP
   \       0x1E   0x8809             LDRH     R1,[R1, #+0]
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD300             BCC      .+4
   \       0x24   0xE08C             B        ??DebounceAnalogAmps_0
    281            {  // Change is analog is above debounce
    282              if (analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCountsStable_u16  >  analog_amps_counts_u16)
   \       0x26   0x8830             LDRH     R0,[R6, #+0]
   \       0x28   0x2146             MOVS     R1,#+70
   \       0x2A   0x5A61             LDRH     R1,[R4, R1]
   \       0x2C   0x4288             CMP      R0,R1
   \       0x2E   0xD207             BCS      ??DebounceAnalogAmps_1
    283              { // Analog is decreasing
    284                analog_amps_decreasing_debounce_count_u16++;
   \       0x30   0x....             LDR      R0,??DataTable4_8
   \       0x32   0x7801             LDRB     R1,[R0, #+0]
   \       0x34   0x1C49             ADDS     R1,R1,#+1
   \       0x36   0x7001             STRB     R1,[R0, #+0]
    285                analog_amps_increasing_debounce_count_u16 = 0;
   \       0x38   0x0028             MOVS     R0,R5
   \       0x3A   0x....             LDR      R1,??DataTable4_9
   \       0x3C   0x7008             STRB     R0,[R1, #+0]
   \       0x3E   0xE00B             B        ??DebounceAnalogAmps_2
    286              } else if (analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCountsStable_u16  <  analog_amps_counts_u16)
   \                     ??DebounceAnalogAmps_1: (+1)
   \       0x40   0x2046             MOVS     R0,#+70
   \       0x42   0x5A20             LDRH     R0,[R4, R0]
   \       0x44   0x8831             LDRH     R1,[R6, #+0]
   \       0x46   0x4288             CMP      R0,R1
   \       0x48   0xD206             BCS      ??DebounceAnalogAmps_2
    287              { // Analog is increasing
    288                analog_amps_increasing_debounce_count_u16++;
   \       0x4A   0x....             LDR      R0,??DataTable4_9
   \       0x4C   0x7801             LDRB     R1,[R0, #+0]
   \       0x4E   0x1C49             ADDS     R1,R1,#+1
   \       0x50   0x7001             STRB     R1,[R0, #+0]
    289                analog_amps_decreasing_debounce_count_u16 = 0;
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0x....             LDR      R1,??DataTable4_8
   \       0x56   0x7008             STRB     R0,[R1, #+0]
    290              } 
    291              
    292              // Check debounce loop count
    293              if ( (analog_amps_increasing_debounce_count_u16 > analog_4_20ma_Control_ptr.analog_4_20mA_Setting.debounceLoopCount_u16) || (analog_amps_decreasing_debounce_count_u16 > analog_4_20ma_Control_ptr.analog_4_20mA_Setting.debounceLoopCount_u16)  )
   \                     ??DebounceAnalogAmps_2: (+1)
   \       0x58   0x....             LDR      R7,??DataTable4_9
   \       0x5A   0x8D60             LDRH     R0,[R4, #+42]
   \       0x5C   0x7839             LDRB     R1,[R7, #+0]
   \       0x5E   0xB289             UXTH     R1,R1
   \       0x60   0x4288             CMP      R0,R1
   \       0x62   0xD305             BCC      ??DebounceAnalogAmps_3
   \       0x64   0x8D60             LDRH     R0,[R4, #+42]
   \       0x66   0x....             LDR      R1,??DataTable4_8
   \       0x68   0x7809             LDRB     R1,[R1, #+0]
   \       0x6A   0xB289             UXTH     R1,R1
   \       0x6C   0x4288             CMP      R0,R1
   \       0x6E   0xD237             BCS      ??DebounceAnalogAmps_4
    294              {
    295                analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCountsStable_u16 = analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCounts_u16  + analog_4_20ma_Control_ptr.analog_4_20mA_Setting.calibratonFactor_s16 ; // Update only when debounce count is satisfied and calibrate
   \                     ??DebounceAnalogAmps_3: (+1)
   \       0x70   0x2040             MOVS     R0,#+64
   \       0x72   0x5A20             LDRH     R0,[R4, R0]
   \       0x74   0x2114             MOVS     R1,#+20
   \       0x76   0x5E61             LDRSH    R1,[R4, R1]
   \       0x78   0x1840             ADDS     R0,R0,R1
   \       0x7A   0x2146             MOVS     R1,#+70
   \       0x7C   0x5260             STRH     R0,[R4, R1]
    296                analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVolts_u16 = (uint16_t)(analog_4_20ma_Control_ptr.analog_4_20mA_Setting.analogGain_f * analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCountsStable_u16); // No need to rightshift since analogGain_f is adjusted by a factor of 100 // Convert ADC count to volts 
   \       0x7E   0x2046             MOVS     R0,#+70
   \       0x80   0x5A20             LDRH     R0,[R4, R0]
   \       0x82   0x....'....        BL       __aeabi_ui2f
   \       0x86   0x0001             MOVS     R1,R0
   \       0x88   0x6820             LDR      R0,[R4, #+0]
   \       0x8A   0x....'....        BL       __aeabi_fmul
   \       0x8E   0x....'....        BL       __aeabi_f2iz
   \       0x92   0x2144             MOVS     R1,#+68
   \       0x94   0x5260             STRH     R0,[R4, R1]
    297                analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogAmps_u16 = (uint16_t)(analog_4_20ma_Control_ptr.analog_4_20mA_Setting.analogVoltsToAmpsGain_f * analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVolts_u16); // No need to rightshift since analogVolts_u16 is already right shifted // Convert volts to amps 
   \       0x96   0x2044             MOVS     R0,#+68
   \       0x98   0x5A20             LDRH     R0,[R4, R0]
   \       0x9A   0x....'....        BL       __aeabi_ui2f
   \       0x9E   0x0001             MOVS     R1,R0
   \       0xA0   0x6860             LDR      R0,[R4, #+4]
   \       0xA2   0x....'....        BL       __aeabi_fmul
   \       0xA6   0x....'....        BL       __aeabi_f2iz
   \       0xAA   0x2142             MOVS     R1,#+66
   \       0xAC   0x5260             STRH     R0,[R4, R1]
    298                analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCounts_u16 = analog_amps_counts_u16; // Update only when debounce count is satisfied  
   \       0xAE   0x8830             LDRH     R0,[R6, #+0]
   \       0xB0   0x2140             MOVS     R1,#+64
   \       0xB2   0x5260             STRH     R0,[R4, R1]
    299                
    300                // Determine if volts are increasing or decreasing
    301                if(analog_amps_decreasing_debounce_count_u16 > analog_4_20ma_Control_ptr.analog_4_20mA_Setting.debounceLoopCount_u16) 
   \       0xB4   0x....             LDR      R0,??DataTable4_8
   \       0xB6   0x8D61             LDRH     R1,[R4, #+42]
   \       0xB8   0x7802             LDRB     R2,[R0, #+0]
   \       0xBA   0xB292             UXTH     R2,R2
   \       0xBC   0x4291             CMP      R1,R2
   \       0xBE   0xD206             BCS      ??DebounceAnalogAmps_5
    302                {
    303                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_decreasingAnalog = TRUE;
   \       0xC0   0x2150             MOVS     R1,#+80
   \       0xC2   0x5A61             LDRH     R1,[R4, R1]
   \       0xC4   0x2202             MOVS     R2,#+2
   \       0xC6   0x430A             ORRS     R2,R2,R1
   \       0xC8   0x2150             MOVS     R1,#+80
   \       0xCA   0x5262             STRH     R2,[R4, R1]
   \       0xCC   0xE005             B        ??DebounceAnalogAmps_6
    304                } else
    305                {
    306                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_decreasingAnalog = FALSE;
   \                     ??DebounceAnalogAmps_5: (+1)
   \       0xCE   0x2150             MOVS     R1,#+80
   \       0xD0   0x5A61             LDRH     R1,[R4, R1]
   \       0xD2   0x....             LDR      R2,??DataTable4_2  ;; 0xfffd
   \       0xD4   0x400A             ANDS     R2,R2,R1
   \       0xD6   0x2150             MOVS     R1,#+80
   \       0xD8   0x5262             STRH     R2,[R4, R1]
    307                }
    308                analog_amps_decreasing_debounce_count_u16 = 0;
   \                     ??DebounceAnalogAmps_6: (+1)
   \       0xDA   0x0029             MOVS     R1,R5
   \       0xDC   0x7001             STRB     R1,[R0, #+0]
    309                analog_amps_increasing_debounce_count_u16 = 0;
   \       0xDE   0x703D             STRB     R5,[R7, #+0]
    310              }
    311              
    312              // Set Digital input flag
    313              if(analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCountsStable_u16 < analog_4_20ma_Control_ptr.analog_4_20mA_Setting.digtialOffVolts_u16)
   \                     ??DebounceAnalogAmps_4: (+1)
   \       0xE0   0x2046             MOVS     R0,#+70
   \       0xE2   0x5A20             LDRH     R0,[R4, R0]
   \       0xE4   0x8CE1             LDRH     R1,[R4, #+38]
   \       0xE6   0x4288             CMP      R0,R1
   \       0xE8   0xD206             BCS      ??DebounceAnalogAmps_7
    314              {
    315                analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_digitalInputON = FALSE;
   \       0xEA   0x2050             MOVS     R0,#+80
   \       0xEC   0x5A20             LDRH     R0,[R4, R0]
   \       0xEE   0x....             LDR      R1,??DataTable4_10  ;; 0xffdf
   \       0xF0   0x4001             ANDS     R1,R1,R0
   \       0xF2   0x2050             MOVS     R0,#+80
   \       0xF4   0x5221             STRH     R1,[R4, R0]
   \       0xF6   0xE005             B        ??DebounceAnalogAmps_8
    316              } else{
    317                analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_digitalInputON = TRUE;
   \                     ??DebounceAnalogAmps_7: (+1)
   \       0xF8   0x2050             MOVS     R0,#+80
   \       0xFA   0x5A20             LDRH     R0,[R4, R0]
   \       0xFC   0x2120             MOVS     R1,#+32
   \       0xFE   0x4301             ORRS     R1,R1,R0
   \      0x100   0x2050             MOVS     R0,#+80
   \      0x102   0x5221             STRH     R1,[R4, R0]
    318              }
    319              
    320              // Delay low analog detection. Need when power up
    321              if(analog_amps_low_alarm_enable_count_u16 == 0) 
   \                     ??DebounceAnalogAmps_8: (+1)
   \      0x104   0x....             LDR      R0,??DataTable4_11
   \      0x106   0x7800             LDRB     R0,[R0, #+0]
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xD112             BNE      ??DebounceAnalogAmps_9
    322              { // Check if analog volts is low
    323                if (analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCounts_u16 < analog_4_20ma_Control_ptr.analog_4_20mA_Setting.analogLowVolts_u16)
   \      0x10C   0x2040             MOVS     R0,#+64
   \      0x10E   0x5A20             LDRH     R0,[R4, R0]
   \      0x110   0x8BE1             LDRH     R1,[R4, #+30]
   \      0x112   0x4288             CMP      R0,R1
   \      0x114   0xD206             BCS      ??DebounceAnalogAmps_10
    324                {
    325                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_analogLow = TRUE;
   \      0x116   0x2050             MOVS     R0,#+80
   \      0x118   0x5A20             LDRH     R0,[R4, R0]
   \      0x11A   0x2101             MOVS     R1,#+1
   \      0x11C   0x4301             ORRS     R1,R1,R0
   \      0x11E   0x2050             MOVS     R0,#+80
   \      0x120   0x5221             STRH     R1,[R4, R0]
   \      0x122   0xE012             B        ??DebounceAnalogAmps_11
    326                } else {
    327                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_analogLow = FALSE;
   \                     ??DebounceAnalogAmps_10: (+1)
   \      0x124   0x2050             MOVS     R0,#+80
   \      0x126   0x5A20             LDRH     R0,[R4, R0]
   \      0x128   0x....             LDR      R1,??DataTable4_5  ;; 0xfffe
   \      0x12A   0x4001             ANDS     R1,R1,R0
   \      0x12C   0x2050             MOVS     R0,#+80
   \      0x12E   0x5221             STRH     R1,[R4, R0]
   \      0x130   0xE00B             B        ??DebounceAnalogAmps_11
    328                }
    329              } else{
    330                //is_amps_above_loss_analog = TRUE;
    331                analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_analogLow = FALSE;
   \                     ??DebounceAnalogAmps_9: (+1)
   \      0x132   0x2050             MOVS     R0,#+80
   \      0x134   0x5A20             LDRH     R0,[R4, R0]
   \      0x136   0x....             LDR      R1,??DataTable4_5  ;; 0xfffe
   \      0x138   0x4001             ANDS     R1,R1,R0
   \      0x13A   0x2050             MOVS     R0,#+80
   \      0x13C   0x5221             STRH     R1,[R4, R0]
   \      0x13E   0xE004             B        ??DebounceAnalogAmps_11
    332              }
    333              
    334            } else
    335            { // debounce threshold not satisified
    336              analog_amps_increasing_debounce_count_u16 = 0;
   \                     ??DebounceAnalogAmps_0: (+1)
   \      0x140   0x0028             MOVS     R0,R5
   \      0x142   0x....             LDR      R1,??DataTable4_9
   \      0x144   0x7008             STRB     R0,[R1, #+0]
    337              analog_amps_decreasing_debounce_count_u16 = 0;
   \      0x146   0x....             LDR      R0,??DataTable4_8
   \      0x148   0x7005             STRB     R5,[R0, #+0]
    338            }
    339          }
   \                     ??DebounceAnalogAmps_11: (+1)
   \      0x14A   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    340          
    341          /**
    342          ********************************************************************************************************************************
    343          * @brief   Convert Analog volts to Demand ( min_Demand_u16 to max_Demand_u16)
    344          * @details Check for hysteresis, turn ON/OFF and calculate demand 
    345          * @retval  None
    346          ********************************************************************************************************************************
    347          */

   \                                 In section .text, align 4, keep-with-next
    348          uint16_t GetAnalogAmpsDemand(void){
   \                     GetAnalogAmpsDemand: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
    349            uint32_t analog_demand_u32 = 0;
   \        0x2   0x2700             MOVS     R7,#+0
   \        0x4   0x003C             MOVS     R4,R7
    350            float slope_f;
    351            float intercept_f;
    352            uint16_t analog_volts_u16 = 0; 
   \        0x6   0x0038             MOVS     R0,R7
    353            
    354            analog_volts_u16 = analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCountsStable_u16; // Used in case analog demand is inverted
   \        0x8   0x4D84             LDR      R5,??GetAnalogAmpsDemand_0
   \        0xA   0x2146             MOVS     R1,#+70
   \        0xC   0x5A6E             LDRH     R6,[R5, R1]
    355            // Check if input mode is enabled (ANALOG_MODE)
    356            if (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.inputMode_u16 != ANALOG_MODE)
   \        0xE   0x8DA9             LDRH     R1,[R5, #+44]
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD007             BEQ      ??GetAnalogAmpsDemand_1
    357            {
    358              analog_demand_u32 = 0;
   \       0x14   0x003C             MOVS     R4,R7
    359              analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_demandOn = FALSE;
   \       0x16   0x2050             MOVS     R0,#+80
   \       0x18   0x5A28             LDRH     R0,[R5, R0]
   \       0x1A   0x4981             LDR      R1,??GetAnalogAmpsDemand_0+0x4  ;; 0xffef
   \       0x1C   0x4001             ANDS     R1,R1,R0
   \       0x1E   0x2050             MOVS     R0,#+80
   \       0x20   0x5229             STRH     R1,[R5, R0]
   \       0x22   0xE1A1             B        ??GetAnalogAmpsDemand_2
    360            } else if( (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_analogLowEnable == TRUE) && (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_analogFailSafeEnable == TRUE ) && (analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_analogLow == TRUE)) { 
   \                     ??GetAnalogAmpsDemand_1: (+1)
   \       0x24   0x202E             MOVS     R0,#+46
   \       0x26   0x5C28             LDRB     R0,[R5, R0]
   \       0x28   0x210C             MOVS     R1,#+12
   \       0x2A   0x4001             ANDS     R1,R1,R0
   \       0x2C   0x290C             CMP      R1,#+12
   \       0x2E   0xD120             BNE      ??GetAnalogAmpsDemand_3
   \       0x30   0x2001             MOVS     R0,#+1
   \       0x32   0x2150             MOVS     R1,#+80
   \       0x34   0x5A69             LDRH     R1,[R5, R1]
   \       0x36   0x0002             MOVS     R2,R0
   \       0x38   0x400A             ANDS     R2,R2,R1
   \       0x3A   0xB292             UXTH     R2,R2
   \       0x3C   0x2A00             CMP      R2,#+0
   \       0x3E   0xD018             BEQ      ??GetAnalogAmpsDemand_3
    361              // Check if Loss of analog
    362              if((analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_demandOn == FALSE))// && (is_amps_above_loss_analog == FALSE))//demand is never gone above min demand. 
   \       0x40   0x2150             MOVS     R1,#+80
   \       0x42   0x5A69             LDRH     R1,[R5, R1]
   \       0x44   0xB289             UXTH     R1,R1
   \       0x46   0x0909             LSRS     R1,R1,#+4
   \       0x48   0x4008             ANDS     R0,R0,R1
   \       0x4A   0xB280             UXTH     R0,R0
   \       0x4C   0x2800             CMP      R0,#+0
   \       0x4E   0xD101             BNE      ??GetAnalogAmpsDemand_4
    363              {  // Analog never crossed turned ON volts
    364                analog_demand_u32 = 0;
   \       0x50   0x003C             MOVS     R4,R7
   \       0x52   0xE189             B        ??GetAnalogAmpsDemand_2
    365                //analog_4_20ma_Control_ptr.analog_4_20mA_Data.is_demandOn = FALSE;
    366              } else{// if (is_amps_above_loss_analog == TRUE){
    367                // Use fail safe demand if low analog volts is detected
    368                analog_demand_u32 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.failSafeDemand_u16;
   \                     ??GetAnalogAmpsDemand_4: (+1)
   \       0x54   0x8C28             LDRH     R0,[R5, #+32]
   \       0x56   0x0004             MOVS     R4,R0
    369                analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_demandOn = TRUE;
   \       0x58   0x0028             MOVS     R0,R5
   \       0x5A   0x3050             ADDS     R0,R0,#+80
   \       0x5C   0x2150             MOVS     R1,#+80
   \       0x5E   0x5A69             LDRH     R1,[R5, R1]
   \       0x60   0x2210             MOVS     R2,#+16
   \       0x62   0x430A             ORRS     R2,R2,R1
   \       0x64   0x8002             STRH     R2,[R0, #+0]
    370                analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_upperHysteresisEnable = FALSE;
   \       0x66   0x2150             MOVS     R1,#+80
   \       0x68   0x5A69             LDRH     R1,[R5, R1]
   \       0x6A   0x....             LDR      R2,??DataTable5  ;; 0xfff7
   \       0x6C   0x400A             ANDS     R2,R2,R1
   \       0x6E   0x8002             STRH     R2,[R0, #+0]
   \       0x70   0xE17A             B        ??GetAnalogAmpsDemand_2
    371              }
    372            } else {
    373              // If invert is enabled invert measured value
    374              //if (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_invertAnalog == TRUE) 
    375              //{
    376                //analog_volts_u16 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxAdcCounts_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogVoltsCountsStable_u16;
    377              //}
    378              
    379              if (analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_decreasingAnalog == FALSE)
   \                     ??GetAnalogAmpsDemand_3: (+1)
   \       0x72   0x2001             MOVS     R0,#+1
   \       0x74   0x2150             MOVS     R1,#+80
   \       0x76   0x5A69             LDRH     R1,[R5, R1]
   \       0x78   0xB289             UXTH     R1,R1
   \       0x7A   0x0849             LSRS     R1,R1,#+1
   \       0x7C   0x0002             MOVS     R2,R0
   \       0x7E   0x400A             ANDS     R2,R2,R1
   \       0x80   0xB292             UXTH     R2,R2
   \       0x82   0x2A00             CMP      R2,#+0
   \       0x84   0xD104             BNE      ??GetAnalogAmpsDemand_5
    380              { // Slope used when analog value is increasing
    381                slope_f = analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingSlope_f;
   \       0x86   0x6B69             LDR      R1,[R5, #+52]
   \       0x88   0x9101             STR      R1,[SP, #+4]
    382                intercept_f = analog_4_20ma_Control_ptr.analog_4_20mA_Data.increasingIntercept_f;
   \       0x8A   0x6BA9             LDR      R1,[R5, #+56]
   \       0x8C   0x9100             STR      R1,[SP, #+0]
   \       0x8E   0xE003             B        ??GetAnalogAmpsDemand_6
    383              } else {
    384                // Slope used when analog value is decreasing
    385                slope_f = analog_4_20ma_Control_ptr.analog_4_20mA_Data.decreasingSlope_f;
   \                     ??GetAnalogAmpsDemand_5: (+1)
   \       0x90   0x6B29             LDR      R1,[R5, #+48]
   \       0x92   0x9101             STR      R1,[SP, #+4]
    386                intercept_f = analog_4_20ma_Control_ptr.analog_4_20mA_Data.decreasingIntercept_f;
   \       0x94   0x6BE9             LDR      R1,[R5, #+60]
   \       0x96   0x9100             STR      R1,[SP, #+0]
    387              }
    388              
    389              // Analog volts is divided up into three parts
    390              // Part 1: 0v to off volts
    391              // Part 2: off volts to upper hysteresis volts
    392              // Part 3: Upper hysteresis volts to max volts
    393              
    394              // Part 1, 2 : Analog input between OFF volts and upper hysteresis
    395              if ((analog_volts_u16 >= analog_4_20ma_Control_ptr.analog_4_20mA_Setting.offVolts_u16) && (analog_volts_u16 < (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxVolts_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Setting.voltsHysteresis_u16)))
   \                     ??GetAnalogAmpsDemand_6: (+1)
   \       0x98   0x0031             MOVS     R1,R6
   \       0x9A   0x896A             LDRH     R2,[R5, #+10]
   \       0x9C   0xB289             UXTH     R1,R1
   \       0x9E   0x4291             CMP      R1,R2
   \       0xA0   0xD200             BCS      .+4
   \       0xA2   0xE0BF             B        ??GetAnalogAmpsDemand_7
   \       0xA4   0x0031             MOVS     R1,R6
   \       0xA6   0xB289             UXTH     R1,R1
   \       0xA8   0x89EA             LDRH     R2,[R5, #+14]
   \       0xAA   0x8AEB             LDRH     R3,[R5, #+22]
   \       0xAC   0x1AD2             SUBS     R2,R2,R3
   \       0xAE   0x4291             CMP      R1,R2
   \       0xB0   0xDB00             BLT      .+4
   \       0xB2   0xE0B7             B        ??GetAnalogAmpsDemand_7
    396              {
    397                // If analog is between ON and OFF volts. Hysteresis part
    398                analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_upperHysteresisEnable = FALSE;
   \       0xB4   0x0029             MOVS     R1,R5
   \       0xB6   0x3150             ADDS     R1,R1,#+80
   \       0xB8   0x2250             MOVS     R2,#+80
   \       0xBA   0x5AAA             LDRH     R2,[R5, R2]
   \       0xBC   0x....             LDR      R3,??DataTable5  ;; 0xfff7
   \       0xBE   0x4013             ANDS     R3,R3,R2
   \       0xC0   0x800B             STRH     R3,[R1, #+0]
    399                
    400                // Part 2
    401                // onVolts till upperHysteresis
    402                if (analog_volts_u16 >= analog_4_20ma_Control_ptr.analog_4_20mA_Setting.onVolts_u16) {
   \       0xC2   0x0032             MOVS     R2,R6
   \       0xC4   0x892B             LDRH     R3,[R5, #+8]
   \       0xC6   0xB292             UXTH     R2,R2
   \       0xC8   0x429A             CMP      R2,R3
   \       0xCA   0xD36A             BCC      ??GetAnalogAmpsDemand_8
    403                  if (analog_volts_u16 >= analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minVolts_u16)
   \       0xCC   0x0032             MOVS     R2,R6
   \       0xCE   0x89AB             LDRH     R3,[R5, #+12]
   \       0xD0   0xB292             UXTH     R2,R2
   \       0xD2   0x429A             CMP      R2,R3
   \       0xD4   0xD314             BCC      ??GetAnalogAmpsDemand_9
    404                  {          
    405                    // Analog voltage is above ON volts for first time
    406                    analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_lowerHysteresisEnable = TRUE;
   \       0xD6   0x2050             MOVS     R0,#+80
   \       0xD8   0x5A28             LDRH     R0,[R5, R0]
   \       0xDA   0x2204             MOVS     R2,#+4
   \       0xDC   0x4302             ORRS     R2,R2,R0
   \       0xDE   0x800A             STRH     R2,[R1, #+0]
    407                    analog_demand_u32 = (uint32_t)((float)(slope_f * analog_volts_u16) + intercept_f);
   \       0xE0   0x0030             MOVS     R0,R6
   \       0xE2   0xB280             UXTH     R0,R0
   \       0xE4   0x....'....        BL       __aeabi_ui2f
   \       0xE8   0x0001             MOVS     R1,R0
   \       0xEA   0x9801             LDR      R0,[SP, #+4]
   \       0xEC   0x....'....        BL       __aeabi_fmul
   \       0xF0   0x0001             MOVS     R1,R0
   \       0xF2   0x9800             LDR      R0,[SP, #+0]
   \       0xF4   0x....'....        BL       __aeabi_fadd
   \       0xF8   0x....'....        BL       __aeabi_f2uiz
   \       0xFC   0x0004             MOVS     R4,R0
   \       0xFE   0xE10C             B        ??GetAnalogAmpsDemand_10
    408                  } else if (analog_volts_u16 < analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minVolts_u16){
   \                     ??GetAnalogAmpsDemand_9: (+1)
   \      0x100   0x0032             MOVS     R2,R6
   \      0x102   0x89AB             LDRH     R3,[R5, #+12]
   \      0x104   0xB292             UXTH     R2,R2
   \      0x106   0x429A             CMP      R2,R3
   \      0x108   0xD300             BCC      .+4
   \      0x10A   0xE106             B        ??GetAnalogAmpsDemand_10
    409                    // Analog voltage below minVolts limit
    410                    if((analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_analogMinDemandEnable) == TRUE ){//&& ( analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_lowerHysteresisEnable == TRUE)){
   \      0x10C   0x8DEA             LDRH     R2,[R5, #+46]
   \      0x10E   0xB292             UXTH     R2,R2
   \      0x110   0x0912             LSRS     R2,R2,#+4
   \      0x112   0x0003             MOVS     R3,R0
   \      0x114   0x4013             ANDS     R3,R3,R2
   \      0x116   0xB29B             UXTH     R3,R3
   \      0x118   0x2B00             CMP      R3,#+0
   \      0x11A   0xD00C             BEQ      ??GetAnalogAmpsDemand_11
    411                      // Default to min demand when is_analogMinDemandEn is TRUE
    412                      //analog_demand_u32 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16;
    413                      if(analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_invertAnalog == FALSE)
   \      0x11C   0x8DE9             LDRH     R1,[R5, #+46]
   \      0x11E   0xB289             UXTH     R1,R1
   \      0x120   0x0849             LSRS     R1,R1,#+1
   \      0x122   0x4008             ANDS     R0,R0,R1
   \      0x124   0xB280             UXTH     R0,R0
   \      0x126   0x2800             CMP      R0,#+0
   \      0x128   0xD102             BNE      ??GetAnalogAmpsDemand_12
    414                      {
    415                        analog_demand_u32 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16;
   \      0x12A   0x8B28             LDRH     R0,[R5, #+24]
   \      0x12C   0x0004             MOVS     R4,R0
   \      0x12E   0xE0F4             B        ??GetAnalogAmpsDemand_10
    416                      } else
    417                      {
    418                        analog_demand_u32 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxDemand_u16;
   \                     ??GetAnalogAmpsDemand_12: (+1)
   \      0x130   0x8B68             LDRH     R0,[R5, #+26]
   \      0x132   0x0004             MOVS     R4,R0
   \      0x134   0xE0F1             B        ??GetAnalogAmpsDemand_10
    419                      }
    420                    } else if( (analog_volts_u16 >= (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minVolts_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemandHysteresis_u16)) && ( analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_lowerHysteresisEnable == TRUE)){
   \                     ??GetAnalogAmpsDemand_11: (+1)
   \      0x136   0x0033             MOVS     R3,R6
   \      0x138   0xB29B             UXTH     R3,R3
   \      0x13A   0x469C             MOV      R12,R3
   \      0x13C   0x89AB             LDRH     R3,[R5, #+12]
   \      0x13E   0x8BAA             LDRH     R2,[R5, #+28]
   \      0x140   0x1A9A             SUBS     R2,R3,R2
   \      0x142   0x4663             MOV      R3,R12
   \      0x144   0x4293             CMP      R3,R2
   \      0x146   0xDB17             BLT      ??GetAnalogAmpsDemand_13
   \      0x148   0x2250             MOVS     R2,#+80
   \      0x14A   0x5AAA             LDRH     R2,[R5, R2]
   \      0x14C   0xB292             UXTH     R2,R2
   \      0x14E   0x0892             LSRS     R2,R2,#+2
   \      0x150   0x4010             ANDS     R0,R0,R2
   \      0x152   0xB280             UXTH     R0,R0
   \      0x154   0x2800             CMP      R0,#+0
   \      0x156   0xD00F             BEQ      ??GetAnalogAmpsDemand_13
    421                      // Apply lower end hysteresis
    422                      analog_demand_u32 = (uint32_t)((float)(slope_f * analog_volts_u16) + intercept_f);
   \      0x158   0x0030             MOVS     R0,R6
   \      0x15A   0xB280             UXTH     R0,R0
   \      0x15C   0x....'....        BL       __aeabi_ui2f
   \      0x160   0x0001             MOVS     R1,R0
   \      0x162   0x9801             LDR      R0,[SP, #+4]
   \      0x164   0x....'....        BL       __aeabi_fmul
   \      0x168   0x0001             MOVS     R1,R0
   \      0x16A   0x9800             LDR      R0,[SP, #+0]
   \      0x16C   0x....'....        BL       __aeabi_fadd
   \      0x170   0x....'....        BL       __aeabi_f2uiz
   \      0x174   0x0004             MOVS     R4,R0
   \      0x176   0xE0D0             B        ??GetAnalogAmpsDemand_10
    423                    } else{
    424                      if ((analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_invertAnalog == TRUE) && (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_analogMinDemandEnable == TRUE))
   \                     ??GetAnalogAmpsDemand_13: (+1)
   \      0x178   0x202E             MOVS     R0,#+46
   \      0x17A   0x5C28             LDRB     R0,[R5, R0]
   \      0x17C   0x2212             MOVS     R2,#+18
   \      0x17E   0x4002             ANDS     R2,R2,R0
   \      0x180   0x2A12             CMP      R2,#+18
   \      0x182   0xD102             BNE      ??GetAnalogAmpsDemand_14
    425                      {
    426                        analog_demand_u32 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16;
   \      0x184   0x8B28             LDRH     R0,[R5, #+24]
   \      0x186   0x0004             MOVS     R4,R0
   \      0x188   0xE0C7             B        ??GetAnalogAmpsDemand_10
    427                      } else{
    428                        // Analog volts below hysteresis value
    429                        analog_demand_u32 = 0;
   \                     ??GetAnalogAmpsDemand_14: (+1)
   \      0x18A   0x003C             MOVS     R4,R7
    430                        analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_lowerHysteresisEnable = FALSE;
   \      0x18C   0x2050             MOVS     R0,#+80
   \      0x18E   0x5A28             LDRH     R0,[R5, R0]
   \      0x190   0x....             LDR      R2,??DataTable5_1  ;; 0xfffb
   \      0x192   0x4002             ANDS     R2,R2,R0
   \      0x194   0x800A             STRH     R2,[R1, #+0]
    431                        analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_demandOn = FALSE;  
   \      0x196   0x2050             MOVS     R0,#+80
   \      0x198   0x5A28             LDRH     R0,[R5, R0]
   \      0x19A   0x4A21             LDR      R2,??GetAnalogAmpsDemand_0+0x4  ;; 0xffef
   \      0x19C   0x4002             ANDS     R2,R2,R0
   \      0x19E   0x800A             STRH     R2,[R1, #+0]
   \      0x1A0   0xE0BB             B        ??GetAnalogAmpsDemand_10
    432                      }
    433                    }          
    434                  }
    435                }else if (analog_volts_u16 >= analog_4_20ma_Control_ptr.analog_4_20mA_Setting.offVolts_u16) {
   \                     ??GetAnalogAmpsDemand_8: (+1)
   \      0x1A2   0x0032             MOVS     R2,R6
   \      0x1A4   0x896B             LDRH     R3,[R5, #+10]
   \      0x1A6   0xB292             UXTH     R2,R2
   \      0x1A8   0x429A             CMP      R2,R3
   \      0x1AA   0xD324             BCC      ??GetAnalogAmpsDemand_15
    436                  // Part 1
    437                  // upper hysteresisdown to off volatge
    438                  
    439                  // Demand is minimum until analog reaches below off volatge
    440                  if((analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_analogMinDemandEnable) == TRUE && ( analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_lowerHysteresisEnable == TRUE)){
   \      0x1AC   0x8DEA             LDRH     R2,[R5, #+46]
   \      0x1AE   0xB292             UXTH     R2,R2
   \      0x1B0   0x0912             LSRS     R2,R2,#+4
   \      0x1B2   0x0003             MOVS     R3,R0
   \      0x1B4   0x4013             ANDS     R3,R3,R2
   \      0x1B6   0xB29B             UXTH     R3,R3
   \      0x1B8   0x2B00             CMP      R3,#+0
   \      0x1BA   0xD015             BEQ      ??GetAnalogAmpsDemand_16
   \      0x1BC   0x2250             MOVS     R2,#+80
   \      0x1BE   0x5AAA             LDRH     R2,[R5, R2]
   \      0x1C0   0xB292             UXTH     R2,R2
   \      0x1C2   0x0892             LSRS     R2,R2,#+2
   \      0x1C4   0x0003             MOVS     R3,R0
   \      0x1C6   0x4013             ANDS     R3,R3,R2
   \      0x1C8   0xB29B             UXTH     R3,R3
   \      0x1CA   0x2B00             CMP      R3,#+0
   \      0x1CC   0xD00C             BEQ      ??GetAnalogAmpsDemand_16
    441                      // Default to min demand when is_analogMinDemandEn is TRUE
    442                      //analog_demand_u32 = analogVolts_Control.analogVolts_Setting.minDemand_u16;
    443                      if(analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_invertAnalog == FALSE)
   \      0x1CE   0x8DE9             LDRH     R1,[R5, #+46]
   \      0x1D0   0xB289             UXTH     R1,R1
   \      0x1D2   0x0849             LSRS     R1,R1,#+1
   \      0x1D4   0x4008             ANDS     R0,R0,R1
   \      0x1D6   0xB280             UXTH     R0,R0
   \      0x1D8   0x2800             CMP      R0,#+0
   \      0x1DA   0xD102             BNE      ??GetAnalogAmpsDemand_17
    444                      {
    445                        analog_demand_u32 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16;
   \      0x1DC   0x8B28             LDRH     R0,[R5, #+24]
   \      0x1DE   0x0004             MOVS     R4,R0
   \      0x1E0   0xE09B             B        ??GetAnalogAmpsDemand_10
    446                      } else
    447                      {
    448                        analog_demand_u32 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxDemand_u16;
   \                     ??GetAnalogAmpsDemand_17: (+1)
   \      0x1E2   0x8B68             LDRH     R0,[R5, #+26]
   \      0x1E4   0x0004             MOVS     R4,R0
   \      0x1E6   0xE098             B        ??GetAnalogAmpsDemand_10
    449                      }
    450                  }else{
    451                    analog_demand_u32 = 0;
   \                     ??GetAnalogAmpsDemand_16: (+1)
   \      0x1E8   0x003C             MOVS     R4,R7
    452                    analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_demandOn = FALSE;
   \      0x1EA   0x2050             MOVS     R0,#+80
   \      0x1EC   0x5A28             LDRH     R0,[R5, R0]
   \      0x1EE   0x4A0C             LDR      R2,??GetAnalogAmpsDemand_0+0x4  ;; 0xffef
   \      0x1F0   0x4002             ANDS     R2,R2,R0
   \      0x1F2   0x800A             STRH     R2,[R1, #+0]
   \      0x1F4   0xE091             B        ??GetAnalogAmpsDemand_10
    453                  }
    454                } else if (analog_volts_u16 < analog_4_20ma_Control_ptr.analog_4_20mA_Setting.onVolts_u16) {
   \                     ??GetAnalogAmpsDemand_15: (+1)
   \      0x1F6   0x0030             MOVS     R0,R6
   \      0x1F8   0x892A             LDRH     R2,[R5, #+8]
   \      0x1FA   0xB280             UXTH     R0,R0
   \      0x1FC   0x4290             CMP      R0,R2
   \      0x1FE   0xD206             BCS      ??GetAnalogAmpsDemand_18
    455                  // Part 1
    456                  // 0V till onVolts
    457                  
    458                  // Demand is zero when analog never crossed ON volts
    459                  analog_demand_u32 = 0;
   \      0x200   0x003C             MOVS     R4,R7
    460                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_demandOn = FALSE;
   \      0x202   0x2050             MOVS     R0,#+80
   \      0x204   0x5A28             LDRH     R0,[R5, R0]
   \      0x206   0x4A06             LDR      R2,??GetAnalogAmpsDemand_0+0x4  ;; 0xffef
   \      0x208   0x4002             ANDS     R2,R2,R0
   \      0x20A   0x800A             STRH     R2,[R1, #+0]
   \      0x20C   0xE085             B        ??GetAnalogAmpsDemand_10
    461                } else {
    462                  analog_demand_u32 = 0;
   \                     ??GetAnalogAmpsDemand_18: (+1)
   \      0x20E   0x003C             MOVS     R4,R7
    463                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_demandOn = FALSE;
   \      0x210   0x2050             MOVS     R0,#+80
   \      0x212   0x5A28             LDRH     R0,[R5, R0]
   \      0x214   0x4A02             LDR      R2,??GetAnalogAmpsDemand_0+0x4  ;; 0xffef
   \      0x216   0x4002             ANDS     R2,R2,R0
   \      0x218   0x800A             STRH     R2,[R1, #+0]
   \      0x21A   0xE07E             B        ??GetAnalogAmpsDemand_10
   \                     ??GetAnalogAmpsDemand_0:
   \      0x21C   0x....'....        DC32     analog_4_20ma_Control_ptr
   \      0x220   0x0000'FFEF        DC32     0xffef
    464                }
    465              } else if ((analog_volts_u16 >= (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxVolts_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Setting.voltsHysteresis_u16)) && (analog_volts_u16 < analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxVolts_u16) ){
   \                     ??GetAnalogAmpsDemand_7: (+1)
   \      0x224   0x0031             MOVS     R1,R6
   \      0x226   0xB289             UXTH     R1,R1
   \      0x228   0x89EA             LDRH     R2,[R5, #+14]
   \      0x22A   0x8AEB             LDRH     R3,[R5, #+22]
   \      0x22C   0x1AD2             SUBS     R2,R2,R3
   \      0x22E   0x4291             CMP      R1,R2
   \      0x230   0xDB4E             BLT      ??GetAnalogAmpsDemand_19
   \      0x232   0x0031             MOVS     R1,R6
   \      0x234   0x89EA             LDRH     R2,[R5, #+14]
   \      0x236   0xB289             UXTH     R1,R1
   \      0x238   0x4291             CMP      R1,R2
   \      0x23A   0xD249             BCS      ??GetAnalogAmpsDemand_19
    466                // Part 3: 
    467                // upperHysteresis till maxVolts
    468                
    469                // Analog voltage above upper hysteresis voltage      
    470                if (analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_upperHysteresisEnable  == TRUE)
   \      0x23C   0x2150             MOVS     R1,#+80
   \      0x23E   0x5A69             LDRH     R1,[R5, R1]
   \      0x240   0xB289             UXTH     R1,R1
   \      0x242   0x08C9             LSRS     R1,R1,#+3
   \      0x244   0x0002             MOVS     R2,R0
   \      0x246   0x400A             ANDS     R2,R2,R1
   \      0x248   0xB292             UXTH     R2,R2
   \      0x24A   0x2A00             CMP      R2,#+0
   \      0x24C   0xD025             BEQ      ??GetAnalogAmpsDemand_20
    471                { // Analog already crossed hysteresis point
    472                  if (analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_decreasingAnalog == TRUE)
   \      0x24E   0x2150             MOVS     R1,#+80
   \      0x250   0x5A69             LDRH     R1,[R5, R1]
   \      0x252   0xB289             UXTH     R1,R1
   \      0x254   0x0849             LSRS     R1,R1,#+1
   \      0x256   0x0002             MOVS     R2,R0
   \      0x258   0x400A             ANDS     R2,R2,R1
   \      0x25A   0xB292             UXTH     R2,R2
   \      0x25C   0x2A00             CMP      R2,#+0
   \      0x25E   0xD00C             BEQ      ??GetAnalogAmpsDemand_21
    473                  { // Output demand = max demand till below hysteresis value          
    474          		  if(analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_invertAnalog == FALSE)
   \      0x260   0x8DE9             LDRH     R1,[R5, #+46]
   \      0x262   0xB289             UXTH     R1,R1
   \      0x264   0x0849             LSRS     R1,R1,#+1
   \      0x266   0x4008             ANDS     R0,R0,R1
   \      0x268   0xB280             UXTH     R0,R0
   \      0x26A   0x2800             CMP      R0,#+0
   \      0x26C   0xD102             BNE      ??GetAnalogAmpsDemand_22
    475                    {
    476                      analog_demand_u32 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxDemand_u16;
   \      0x26E   0x8B68             LDRH     R0,[R5, #+26]
   \      0x270   0x0004             MOVS     R4,R0
   \      0x272   0xE052             B        ??GetAnalogAmpsDemand_10
    477                    } else
    478                    {
    479                      analog_demand_u32 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16;
   \                     ??GetAnalogAmpsDemand_22: (+1)
   \      0x274   0x8B28             LDRH     R0,[R5, #+24]
   \      0x276   0x0004             MOVS     R4,R0
   \      0x278   0xE04F             B        ??GetAnalogAmpsDemand_10
    480                    }
    481                  } else {
    482                    // Analog volts never when above hysteresis voltage
    483                    analog_demand_u32 = (uint32_t)((float)(slope_f * analog_volts_u16) + intercept_f);
   \                     ??GetAnalogAmpsDemand_21: (+1)
   \      0x27A   0x0030             MOVS     R0,R6
   \      0x27C   0xB280             UXTH     R0,R0
   \      0x27E   0x....'....        BL       __aeabi_ui2f
   \      0x282   0x0001             MOVS     R1,R0
   \      0x284   0x9801             LDR      R0,[SP, #+4]
   \      0x286   0x....'....        BL       __aeabi_fmul
   \      0x28A   0x0001             MOVS     R1,R0
   \      0x28C   0x9800             LDR      R0,[SP, #+0]
   \      0x28E   0x....'....        BL       __aeabi_fadd
   \      0x292   0x....'....        BL       __aeabi_f2uiz
   \      0x296   0x0004             MOVS     R4,R0
   \      0x298   0xE03F             B        ??GetAnalogAmpsDemand_10
    484                  }
    485                } else if (analog_volts_u16 <= analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxVolts_u16) {
   \                     ??GetAnalogAmpsDemand_20: (+1)
   \      0x29A   0x89E8             LDRH     R0,[R5, #+14]
   \      0x29C   0x0031             MOVS     R1,R6
   \      0x29E   0xB289             UXTH     R1,R1
   \      0x2A0   0x4288             CMP      R0,R1
   \      0x2A2   0xD33A             BCC      ??GetAnalogAmpsDemand_10
    486                  // Analog went above Upper Hysteresis value for the first time
    487                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_upperHysteresisEnable  = TRUE;
   \      0x2A4   0x2050             MOVS     R0,#+80
   \      0x2A6   0x5A28             LDRH     R0,[R5, R0]
   \      0x2A8   0x2108             MOVS     R1,#+8
   \      0x2AA   0x4301             ORRS     R1,R1,R0
   \      0x2AC   0x2050             MOVS     R0,#+80
   \      0x2AE   0x5229             STRH     R1,[R5, R0]
    488                  analog_demand_u32 = (uint32_t)((float)(slope_f * analog_volts_u16) + intercept_f);
   \      0x2B0   0x0030             MOVS     R0,R6
   \      0x2B2   0xB280             UXTH     R0,R0
   \      0x2B4   0x....'....        BL       __aeabi_ui2f
   \      0x2B8   0x0001             MOVS     R1,R0
   \      0x2BA   0x9801             LDR      R0,[SP, #+4]
   \      0x2BC   0x....'....        BL       __aeabi_fmul
   \      0x2C0   0x0001             MOVS     R1,R0
   \      0x2C2   0x9800             LDR      R0,[SP, #+0]
   \      0x2C4   0x....'....        BL       __aeabi_fadd
   \      0x2C8   0x....'....        BL       __aeabi_f2uiz
   \      0x2CC   0x0004             MOVS     R4,R0
   \      0x2CE   0xE024             B        ??GetAnalogAmpsDemand_10
    489                }
    490              } else if (analog_volts_u16 > analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxVolts_u16) {
   \                     ??GetAnalogAmpsDemand_19: (+1)
   \      0x2D0   0x89E9             LDRH     R1,[R5, #+14]
   \      0x2D2   0x0032             MOVS     R2,R6
   \      0x2D4   0xB292             UXTH     R2,R2
   \      0x2D6   0x4291             CMP      R1,R2
   \      0x2D8   0xD218             BCS      ??GetAnalogAmpsDemand_23
    491          	if(analog_4_20ma_Control_ptr.analog_4_20mA_Setting.flags_u16.is_invertAnalog == FALSE)
   \      0x2DA   0x8DE9             LDRH     R1,[R5, #+46]
   \      0x2DC   0xB289             UXTH     R1,R1
   \      0x2DE   0x0849             LSRS     R1,R1,#+1
   \      0x2E0   0x4008             ANDS     R0,R0,R1
   \      0x2E2   0xB280             UXTH     R0,R0
   \      0x2E4   0x2800             CMP      R0,#+0
   \      0x2E6   0xD108             BNE      ??GetAnalogAmpsDemand_24
    492                {
    493                  // Saturate demand value
    494                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_upperHysteresisEnable  = TRUE;
   \      0x2E8   0x2050             MOVS     R0,#+80
   \      0x2EA   0x5A28             LDRH     R0,[R5, R0]
   \      0x2EC   0x2108             MOVS     R1,#+8
   \      0x2EE   0x4301             ORRS     R1,R1,R0
   \      0x2F0   0x2050             MOVS     R0,#+80
   \      0x2F2   0x5229             STRH     R1,[R5, R0]
    495                  analog_demand_u32 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxDemand_u16;
   \      0x2F4   0x8B68             LDRH     R0,[R5, #+26]
   \      0x2F6   0x0004             MOVS     R4,R0
   \      0x2F8   0xE00F             B        ??GetAnalogAmpsDemand_10
    496                } else
    497                {
    498                  // Saturate demand value for inverted input
    499                  //if( analog_volts_u16 > (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxVolts_u16) )
    500                 // analogVolts_Control.analogVolts_Data.discretes_u16.is_upperHysteresisEnable  = FALSE;
    501                  //analog_demand_u32 = 0;
    502                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_upperHysteresisEnable  = TRUE;
   \                     ??GetAnalogAmpsDemand_24: (+1)
   \      0x2FA   0x2050             MOVS     R0,#+80
   \      0x2FC   0x5A28             LDRH     R0,[R5, R0]
   \      0x2FE   0x2108             MOVS     R1,#+8
   \      0x300   0x4301             ORRS     R1,R1,R0
   \      0x302   0x2050             MOVS     R0,#+80
   \      0x304   0x5229             STRH     R1,[R5, R0]
    503                  analog_demand_u32 = analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16;
   \      0x306   0x8B28             LDRH     R0,[R5, #+24]
   \      0x308   0x0004             MOVS     R4,R0
   \      0x30A   0xE006             B        ??GetAnalogAmpsDemand_10
    504                }      
    505              }else{// lessthan OFF volatge
    506                 analog_demand_u32 = 0;
   \                     ??GetAnalogAmpsDemand_23: (+1)
   \      0x30C   0x003C             MOVS     R4,R7
    507                 analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_demandOn = FALSE;
   \      0x30E   0x2050             MOVS     R0,#+80
   \      0x310   0x5A28             LDRH     R0,[R5, R0]
   \      0x312   0x....             LDR      R1,??DataTable5_2  ;; 0xffef
   \      0x314   0x4001             ANDS     R1,R1,R0
   \      0x316   0x2050             MOVS     R0,#+80
   \      0x318   0x5229             STRH     R1,[R5, R0]
    508              }
    509              
    510              
    511              // Min demand is min_Demand_u16.
    512              if (analog_demand_u32 < analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16)
   \                     ??GetAnalogAmpsDemand_10: (+1)
   \      0x31A   0x8B28             LDRH     R0,[R5, #+24]
   \      0x31C   0x4284             CMP      R4,R0
   \      0x31E   0xD212             BCS      ??GetAnalogAmpsDemand_25
    513              {
    514                // Check if low end demand hysteresis
    515                if (analog_demand_u32 < (analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemand_u16 - analog_4_20ma_Control_ptr.analog_4_20mA_Setting.minDemandHysteresis_u16))
   \      0x320   0x8B28             LDRH     R0,[R5, #+24]
   \      0x322   0x8BA9             LDRH     R1,[R5, #+28]
   \      0x324   0x1A40             SUBS     R0,R0,R1
   \      0x326   0x4284             CMP      R4,R0
   \      0x328   0xD219             BCS      ??GetAnalogAmpsDemand_26
    516                {
    517                  analog_demand_u32 = 0;
   \      0x32A   0x003C             MOVS     R4,R7
    518                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_demandOn = FALSE;
   \      0x32C   0x0028             MOVS     R0,R5
   \      0x32E   0x3050             ADDS     R0,R0,#+80
   \      0x330   0x2150             MOVS     R1,#+80
   \      0x332   0x5A69             LDRH     R1,[R5, R1]
   \      0x334   0x....             LDR      R2,??DataTable5_2  ;; 0xffef
   \      0x336   0x400A             ANDS     R2,R2,R1
   \      0x338   0x8002             STRH     R2,[R0, #+0]
    519                  analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_lowerHysteresisEnable = FALSE;
   \      0x33A   0x2150             MOVS     R1,#+80
   \      0x33C   0x5A69             LDRH     R1,[R5, R1]
   \      0x33E   0x....             LDR      R2,??DataTable5_1  ;; 0xfffb
   \      0x340   0x400A             ANDS     R2,R2,R1
   \      0x342   0x8002             STRH     R2,[R0, #+0]
   \      0x344   0xE00B             B        ??GetAnalogAmpsDemand_26
    520                }
    521              } else {
    522                analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_demandOn = TRUE; // Demand greater than min demand.  
   \                     ??GetAnalogAmpsDemand_25: (+1)
   \      0x346   0x0028             MOVS     R0,R5
   \      0x348   0x3050             ADDS     R0,R0,#+80
   \      0x34A   0x2150             MOVS     R1,#+80
   \      0x34C   0x5A69             LDRH     R1,[R5, R1]
   \      0x34E   0x2210             MOVS     R2,#+16
   \      0x350   0x430A             ORRS     R2,R2,R1
   \      0x352   0x8002             STRH     R2,[R0, #+0]
    523                analog_4_20ma_Control_ptr.analog_4_20mA_Data.discretes_u16.is_lowerHysteresisEnable = TRUE; // Enable Hysteresis
   \      0x354   0x2150             MOVS     R1,#+80
   \      0x356   0x5A69             LDRH     R1,[R5, R1]
   \      0x358   0x2204             MOVS     R2,#+4
   \      0x35A   0x430A             ORRS     R2,R2,R1
   \      0x35C   0x8002             STRH     R2,[R0, #+0]
    524              }
    525              
    526              // Demand can't exceed max_Demand_u16
    527              if (analog_demand_u32 > analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxDemand_u16)
   \                     ??GetAnalogAmpsDemand_26: (+1)
   \      0x35E   0x8B68             LDRH     R0,[R5, #+26]
   \      0x360   0x42A0             CMP      R0,R4
   \      0x362   0xD201             BCS      ??GetAnalogAmpsDemand_2
    528              {
    529                analog_demand_u32 = (uint16_t)analog_4_20ma_Control_ptr.analog_4_20mA_Setting.maxDemand_u16;
   \      0x364   0x8B68             LDRH     R0,[R5, #+26]
   \      0x366   0x0004             MOVS     R4,R0
    530              }      
    531            }
    532            analog_4_20ma_Control_ptr.analog_4_20mA_Data.analogDemand_u16 = analog_demand_u32;
   \                     ??GetAnalogAmpsDemand_2: (+1)
   \      0x368   0x0020             MOVS     R0,R4
   \      0x36A   0x2148             MOVS     R1,#+72
   \      0x36C   0x5268             STRH     R0,[R5, R1]
    533            return ((uint16_t)analog_demand_u32);  
   \      0x36E   0x0020             MOVS     R0,R4
   \      0x370   0xB280             UXTH     R0,R0
   \      0x372   0xBDFE             POP      {R1-R7,PC}       ;; return
    534          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     processInfoTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x....'....        DC32     adc1_LocalAnalogAmpsControl_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     module_analog_4_20ma_poll_time_u64

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x4024'0000        DC32     0x40240000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x....'....        DC32     analog_4_20ma_Control_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x....'....        DC32     analog_amps_low_alarm_enable_count_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     analog_amps_counts_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x0000'FFEF        DC32     0xffef

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x0000'FFFB        DC32     0xfffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x0000'FFF7        DC32     0xfff7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \        0x0   0x....'....        DC32     analog_4_20ma_StructMem_u32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \        0x0   0x0000'026D        DC32     0x26d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \        0x0   0x0000'03A3        DC32     0x3a3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \        0x0   0x0000'0AE9        DC32     0xae9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \        0x0   0x0000'0FFF        DC32     0xfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \        0x0   0x0000'5555        DC32     0x5555

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \        0x0   0x0000'FFFF        DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \        0x0   0x0000'7FFF        DC32     0x7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x3DA5'0000        DC32     0x3da50000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x40FF'3F3F        DC32     0x40ff3f3f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x0000'FFFD        DC32     0xfffd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x....'....        DC32     analog_4_20ma_Control_ptr+0x3C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0xBF80'0000        DC32     0xbf800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0x0000'FFFE        DC32     0xfffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \        0x0   0x....'....        DC32     analog_amps_counts_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \        0x0   0x....'....        DC32     analog_4_20ma_Control_ptr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \        0x0   0x....'....        DC32     analog_amps_decreasing_debounce_count_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \        0x0   0x....'....        DC32     analog_amps_increasing_debounce_count_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \        0x0   0x0000'FFDF        DC32     0xffdf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \        0x0   0x....'....        DC32     analog_amps_low_alarm_enable_count_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x0000'FFF7        DC32     0xfff7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x0000'FFFB        DC32     0xfffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x0000'FFEF        DC32     0xffef

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   AssignModuleMemAnalog_4_20mA
        16   -> StructMem_CreateInstance
        16   -> getProcessInfoIndex
        16 __aeabi_uwrite4
      24   DebounceAnalogAmps
        24   -> __aeabi_f2iz
        24   -> __aeabi_fmul
        24   -> __aeabi_ui2f
        24   -> abs
      32   GetAnalogAmpsDemand
        32   -> __aeabi_f2uiz
        32   -> __aeabi_fadd
        32   -> __aeabi_fmul
        32   -> __aeabi_ui2f
      32   InitAnalogAmpsInputParameters
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> __aeabi_ui2f
       8   Init_Analog_4_20mA_Setting
      64   moduleAnalog_4_20mA
        64   -> AssignModuleMemAnalog_4_20mA
        64   -> DebounceAnalogAmps
        64   -> GetAnalogAmpsDemand
        64   -> InitAnalogAmpsInputParameters
        64   -> Init_Analog_4_20mA_Setting
        64   -> __aeabi_d2iz
        64   -> __aeabi_dmul
        64   -> __aeabi_f2d
        64   -> __aeabi_fdiv
        64   -> __aeabi_i2f
        64   -> getProcessInfoIndex
        64   -> getSysCount
        64 __aeabi_uread4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
      60  AssignModuleMemAnalog_4_20mA
     332  DebounceAnalogAmps
     884  GetAnalogAmpsDemand
     276  InitAnalogAmpsInputParameters
     138  Init_Analog_4_20mA_Setting
       4  adc1_LocalAnalogAmpsControl_ptr
      84  analog_4_20ma_Control_ptr
       4  analog_4_20ma_StructMem_u32
       2  analog_amps_counts_u16
       1  analog_amps_decreasing_debounce_count_u16
       1  analog_amps_increasing_debounce_count_u16
       1  analog_amps_low_alarm_enable_count_u16
       1  is_amps_above_loss_analog
     472  moduleAnalog_4_20mA
       8  module_analog_4_20ma_poll_time_u64

 
   106 bytes in section .bss
 2'294 bytes in section .text
 
 2'294 bytes of CODE memory
   106 bytes of DATA memory

Errors: none
Warnings: none

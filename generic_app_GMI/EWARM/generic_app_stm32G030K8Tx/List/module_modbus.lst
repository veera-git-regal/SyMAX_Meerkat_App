###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         11/Feb/2022  22:50:34
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Features\module_modbus.c
#    Command line                 =
#        -f C:\Users\610126~1\AppData\Local\Temp\EW6D37.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Features\module_modbus.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale                       =  C
#    List file                    =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\module_modbus.lst
#    Object file                  =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\module_modbus.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_full_locale_support =  1
#      __dlib_version             =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\FlexMouse\Features\module_modbus.c
      1          /**
      2          ********************************************************************************************************************************
      3          * @file    module_modbus.c 
      4          * @author  Myron Mychal
      5          * @brief   This is a module that handles MODBUS responses o to valid MODBUS requests
      6          * @details rocesses MODBUS funtion requst by responding with appropriate data
      7          ********************************************************************************************************************************
      8          */
      9          
     10          /* Includes --------------------------------------------------------------------------------------------------------------------*/
     11          #include "driver_usart1.h"
     12          #include "driver_usart2.h"
     13          #include "module_modbus_application_map.h"

   \                                 In section .bss, align 2
   \   __absolute uint16_t void_start_of_coils_pu16[1]
   \                     void_start_of_coils_pu16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
   \   __absolute uint16_t void_start_of_discretes_pu16[1]
   \                     void_start_of_discretes_pu16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
   \   __absolute uint16_t void_start_of_inputs_pu16[1]
   \                     void_start_of_inputs_pu16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
   \   __absolute uint16_t void_start_of_holdings_pu16[1]
   \                     void_start_of_holdings_pu16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 4
   \   __absolute uint16_t *module_start_of_coils_pu16
   \                     module_start_of_coils_pu16:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute uint16_t *module_start_of_discretes_pu16
   \                     module_start_of_discretes_pu16:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute uint16_t *module_start_of_inputs_pu16
   \                     module_start_of_inputs_pu16:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute uint16_t *module_start_of_holdings_pu16
   \                     module_start_of_holdings_pu16:
   \        0x0                      DS8 4

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_analog_inputs_0TO10_start_of_coils_pu16
   \                     module_analog_inputs_0TO10_start_of_coils_pu16:
   \        0x0   0x....'....        DC32 analogVolts_Control + 0x2a

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_analog_inputs_0TO10_start_of_discretes_pu16
   \                     module_analog_inputs_0TO10_start_of_discretes_pu16:
   \        0x0   0x....'....        DC32 analogVolts_Control + 0x4a

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_analog_inputs_0TO10_start_of_inputs_pu16
   \                     module_analog_inputs_0TO10_start_of_inputs_pu16:
   \        0x0   0x....'....        DC32 analogVolts_Control + 0x2c

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_analog_inputs_0TO10_start_of_holdings_pu16
   \                     module_analog_inputs_0TO10_start_of_holdings_pu16:
   \        0x0   0x....'....        DC32 analogVolts_Control

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_digital_inputs_start_of_coils_pu16
   \                     module_digital_inputs_start_of_coils_pu16:
   \        0x0   0x....'....        DC32 void_start_of_coils_pu16

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_digital_inputs_start_of_discretes_pu16
   \                     module_digital_inputs_start_of_discretes_pu16:
   \        0x0   0x....'....        DC32 digitalInputs_Control + 0x4e

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_digital_inputs_start_of_inputs_pu16
   \                     module_digital_inputs_start_of_inputs_pu16:
   \        0x0   0x....'....        DC32 digitalInputs_Control + 0x28

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_digital_inputs_start_of_holdings_pu16
   \                     module_digital_inputs_start_of_holdings_pu16:
   \        0x0   0x....'....        DC32 digitalInputs_Control

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_pwm_input_start_of_coils_pu16
   \                     module_pwm_input_start_of_coils_pu16:
   \        0x0   0x....'....        DC32 pwmInput_Control + 0x2a

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_pwm_input_start_of_discretes_pu16
   \                     module_pwm_input_start_of_discretes_pu16:
   \        0x0   0x....'....        DC32 pwmInput_Control + 0x4c

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_pwm_input_start_of_inputs_pu16
   \                     module_pwm_input_start_of_inputs_pu16:
   \        0x0   0x....'....        DC32 pwmInput_Control + 0x2c

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_pwm_input_start_of_holdings_pu16
   \                     module_pwm_input_start_of_holdings_pu16:
   \        0x0   0x....'....        DC32 pwmInput_Control

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_modbus_rtu_start_of_coils_pu16
   \                     module_modbus_rtu_start_of_coils_pu16:
   \        0x0   0x....'....        DC32 modbus_RTU_Control + 0xa

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_modbus_rtu_start_of_discretes_pu16
   \                     module_modbus_rtu_start_of_discretes_pu16:
   \        0x0   0x....'....        DC32 void_start_of_discretes_pu16

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_modbus_rtu_start_of_holdings_pu16
   \                     module_modbus_rtu_start_of_holdings_pu16:
   \        0x0   0x....'....        DC32 modbus_RTU_Control

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_modbus_rtu_start_of_inputs_pu16
   \                     module_modbus_rtu_start_of_inputs_pu16:
   \        0x0   0x....'....        DC32 modbus_RTU_Control + 0xc

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_analog_inputs_4TO20_start_of_coils_pu16
   \                     module_analog_inputs_4TO20_start_of_coils_pu16:
   \        0x0   0x....'....        DC32 analog_4_20ma_Control_ptr + 0x2e

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_analog_inputs_4TO20_start_of_discretes_pu16
   \                     module_analog_inputs_4TO20_start_of_discretes_pu16:
   \        0x0   0x....'....        DC32 analog_4_20ma_Control_ptr + 0x50

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_analog_inputs_4TO20_start_of_inputs_pu16
   \                     module_analog_inputs_4TO20_start_of_inputs_pu16:
   \        0x0   0x....'....        DC32 analog_4_20ma_Control_ptr + 0x30

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_analog_inputs_4TO20_start_of_holdings_pu16
   \                     module_analog_inputs_4TO20_start_of_holdings_pu16:
   \        0x0   0x....'....        DC32 analog_4_20ma_Control_ptr

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_demand_multiplexer_start_of_coils_pu16
   \                     module_demand_multiplexer_start_of_coils_pu16:
   \        0x0   0x....'....        DC32 void_start_of_coils_pu16

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_demand_multiplexer_start_of_discretes_pu16
   \                     module_demand_multiplexer_start_of_discretes_pu16:
   \        0x0   0x....'....        DC32 void_start_of_discretes_pu16

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_demand_multiplexer_start_of_inputs_pu16
   \                     module_demand_multiplexer_start_of_inputs_pu16:
   \        0x0   0x....'....        DC32 motorDemandMux_Control + 0x10

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_demand_multiplexer_start_of_holdings_pu16
   \                     module_demand_multiplexer_start_of_holdings_pu16:
   \        0x0   0x....'....        DC32 motorDemandMux_Control

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_digital_outputs_start_of_coils_pu16
   \                     module_digital_outputs_start_of_coils_pu16:
   \        0x0   0x....'....        DC32 void_start_of_coils_pu16

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_digital_outputs_start_of_discretes_pu16
   \                     module_digital_outputs_start_of_discretes_pu16:
   \        0x0   0x....'....        DC32 digital_Outputs_Control + 0x4c

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_digital_outputs_start_of_holdings_pu16
   \                     module_digital_outputs_start_of_holdings_pu16:
   \        0x0   0x....'....        DC32 digital_Outputs_Control

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_digital_outputs_start_of_inputs_pu16
   \                     module_digital_outputs_start_of_inputs_pu16:
   \        0x0   0x....'....        DC32 digital_Outputs_Control + 0x44

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_motor_communication_start_of_coils_pu16
   \                     module_motor_communication_start_of_coils_pu16:
   \        0x0   0x....'....        DC32 void_start_of_coils_pu16

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_motor_communication_start_of_discretes_pu16
   \                     module_motor_communication_start_of_discretes_pu16:
   \        0x0   0x....'....        DC32 motor_Com_Control + 0x32

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_motor_communication_start_of_holdings_pu16
   \                     module_motor_communication_start_of_holdings_pu16:
   \        0x0   0x....'....        DC32 motor_Com_Control

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_motor_communication_start_of_inputs_pu16
   \                     module_motor_communication_start_of_inputs_pu16:
   \        0x0   0x....'....        DC32 motor_Com_Control + 0x14

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_test_start_of_coils_pu16
   \                     module_test_start_of_coils_pu16:
   \        0x0   0x....'....        DC32 moduleTest_Control + 0xe

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_test_start_of_discretes_pu16
   \                     module_test_start_of_discretes_pu16:
   \        0x0   0x....'....        DC32 moduleTest_Control + 0x14

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_test_start_of_holdings_pu16
   \                     module_test_start_of_holdings_pu16:
   \        0x0   0x....'....        DC32 moduleTest_Control

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_test_start_of_inputs_pu16
   \                     module_test_start_of_inputs_pu16:
   \        0x0   0x....'....        DC32 moduleTest_Control + 0x10

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_application_id_start_of_coils_pu16
   \                     module_application_id_start_of_coils_pu16:
   \        0x0   0x....'....        DC32 application_id_control + 0x6

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_application_id_start_of_discretes_pu16
   \                     module_application_id_start_of_discretes_pu16:
   \        0x0   0x....'....        DC32 application_id_control + 0xa

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_application_id_start_of_holdings_pu16
   \                     module_application_id_start_of_holdings_pu16:
   \        0x0   0x....'....        DC32 application_id_control

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_application_id_start_of_inputs_pu16
   \                     module_application_id_start_of_inputs_pu16:
   \        0x0   0x....'....        DC32 application_id_control + 0x8
     14          #include "module_modbus_drive_map.h"

   \                                 In section .bss, align 2
   \   __absolute uint16_t void_drive_start_of_coils_pu16[1]
   \                     void_drive_start_of_coils_pu16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
   \   __absolute uint16_t void_drive_start_of_discretes_pu16[1]
   \                     void_drive_start_of_discretes_pu16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
   \   __absolute uint16_t void_drive_start_of_inputs_pu16[1]
   \                     void_drive_start_of_inputs_pu16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 2
   \   __absolute uint16_t void_drive_start_of_holdings_pu16[1]
   \                     void_drive_start_of_holdings_pu16:
   \        0x0                      DS8 2

   \                                 In section .bss, align 4
   \   __absolute uint16_t *module_drive_start_of_coils_pu16
   \                     module_drive_start_of_coils_pu16:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute uint16_t *module_drive_start_of_discretes_pu16
   \                     module_drive_start_of_discretes_pu16:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute uint16_t *module_drive_start_of_inputs_pu16
   \                     module_drive_start_of_inputs_pu16:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute uint16_t *module_drive_start_of_holdings_pu16
   \                     module_drive_start_of_holdings_pu16:
   \        0x0                      DS8 4

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_drive_dynamic_start_of_coils_pu16
   \                     module_drive_dynamic_start_of_coils_pu16:
   \        0x0   0x....'....        DC32 drive_dynamic_control + 0xa

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_drive_dynamic_start_of_discretes_pu16
   \                     module_drive_dynamic_start_of_discretes_pu16:
   \        0x0   0x....'....        DC32 drive_dynamic_control + 0x22

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_drive_dynamic_start_of_inputs_pu16
   \                     module_drive_dynamic_start_of_inputs_pu16:
   \        0x0   0x....'....        DC32 drive_dynamic_control + 0xc

   \                                 In section .data, align 4
   \   __absolute uint16_t *module_drive_dynamic_start_of_holdings_pu16
   \                     module_drive_dynamic_start_of_holdings_pu16:
   \        0x0   0x....'....        DC32 drive_dynamic_control
     15          #include "module_motor_demand_multiplexer.h"
     16          //#include "main.h"
     17          #include "stm32g0xx_ll_iwdg.h" // TODO: Watchdog is for Bootloader Resets only. Move Bootloader Features to a better location

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_IWDG_Enable(IWDG_TypeDef *)
   \                     LL_IWDG_Enable: (+1)
   \        0x0   0x....             LDR      R1,??DataTable3  ;; 0xcccc
   \        0x2   0x6001             STR      R1,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_IWDG_EnableWriteAccess(IWDG_TypeDef *)
   \                     LL_IWDG_EnableWriteAccess: (+1)
   \        0x0   0x....             LDR      R1,??DataTable3_1  ;; 0x5555
   \        0x2   0x6001             STR      R1,[R0, #+0]
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_IWDG_SetPrescaler(IWDG_TypeDef *, uint32_t)
   \                     LL_IWDG_SetPrescaler: (+1)
   \        0x0   0x074A             LSLS     R2,R1,#+29       ;; ZeroExtS R2,R1,#+29,#+29
   \        0x2   0x0F52             LSRS     R2,R2,#+29
   \        0x4   0x6042             STR      R2,[R0, #+4]
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_IWDG_SetReloadCounter(IWDG_TypeDef *, uint32_t)
   \                     LL_IWDG_SetReloadCounter: (+1)
   \        0x0   0x050A             LSLS     R2,R1,#+20       ;; ZeroExtS R2,R1,#+20,#+20
   \        0x2   0x0D12             LSRS     R2,R2,#+20
   \        0x4   0x6082             STR      R2,[R0, #+8]
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_IWDG_SetWindow(IWDG_TypeDef *, uint32_t)
   \                     LL_IWDG_SetWindow: (+1)
   \        0x0   0x050A             LSLS     R2,R1,#+20       ;; ZeroExtS R2,R1,#+20,#+20
   \        0x2   0x0D12             LSRS     R2,R2,#+20
   \        0x4   0x6102             STR      R2,[R0, #+16]
   \        0x6   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t LL_IWDG_IsReady(IWDG_TypeDef *)
   \                     LL_IWDG_IsReady: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x68C0             LDR      R0,[R0, #+12]
   \        0x4   0x0740             LSLS     R0,R0,#+29       ;; ZeroExtS R0,R0,#+29,#+29
   \        0x6   0x0F40             LSRS     R0,R0,#+29
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD101             BNE      ??LL_IWDG_IsReady_0
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE000             B        ??LL_IWDG_IsReady_1
   \                     ??LL_IWDG_IsReady_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \                     ??LL_IWDG_IsReady_1: (+1)
   \       0x12   0xBD00             POP      {PC}             ;; return
     18          
     19          typedef struct ModbusDataRangeStruct
     20          {
     21            uint16_t	minimum_value_u16;
     22            uint16_t	maximum_value_u16;
     23          } ModbusDataRange;
     24          
     25          typedef struct ModbusMapBlockStruct
     26          {
     27            uint16_t *start_of_data_pu16;		// a pointer to where the sequential data used by the motor is stored
     28            uint16_t start_address_u16;	        // the modbus start address
     29            uint8_t number_of_registers_u8;	// number registers from the start address in this struct
     30            //ModbusDataRange data_range_pu16[];	// store the minimum values for the data in this block (sequentially)
     31            //uint16_t maximum_values_pu16[];	// store the maximum values for the data in this block (sequentially)	
     32          } ModbusMapBlock;
     33          
     34          typedef struct ModbusCoilMapBlockStruct
     35          {
     36            uint16_t *start_of_coil_data_pu16;		// a pointer to where the sequential data used by the motor is stored
     37            uint16_t start_coil_address_u16;	    	// the modbus start address
     38            uint8_t number_of_coil_registers_u8;	// number registers from the start address in this struct
     39            uint8_t number_of_coils_u8;				// number registers from the start address in this struct 
     40          } ModbusCoilMapBlock;
     41          
     42          // Now each modbus block has to be defined to point to a valid data structure and exactly match its sizes
     43          // MODBUS BLocks:
     44          //
     45          // Monitor
     46          // Operation
     47          

   \                                 In section .bss, align 4
     48          int16_t  hi_amplitude_s16[8]; 		
   \                     hi_amplitude_s16:
   \        0x0                      DS8 16

   \                                 In section .bss, align 4
     49          uint8_t  hi_angle_multiplier_hi_u8[8];
   \                     hi_angle_multiplier_hi_u8:
   \        0x0                      DS8 8

   \                                 In section .bss, align 4
     50          uint16_t hi_angle_offset_u16[8]; 		
   \                     hi_angle_offset_u16:
   \        0x0                      DS8 16

   \                                 In section .bss, align 4
     51          uint8_t  hi_is_phase_inverted_u8[8]; 	
   \                     hi_is_phase_inverted_u8:
   \        0x0                      DS8 8

   \                                 In section .bss, align 4
     52          uint16_t hi_min_speed_u16[8]; 		
   \                     hi_min_speed_u16:
   \        0x0                      DS8 16

   \                                 In section .bss, align 4
     53          uint16_t hi_max_speed_u16[8]; 		
   \                     hi_max_speed_u16:
   \        0x0                      DS8 16

   \                                 In section .bss, align 1
     54          uint8_t  hi_is_harmonic_injection_allowed_hi_u8; 
   \                     hi_is_harmonic_injection_allowed_hi_u8:
   \        0x0                      DS8 1
     55          

   \                                 In section .bss, align 8
     56          uint64_t tt_ModbusLinkLostStop;
   \                     tt_ModbusLinkLostStop:
   \        0x0                      DS8 8
     57          #define MODBUS_LOST_LINK_TIME 3000//10000
     58          
     59          #define NUM_MODBUS_REGISTERS_5000s 1 // 49

   \                                 In section .bss, align 2
     60          uint16_t modbusRegisters5000s[NUM_MODBUS_REGISTERS_5000s] = {
   \                     modbusRegisters5000s:
   \        0x0                      DS8 2
     61            0,		// HI ENable/Disable		5000	
     62          /*  0,		// Amplitude 1				5001	
     63            0,		// Amplitude 2				5002	
     64            0,		// Amplitude 3				5003	
     65            0,		// Amplitude 4				5004	
     66            0,		// Amplitude 5				5005		
     67            0,		// Amplitude 6				5006	
     68            0,		// Amplitude 7				5007	
     69            0,		// Amplitude 8				5008	
     70            0,		// Angle Multiplier 1 		5009	
     71            0,		// Angle Multiplier 2 		5010	
     72            0,		// Angle Multiplier 3 		5011	
     73            0,		// Angle Multiplier 4 		5012
     74            0,		// Angle Multiplier 5 		5013	
     75            0,		// Angle Multiplier 6 		5014  
     76            0,		// Angle Multiplier 7 		5015	
     77            0,		// Angle Multiplier 8 		5016	
     78            0,		// Angle Offset 1 			5017
     79            0,		// Angle Offset 2 			5018
     80            0,		// Angle Offset 3 			5019
     81            0,		// Angle Offset 4 			5020
     82            0,		// Angle Offset 5 			5021
     83            0,		// Angle Offset 6 			5022
     84            0,		// Angle Offset 7 			5023
     85            0,		// Angle Offset 8 			5024
     86            0,		// Phase Inversion 1 		5025
     87            0,		// Phase Inversion 2 		5026
     88            0,		// Phase Inversion 3 		5027
     89            0,		// Phase Inversion 4 		5028
     90            0,		// Phase Inversion 5 		5029
     91            0,		// Phase Inversion 6 		5030
     92            0,		// Phase Inversion 7 		5031
     93            0,		// Phase Inversion 8 		5032
     94            0,		// Minimum Speed 1 			5033
     95            0,		// Minimum Speed 2 			5034
     96            0,		// Minimum Speed 3 			5035
     97            0,		// Minimum Speed 4 			5036
     98            0,		// Minimum Speed 5 			5037
     99            0,		// Minimum Speed 6 			5038
    100            0,		// Minimum Speed 7 			5039
    101            0,		// Minimum Speed 8 			5040
    102            2250,		// Maximum Speed 1 			5041
    103            2250,		// Maximum Speed 2 			5042
    104            2250,		// Maximum Speed 3 			5043
    105            2250,		// Maximum Speed 4 			5044
    106            2250,		// Maximum Speed 5 			5045
    107            2250,		// Maximum Speed 6 			5046
    108            2250,		// Maximum Speed 7 			5047
    109            2250		// Maximum Speed 8 			5048  
    110          */
    111          };
    112            

   \                                 In section .data, align 4
    113          ModbusMapBlock BlockHarmonic =
   \                     BlockHarmonic:
   \        0x0   0x....'....        DC32 modbusRegisters5000s
   \        0x4   0x1388             DC16 5'000
   \        0x6   0x01               DC8 1
   \        0x7                      DS8 1
    114          {
    115            //	(uint16_t *)&measued_speed_u16,	// first data value in block
    116            modbusRegisters5000s,				// first data value in block
    117            5000,						// starting address for block
    118            NUM_MODBUS_REGISTERS_5000s,			// number of elements in block
    119          };
    120          

   \                                 In section .data, align 4
    121          ModbusCoilMapBlock BlockAnalog0TO10V_Coils =
   \                     BlockAnalog0TO10V_Coils:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8800             DC16 34'816
   \        0x6   0x01 0x05          DC8 1, 5
    122          {
    123            0,				// first data value in block
    124            MODULE_ANALOG_INPUTS_0TO10_START_OF_COILS_ADDRESS,	// starting address for block
    125            MODULE_ANALOG_INPUTS_0TO10_NUMBER_OF_COIL_REGISTERS,	// number of coil words in block
    126            MODULE_ANALOG_INPUTS_0TO10_NUMBER_OF_COILS,			// number of coil bits in block
    127          };
    128          

   \                                 In section .data, align 4
    129          ModbusCoilMapBlock BlockPWMInputs_Coils =
   \                     BlockPWMInputs_Coils:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8A00             DC16 35'328
   \        0x6   0x01 0x04          DC8 1, 4
    130          {
    131            0,				// first data value in block
    132            MODULE_PWM_INPUT_START_OF_COILS_ADDRESS,	// starting address for block
    133            MODULE_PWM_INPUT_NUMBER_OF_COIL_REGISTERS,	// number of coil words in block
    134            MODULE_PWM_INPUT_NUMBER_OF_COILS,			// number of coil bits in block
    135          };
    136          

   \                                 In section .data, align 4
    137          ModbusMapBlock BlockAnalog0TO10V_Inputs =
   \                     BlockAnalog0TO10V_Inputs:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8828             DC16 34'856
   \        0x6   0x0F               DC8 15
   \        0x7                      DS8 1
    138          {
    139            0,				// first data value in block
    140            MODULE_ANALOG_INPUTS_0TO10_START_OF_INPUTS_ADDRESS,	// starting address for block
    141            MODULE_ANALOG_INPUTS_0TO10_NUMBER_OF_INPUTS,			// number of elements in block					
    142          };
    143          

   \                                 In section .data, align 4
    144          ModbusMapBlock BlockAnalog0TO10V_Holdings =
   \                     BlockAnalog0TO10V_Holdings:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8868             DC16 34'920
   \        0x6   0x15               DC8 21
   \        0x7                      DS8 1
    145          {
    146            0,				// first data value in block
    147            MODULE_ANALOG_INPUTS_0TO10_START_OF_HOLDINGS_ADDRESS,	// starting address for block
    148            MODULE_ANALOG_INPUTS_0TO10_NUMBER_OF_HOLDINGS,		// number of elements in block				
    149          };
    150          
    151          
    152          

   \                                 In section .data, align 4
    153          ModbusCoilMapBlock BlockDigitalInputs_Discrete =
   \                     BlockDigitalInputs_Discrete:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8910             DC16 35'088
   \        0x6   0x01 0x02          DC8 1, 2
    154          {
    155            0,				// first data value in block
    156            MODULE_DIGITAL_INPUTS_START_OF_DISCRETES_ADDRESS,	// starting address for block
    157            MODULE_DIGITAL_INPUTS_NUMBER_OF_DISCRETE_REGISTERS,	// number of coil words in block
    158            MODULE_DIGITAL_INPUTS_NUMBER_OF_DISCRETES,			// number of coil bits in block
    159          };
    160          

   \                                 In section .data, align 4
    161          ModbusMapBlock BlockDigitalInputs_Inputs =
   \                     BlockDigitalInputs_Inputs:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8928             DC16 35'112
   \        0x6   0x13               DC8 19
   \        0x7                      DS8 1
    162          {
    163            0,				// first data value in block
    164            MODULE_DIGITAL_INPUTS_START_OF_INPUTS_ADDRESS,	// starting address for block
    165            MODULE_DIGITAL_INPUTS_NUMBER_OF_INPUTS,			// number of elements in block				
    166          };
    167          

   \                                 In section .data, align 4
    168          ModbusMapBlock BlockDigitalInputs_Holdings =
   \                     BlockDigitalInputs_Holdings:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8968             DC16 35'176
   \        0x6   0x13               DC8 19
   \        0x7                      DS8 1
    169          {
    170            0,				// first data value in block
    171            MODULE_DIGITAL_INPUTS_START_OF_HOLDINGS_ADDRESS,	// starting address for block
    172            MODULE_DIGITAL_INPUTS_NUMBER_OF_HOLDINGS,			// number of elements in block					
    173          };
    174          

   \                                 In section .data, align 4
    175          ModbusCoilMapBlock BlockDigitalOutputs_Discrete =
   \                     BlockDigitalOutputs_Discrete:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x9010             DC16 36'880
   \        0x6   0x01 0x01          DC8 1, 1
    176          {
    177            0,				// first data value in block
    178            MODULE_DIGITAL_OUTPUTS_START_OF_DISCRETES_ADDRESS,	// starting address for block
    179            MODULE_DIGITAL_OUTPUTS_NUMBER_OF_DISCRETE_REGISTERS,	// number of coil words in block
    180            MODULE_DIGITAL_OUTPUTS_NUMBER_OF_DISCRETES,			// number of coil bits in block
    181          };
    182          

   \                                 In section .data, align 4
    183          ModbusMapBlock BlockDigitalOutputs_Inputs =
   \                     BlockDigitalOutputs_Inputs:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x9028             DC16 36'904
   \        0x6   0x04               DC8 4
   \        0x7                      DS8 1
    184          {
    185            0,				// first data value in block
    186            MODULE_DIGITAL_OUTPUTS_START_OF_INPUTS_ADDRESS,	// starting address for block
    187            MODULE_DIGITAL_OUTPUTS_NUMBER_OF_INPUTS,			// number of elements in block				
    188          };
    189          

   \                                 In section .data, align 4
    190          ModbusMapBlock BlockDigitalOutputs_Holdings =
   \                     BlockDigitalOutputs_Holdings:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x9068             DC16 36'968
   \        0x6   0x22               DC8 34
   \        0x7                      DS8 1
    191          {
    192            0,				// first data value in block
    193            MODULE_DIGITAL_OUTPUTS_START_OF_HOLDINGS_ADDRESS,	// starting address for block
    194            MODULE_DIGITAL_OUTPUTS_NUMBER_OF_HOLDINGS,		// number of elements in block					
    195          };
    196          
    197          

   \                                 In section .data, align 4
    198          ModbusMapBlock BlockPWMInputs_Inputs =
   \                     BlockPWMInputs_Inputs:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8A28             DC16 35'368
   \        0x6   0x10               DC8 16
   \        0x7                      DS8 1
    199          {
    200            0,				// first data value in block
    201            MODULE_PWM_INPUT_START_OF_INPUTS_ADDRESS,	// starting address for block
    202            MODULE_PWM_INPUT_NUMBER_OF_INPUTS,			// number of elements in block				
    203          };
    204          

   \                                 In section .data, align 4
    205          ModbusMapBlock BlockPWMInputs_Holdings =
   \                     BlockPWMInputs_Holdings:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8A68             DC16 35'432
   \        0x6   0x15               DC8 21
   \        0x7                      DS8 1
    206          {
    207            0,				// first data value in block
    208            MODULE_PWM_INPUT_START_OF_HOLDINGS_ADDRESS,	// starting address for block
    209            MODULE_PWM_INPUT_NUMBER_OF_HOLDINGS,		// number of elements in block			
    210          };
    211          

   \                                 In section .data, align 4
    212          ModbusCoilMapBlock BlockModbusRTU_Coils =
   \                     BlockModbusRTU_Coils:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8B00             DC16 35'584
   \        0x6   0x01 0x06          DC8 1, 6
    213          {
    214            0,				// first data value in block
    215            MODULE_MODBUS_RTU_START_OF_COILS_ADDRESS,	// starting address for block
    216            MODULE_MODBUS_RTU_NUMBER_OF_COIL_REGISTERS,	// number of coil words in block
    217            MODULE_MODBUS_RTU_NUMBER_OF_COILS,			// number of coil bits in block
    218          };
    219          

   \                                 In section .data, align 4
    220          ModbusCoilMapBlock BlockAnalog0TO10V_Discrete =
   \                     BlockAnalog0TO10V_Discrete:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8810             DC16 34'832
   \        0x6   0x01 0x06          DC8 1, 6
    221          {
    222            0,				// first data value in block
    223            MODULE_ANALOG_INPUTS_0TO10_START_OF_DISCRETES_ADDRESS,	// starting address for block
    224            MODULE_ANALOG_INPUTS_0TO10_NUMBER_OF_DISCRETE_REGISTERS,			// number of coil words in block
    225            MODULE_ANALOG_INPUTS_0TO10_NUMBER_OF_DISCRETES,			// number of coil bits in block
    226          };
    227          

   \                                 In section .data, align 4
    228          ModbusCoilMapBlock BlockPWMInputs_Discrete =
   \                     BlockPWMInputs_Discrete:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8A10             DC16 35'344
   \        0x6   0x01 0x09          DC8 1, 9
    229          {
    230            0,				// first data value in block
    231            MODULE_PWM_INPUT_START_OF_DISCRETES_ADDRESS,	// starting address for block
    232            MODULE_PWM_INPUT_NUMBER_OF_DISCRETE_REGISTERS,			// number of coil words in block
    233            MODULE_PWM_INPUT_NUMBER_OF_DISCRETES,			// number of coil bits in block
    234          };
    235          

   \                                 In section .data, align 4
    236          ModbusMapBlock BlockModbusRTU_Inputs =
   \                     BlockModbusRTU_Inputs:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8B28             DC16 35'624
   \        0x6   0x01               DC8 1
   \        0x7                      DS8 1
    237          {
    238            0,				// first data value in block
    239            MODULE_MODBUS_RTU_START_OF_INPUTS_ADDRESS,	// starting address for block
    240            MODULE_MODBUS_RTU_NUMBER_OF_INPUTS,			// number of elements in block					
    241          };
    242          

   \                                 In section .data, align 4
    243          ModbusMapBlock BlockModbusRTU_Holdings =
   \                     BlockModbusRTU_Holdings:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8B68             DC16 35'688
   \        0x6   0x05               DC8 5
   \        0x7                      DS8 1
    244          {
    245            0,				// first data value in block
    246            MODULE_MODBUS_RTU_START_OF_HOLDINGS_ADDRESS,	// starting address for block
    247            MODULE_MODBUS_RTU_NUMBER_OF_HOLDINGS,		// number of elements in block				
    248          };
    249          

   \                                 In section .data, align 4
    250          ModbusCoilMapBlock BlockAnalog4TO20_Coils =
   \                     BlockAnalog4TO20_Coils:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8C00             DC16 35'840
   \        0x6   0x01 0x05          DC8 1, 5
    251          {
    252            0,				// first data value in block
    253            MODULE_ANALOG_INPUTS_4TO20_START_OF_COILS_ADDRESS,	// starting address for block
    254            MODULE_ANALOG_INPUTS_4TO20_NUMBER_OF_COIL_REGISTERS,	// number of coil words in block
    255            MODULE_ANALOG_INPUTS_4TO20_NUMBER_OF_COILS,			// number of coil bits in block
    256          };
    257          

   \                                 In section .data, align 4
    258          ModbusCoilMapBlock BlockAnalog4TO20_Discrete =
   \                     BlockAnalog4TO20_Discrete:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8C10             DC16 35'856
   \        0x6   0x01 0x06          DC8 1, 6
    259          {
    260            0,				// first data value in block
    261            MODULE_ANALOG_INPUTS_4TO20_START_OF_DISCRETES_ADDRESS,	// starting address for block
    262            MODULE_ANALOG_INPUTS_4TO20_NUMBER_OF_DISCRETE_REGISTERS,	// number of coil words in block
    263            MODULE_ANALOG_INPUTS_4TO20_NUMBER_OF_DISCRETES,			// number of coil bits in block
    264          };
    265          

   \                                 In section .data, align 4
    266          ModbusMapBlock BlockAnalog4TO20_Inputs =
   \                     BlockAnalog4TO20_Inputs:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8C28             DC16 35'880
   \        0x6   0x10               DC8 16
   \        0x7                      DS8 1
    267          {
    268            0,				// first data value in block
    269            MODULE_ANALOG_INPUTS_4TO20_START_OF_INPUTS_ADDRESS,	// starting address for block
    270            MODULE_ANALOG_INPUTS_4TO20_NUMBER_OF_INPUTS,			// number of elements in block				
    271          };
    272          

   \                                 In section .data, align 4
    273          ModbusMapBlock BlockAnalog4TO20_Holdings =
   \                     BlockAnalog4TO20_Holdings:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8C68             DC16 35'944
   \        0x6   0x17               DC8 23
   \        0x7                      DS8 1
    274          {
    275            0,				// first data value in block
    276            MODULE_ANALOG_INPUTS_4TO20_START_OF_HOLDINGS_ADDRESS,	// starting address for block
    277            MODULE_ANALOG_INPUTS_4TO20_NUMBER_OF_HOLDINGS,		// number of elements in block				
    278          };
    279          

   \                                 In section .data, align 4
    280          ModbusMapBlock BlockDemandMultiplexer_Inputs =
   \                     BlockDemandMultiplexer_Inputs:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8D28             DC16 36'136
   \        0x6   0x02               DC8 2
   \        0x7                      DS8 1
    281          {
    282            0,				// first data value in block
    283            MODULE_DEMAND_MULTIPLEXER_START_OF_INPUTS_ADDRESS,	// starting address for block
    284            MODULE_DEMAND_MULTIPLEXER_NUMBER_OF_INPUTS,			// number of elements in block					
    285          };
    286          

   \                                 In section .data, align 4
    287          ModbusMapBlock BlockDemandMultiplexer_Holdings =
   \                     BlockDemandMultiplexer_Holdings:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x8D68             DC16 36'200
   \        0x6   0x08               DC8 8
   \        0x7                      DS8 1
    288          {
    289            0,				// first data value in block
    290            MODULE_DEMAND_MULTIPLEXER_START_OF_HOLDINGS_ADDRESS,	// starting address for block
    291            MODULE_DEMAND_MULTIPLEXER_NUMBER_OF_HOLDINGS,		// number of elements in block				
    292          };
    293          

   \                                 In section .data, align 4
    294          ModbusCoilMapBlock BlockMotorCommunication_Discrete =
   \                     BlockMotorCommunication_Discrete:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x9110             DC16 37'136
   \        0x6   0x01 0x01          DC8 1, 1
    295          {
    296            0,				// first data value in block
    297            MODULE_MOTOR_COMMUNICATION_START_OF_DISCRETES_ADDRESS,	// starting address for block
    298            MODULE_MOTOR_COMMUNICATION_NUMBER_OF_DISCRETE_REGISTERS,	// number of coil words in block
    299            MODULE_MOTOR_COMMUNICATION_NUMBER_OF_DISCRETES,			// number of coil bits in block
    300          };
    301          

   \                                 In section .data, align 4
    302          ModbusMapBlock BlockMotorCommunication_Inputs =
   \                     BlockMotorCommunication_Inputs:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x9128             DC16 37'160
   \        0x6   0x0F               DC8 15
   \        0x7                      DS8 1
    303          {
    304            0,				// first data value in block
    305            MODULE_MOTOR_COMMUNICATION_START_OF_INPUTS_ADDRESS,	// starting address for block
    306            MODULE_MOTOR_COMMUNICATION_NUMBER_OF_INPUTS,			// number of elements in block					
    307          };
    308          

   \                                 In section .data, align 4
    309          ModbusMapBlock BlockMotorCommunication_Holdings =
   \                     BlockMotorCommunication_Holdings:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x9168             DC16 37'224
   \        0x6   0x09               DC8 9
   \        0x7                      DS8 1
    310          {
    311            0,				// first data value in block
    312            MODULE_MOTOR_COMMUNICATION_START_OF_HOLDINGS_ADDRESS,	// starting address for block
    313            MODULE_MOTOR_COMMUNICATION_NUMBER_OF_HOLDINGS,		// number of elements in block					
    314          };
    315          
    316          /***
    317          ModbusMapBlock BlockFirmwareUpdate_Inputs =
    318          {
    319            0,				// first data value in block
    320            MODULE_FIRMWARE_UPDATE_START_OF_INPUTS_ADDRESS,	// starting address for block
    321            MODULE_FIRMWARE_UPDATE_NUMBER_OF_INPUTS,			// number of elements in block					
    322          };
    323          
    324          ModbusMapBlock BlockFirmwareUpdate_Holdings =
    325          {
    326            0,				// first data value in block
    327            MODULE_FIRMWARE_UPDATE_START_OF_HOLDINGS_ADDRESS,	// starting address for block
    328            MODULE_FIRMWARE_UPDATE_NUMBER_OF_HOLDINGS,		// number of elements in block				
    329          };
    330          
    331          ModbusMapBlock BlockFlashBlock_Inputs =
    332          {
    333            0,				// first data value in block
    334            MODULE_FLASH_BLOCK_START_OF_INPUTS_ADDRESS,	// starting address for block
    335            MODULE_FLASH_BLOCK_NUMBER_OF_INPUTS,			// number of elements in block				
    336          };
    337          ***/
    338          
    339          /***
    340          ModbusCoilMapBlock BlockApplicationID_Coils =
    341          {
    342            0,				// first data value in block
    343            MODULE_APP_ID_START_OF_COILS_ADDRESS,	// starting address for block
    344            MODULE_APP_ID_NUMBER_OF_COIL_REGISTERS,	// number of coil words in block
    345            MODULE_APP_ID_NUMBER_OF_COILS,			// number of coil bits in block
    346          };
    347          
    348          ModbusMapBlock BlockApplicationID_Holdings =
    349          {
    350            0,				// first data value in block
    351            MODULE_APP_ID_START_OF_HOLDINGS_ADDRESS,	// starting address for block
    352            MODULE_APP_ID_NUMBER_OF_HOLDINGS,			// number of elements in block					
    353          };
    354          
    355          ModbusCoilMapBlock BlockApplicationID_Discretes =
    356          {
    357            0,				// first data value in block
    358            MODULE_APP_ID_START_OF_DISCRETES_ADDRESS,	// starting address for block
    359            MODULE_APP_ID_NUMBER_OF_DISCRETE_REGISTERS,	// number of coil words in block
    360            MODULE_APP_ID_NUMBER_OF_DISCRETES,			// number of coil bits in block
    361          };
    362          
    363          ModbusMapBlock BlockApplicationID_Inputs =
    364          {
    365            0,				// first data value in block
    366            MODULE_APP_ID_START_OF_INPUTS_ADDRESS,	// starting address for block
    367            MODULE_APP_ID_NUMBER_OF_INPUTS,			// number of elements in block				
    368          };
    369          ***/
    370          

   \                                 In section .data, align 4
    371          ModbusCoilMapBlock BlockDriveDynamic_Coils =
   \                     BlockDriveDynamic_Coils:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x0000             DC16 0
   \        0x6   0x01 0x01          DC8 1, 1
    372          {
    373            0,				// first data value in block
    374            MODULE_DRIVE_DYNAMIC_START_OF_COILS_ADDRESS,	// starting address for block
    375            MODULE_DRIVE_DYNAMIC_NUMBER_OF_COIL_REGISTERS,	// number of coil words in block
    376            MODULE_DRIVE_DYNAMIC_NUMBER_OF_COILS,			// number of coil bits in block
    377          };
    378          

   \                                 In section .data, align 4
    379          ModbusMapBlock BlockDriveDynamic_Holdings =
   \                     BlockDriveDynamic_Holdings:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x0068             DC16 104
   \        0x6   0x05               DC8 5
   \        0x7                      DS8 1
    380          {
    381            0,				// first data value in block
    382            MODULE_DRIVE_DYNAMIC_START_OF_HOLDINGS_ADDRESS,	// starting address for block
    383            MODULE_DRIVE_DYNAMIC_NUMBER_OF_HOLDINGS,			// number of elements in block					
    384          };
    385          

   \                                 In section .data, align 4
    386          ModbusCoilMapBlock BlockDriveDynamic_Discretes =
   \                     BlockDriveDynamic_Discretes:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x0010             DC16 16
   \        0x6   0x01 0x01          DC8 1, 1
    387          {
    388            0,				// first data value in block
    389            MODULE_DRIVE_DYNAMIC_START_OF_DISCRETES_ADDRESS,	// starting address for block
    390            MODULE_DRIVE_DYNAMIC_NUMBER_OF_DISCRETE_REGISTERS,	// number of coil words in block
    391            MODULE_DRIVE_DYNAMIC_NUMBER_OF_DISCRETES,			// number of coil bits in block
    392          };
    393          

   \                                 In section .data, align 4
    394          ModbusMapBlock BlockDriveDynamic_Inputs =
   \                     BlockDriveDynamic_Inputs:
   \        0x0   0x0000'0000        DC32 0x0
   \        0x4   0x0028             DC16 40
   \        0x6   0x08               DC8 8
   \        0x7                      DS8 1
    395          {
    396            0,				// first data value in block
    397            MODULE_DRIVE_DYNAMIC_START_OF_INPUTS_ADDRESS,	// starting address for block
    398            MODULE_DRIVE_DYNAMIC_NUMBER_OF_INPUTS,			// number of elements in block				
    399          };
    400          

   \                                 In section .data, align 4
    401          ModbusCoilMapBlock *masterCoilBlocks[] =
   \                     masterCoilBlocks:
   \        0x0   0x....'....        DC32 BlockAnalog0TO10V_Coils, BlockAnalog0TO10V_Discrete

   \              0x....'....
   \        0x8   0x....'....        DC32 BlockAnalog4TO20_Coils, BlockAnalog4TO20_Discrete

   \              0x....'....
   \       0x10   0x....'....        DC32 BlockDigitalInputs_Discrete, BlockDigitalOutputs_Discrete

   \              0x....'....
   \       0x18   0x....'....        DC32 BlockPWMInputs_Coils, BlockPWMInputs_Discrete

   \              0x....'....
   \       0x20   0x....'....        DC32 BlockModbusRTU_Coils, BlockMotorCommunication_Discrete

   \              0x....'....
   \       0x28   0x....'....        DC32 BlockDriveDynamic_Coils, BlockDriveDynamic_Discretes

   \              0x....'....
    402          {
    403            //&BlockTest,
    404            //&BlockCoils,					// segregated into drive groups
    405            &BlockAnalog0TO10V_Coils,
    406            &BlockAnalog0TO10V_Discrete,  
    407            &BlockAnalog4TO20_Coils,
    408            &BlockAnalog4TO20_Discrete, 
    409            &BlockDigitalInputs_Discrete,
    410            &BlockDigitalOutputs_Discrete,
    411            &BlockPWMInputs_Coils,
    412            &BlockPWMInputs_Discrete, 
    413            &BlockModbusRTU_Coils,  
    414            &BlockMotorCommunication_Discrete,
    415            //&BlockApplicationID_Coils,
    416            //&BlockApplicationID_Discretes,
    417            &BlockDriveDynamic_Coils,
    418            &BlockDriveDynamic_Discretes,  
    419          };
    420          

   \                                 In section .data, align 4
    421          ModbusMapBlock *masterBlocks[] =
   \                     masterBlocks:
   \        0x0   0x....'....        DC32 BlockDriveDynamic_Inputs, BlockDriveDynamic_Holdings

   \              0x....'....
   \        0x8   0x....'....        DC32 BlockAnalog0TO10V_Inputs, BlockAnalog0TO10V_Holdings

   \              0x....'....
   \       0x10   0x....'....        DC32 BlockDigitalInputs_Inputs, BlockDigitalInputs_Holdings

   \              0x....'....
   \       0x18   0x....'....        DC32 BlockDigitalOutputs_Inputs, BlockDigitalOutputs_Holdings

   \              0x....'....
   \       0x20   0x....'....        DC32 BlockPWMInputs_Inputs, BlockPWMInputs_Holdings

   \              0x....'....
   \       0x28   0x....'....        DC32 BlockModbusRTU_Inputs, BlockModbusRTU_Holdings

   \              0x....'....
   \       0x30   0x....'....        DC32 BlockAnalog4TO20_Inputs, BlockAnalog4TO20_Holdings

   \              0x....'....
   \       0x38   0x....'....        DC32 BlockDemandMultiplexer_Inputs, BlockDemandMultiplexer_Holdings

   \              0x....'....
   \       0x40   0x....'....        DC32 BlockMotorCommunication_Inputs, BlockMotorCommunication_Holdings

   \              0x....'....
    422          {
    423            //&BlockTest,
    424            //&BlockMonitor,				// moved to drive dynamic inputs
    425            //&BlockOperation,				// moved to drive drive dynamic holdings
    426            &BlockDriveDynamic_Inputs,
    427            &BlockDriveDynamic_Holdings,
    428            //&BlockHarmonic,
    429            &BlockAnalog0TO10V_Inputs,
    430            &BlockAnalog0TO10V_Holdings,  
    431            &BlockDigitalInputs_Inputs,
    432            &BlockDigitalInputs_Holdings,
    433            &BlockDigitalOutputs_Inputs,
    434            &BlockDigitalOutputs_Holdings,   
    435            &BlockPWMInputs_Inputs,
    436            &BlockPWMInputs_Holdings, 
    437            //&BlockApplicationID_Inputs,
    438            //&BlockApplicationID_Holdings,
    439            &BlockModbusRTU_Inputs,
    440            &BlockModbusRTU_Holdings,
    441            &BlockAnalog4TO20_Inputs,
    442            &BlockAnalog4TO20_Holdings,
    443            &BlockDemandMultiplexer_Inputs,
    444            &BlockDemandMultiplexer_Holdings,
    445            &BlockMotorCommunication_Inputs,
    446            &BlockMotorCommunication_Holdings,
    447            //&BlockFirmwareUpdate_Holdings,
    448            //&BlockFlashBlock_Inputs,
    449          };
    450          

   \                                 In section .data, align 2
    451          uint16_t number_of_modbus_blocks_u16 = sizeof(masterBlocks)/sizeof(masterBlocks[0]);
   \                     number_of_modbus_blocks_u16:
   \        0x0   0x0012             DC16 18

   \                                 In section .data, align 2
    452          uint16_t number_of_modbus_coil_blocks_u16 = sizeof(masterCoilBlocks)/sizeof(masterCoilBlocks[0]);
   \                     number_of_modbus_coil_blocks_u16:
   \        0x0   0x000C             DC16 12
    453          
    454          enum {
    455            MEMORY_INIT_MODULE,
    456            INIT_MODULE,
    457            RUN_MODULE,
    458            // Ddditional states to be added here as necessary.
    459            IRQ_MODULE = DEFAULT_IRQ_STATE,
    460            KILL_MODULE = KILL_APP
    461          };
    462          
    463          // Global variables
    464          extern ProcessInfo processInfoTable[];
    465          extern Usart2_Control* usart2Control_AppLocal;

   \                                 In section .bss, align 4
    466          Usart1_Control* usart1Control_Modbus;
   \                     usart1Control_Modbus:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
    467          Modbus_RTU_Control modbus_RTU_Control;
   \                     modbus_RTU_Control:
   \        0x0                      DS8 16

   \                                 In section .bss, align 4
    468          ApplicationID_Control application_id_control;
   \                     application_id_control:
   \        0x0                      DS8 12

   \                                 In section .bss, align 4
    469          DriveDynamic_Control drive_dynamic_control;
   \                     drive_dynamic_control:
   \        0x0                      DS8 36

   \                                 In section .bss, align 4
    470          Modbus_Message last_eeprom_request;				// last modbus message sent performing an eeprom request
   \                     last_eeprom_request:
   \        0x0                      DS8 8

   \                                 In section .bss, align 4
    471          Modbus_Message last_drive_flash_request;		// last modbus message sent peforming a drive-ide flash request
   \                     last_drive_flash_request:
   \        0x0                      DS8 8
    472          

   \                                 In section .bss, align 4
    473          static Ram_Buf_Handle module_Control_StructMem_u32;
   \                     module_Control_StructMem_u32:
   \        0x0                      DS8 4
    474          
    475          
    476          #define ENABLE_MODBUS_PROTOCOLBUF_RX_FIXED_LEN 1
    477          #if ENABLE_MODBUS_PROTOCOLBUF_RX_FIXED_LEN >= 1
    478          // This is a one-shot buffer, that is written to and read from in single calls.
    479          // - it does not currently need to be tracked for current index because of this.
    480          #define FIXED_MODBUS_PROTOCOLBUF_RX_MAX_LENGTH USART1_SINGLE_MESSAGE_RX_BUF_SIZE // Inclusive (this value is accepted) 

   \                                 In section .bss, align 1
    481          uint8_t fixedModbus_ProtocolBufRX_Length = 0;
   \                     fixedModbus_ProtocolBufRX_Length:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
    482          uint8_t fixedModbus_ProtocolBufRX[FIXED_MODBUS_PROTOCOLBUF_RX_MAX_LENGTH];
   \                     fixedModbus_ProtocolBufRX:
   \        0x0                      DS8 80

   \                                 In section .data, align 4
    483          uint8_t* modbus_ProtocolBufRX = fixedModbus_ProtocolBufRX;
   \                     modbus_ProtocolBufRX:
   \        0x0   0x....'....        DC32 fixedModbus_ProtocolBufRX
    484          #else // if ENABLE_MODBUS_PROTOCOLBUF_RX_FIXED_LEN <= 0
    485          uint8_t* modbus_ProtocolBufRX;
    486          #endif // if ENABLE_MODBUS_PROTOCOLBUF_RX_FIXED_LEN <= 0
    487          
    488          
    489          #define ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN 1
    490          #if ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN >= 1
    491          // This is a one-shot buffer, that is written to and read from in single calls.
    492          // - it does not currently need to be tracked for current index because of this.
    493          #define FIXED_MODBUS_PROTOCOLBUF_TX_MAX_LENGTH USART1_SINGLE_MESSAGE_TX_BUF_SIZE // Inclusive (this value is accepted) 

   \                                 In section .bss, align 1
    494          uint8_t fixedModbus_ProtocolBufTX_Length = 0;
   \                     fixedModbus_ProtocolBufTX_Length:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
    495          uint8_t fixedModbus_ProtocolBufTX[FIXED_MODBUS_PROTOCOLBUF_TX_MAX_LENGTH];
   \                     fixedModbus_ProtocolBufTX:
   \        0x0                      DS8 80

   \                                 In section .data, align 4
    496          uint8_t* modbus_ProtocolBufTX = fixedModbus_ProtocolBufTX;
   \                     modbus_ProtocolBufTX:
   \        0x0   0x....'....        DC32 fixedModbus_ProtocolBufTX
    497          #else // if ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN <= 0
    498          uint8_t* modbus_ProtocolBufTX;
    499          #endif // if ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN <= 0
    500          

   \                                 In section .bss, align 4
    501          Modbus_RTU_Control modbus_RTU_control;
   \                     modbus_RTU_control:
   \        0x0                      DS8 16
    502          
    503          // Local Function Prototypes
    504          void Modbus_ParseReceivedMessages(void);
    505          ModbusMapBlock *find_modbus_block(uint16_t desired_address_u16, uint16_t number_of_registers_u16);
    506          ModbusCoilMapBlock *find_modbus_coil_block(uint16_t desired_coil_address_u16, uint16_t number_of_coils_u16);
    507          
    508          MBErrorCode ProcessMBHoldingRegister(uint8_t * data_buffer_pu8, uint16_t starting_address_u16, uint16_t number_of_registers_u16, MBRegisterMode eMode);
    509          MBErrorCode ProcessMBCoilRegister_New(uint8_t * data_buffer_pu8, uint16_t desired_coil_address_u16, uint16_t number_of_coils_u16, MBRegisterMode eMode);
    510          MBErrorCode ProcessMBReadRecords(uint8_t * data_buffer_pu8, uint16_t offset_address_u16, uint16_t number_of_registers_u16, uint8_t file_number_u8);
    511          MBErrorCode ProcessMBWriteRecords(uint8_t * data_buffer_pu8, uint16_t flash_offset_address_u16, uint16_t number_of_flash_words_u16, uint8_t file_number_u8);
    512          MBErrorCode ProcessMBDiscreteRegister(uint8_t * data_buffer_pu8, uint16_t starting_address_u16, uint16_t number_of_registers_u16, MBRegisterMode eMode);
    513          void Build_UPDrive_Flash_Request(uint16_t data_address_u16, uint8_t length_u8);
    514          void Build_UPEEPROM_Request(uint16_t data_address_u16, uint8_t length_u8);
    515          void AssignModuleMemModbus(void);
    516          void Modbus_JumpToBootloader(void);
    517          
    518          uint16_t calculateModbusCRC(uint8_t *buf_pu8, uint16_t length_u16);
    519          

   \                                 In section .text, align 2, keep-with-next
    520          void UpdateMotorDemandMultiplexer(void) {
   \                     UpdateMotorDemandMultiplexer: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
    521            uint16_t commanded_speed = drive_dynamic_control.drive_dynamic_settings.commanded_speed_u16;
   \        0x2   0x....             LDR      R0,??DataTable3_2
   \        0x4   0x8804             LDRH     R4,[R0, #+0]
    522            uint16_t commanded_demand = drive_dynamic_control.drive_dynamic_settings.commanded_demand_u16;
   \        0x6   0x8841             LDRH     R1,[R0, #+2]
   \        0x8   0x466A             MOV      R2,SP
   \        0xA   0x8091             STRH     R1,[R2, #+4]
    523            uint16_t commanded_start = drive_dynamic_control.drive_dynamic_settings.start_command_u16;
   \        0xC   0x8887             LDRH     R7,[R0, #+4]
    524            uint16_t demand_source = drive_dynamic_control.drive_dynamic_settings.demand_source_u16;
   \        0xE   0x88C6             LDRH     R6,[R0, #+6]
    525            uint16_t direction = drive_dynamic_control.drive_dynamic_settings.direction_u16;
   \       0x10   0x8905             LDRH     R5,[R0, #+8]
    526            MotorDemandMux_ModbusUpdate(commanded_speed, commanded_demand, commanded_start, demand_source, direction);
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0xB280             UXTH     R0,R0
   \       0x16   0x9000             STR      R0,[SP, #+0]
   \       0x18   0x0033             MOVS     R3,R6
   \       0x1A   0xB29B             UXTH     R3,R3
   \       0x1C   0x003A             MOVS     R2,R7
   \       0x1E   0xB292             UXTH     R2,R2
   \       0x20   0x4668             MOV      R0,SP
   \       0x22   0x8881             LDRH     R1,[R0, #+4]
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0xB280             UXTH     R0,R0
   \       0x28   0x....'....        BL       MotorDemandMux_ModbusUpdate
    527          }
   \       0x2C   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    528          

   \                                 In section .text, align 2, keep-with-next
    529          void UpdateHarmonicInjectionParameters(void) {
   \                     UpdateHarmonicInjectionParameters: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
    530            uint8_t	index_u8 = 0;	
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x0022             MOVS     R2,R4
    531            hi_is_harmonic_injection_allowed_hi_u8 	= modbusRegisters5000s[0]; 
   \        0x6   0x....             LDR      R0,??DataTable3_3
   \        0x8   0x....             LDR      R1,??DataTable3_4
   \        0xA   0x880B             LDRH     R3,[R1, #+0]
   \        0xC   0x7003             STRB     R3,[R0, #+0]
    532            for(index_u8 = 0; index_u8 < 8; index_u8++) {
   \                     ??UpdateHarmonicInjectionParameters_0: (+1)
   \        0xE   0x0022             MOVS     R2,R4
   \       0x10   0xB2D2             UXTB     R2,R2
   \       0x12   0x2A08             CMP      R2,#+8
   \       0x14   0xDA47             BGE      ??UpdateHarmonicInjectionParameters_1
    533            	hi_amplitude_s16[index_u8] 			= (int16_t)  modbusRegisters5000s[1+index_u8]; 
   \       0x16   0x0022             MOVS     R2,R4
   \       0x18   0xB2D2             UXTB     R2,R2
   \       0x1A   0x2302             MOVS     R3,#+2
   \       0x1C   0x435A             MULS     R2,R3,R2
   \       0x1E   0x188A             ADDS     R2,R1,R2
   \       0x20   0x8852             LDRH     R2,[R2, #+2]
   \       0x22   0x....             LDR      R3,??DataTable4
   \       0x24   0x0025             MOVS     R5,R4
   \       0x26   0xB2ED             UXTB     R5,R5
   \       0x28   0x2602             MOVS     R6,#+2
   \       0x2A   0x4375             MULS     R5,R6,R5
   \       0x2C   0x535A             STRH     R2,[R3, R5]
    534            	hi_angle_multiplier_hi_u8[index_u8] 	= (uint8_t)  modbusRegisters5000s[9+index_u8];
   \       0x2E   0x0022             MOVS     R2,R4
   \       0x30   0xB2D2             UXTB     R2,R2
   \       0x32   0x2302             MOVS     R3,#+2
   \       0x34   0x435A             MULS     R2,R3,R2
   \       0x36   0x188A             ADDS     R2,R1,R2
   \       0x38   0x8A52             LDRH     R2,[R2, #+18]
   \       0x3A   0x....             LDR      R3,??DataTable3_5
   \       0x3C   0x0025             MOVS     R5,R4
   \       0x3E   0xB2ED             UXTB     R5,R5
   \       0x40   0x555A             STRB     R2,[R3, R5]
    535            	hi_angle_offset_u16[index_u8] 			= (uint16_t) modbusRegisters5000s[17+index_u8];
   \       0x42   0x0022             MOVS     R2,R4
   \       0x44   0xB2D2             UXTB     R2,R2
   \       0x46   0x2302             MOVS     R3,#+2
   \       0x48   0x435A             MULS     R2,R3,R2
   \       0x4A   0x188A             ADDS     R2,R1,R2
   \       0x4C   0x8C52             LDRH     R2,[R2, #+34]
   \       0x4E   0x....             LDR      R3,??DataTable3_6
   \       0x50   0x0025             MOVS     R5,R4
   \       0x52   0xB2ED             UXTB     R5,R5
   \       0x54   0x2602             MOVS     R6,#+2
   \       0x56   0x4375             MULS     R5,R6,R5
   \       0x58   0x535A             STRH     R2,[R3, R5]
    536            	hi_is_phase_inverted_u8[index_u8] 		= (uint8_t)  modbusRegisters5000s[25+index_u8];
   \       0x5A   0x0022             MOVS     R2,R4
   \       0x5C   0xB2D2             UXTB     R2,R2
   \       0x5E   0x2302             MOVS     R3,#+2
   \       0x60   0x435A             MULS     R2,R3,R2
   \       0x62   0x188A             ADDS     R2,R1,R2
   \       0x64   0x8E52             LDRH     R2,[R2, #+50]
   \       0x66   0x....             LDR      R3,??DataTable3_7
   \       0x68   0x0025             MOVS     R5,R4
   \       0x6A   0xB2ED             UXTB     R5,R5
   \       0x6C   0x555A             STRB     R2,[R3, R5]
    537            	hi_min_speed_u16[index_u8] 			= (uint16_t) modbusRegisters5000s[33+index_u8];
   \       0x6E   0x0022             MOVS     R2,R4
   \       0x70   0xB2D2             UXTB     R2,R2
   \       0x72   0x2302             MOVS     R3,#+2
   \       0x74   0x435A             MULS     R2,R3,R2
   \       0x76   0x188A             ADDS     R2,R1,R2
   \       0x78   0x2342             MOVS     R3,#+66
   \       0x7A   0x5AD2             LDRH     R2,[R2, R3]
   \       0x7C   0x....             LDR      R3,??DataTable3_8
   \       0x7E   0x0025             MOVS     R5,R4
   \       0x80   0xB2ED             UXTB     R5,R5
   \       0x82   0x2602             MOVS     R6,#+2
   \       0x84   0x4375             MULS     R5,R6,R5
   \       0x86   0x535A             STRH     R2,[R3, R5]
    538            	hi_max_speed_u16[index_u8] 			= (uint16_t) modbusRegisters5000s[41+index_u8];  
   \       0x88   0x0022             MOVS     R2,R4
   \       0x8A   0xB2D2             UXTB     R2,R2
   \       0x8C   0x2302             MOVS     R3,#+2
   \       0x8E   0x435A             MULS     R2,R3,R2
   \       0x90   0x188A             ADDS     R2,R1,R2
   \       0x92   0x2352             MOVS     R3,#+82
   \       0x94   0x5AD2             LDRH     R2,[R2, R3]
   \       0x96   0x....             LDR      R3,??DataTable3_9
   \       0x98   0x0025             MOVS     R5,R4
   \       0x9A   0xB2ED             UXTB     R5,R5
   \       0x9C   0x2602             MOVS     R6,#+2
   \       0x9E   0x4375             MULS     R5,R6,R5
   \       0xA0   0x535A             STRH     R2,[R3, R5]
    539            }
   \       0xA2   0x1C64             ADDS     R4,R4,#+1
   \       0xA4   0xE7B3             B        ??UpdateHarmonicInjectionParameters_0
    540            HarmonicInjection_ModbusUpdate(hi_is_harmonic_injection_allowed_hi_u8, hi_amplitude_s16, hi_angle_multiplier_hi_u8, hi_angle_offset_u16, hi_is_phase_inverted_u8, hi_min_speed_u16, hi_max_speed_u16);
   \                     ??UpdateHarmonicInjectionParameters_1: (+1)
   \       0xA6   0x....             LDR      R1,??DataTable3_9
   \       0xA8   0x9102             STR      R1,[SP, #+8]
   \       0xAA   0x....             LDR      R1,??DataTable3_8
   \       0xAC   0x9101             STR      R1,[SP, #+4]
   \       0xAE   0x....             LDR      R1,??DataTable3_7
   \       0xB0   0x9100             STR      R1,[SP, #+0]
   \       0xB2   0x....             LDR      R3,??DataTable3_6
   \       0xB4   0x....             LDR      R2,??DataTable3_5
   \       0xB6   0x....             LDR      R1,??DataTable4
   \       0xB8   0x7800             LDRB     R0,[R0, #+0]
   \       0xBA   0x....'....        BL       HarmonicInjection_ModbusUpdate
    541          }
   \       0xBE   0xBD7F             POP      {R0-R6,PC}       ;; return
    542          
    543          // module functions

   \                                 In section .text, align 4, keep-with-next
    544          uint8_t moduleModbus(uint8_t drv_id_u8, uint8_t prev_state_u8, uint8_t next_state_u8, uint8_t irq_id_u8) {
   \                     moduleModbus: (+1)
   \        0x0   0xB5FF             PUSH     {R0-R7,LR}
   \        0x2   0xB083             SUB      SP,SP,#+12
    545            uint8_t return_state_u8 = MEMORY_INIT_MODULE;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x0008             MOVS     R0,R1
   \        0x8   0x466A             MOV      R2,SP
   \        0xA   0x7110             STRB     R0,[R2, #+4]
    546            switch (next_state_u8) {
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x7D00             LDRB     R0,[R0, #+20]
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0xD009             BEQ      ??moduleModbus_2
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD100             BNE      .+4
   \       0x18   0xE0DC             B        ??moduleModbus_3
   \       0x1A   0x2802             CMP      R0,#+2
   \       0x1C   0xD100             BNE      .+4
   \       0x1E   0xE0F5             B        ??moduleModbus_4
   \       0x20   0x28FF             CMP      R0,#+255
   \       0x22   0xD100             BNE      .+4
   \       0x24   0xE107             B        ??moduleModbus_5
   \       0x26   0xE119             B        ??moduleModbus_6
    547            case MEMORY_INIT_MODULE:
    548              {
    549                //AssignModuleMemModbus(); // Assign structured memory to Analog 0-10V setting and data 
    550                return_state_u8 = INIT_MODULE;
   \                     ??moduleModbus_2: (+1)
   \       0x28   0x2201             MOVS     R2,#+1
   \       0x2A   0x0010             MOVS     R0,R2
    551          	  // Modbus RTU settings
    552          	  modbus_RTU_Control.modbus_RTU_Settings.baud_rate_u16 = 24;	// baud rate = 24*4800 = 115200
   \       0x2C   0x....             LDR      R4,??DataTable5
   \       0x2E   0x2318             MOVS     R3,#+24
   \       0x30   0x8023             STRH     R3,[R4, #+0]
    553          	  modbus_RTU_Control.modbus_RTU_Settings.data_bits_u16 = 8;		// data bits
   \       0x32   0x2308             MOVS     R3,#+8
   \       0x34   0x8063             STRH     R3,[R4, #+2]
    554          	  modbus_RTU_Control.modbus_RTU_Settings.stop_bits_u16 = 1;		// stop bits
   \       0x36   0x0013             MOVS     R3,R2
   \       0x38   0x80A3             STRH     R3,[R4, #+4]
    555          	  modbus_RTU_Control.modbus_RTU_Settings.parity_u16 = 0;		// parity 0 = NONE, 1 = ODD; 2 = EVEN
   \       0x3A   0x80E1             STRH     R1,[R4, #+6]
    556          	  modbus_RTU_Control.modbus_RTU_Settings.motor_address_u16 = MODBUS_ADDRESS;			// motor's MDBUS follower address
   \       0x3C   0x23F7             MOVS     R3,#+247
   \       0x3E   0x8123             STRH     R3,[R4, #+8]
    557          	  modbus_RTU_Control.modbus_RTU_Settings.flags_u16.is_happy = 1;
   \       0x40   0x0025             MOVS     R5,R4
   \       0x42   0x350A             ADDS     R5,R5,#+10
   \       0x44   0x8966             LDRH     R6,[R4, #+10]
   \       0x46   0x0017             MOVS     R7,R2
   \       0x48   0x4337             ORRS     R7,R7,R6
   \       0x4A   0x802F             STRH     R7,[R5, #+0]
    558          	  modbus_RTU_Control.modbus_RTU_Settings.flags_u16.is_working = 1;
   \       0x4C   0x8966             LDRH     R6,[R4, #+10]
   \       0x4E   0x2702             MOVS     R7,#+2
   \       0x50   0x4337             ORRS     R7,R7,R6
   \       0x52   0x802F             STRH     R7,[R5, #+0]
    559          	  modbus_RTU_Control.modbus_RTU_Settings.flags_u16.is_sleeping = 0;
   \       0x54   0x8966             LDRH     R6,[R4, #+10]
   \       0x56   0x....             LDR      R7,??DataTable5_1  ;; 0xfffb
   \       0x58   0x4037             ANDS     R7,R7,R6
   \       0x5A   0x802F             STRH     R7,[R5, #+0]
    560          	  modbus_RTU_Control.modbus_RTU_Settings.flags_u16.is_enabled = 0;
   \       0x5C   0x8966             LDRH     R6,[R4, #+10]
   \       0x5E   0x....             LDR      R7,??DataTable5_2  ;; 0xfff7
   \       0x60   0x4037             ANDS     R7,R7,R6
   \       0x62   0x802F             STRH     R7,[R5, #+0]
    561          	  modbus_RTU_Control.modbus_RTU_Settings.flags_u16.is_powered = 0;
   \       0x64   0x8966             LDRH     R6,[R4, #+10]
   \       0x66   0x4F51             LDR      R7,??moduleModbus_0  ;; 0xffef
   \       0x68   0x4037             ANDS     R7,R7,R6
   \       0x6A   0x802F             STRH     R7,[R5, #+0]
    562          	  modbus_RTU_Control.modbus_RTU_Settings.flags_u16.is_over = 1;
   \       0x6C   0x8966             LDRH     R6,[R4, #+10]
   \       0x6E   0x2720             MOVS     R7,#+32
   \       0x70   0x4337             ORRS     R7,R7,R6
   \       0x72   0x802F             STRH     R7,[R5, #+0]
    563          
    564          	  modbus_RTU_Control.modbus_RTU_Data.messages_received_u16 = 2112;
   \       0x74   0x2584             MOVS     R5,#+132
   \       0x76   0x012D             LSLS     R5,R5,#+4        ;; #+2112
   \       0x78   0x81A5             STRH     R5,[R4, #+12]
    565          	  
    566          	  application_id_control.application_id_settings.minor_software_rev_u16 = 0x3036;	// Revision 06
   \       0x7A   0x4C4D             LDR      R4,??moduleModbus_0+0x4
   \       0x7C   0x4E4D             LDR      R6,??moduleModbus_0+0x8  ;; 0x3036
   \       0x7E   0x8026             STRH     R6,[R4, #+0]
    567          	  application_id_control.application_id_settings.median_software_rev_u16 = 0x3052;	// Revision 0R
   \       0x80   0x4F4D             LDR      R7,??moduleModbus_0+0xC  ;; 0x3052
   \       0x82   0x8067             STRH     R7,[R4, #+2]
    568          	  application_id_control.application_id_settings.major_software_rev_u16 = 0x3036;	// Revision 00	  
   \       0x84   0x80A6             STRH     R6,[R4, #+4]
    569          	  application_id_control.application_id_settings.flags_u16.is_enabled = 1;
   \       0x86   0x88E6             LDRH     R6,[R4, #+6]
   \       0x88   0x0017             MOVS     R7,R2
   \       0x8A   0x4337             ORRS     R7,R7,R6
   \       0x8C   0x80E7             STRH     R7,[R4, #+6]
    570          	  
    571          	  application_id_control.application_id_data.errorCode_u16 = 2112;	  
   \       0x8E   0x8125             STRH     R5,[R4, #+8]
    572          	  application_id_control.application_id_data.discretes_u16.is_enabled = 1;
   \       0x90   0x8965             LDRH     R5,[R4, #+10]
   \       0x92   0x0016             MOVS     R6,R2
   \       0x94   0x432E             ORRS     R6,R6,R5
   \       0x96   0x8166             STRH     R6,[R4, #+10]
    573          	  
    574          	  // map modbus registers to corresponding modules
    575          	  BlockAnalog0TO10V_Coils.start_of_coil_data_pu16	= module_analog_inputs_0TO10_start_of_coils_pu16;
   \       0x98   0x4C48             LDR      R4,??moduleModbus_0+0x10
   \       0x9A   0x6824             LDR      R4,[R4, #+0]
   \       0x9C   0x4D48             LDR      R5,??moduleModbus_0+0x14
   \       0x9E   0x602C             STR      R4,[R5, #+0]
    576          	  BlockAnalog0TO10V_Discrete.start_of_coil_data_pu16	= module_analog_inputs_0TO10_start_of_discretes_pu16;
   \       0xA0   0x4C48             LDR      R4,??moduleModbus_0+0x18
   \       0xA2   0x6824             LDR      R4,[R4, #+0]
   \       0xA4   0x4D48             LDR      R5,??moduleModbus_0+0x1C
   \       0xA6   0x602C             STR      R4,[R5, #+0]
    577          	  BlockAnalog0TO10V_Inputs.start_of_data_pu16 		= module_analog_inputs_0TO10_start_of_inputs_pu16;
   \       0xA8   0x4C48             LDR      R4,??moduleModbus_0+0x20
   \       0xAA   0x6824             LDR      R4,[R4, #+0]
   \       0xAC   0x....             LDR      R5,??DataTable5_3
   \       0xAE   0x602C             STR      R4,[R5, #+0]
    578          	  BlockAnalog0TO10V_Holdings.start_of_data_pu16 	= module_analog_inputs_0TO10_start_of_holdings_pu16;
   \       0xB0   0x....             LDR      R4,??DataTable5_4
   \       0xB2   0x6824             LDR      R4,[R4, #+0]
   \       0xB4   0x....             LDR      R5,??DataTable5_5
   \       0xB6   0x602C             STR      R4,[R5, #+0]
    579          	  
    580          	  BlockDigitalInputs_Discrete.start_of_coil_data_pu16 = module_digital_inputs_start_of_discretes_pu16;
   \       0xB8   0x....             LDR      R4,??DataTable5_6
   \       0xBA   0x....             LDR      R5,??DataTable5_7
   \       0xBC   0x682D             LDR      R5,[R5, #+0]
   \       0xBE   0x6025             STR      R5,[R4, #+0]
    581          	  BlockDigitalInputs_Inputs.start_of_data_pu16 		= module_digital_inputs_start_of_inputs_pu16;
   \       0xC0   0x....             LDR      R5,??DataTable4_1
   \       0xC2   0x682D             LDR      R5,[R5, #+0]
   \       0xC4   0x....             LDR      R6,??DataTable4_2
   \       0xC6   0x6035             STR      R5,[R6, #+0]
    582          	  BlockDigitalInputs_Holdings.start_of_data_pu16 	= module_digital_inputs_start_of_holdings_pu16;
   \       0xC8   0x....             LDR      R5,??DataTable4_3
   \       0xCA   0x682D             LDR      R5,[R5, #+0]
   \       0xCC   0x....             LDR      R6,??DataTable4_4
   \       0xCE   0x6035             STR      R5,[R6, #+0]
    583          	  BlockDigitalInputs_Discrete.start_of_coil_data_pu16 = module_digital_outputs_start_of_discretes_pu16;
   \       0xD0   0x....             LDR      R5,??DataTable4_5
   \       0xD2   0x682D             LDR      R5,[R5, #+0]
   \       0xD4   0x6025             STR      R5,[R4, #+0]
    584          	  
    585          	  BlockDigitalOutputs_Inputs.start_of_data_pu16 	= module_digital_outputs_start_of_inputs_pu16;
   \       0xD6   0x....             LDR      R4,??DataTable4_6
   \       0xD8   0x6824             LDR      R4,[R4, #+0]
   \       0xDA   0x....             LDR      R5,??DataTable4_7
   \       0xDC   0x602C             STR      R4,[R5, #+0]
    586          	  BlockDigitalOutputs_Holdings.start_of_data_pu16 	= module_digital_outputs_start_of_holdings_pu16;
   \       0xDE   0x....             LDR      R4,??DataTable4_8
   \       0xE0   0x6824             LDR      R4,[R4, #+0]
   \       0xE2   0x....             LDR      R5,??DataTable4_9
   \       0xE4   0x602C             STR      R4,[R5, #+0]
    587          	  
    588                    BlockPWMInputs_Coils.start_of_coil_data_pu16	        = module_pwm_input_start_of_coils_pu16;
   \       0xE6   0x....             LDR      R4,??DataTable5_8
   \       0xE8   0x6824             LDR      R4,[R4, #+0]
   \       0xEA   0x....             LDR      R5,??DataTable5_9
   \       0xEC   0x602C             STR      R4,[R5, #+0]
    589          	  BlockPWMInputs_Discrete.start_of_coil_data_pu16	= module_pwm_input_start_of_discretes_pu16;
   \       0xEE   0x....             LDR      R4,??DataTable5_10
   \       0xF0   0x6824             LDR      R4,[R4, #+0]
   \       0xF2   0x....             LDR      R5,??DataTable5_11
   \       0xF4   0x602C             STR      R4,[R5, #+0]
    590          	  BlockPWMInputs_Inputs.start_of_data_pu16 			= module_pwm_input_start_of_inputs_pu16;
   \       0xF6   0x....             LDR      R4,??DataTable5_12
   \       0xF8   0x6824             LDR      R4,[R4, #+0]
   \       0xFA   0x....             LDR      R5,??DataTable5_13
   \       0xFC   0x602C             STR      R4,[R5, #+0]
    591          	  BlockPWMInputs_Holdings.start_of_data_pu16 		= module_pwm_input_start_of_holdings_pu16;
   \       0xFE   0x....             LDR      R4,??DataTable5_14
   \      0x100   0x6824             LDR      R4,[R4, #+0]
   \      0x102   0x....             LDR      R5,??DataTable5_15
   \      0x104   0x602C             STR      R4,[R5, #+0]
    592          	  
    593          	  BlockModbusRTU_Coils.start_of_coil_data_pu16		= module_modbus_rtu_start_of_coils_pu16;
   \      0x106   0x....             LDR      R4,??DataTable5_16
   \      0x108   0x6824             LDR      R4,[R4, #+0]
   \      0x10A   0x....             LDR      R5,??DataTable5_17
   \      0x10C   0x602C             STR      R4,[R5, #+0]
    594          	  BlockModbusRTU_Inputs.start_of_data_pu16 			= module_modbus_rtu_start_of_inputs_pu16;
   \      0x10E   0x....             LDR      R4,??DataTable5_18
   \      0x110   0x6824             LDR      R4,[R4, #+0]
   \      0x112   0x....             LDR      R5,??DataTable5_19
   \      0x114   0x602C             STR      R4,[R5, #+0]
    595          	  BlockModbusRTU_Holdings.start_of_data_pu16 		= module_modbus_rtu_start_of_holdings_pu16;
   \      0x116   0x....             LDR      R4,??DataTable5_20
   \      0x118   0x6824             LDR      R4,[R4, #+0]
   \      0x11A   0x....             LDR      R5,??DataTable5_21
   \      0x11C   0x602C             STR      R4,[R5, #+0]
    596          	  
    597          	  BlockAnalog4TO20_Coils.start_of_coil_data_pu16	= module_analog_inputs_4TO20_start_of_coils_pu16;
   \      0x11E   0x....             LDR      R4,??DataTable5_22
   \      0x120   0x6824             LDR      R4,[R4, #+0]
   \      0x122   0x....             LDR      R5,??DataTable5_23
   \      0x124   0x602C             STR      R4,[R5, #+0]
    598          	  BlockAnalog4TO20_Discrete.start_of_coil_data_pu16	= module_analog_inputs_4TO20_start_of_discretes_pu16;
   \      0x126   0x....             LDR      R4,??DataTable5_24
   \      0x128   0x6824             LDR      R4,[R4, #+0]
   \      0x12A   0x....             LDR      R5,??DataTable5_25
   \      0x12C   0x602C             STR      R4,[R5, #+0]
    599          	  BlockAnalog4TO20_Inputs.start_of_data_pu16 		= module_analog_inputs_4TO20_start_of_inputs_pu16;
   \      0x12E   0x....             LDR      R4,??DataTable5_26
   \      0x130   0x6824             LDR      R4,[R4, #+0]
   \      0x132   0x....             LDR      R5,??DataTable5_27
   \      0x134   0x602C             STR      R4,[R5, #+0]
    600          	  BlockAnalog4TO20_Holdings.start_of_data_pu16 		= module_analog_inputs_4TO20_start_of_holdings_pu16;	
   \      0x136   0x....             LDR      R4,??DataTable5_28
   \      0x138   0x6824             LDR      R4,[R4, #+0]
   \      0x13A   0x....             LDR      R5,??DataTable5_29
   \      0x13C   0x602C             STR      R4,[R5, #+0]
    601          	  
    602          	  BlockMotorCommunication_Discrete.start_of_coil_data_pu16	= module_motor_communication_start_of_discretes_pu16;
   \      0x13E   0x....             LDR      R4,??DataTable5_30
   \      0x140   0x6824             LDR      R4,[R4, #+0]
   \      0x142   0x....             LDR      R5,??DataTable5_31
   \      0x144   0x602C             STR      R4,[R5, #+0]
    603          	  BlockMotorCommunication_Inputs.start_of_data_pu16 		= module_motor_communication_start_of_inputs_pu16;
   \      0x146   0x....             LDR      R4,??DataTable5_32
   \      0x148   0x6824             LDR      R4,[R4, #+0]
   \      0x14A   0x....             LDR      R5,??DataTable5_33
   \      0x14C   0x602C             STR      R4,[R5, #+0]
    604          	  BlockMotorCommunication_Holdings.start_of_data_pu16 		= module_motor_communication_start_of_holdings_pu16;	
   \      0x14E   0x....             LDR      R4,??DataTable5_34
   \      0x150   0x6824             LDR      R4,[R4, #+0]
   \      0x152   0x....             LDR      R5,??DataTable5_35
   \      0x154   0x602C             STR      R4,[R5, #+0]
    605          	  
    606          	  BlockDemandMultiplexer_Inputs.start_of_data_pu16 		= module_demand_multiplexer_start_of_inputs_pu16;
   \      0x156   0x....             LDR      R4,??DataTable5_36
   \      0x158   0x6824             LDR      R4,[R4, #+0]
   \      0x15A   0x....             LDR      R5,??DataTable5_37
   \      0x15C   0x602C             STR      R4,[R5, #+0]
    607          	  BlockDemandMultiplexer_Holdings.start_of_data_pu16 	= module_demand_multiplexer_start_of_holdings_pu16;	  	  
   \      0x15E   0x....             LDR      R4,??DataTable5_38
   \      0x160   0x6824             LDR      R4,[R4, #+0]
   \      0x162   0x....             LDR      R5,??DataTable5_39
   \      0x164   0x602C             STR      R4,[R5, #+0]
    608          	  
    609          	  //BlockFirmwareUpdate_Inputs.start_of_data_pu16 	= module_firmware_update_start_of_inputs_pu16;
    610          	  
    611          	  //BlockFirmwareUpdate_Holdings.start_of_data_pu16 	= module_firmware_update_start_of_holdings_pu16;	  
    612          	  
    613          	  //BlockFlashBlock_Inputs.start_of_data_pu16 		= module_flash_block_start_of_inputs_pu16;
    614          	  
    615          	  
    616          	  //BlockApplicationID_Coils.start_of_coil_data_pu16		= module_application_id_start_of_coils_pu16;
    617          	  //BlockApplicationID_Discretes.start_of_coil_data_pu16	= module_application_id_start_of_discretes_pu16;
    618          	  //BlockApplicationID_Inputs.start_of_data_pu16 			= module_application_id_start_of_inputs_pu16;
    619          	  //BlockApplicationID_Holdings.start_of_data_pu16 		= module_application_id_start_of_holdings_pu16;	
    620          
    621          	  BlockDriveDynamic_Coils.start_of_coil_data_pu16		= module_drive_dynamic_start_of_coils_pu16;
   \      0x166   0x....             LDR      R4,??DataTable5_40
   \      0x168   0x6824             LDR      R4,[R4, #+0]
   \      0x16A   0x....             LDR      R5,??DataTable5_41
   \      0x16C   0x602C             STR      R4,[R5, #+0]
    622          	  BlockDriveDynamic_Discretes.start_of_coil_data_pu16	= module_drive_dynamic_start_of_discretes_pu16;
   \      0x16E   0x....             LDR      R4,??DataTable5_42
   \      0x170   0x6824             LDR      R4,[R4, #+0]
   \      0x172   0x....             LDR      R5,??DataTable5_43
   \      0x174   0x602C             STR      R4,[R5, #+0]
    623          	  BlockDriveDynamic_Inputs.start_of_data_pu16 			= module_drive_dynamic_start_of_inputs_pu16;
   \      0x176   0x....             LDR      R4,??DataTable5_44
   \      0x178   0x6824             LDR      R4,[R4, #+0]
   \      0x17A   0x....             LDR      R5,??DataTable5_45
   \      0x17C   0x602C             STR      R4,[R5, #+0]
    624          	  BlockDriveDynamic_Holdings.start_of_data_pu16 		= module_drive_dynamic_start_of_holdings_pu16;		  
   \      0x17E   0x....             LDR      R4,??DataTable5_46
   \      0x180   0x6824             LDR      R4,[R4, #+0]
   \      0x182   0x....             LDR      R5,??DataTable5_47
   \      0x184   0x602C             STR      R4,[R5, #+0]
    625          	  
    626          	  // initialize last eeprom request to have an exception
    627          	  last_eeprom_request.device_address_u8 = MODBUS_ADDRESS;
   \      0x186   0x....             LDR      R4,??DataTable5_48
   \      0x188   0x001D             MOVS     R5,R3
   \      0x18A   0x7025             STRB     R5,[R4, #+0]
    628          	  last_eeprom_request.function_code_u8 = MODBUS_FUNCTION_CODE_READ_RECORDS;
   \      0x18C   0x2514             MOVS     R5,#+20
   \      0x18E   0x7065             STRB     R5,[R4, #+1]
    629          	  last_eeprom_request.length_u8 = 0;
   \      0x190   0x000E             MOVS     R6,R1
   \      0x192   0x70A6             STRB     R6,[R4, #+2]
    630          	  last_eeprom_request.is_exception_u8 = TRUE;
   \      0x194   0x0016             MOVS     R6,R2
   \      0x196   0x70E6             STRB     R6,[R4, #+3]
    631          	  last_eeprom_request.exception_type_u8 = MODBUS_EXCEPTION_04; // device failure
   \      0x198   0x2604             MOVS     R6,#+4
   \      0x19A   0x0037             MOVS     R7,R6
   \      0x19C   0x7127             STRB     R7,[R4, #+4]
    632          
    633          	  last_drive_flash_request.device_address_u8 = MODBUS_ADDRESS;
   \      0x19E   0x4C0C             LDR      R4,??moduleModbus_0+0x24
   \      0x1A0   0x7023             STRB     R3,[R4, #+0]
    634          	  last_drive_flash_request.function_code_u8 = MODBUS_FUNCTION_CODE_READ_RECORDS;
   \      0x1A2   0x7065             STRB     R5,[R4, #+1]
    635          	  last_drive_flash_request.length_u8 = 0;
   \      0x1A4   0x70A1             STRB     R1,[R4, #+2]
    636          	  last_drive_flash_request.is_exception_u8 = TRUE;
   \      0x1A6   0x70E2             STRB     R2,[R4, #+3]
    637          	  last_drive_flash_request.exception_type_u8 = MODBUS_EXCEPTION_04; // device failure	  
   \      0x1A8   0x7126             STRB     R6,[R4, #+4]
    638          	  
    639          	  break;
   \      0x1AA   0xE058             B        ??moduleModbus_7
   \                     ??moduleModbus_0:
   \      0x1AC   0x0000'FFEF        DC32     0xffef
   \      0x1B0   0x....'....        DC32     application_id_control
   \      0x1B4   0x0000'3036        DC32     0x3036
   \      0x1B8   0x0000'3052        DC32     0x3052
   \      0x1BC   0x....'....        DC32     module_analog_inputs_0TO10_start_of_coils_pu16
   \      0x1C0   0x....'....        DC32     BlockAnalog0TO10V_Coils
   \      0x1C4   0x....'....        DC32     module_analog_inputs_0TO10_start_of_discretes_pu16
   \      0x1C8   0x....'....        DC32     BlockAnalog0TO10V_Discrete
   \      0x1CC   0x....'....        DC32     module_analog_inputs_0TO10_start_of_inputs_pu16
   \      0x1D0   0x....'....        DC32     last_drive_flash_request
    640              }
    641            case INIT_MODULE: 
    642              {
    643                // initialize test registers for modbus
    644                //initMODBUSRegisterMap();
    645                /* Attach Uart1 shared memory into this Module */
    646          
    647                tt_ModbusLinkLostStop = 0xFFFFFFFFFFFFFFFF; // Restart Modbus Link Lost Timer
   \                     ??moduleModbus_3: (+1)
   \      0x1D4   0xA000             ADR      R0,??moduleModbus_1
   \      0x1D6   0xE003             B.N      ??moduleModbus_8
   \                     ??moduleModbus_1:
   \      0x1D8   0xFFFF'FFFF        DC32     0xFFFFFFFF,0xFFFFFFFF

   \              0xFFFF'FFFF
   \                     ??moduleModbus_8: (+1)
   \      0x1E0   0xC803             LDM      R0,{R0,R1}
   \      0x1E2   0x....             LDR      R2,??DataTable5_49
   \      0x1E4   0xC203             STM      R2!,{R0,R1}
   \      0x1E6   0x3A08             SUBS     R2,R2,#+8
    648                
    649                uint8_t Usart1index  = getProcessInfoIndex(MODULE_USART1);              //return Process index from processInfo array with the Uart2 driver
   \      0x1E8   0x2009             MOVS     R0,#+9
   \      0x1EA   0x....'....        BL       getProcessInfoIndex
   \      0x1EE   0x0004             MOVS     R4,R0
    650                usart1Control_Modbus = (Usart1_Control*) ((*(processInfoTable[Usart1index].Sched_DrvData.p_masterSharedMem_u32)).p_ramBuf_u8);
   \      0x1F0   0x....             LDR      R0,??DataTable5_50
   \      0x1F2   0x0021             MOVS     R1,R4
   \      0x1F4   0xB2C9             UXTB     R1,R1
   \      0x1F6   0x2216             MOVS     R2,#+22
   \      0x1F8   0x4351             MULS     R1,R2,R1
   \      0x1FA   0x1840             ADDS     R0,R0,R1
   \      0x1FC   0x300B             ADDS     R0,R0,#+11
   \      0x1FE   0x....'....        BL       __aeabi_uread4
   \      0x202   0x6800             LDR      R0,[R0, #+0]
   \      0x204   0x....             LDR      R1,??Modbus_ParseReceivedMessages_0
   \      0x206   0x6008             STR      R0,[R1, #+0]
    651                return_state_u8 = RUN_MODULE ;
   \      0x208   0x2002             MOVS     R0,#+2
    652                break;
   \      0x20A   0xE028             B        ??moduleModbus_7
    653              }
    654            case RUN_MODULE: 
    655              {
    656                //unsigned char received_slave_address_u8 = (*usart1Control_Modbus).seqMem_RawRx;
    657                //unsigned char received_function_code_u8 = (*usart1Control_Modbus).seqMem_RawRx;
    658                // test CRC
    659                // test length
    660                
    661                //Ring_Buf_Handle seqMem_ModbusRx;
    662                //Ring_Buf_Handle seqMemTX;
    663                //Ring_Buf_Handle seqMem_RawRx;
    664                //int16_t motorSpeed_s16;
    665                //uint16_t motorStatus_u16;
    666                //uint8_t errorCode_u8;
    667                //} Usart1_Control;		
    668          
    669                if(getSysCount() >= tt_ModbusLinkLostStop) // Modbus Link Lost
   \                     ??moduleModbus_4: (+1)
   \      0x20C   0x....'....        BL       getSysCount
   \      0x210   0x....             LDR      R2,??DataTable5_49
   \      0x212   0xCA0C             LDM      R2,{R2,R3}
   \      0x214   0x4299             CMP      R1,R3
   \      0x216   0xD30A             BCC      ??moduleModbus_9
   \      0x218   0xD801             BHI      ??moduleModbus_10
   \      0x21A   0x4290             CMP      R0,R2
   \      0x21C   0xD307             BCC      ??moduleModbus_9
    670                {            
    671                  MotorDemandMux_ModbusUpdate(0, 0, 1, 5, 1);
   \                     ??moduleModbus_10: (+1)
   \      0x21E   0x2001             MOVS     R0,#+1
   \      0x220   0x9000             STR      R0,[SP, #+0]
   \      0x222   0x2305             MOVS     R3,#+5
   \      0x224   0x2201             MOVS     R2,#+1
   \      0x226   0x2100             MOVS     R1,#+0
   \      0x228   0x2000             MOVS     R0,#+0
   \      0x22A   0x....'....        BL       MotorDemandMux_ModbusUpdate
    672                }  	  
    673                Modbus_ParseReceivedMessages();
   \                     ??moduleModbus_9: (+1)
   \      0x22E   0x....'....        BL       Modbus_ParseReceivedMessages
    674          	/*  if(RingBuf_GetUsedNumOfElements((*usart1Control_Modbus).seqMemTX) == 0 ) {
    675          		//if no message are to be sent then flip the direction of the tranciever to receive new messages
    676          		Set_DE_Mode(MODBUS_FOLLOWER_RX);
    677          	  }*/
    678          	  
    679                return_state_u8 = RUN_MODULE ;
   \      0x232   0x2002             MOVS     R0,#+2
    680                break;
   \      0x234   0xE013             B        ??moduleModbus_7
    681              }
    682            case KILL_MODULE: 
    683              {
    684                // The USART1 driver module must only be executed once.
    685                // Setting processStatus_u8 to PROCESS_STATUS_KILLED prevents the scheduler main loop from calling this module again.
    686                uint8_t table_index_u8 = getProcessInfoIndex(drv_id_u8);
   \                     ??moduleModbus_5: (+1)
   \      0x236   0x4668             MOV      R0,SP
   \      0x238   0x7B00             LDRB     R0,[R0, #+12]
   \      0x23A   0x....'....        BL       getProcessInfoIndex
   \      0x23E   0x0001             MOVS     R1,R0
    687                if (table_index_u8 != INDEX_NOT_FOUND) {
   \      0x240   0x0008             MOVS     R0,R1
   \      0x242   0xB2C0             UXTB     R0,R0
   \      0x244   0x28FF             CMP      R0,#+255
   \      0x246   0xD007             BEQ      ??moduleModbus_11
    688                  processInfoTable[table_index_u8].Sched_DrvData.processStatus_u8 = PROCESS_STATUS_KILLED;
   \      0x248   0x20FF             MOVS     R0,#+255
   \      0x24A   0x....             LDR      R2,??DataTable5_50
   \      0x24C   0x000B             MOVS     R3,R1
   \      0x24E   0xB2DB             UXTB     R3,R3
   \      0x250   0x2416             MOVS     R4,#+22
   \      0x252   0x4363             MULS     R3,R4,R3
   \      0x254   0x18D2             ADDS     R2,R2,R3
   \      0x256   0x7290             STRB     R0,[R2, #+10]
    689                }
    690                return_state_u8 = KILL_MODULE;
   \                     ??moduleModbus_11: (+1)
   \      0x258   0x20FF             MOVS     R0,#+255
    691                break;
   \      0x25A   0xE000             B        ??moduleModbus_7
    692              }
    693            default: 
    694              {
    695                return_state_u8 = KILL_MODULE;
   \                     ??moduleModbus_6: (+1)
   \      0x25C   0x20FF             MOVS     R0,#+255
    696                break;
    697              }
    698            }
    699            return return_state_u8;
   \                     ??moduleModbus_7: (+1)
   \      0x25E   0xB2C0             UXTB     R0,R0
   \      0x260   0xB007             ADD      SP,SP,#+28
   \      0x262   0xBDF0             POP      {R4-R7,PC}       ;; return
    700          }
    701          
    702          
    703          /**
    704          ********************************************************************************
    705          * @brief   Assign structured memory
    706          * @details Assign structured memory for digital outputs module
    707          * @param   None 
    708          * @return  None
    709          ********************************************************************************
    710          */

   \                                 In section .text, align 2, keep-with-next
    711          void AssignModuleMemModbus(void){   
   \                     AssignModuleMemModbus: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    712            module_Control_StructMem_u32 =  StructMem_CreateInstance(MODULE_MODBUS, sizeof(Modbus_Control), ACCESS_MODE_WRITE_ONLY, NULL, EMPTY_LIST);
   \        0x2   0x....             LDR      R4,??DataTable5_51
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x2202             MOVS     R2,#+2
   \        0xC   0x210C             MOVS     R1,#+12
   \        0xE   0x200B             MOVS     R0,#+11
   \       0x10   0x....'....        BL       StructMem_CreateInstance
   \       0x14   0x6020             STR      R0,[R4, #+0]
    713            (*module_Control_StructMem_u32).p_ramBuf_u8 = (uint8_t *)&modbus_RTU_Control ;    // Map the ADC1 memory into the structured memory
   \       0x16   0x....             LDR      R0,??DataTable5
   \       0x18   0x6821             LDR      R1,[R4, #+0]
   \       0x1A   0x6008             STR      R0,[R1, #+0]
    714            uint8_t module_modbus_index_u8 = getProcessInfoIndex(MODULE_MODBUS);
   \       0x1C   0x200B             MOVS     R0,#+11
   \       0x1E   0x....'....        BL       getProcessInfoIndex
   \       0x22   0x0005             MOVS     R5,R0
    715            processInfoTable[module_modbus_index_u8].Sched_ModuleData.p_masterSharedMem_u32 = (Ram_Buf_Handle)module_Control_StructMem_u32;
   \       0x24   0x....             LDR      R0,??DataTable5_50
   \       0x26   0x0029             MOVS     R1,R5
   \       0x28   0xB2C9             UXTB     R1,R1
   \       0x2A   0x2216             MOVS     R2,#+22
   \       0x2C   0x4351             MULS     R1,R2,R1
   \       0x2E   0x1840             ADDS     R0,R0,R1
   \       0x30   0x0001             MOVS     R1,R0
   \       0x32   0x310B             ADDS     R1,R1,#+11
   \       0x34   0x6820             LDR      R0,[R4, #+0]
   \       0x36   0x....'....        BL       __aeabi_uwrite4
    716          }
   \       0x3A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    717          

   \                                 In section .bss, align 1
    718          uint8_t modbus_message_counter_u8 = 0; // !errorTemporary
   \                     modbus_message_counter_u8:
   \        0x0                      DS8 1
    719          
    720          // Checks Message Length: Returns 0, if length accepted, Returns 1 if buffer overflow

   \                                 In section .text, align 2, keep-with-next
    721          uint8_t Modbus_ReallocateTxBufferForLength(uint8_t message_length) {
   \                     Modbus_ReallocateTxBufferForLength: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
    722          #if ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN >= 1
    723            if (message_length > FIXED_MODBUS_PROTOCOLBUF_TX_MAX_LENGTH) {
   \        0x4   0x0008             MOVS     R0,R1
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x2851             CMP      R0,#+81
   \        0xA   0xDB01             BLT      ??Modbus_ReallocateTxBufferForLength_0
    724              return 1; // Message would overflow buffer
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE000             B        ??Modbus_ReallocateTxBufferForLength_1
    725            }
    726          #else // if ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN <= 0
    727            if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, message_length)) == NULL) {
    728              reallocError++;
    729              return 1;
    730            }
    731          #endif // if ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN <= 0
    732            return 0; // Message will fit in allocated buffer
   \                     ??Modbus_ReallocateTxBufferForLength_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \                     ??Modbus_ReallocateTxBufferForLength_1: (+1)
   \       0x12   0xBD00             POP      {PC}             ;; return
    733          }
    734          

   \                                 In section .text, align 2, keep-with-next
    735          uint8_t Modbus_ReallocateRxBufferForLength(uint8_t message_length) {
   \                     Modbus_ReallocateRxBufferForLength: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0001             MOVS     R1,R0
    736          #if ENABLE_MODBUS_PROTOCOLBUF_RX_FIXED_LEN >= 1
    737            if (message_length > FIXED_MODBUS_PROTOCOLBUF_RX_MAX_LENGTH) {
   \        0x4   0x0008             MOVS     R0,R1
   \        0x6   0xB2C0             UXTB     R0,R0
   \        0x8   0x2851             CMP      R0,#+81
   \        0xA   0xDB01             BLT      ??Modbus_ReallocateRxBufferForLength_0
    738              return 1; // Message would overflow buffer
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE000             B        ??Modbus_ReallocateRxBufferForLength_1
    739            }
    740          #else // if ENABLE_MODBUS_PROTOCOLBUF_RX_FIXED_LEN <= 0
    741            if((modbus_ProtocolBufRX = (uint8_t *) realloc(modbus_ProtocolBufRX, message_length)) == NULL) {
    742              reallocError++;
    743              return 1;
    744            }
    745          #endif // if ENABLE_MODBUS_PROTOCOLBUF_RX_FIXED_LEN <= 0
    746            return 0; // Message will fit in allocated buffer
   \                     ??Modbus_ReallocateRxBufferForLength_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \                     ??Modbus_ReallocateRxBufferForLength_1: (+1)
   \       0x12   0xBD00             POP      {PC}             ;; return
    747          }
    748          
    749          

   \                                 In section .text, align 4, keep-with-next
    750          void Modbus_ParseReceivedMessages(void) {
   \                     Modbus_ParseReceivedMessages: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    751            // TODO: Accept Messages of Various Lengths, will require updates to driver_usart1 as well.
    752            // TODO: Length Checking for individual Messages
    753            uint32_t DataLen2_u32		= MODBUS_MIN_MESSAGE_LEN;
   \        0x4   0x2405             MOVS     R4,#+5
   \        0x6   0x9403             STR      R4,[SP, #+12]
    754            uint32_t responseLength_u32 = (uint32_t) MINIMUM_RESPONSE_LENGTH;
   \        0x8   0x9401             STR      R4,[SP, #+4]
    755            uint8_t number_of_coil_bytes_u8 = 0;
   \        0xA   0x2600             MOVS     R6,#+0
   \        0xC   0x0030             MOVS     R0,R6
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x7048             STRB     R0,[R1, #+1]
    756            
    757            DataLen2_u32 = RingBuf_GetUsedNumOfElements((*usart1Control_Modbus).seqMem_ModbusRx);
   \       0x12   0x4872             LDR      R0,??Modbus_ParseReceivedMessages_0
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0x....'....        BL       RingBuf_GetUsedNumOfElements
   \       0x1C   0x9003             STR      R0,[SP, #+12]
    758            if(DataLen2_u32 >= MODBUS_MIN_MESSAGE_LEN) {
   \       0x1E   0x9803             LDR      R0,[SP, #+12]
   \       0x20   0x2805             CMP      R0,#+5
   \       0x22   0xD201             BCS      .+6
   \       0x24   0xF000 0xFF10      BL       ??Modbus_ParseReceivedMessages_8
    759              // if((modbus_ProtocolBufRX = (unsigned char*) realloc(modbus_ProtocolBufRX,DataLen2_u32)) == NULL) reallocError++;     //allocate the right frame size of memory for buffer
    760              uint8_t error_occurred = Modbus_ReallocateRxBufferForLength(DataLen2_u32);
   \       0x28   0x9803             LDR      R0,[SP, #+12]
   \       0x2A   0xB2C0             UXTB     R0,R0
   \       0x2C   0x....'....        BL       Modbus_ReallocateRxBufferForLength
   \       0x30   0x4669             MOV      R1,SP
   \       0x32   0x7588             STRB     R0,[R1, #+22]
    761              if (error_occurred) {
   \       0x34   0x4668             MOV      R0,SP
   \       0x36   0x7D80             LDRB     R0,[R0, #+22]
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD021             BEQ      ??Modbus_ParseReceivedMessages_9
    762                // Read All Data (Clear the Buffer),  so we don't get stuck with the Buffer full
    763                while (DataLen2_u32 > 0) {
   \                     ??Modbus_ParseReceivedMessages_10: (+1)
   \       0x3C   0x9803             LDR      R0,[SP, #+12]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD01C             BEQ      ??Modbus_ParseReceivedMessages_11
    764                  if (DataLen2_u32 > FIXED_MODBUS_PROTOCOLBUF_RX_MAX_LENGTH) {
   \       0x42   0x9803             LDR      R0,[SP, #+12]
   \       0x44   0x2851             CMP      R0,#+81
   \       0x46   0xD30D             BCC      ??Modbus_ParseReceivedMessages_12
    765                    // REVIEW: Replace with RingBuf_ClearContents? Much less processing
    766                    unsigned int read_length = FIXED_MODBUS_PROTOCOLBUF_RX_MAX_LENGTH;
   \       0x48   0x2050             MOVS     R0,#+80
   \       0x4A   0x9007             STR      R0,[SP, #+28]
    767                    RingBuf_ReadBlock((*usart1Control_Modbus).seqMem_ModbusRx, modbus_ProtocolBufRX, &read_length); //extract the whole frame
   \       0x4C   0xAA07             ADD      R2,SP,#+28
   \       0x4E   0x4864             LDR      R0,??Modbus_ParseReceivedMessages_0+0x4
   \       0x50   0x6801             LDR      R1,[R0, #+0]
   \       0x52   0x4862             LDR      R0,??Modbus_ParseReceivedMessages_0
   \       0x54   0x6800             LDR      R0,[R0, #+0]
   \       0x56   0x6800             LDR      R0,[R0, #+0]
   \       0x58   0x....'....        BL       RingBuf_ReadBlock
    768                    DataLen2_u32 -= FIXED_MODBUS_PROTOCOLBUF_RX_MAX_LENGTH;
   \       0x5C   0x9803             LDR      R0,[SP, #+12]
   \       0x5E   0x3850             SUBS     R0,R0,#+80
   \       0x60   0x9003             STR      R0,[SP, #+12]
   \       0x62   0xE7EB             B        ??Modbus_ParseReceivedMessages_10
    769                  } else {
    770                    unsigned int read_length = DataLen2_u32;
   \                     ??Modbus_ParseReceivedMessages_12: (+1)
   \       0x64   0x9803             LDR      R0,[SP, #+12]
   \       0x66   0x9004             STR      R0,[SP, #+16]
    771                    RingBuf_ReadBlock((*usart1Control_Modbus).seqMem_ModbusRx, modbus_ProtocolBufRX, &read_length); //extract the whole frame
   \       0x68   0xAA04             ADD      R2,SP,#+16
   \       0x6A   0x485D             LDR      R0,??Modbus_ParseReceivedMessages_0+0x4
   \       0x6C   0x6801             LDR      R1,[R0, #+0]
   \       0x6E   0x485B             LDR      R0,??Modbus_ParseReceivedMessages_0
   \       0x70   0x6800             LDR      R0,[R0, #+0]
   \       0x72   0x6800             LDR      R0,[R0, #+0]
   \       0x74   0x....'....        BL       RingBuf_ReadBlock
    772                    DataLen2_u32 = 0;
   \       0x78   0x9603             STR      R6,[SP, #+12]
   \       0x7A   0xE7DF             B        ??Modbus_ParseReceivedMessages_10
    773                  }
    774                }
    775                // Exit Gracefully
    776                return;
   \                     ??Modbus_ParseReceivedMessages_11: (+1)
   \       0x7C   0xF000 0xFEE4      BL       ??Modbus_ParseReceivedMessages_13
    777              }
    778              
    779              RingBuf_ReadBlock((*usart1Control_Modbus).seqMem_ModbusRx, modbus_ProtocolBufRX, &DataLen2_u32); //extract the whole frame into he temporary modbus_ProtocolBuf
   \                     ??Modbus_ParseReceivedMessages_9: (+1)
   \       0x80   0x4D57             LDR      R5,??Modbus_ParseReceivedMessages_0+0x4
   \       0x82   0xAA03             ADD      R2,SP,#+12
   \       0x84   0x6829             LDR      R1,[R5, #+0]
   \       0x86   0x4855             LDR      R0,??Modbus_ParseReceivedMessages_0
   \       0x88   0x6800             LDR      R0,[R0, #+0]
   \       0x8A   0x6800             LDR      R0,[R0, #+0]
   \       0x8C   0x....'....        BL       RingBuf_ReadBlock
    780              //decode and perform the CMD function
    781              uint8_t slave_address_u8 = modbus_ProtocolBufRX[BYTE_0];
   \       0x90   0x6828             LDR      R0,[R5, #+0]
   \       0x92   0x7800             LDRB     R0,[R0, #+0]
   \       0x94   0x4669             MOV      R1,SP
   \       0x96   0x7008             STRB     R0,[R1, #+0]
    782              uint8_t function_code_u8 = modbus_ProtocolBufRX[BYTE_1]; // does not include address or checksum, does include this length byte
   \       0x98   0x6828             LDR      R0,[R5, #+0]
   \       0x9A   0x7847             LDRB     R7,[R0, #+1]
    783              uint8_t crc_lo_u8 = modbus_ProtocolBufRX[DataLen2_u32 - 2];
   \       0x9C   0x6828             LDR      R0,[R5, #+0]
   \       0x9E   0x9903             LDR      R1,[SP, #+12]
   \       0xA0   0x1840             ADDS     R0,R0,R1
   \       0xA2   0x1E80             SUBS     R0,R0,#+2
   \       0xA4   0x7800             LDRB     R0,[R0, #+0]
   \       0xA6   0x4669             MOV      R1,SP
   \       0xA8   0x7548             STRB     R0,[R1, #+21]
    784              uint8_t crc_hi_u8 = modbus_ProtocolBufRX[DataLen2_u32 - 1];
   \       0xAA   0x6828             LDR      R0,[R5, #+0]
   \       0xAC   0x9903             LDR      R1,[SP, #+12]
   \       0xAE   0x1840             ADDS     R0,R0,R1
   \       0xB0   0x1E40             SUBS     R0,R0,#+1
   \       0xB2   0x7800             LDRB     R0,[R0, #+0]
   \       0xB4   0x4669             MOV      R1,SP
   \       0xB6   0x7508             STRB     R0,[R1, #+20]
    785              uint16_t register_address_u16 		= modbus_ProtocolBufRX[BYTE_2]*BYTE_TO_WORD_MSB + modbus_ProtocolBufRX[BYTE_3]*BYTE_TO_WORD_LSB;
   \       0xB8   0x6828             LDR      R0,[R5, #+0]
   \       0xBA   0x7880             LDRB     R0,[R0, #+2]
   \       0xBC   0x2180             MOVS     R1,#+128
   \       0xBE   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0xC0   0x4348             MULS     R0,R1,R0
   \       0xC2   0x6829             LDR      R1,[R5, #+0]
   \       0xC4   0x78C9             LDRB     R1,[R1, #+3]
   \       0xC6   0x1840             ADDS     R0,R0,R1
   \       0xC8   0x4669             MOV      R1,SP
   \       0xCA   0x8108             STRH     R0,[R1, #+8]
    786              uint16_t number_of_registers_u16	= modbus_ProtocolBufRX[BYTE_4]*BYTE_TO_WORD_MSB + modbus_ProtocolBufRX[BYTE_5]*BYTE_TO_WORD_LSB;		
   \       0xCC   0x6828             LDR      R0,[R5, #+0]
   \       0xCE   0x7900             LDRB     R0,[R0, #+4]
   \       0xD0   0x2180             MOVS     R1,#+128
   \       0xD2   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \       0xD4   0x4348             MULS     R0,R1,R0
   \       0xD6   0x6829             LDR      R1,[R5, #+0]
   \       0xD8   0x7949             LDRB     R1,[R1, #+5]
   \       0xDA   0x1840             ADDS     R0,R0,R1
   \       0xDC   0x4669             MOV      R1,SP
   \       0xDE   0x8048             STRH     R0,[R1, #+2]
    787              uint16_t crc_received_u16 = (uint16_t) ((crc_hi_u8*256) | (crc_lo_u8));
   \       0xE0   0x4668             MOV      R0,SP
   \       0xE2   0x7D01             LDRB     R1,[R0, #+20]
   \       0xE4   0x2080             MOVS     R0,#+128
   \       0xE6   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \       0xE8   0x4348             MULS     R0,R1,R0
   \       0xEA   0x4669             MOV      R1,SP
   \       0xEC   0x7D49             LDRB     R1,[R1, #+21]
   \       0xEE   0x4308             ORRS     R0,R0,R1
   \       0xF0   0x4669             MOV      R1,SP
   \       0xF2   0x8308             STRH     R0,[R1, #+24]
    788              
    789              //All characters in msg included in checksum
    790              //for (index_u8 = 0; index_u8 < (DataLen2_u32 - 2); index_u8++) {
    791              //	UpdateChecksum(modbus_ProtocolBufRX[index_u8], &localCHK);
    792              //}
    793              //FixChecksum(&localCHK);
    794              //uint8_t myBoolean;
    795              //myBoolean = isChecksumValid(modbus_ProtocolBufRX, DataLen2_u32 - 2, &localCHK);
    796              
    797              uint16_t crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufRX, (DataLen2_u32 - 2));
   \       0xF4   0x9803             LDR      R0,[SP, #+12]
   \       0xF6   0x1E81             SUBS     R1,R0,#+2
   \       0xF8   0xB289             UXTH     R1,R1
   \       0xFA   0x6828             LDR      R0,[R5, #+0]
   \       0xFC   0x....'....        BL       calculateModbusCRC
   \      0x100   0x4669             MOV      R1,SP
   \      0x102   0x8348             STRH     R0,[R1, #+26]
    798              //uint16_t alt_calculated_u16 = calculateMODBUSCRC(modbus_ProtocolBufRX, (DataLen2_u32 - 2));
    799              //uint16_t crc_calculated_u16 = Modbus_CalculateCrc((DataLen2_u32 - 2) , modbus_ProtocolBufRX);
    800              
    801              // MRM: Validate CRC
    802              if(crc_received_u16 != crc_calculated_u16) {
   \      0x104   0x4668             MOV      R0,SP
   \      0x106   0x8B00             LDRH     R0,[R0, #+24]
   \      0x108   0x4669             MOV      R1,SP
   \      0x10A   0x8B49             LDRH     R1,[R1, #+26]
   \      0x10C   0x4288             CMP      R0,R1
   \      0x10E   0xD030             BEQ      ??Modbus_ParseReceivedMessages_14
    803                // send exception for bad CRC
    804                responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \      0x110   0x9401             STR      R4,[SP, #+4]
    805                uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x112   0x9801             LDR      R0,[SP, #+4]
   \      0x114   0xB2C0             UXTB     R0,R0
   \      0x116   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x11A   0x4669             MOV      R1,SP
   \      0x11C   0x7288             STRB     R0,[R1, #+10]
    806                if (error_occurred) {
   \      0x11E   0x4668             MOV      R0,SP
   \      0x120   0x7A80             LDRB     R0,[R0, #+10]
   \      0x122   0x2800             CMP      R0,#+0
   \      0x124   0xD001             BEQ      .+6
   \      0x126   0xF000 0xFE8F      BL       ??Modbus_ParseReceivedMessages_13
    807                  return;
    808                }
    809                // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
    810                
    811                // build header
    812                modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_15: (+1)
   \      0x12A   0x4C94             LDR      R4,??Modbus_ParseReceivedMessages_1
   \      0x12C   0x4668             MOV      R0,SP
   \      0x12E   0x7800             LDRB     R0,[R0, #+0]
   \      0x130   0x6821             LDR      R1,[R4, #+0]
   \      0x132   0x7008             STRB     R0,[R1, #+0]
    813                modbus_ProtocolBufTX[BYTE_1] = function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \      0x134   0x0038             MOVS     R0,R7
   \      0x136   0x3880             SUBS     R0,R0,#+128
   \      0x138   0x6821             LDR      R1,[R4, #+0]
   \      0x13A   0x7048             STRB     R0,[R1, #+1]
    814                modbus_ProtocolBufTX[BYTE_2] = (uint8_t) MODBUS_EXCEPTION_04;
   \      0x13C   0x2004             MOVS     R0,#+4
   \      0x13E   0x6821             LDR      R1,[R4, #+0]
   \      0x140   0x7088             STRB     R0,[R1, #+2]
    815                crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufRX, (DataLen2_u32 - 2));			
   \      0x142   0x9803             LDR      R0,[SP, #+12]
   \      0x144   0x1E81             SUBS     R1,R0,#+2
   \      0x146   0xB289             UXTH     R1,R1
   \      0x148   0x6828             LDR      R0,[R5, #+0]
   \      0x14A   0x....'....        BL       calculateModbusCRC
   \      0x14E   0x0005             MOVS     R5,R0
    816                modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);								// crc LSB
   \      0x150   0x0028             MOVS     R0,R5
   \      0x152   0x6821             LDR      R1,[R4, #+0]
   \      0x154   0x70C8             STRB     R0,[R1, #+3]
    817                modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);								// crc MSB
   \      0x156   0x0028             MOVS     R0,R5
   \      0x158   0xB280             UXTH     R0,R0
   \      0x15A   0x0A00             LSRS     R0,R0,#+8
   \      0x15C   0x6821             LDR      R1,[R4, #+0]
   \      0x15E   0x7108             STRB     R0,[R1, #+4]
    818                     
    819                // write to seq Mem structure
    820                RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf								  
   \      0x160   0xAA01             ADD      R2,SP,#+4
   \      0x162   0x6821             LDR      R1,[R4, #+0]
   \      0x164   0x481D             LDR      R0,??Modbus_ParseReceivedMessages_0
   \      0x166   0x6800             LDR      R0,[R0, #+0]
   \      0x168   0x6840             LDR      R0,[R0, #+4]
   \      0x16A   0x....'....        BL       RingBuf_WriteBlock
    821          #if ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN <= 0
    822                if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX,1)) == NULL) reallocError++;	
    823          #endif //ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN <= 0
    824                
    825                return;
   \      0x16E   0xF000 0xFE6B      BL       ??Modbus_ParseReceivedMessages_13
    826              }
    827              
    828              // Validate modbus slave address
    829              if (slave_address_u8 != MODBUS_ADDRESS) {
   \                     ??Modbus_ParseReceivedMessages_14: (+1)
   \      0x172   0x4668             MOV      R0,SP
   \      0x174   0x7800             LDRB     R0,[R0, #+0]
   \      0x176   0x28F7             CMP      R0,#+247
   \      0x178   0xD034             BEQ      ??Modbus_ParseReceivedMessages_16
    830                // MRM: return exception code for invalid slave address
    831                responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \      0x17A   0x9401             STR      R4,[SP, #+4]
    832                uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x17C   0x9801             LDR      R0,[SP, #+4]
   \      0x17E   0xB2C0             UXTB     R0,R0
   \      0x180   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x184   0x4669             MOV      R1,SP
   \      0x186   0x7288             STRB     R0,[R1, #+10]
    833                if (error_occurred) {
   \      0x188   0x4668             MOV      R0,SP
   \      0x18A   0x7A80             LDRB     R0,[R0, #+10]
   \      0x18C   0x2800             CMP      R0,#+0
   \      0x18E   0xD001             BEQ      .+6
   \      0x190   0xF000 0xFE5A      BL       ??Modbus_ParseReceivedMessages_13
    834                  return;
    835                }
    836                // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
    837                
    838                // build exception header
    839                modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_17: (+1)
   \      0x194   0x4C79             LDR      R4,??Modbus_ParseReceivedMessages_1
   \      0x196   0x4668             MOV      R0,SP
   \      0x198   0x7800             LDRB     R0,[R0, #+0]
   \      0x19A   0x6821             LDR      R1,[R4, #+0]
   \      0x19C   0x7008             STRB     R0,[R1, #+0]
    840                modbus_ProtocolBufTX[BYTE_1] = function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \      0x19E   0x0038             MOVS     R0,R7
   \      0x1A0   0x3880             SUBS     R0,R0,#+128
   \      0x1A2   0x6821             LDR      R1,[R4, #+0]
   \      0x1A4   0x7048             STRB     R0,[R1, #+1]
    841                modbus_ProtocolBufTX[BYTE_2] = (uint8_t) MODBUS_EXCEPTION_04;
   \      0x1A6   0x2004             MOVS     R0,#+4
   \      0x1A8   0x6821             LDR      R1,[R4, #+0]
   \      0x1AA   0x7088             STRB     R0,[R1, #+2]
    842                crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufRX, (DataLen2_u32 - 2));			
   \      0x1AC   0x9803             LDR      R0,[SP, #+12]
   \      0x1AE   0x1E81             SUBS     R1,R0,#+2
   \      0x1B0   0xB289             UXTH     R1,R1
   \      0x1B2   0x6828             LDR      R0,[R5, #+0]
   \      0x1B4   0x....'....        BL       calculateModbusCRC
   \      0x1B8   0x0005             MOVS     R5,R0
    843                modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);								// crc LSB
   \      0x1BA   0x0028             MOVS     R0,R5
   \      0x1BC   0x6821             LDR      R1,[R4, #+0]
   \      0x1BE   0x70C8             STRB     R0,[R1, #+3]
    844                modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);								// crc MSB
   \      0x1C0   0x0028             MOVS     R0,R5
   \      0x1C2   0xB280             UXTH     R0,R0
   \      0x1C4   0x0A00             LSRS     R0,R0,#+8
   \      0x1C6   0x6821             LDR      R1,[R4, #+0]
   \      0x1C8   0x7108             STRB     R0,[R1, #+4]
    845                
    846                // write to seq Mem structure
    847                RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf								  
   \      0x1CA   0xAA01             ADD      R2,SP,#+4
   \      0x1CC   0x6821             LDR      R1,[R4, #+0]
   \      0x1CE   0x4803             LDR      R0,??Modbus_ParseReceivedMessages_0
   \      0x1D0   0x6800             LDR      R0,[R0, #+0]
   \      0x1D2   0x6840             LDR      R0,[R0, #+4]
   \      0x1D4   0x....'....        BL       RingBuf_WriteBlock
    848          #if ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN <= 0
    849                if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX,1)) == NULL) reallocError++;	
    850          #endif //ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN <= 0		  		  
    851                return;
   \      0x1D8   0xF000 0xFE36      BL       ??Modbus_ParseReceivedMessages_13
   \                     ??Modbus_ParseReceivedMessages_0:
   \      0x1DC   0x....'....        DC32     usart1Control_Modbus
   \      0x1E0   0x....'....        DC32     modbus_ProtocolBufRX
    852              }
    853              
    854              // MRM: Validate message length length
    855              //if (DataLen2_u32 < MODBUS_MIN_MESSAGE_LEN) {
    856              //  	// MRM: return exception code for invalid message lengths
    857              //    return;
    858              //}
    859              tt_ModbusLinkLostStop = getSysCount() + MODBUS_LOST_LINK_TIME; // Restart Modbus Link Lost Timer
   \                     ??Modbus_ParseReceivedMessages_16: (+1)
   \      0x1E4   0x....'....        BL       getSysCount
   \      0x1E8   0x0002             MOVS     R2,R0
   \      0x1EA   0x000B             MOVS     R3,R1
   \      0x1EC   0x4864             LDR      R0,??Modbus_ParseReceivedMessages_1+0x4  ;; 0xbb8
   \      0x1EE   0x2100             MOVS     R1,#+0
   \      0x1F0   0x1880             ADDS     R0,R0,R2
   \      0x1F2   0x4159             ADCS     R1,R1,R3
   \      0x1F4   0x4A63             LDR      R2,??Modbus_ParseReceivedMessages_1+0x8
   \      0x1F6   0xC203             STM      R2!,{R0,R1}
   \      0x1F8   0x3A08             SUBS     R2,R2,#+8
    860              switch(function_code_u8) 
   \      0x1FA   0x0038             MOVS     R0,R7
   \      0x1FC   0xB2C0             UXTB     R0,R0
   \      0x1FE   0x2801             CMP      R0,#+1
   \      0x200   0xD029             BEQ      ??Modbus_ParseReceivedMessages_18
   \      0x202   0x2802             CMP      R0,#+2
   \      0x204   0xD100             BNE      .+4
   \      0x206   0xE0B7             B        ??Modbus_ParseReceivedMessages_19
   \      0x208   0x2803             CMP      R0,#+3
   \      0x20A   0xD100             BNE      .+4
   \      0x20C   0xE14C             B        ??Modbus_ParseReceivedMessages_20
   \      0x20E   0x2804             CMP      R0,#+4
   \      0x210   0xD100             BNE      .+4
   \      0x212   0xE1C6             B        ??Modbus_ParseReceivedMessages_21
   \      0x214   0x2806             CMP      R0,#+6
   \      0x216   0xD100             BNE      .+4
   \      0x218   0xE245             B        ??Modbus_ParseReceivedMessages_22
   \      0x21A   0x280F             CMP      R0,#+15
   \      0x21C   0xD100             BNE      .+4
   \      0x21E   0xE2B9             B        ??Modbus_ParseReceivedMessages_23
   \      0x220   0x2810             CMP      R0,#+16
   \      0x222   0xD100             BNE      .+4
   \      0x224   0xE349             B        ??Modbus_ParseReceivedMessages_24
   \      0x226   0x2814             CMP      R0,#+20
   \      0x228   0xD100             BNE      .+4
   \      0x22A   0xE3C1             B        ??Modbus_ParseReceivedMessages_25
   \      0x22C   0x2815             CMP      R0,#+21
   \      0x22E   0xD101             BNE      .+6
   \      0x230   0xF000 0xFCD6      BL       ??Modbus_ParseReceivedMessages_26
   \      0x234   0x28FB             CMP      R0,#+251
   \      0x236   0xD001             BEQ      .+6
   \      0x238   0xF000 0xFDDA      BL       ??Modbus_ParseReceivedMessages_27
    861              {
    862              case MODBUS_FUNCTION_CODE_UTILITY: {
    863                  if (DataLen2_u32 < MODUBS_FUNCTION_CODE_UTILITY_MIN_MESSAGE_LEN) {
   \                     ??Modbus_ParseReceivedMessages_28: (+1)
   \      0x23C   0x9803             LDR      R0,[SP, #+12]
   \      0x23E   0x2807             CMP      R0,#+7
   \      0x240   0xD201             BCS      .+6
   \      0x242   0xF000 0xFE01      BL       ??Modbus_ParseReceivedMessages_13
    864                    return;
    865                  } 
    866                  //        
    867                  Utility_ExecuteOperation(modbus_ProtocolBufRX[BYTE_2], modbus_ProtocolBufRX[BYTE_3], modbus_ProtocolBufRX[BYTE_4]);
   \                     ??Modbus_ParseReceivedMessages_29: (+1)
   \      0x246   0x6828             LDR      R0,[R5, #+0]
   \      0x248   0x7902             LDRB     R2,[R0, #+4]
   \      0x24A   0x6828             LDR      R0,[R5, #+0]
   \      0x24C   0x78C1             LDRB     R1,[R0, #+3]
   \      0x24E   0x6828             LDR      R0,[R5, #+0]
   \      0x250   0x7880             LDRB     R0,[R0, #+2]
   \      0x252   0x....'....        BL       Utility_ExecuteOperation
    868                  // Modbus_JumpToBootloader();
    869              }
    870                //case MODBUS_FUNCTION_CODE_READ_COILS:												
    871              case MODBUS_FUNCTION_CODE_READ_COILS: {
    872                //if (ProcessMBCoilRegister(modbus_ProtocolBufTX+READ_RESPONSE_HEADER_LENGTH, register_address_u16, number_of_registers_u16, MB_READ_REGISTER) == MB_ILLEGAL_ADDRESS) {
    873                if (ProcessMBCoilRegister_New(modbus_ProtocolBufTX+READ_RESPONSE_HEADER_LENGTH, register_address_u16, number_of_registers_u16, MB_READ_REGISTER) == MB_ILLEGAL_ADDRESS) {
   \                     ??Modbus_ParseReceivedMessages_18: (+1)
   \      0x256   0x4D49             LDR      R5,??Modbus_ParseReceivedMessages_1
   \      0x258   0x2300             MOVS     R3,#+0
   \      0x25A   0x4668             MOV      R0,SP
   \      0x25C   0x8842             LDRH     R2,[R0, #+2]
   \      0x25E   0x4668             MOV      R0,SP
   \      0x260   0x8901             LDRH     R1,[R0, #+8]
   \      0x262   0x6828             LDR      R0,[R5, #+0]
   \      0x264   0x1CC0             ADDS     R0,R0,#+3
   \      0x266   0x....'....        BL       ProcessMBCoilRegister_New
   \      0x26A   0x2801             CMP      R0,#+1
   \      0x26C   0xD12D             BNE      ??Modbus_ParseReceivedMessages_30
    874          		// send exception code for bad address
    875                  responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \      0x26E   0x9401             STR      R4,[SP, #+4]
    876                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x270   0x9801             LDR      R0,[SP, #+4]
   \      0x272   0xB2C0             UXTB     R0,R0
   \      0x274   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x278   0x0006             MOVS     R6,R0
    877                  if (error_occurred) {
   \      0x27A   0x0030             MOVS     R0,R6
   \      0x27C   0xB2C0             UXTB     R0,R0
   \      0x27E   0x2800             CMP      R0,#+0
   \      0x280   0xD001             BEQ      .+6
   \      0x282   0xF000 0xFDE1      BL       ??Modbus_ParseReceivedMessages_13
    878                    return;
    879                  }
    880                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
    881                  // build header
    882                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_31: (+1)
   \      0x286   0x4668             MOV      R0,SP
   \      0x288   0x7800             LDRB     R0,[R0, #+0]
   \      0x28A   0x6829             LDR      R1,[R5, #+0]
   \      0x28C   0x7008             STRB     R0,[R1, #+0]
    883                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \      0x28E   0x0038             MOVS     R0,R7
   \      0x290   0x3880             SUBS     R0,R0,#+128
   \      0x292   0x6829             LDR      R1,[R5, #+0]
   \      0x294   0x7048             STRB     R0,[R1, #+1]
    884                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) MODBUS_EXCEPTION_02;
   \      0x296   0x2002             MOVS     R0,#+2
   \      0x298   0x6829             LDR      R1,[R5, #+0]
   \      0x29A   0x7088             STRB     R0,[R1, #+2]
    885                  // build CRC
    886                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x29C   0x9801             LDR      R0,[SP, #+4]
   \      0x29E   0x1E81             SUBS     R1,R0,#+2
   \      0x2A0   0xB289             UXTH     R1,R1
   \      0x2A2   0x6828             LDR      R0,[R5, #+0]
   \      0x2A4   0x....'....        BL       calculateModbusCRC
   \      0x2A8   0x0004             MOVS     R4,R0
    887                  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);								// crc LSB
   \      0x2AA   0x0020             MOVS     R0,R4
   \      0x2AC   0x6829             LDR      R1,[R5, #+0]
   \      0x2AE   0x70C8             STRB     R0,[R1, #+3]
    888                  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);								// crc MSB
   \      0x2B0   0x0020             MOVS     R0,R4
   \      0x2B2   0xB280             UXTH     R0,R0
   \      0x2B4   0x0A00             LSRS     R0,R0,#+8
   \      0x2B6   0x6829             LDR      R1,[R5, #+0]
   \      0x2B8   0x7108             STRB     R0,[R1, #+4]
    889                  // write to seq Mem structure
    890                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf									
   \      0x2BA   0xAA01             ADD      R2,SP,#+4
   \      0x2BC   0x6829             LDR      R1,[R5, #+0]
   \      0x2BE   0x48D6             LDR      R0,??Modbus_ParseReceivedMessages_2
   \      0x2C0   0x6800             LDR      R0,[R0, #+0]
   \      0x2C2   0x6840             LDR      R0,[R0, #+4]
   \      0x2C4   0x....'....        BL       RingBuf_WriteBlock
   \      0x2C8   0xE054             B        ??Modbus_ParseReceivedMessages_32
    891                }
    892                else {
    893                  // build response message and send
    894                  if (number_of_registers_u16 % 8 == 0)
   \                     ??Modbus_ParseReceivedMessages_30: (+1)
   \      0x2CA   0x2408             MOVS     R4,#+8
   \      0x2CC   0x4668             MOV      R0,SP
   \      0x2CE   0x8840             LDRH     R0,[R0, #+2]
   \      0x2D0   0x0021             MOVS     R1,R4
   \      0x2D2   0x....'....        BL       __aeabi_idivmod
   \      0x2D6   0x2900             CMP      R1,#+0
   \      0x2D8   0xD107             BNE      ??Modbus_ParseReceivedMessages_33
    895                    number_of_coil_bytes_u8 = number_of_registers_u16/8;
   \      0x2DA   0x4668             MOV      R0,SP
   \      0x2DC   0x8840             LDRH     R0,[R0, #+2]
   \      0x2DE   0x0021             MOVS     R1,R4
   \      0x2E0   0x....'....        BL       __aeabi_idiv
   \      0x2E4   0x4669             MOV      R1,SP
   \      0x2E6   0x7048             STRB     R0,[R1, #+1]
   \      0x2E8   0xE007             B        ??Modbus_ParseReceivedMessages_34
    896                  else
    897                    number_of_coil_bytes_u8 = number_of_registers_u16/8 + 1;
   \                     ??Modbus_ParseReceivedMessages_33: (+1)
   \      0x2EA   0x4668             MOV      R0,SP
   \      0x2EC   0x8840             LDRH     R0,[R0, #+2]
   \      0x2EE   0x0021             MOVS     R1,R4
   \      0x2F0   0x....'....        BL       __aeabi_idiv
   \      0x2F4   0x1C40             ADDS     R0,R0,#+1
   \      0x2F6   0x4669             MOV      R1,SP
   \      0x2F8   0x7048             STRB     R0,[R1, #+1]
    898                  responseLength_u32 = READ_RESPONSE_HEADER_LENGTH + number_of_coil_bytes_u8 + CRC_LENGTH;	// exactly one partial byte for coils			  
   \                     ??Modbus_ParseReceivedMessages_34: (+1)
   \      0x2FA   0x4668             MOV      R0,SP
   \      0x2FC   0x7840             LDRB     R0,[R0, #+1]
   \      0x2FE   0x1D40             ADDS     R0,R0,#+5
   \      0x300   0x9001             STR      R0,[SP, #+4]
    899                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x302   0x9801             LDR      R0,[SP, #+4]
   \      0x304   0xB2C0             UXTB     R0,R0
   \      0x306   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x30A   0x4669             MOV      R1,SP
   \      0x30C   0x7288             STRB     R0,[R1, #+10]
    900                  if (error_occurred) {
   \      0x30E   0x4668             MOV      R0,SP
   \      0x310   0x7A80             LDRB     R0,[R0, #+10]
   \      0x312   0x2800             CMP      R0,#+0
   \      0x314   0xD001             BEQ      .+6
   \      0x316   0xF000 0xFD97      BL       ??Modbus_ParseReceivedMessages_13
    901                    return;
    902                  }
    903                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;	
    904                  // build header
    905                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_35: (+1)
   \      0x31A   0x4668             MOV      R0,SP
   \      0x31C   0x7800             LDRB     R0,[R0, #+0]
   \      0x31E   0x6829             LDR      R1,[R5, #+0]
   \      0x320   0x7008             STRB     R0,[R1, #+0]
    906                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8;
   \      0x322   0x6828             LDR      R0,[R5, #+0]
   \      0x324   0x7047             STRB     R7,[R0, #+1]
    907                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) number_of_coil_bytes_u8;								// 1 byte per multiple of 8 coils
   \      0x326   0x4668             MOV      R0,SP
   \      0x328   0x7840             LDRB     R0,[R0, #+1]
   \      0x32A   0x6829             LDR      R1,[R5, #+0]
   \      0x32C   0x7088             STRB     R0,[R1, #+2]
    908                  //modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (register_address_u16 >> 8);								// starting register
    909                  //modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (register_address_u16 >> 0);					
    910                  // build CRC
    911                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x32E   0x4ECB             LDR      R6,??Modbus_ParseReceivedMessages_3  ;; 0xfffe
   \      0x330   0x9801             LDR      R0,[SP, #+4]
   \      0x332   0x1981             ADDS     R1,R0,R6
   \      0x334   0xB289             UXTH     R1,R1
   \      0x336   0x6828             LDR      R0,[R5, #+0]
   \      0x338   0x....'....        BL       calculateModbusCRC
   \      0x33C   0x0004             MOVS     R4,R0
    912                  modbus_ProtocolBufTX[responseLength_u32 - 2] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x33E   0x0020             MOVS     R0,R4
   \      0x340   0x6829             LDR      R1,[R5, #+0]
   \      0x342   0x9A01             LDR      R2,[SP, #+4]
   \      0x344   0x1889             ADDS     R1,R1,R2
   \      0x346   0x1E89             SUBS     R1,R1,#+2
   \      0x348   0x7008             STRB     R0,[R1, #+0]
    913                  modbus_ProtocolBufTX[responseLength_u32 - 1] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x34A   0x0020             MOVS     R0,R4
   \      0x34C   0xB280             UXTH     R0,R0
   \      0x34E   0x0A00             LSRS     R0,R0,#+8
   \      0x350   0x6829             LDR      R1,[R5, #+0]
   \      0x352   0x9A01             LDR      R2,[SP, #+4]
   \      0x354   0x1889             ADDS     R1,R1,R2
   \      0x356   0x1E49             SUBS     R1,R1,#+1
   \      0x358   0x7008             STRB     R0,[R1, #+0]
    914                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf	
   \      0x35A   0xAA01             ADD      R2,SP,#+4
   \      0x35C   0x6829             LDR      R1,[R5, #+0]
   \      0x35E   0x48AE             LDR      R0,??Modbus_ParseReceivedMessages_2
   \      0x360   0x6800             LDR      R0,[R0, #+0]
   \      0x362   0x6840             LDR      R0,[R0, #+4]
   \      0x364   0x....'....        BL       RingBuf_WriteBlock
    915                  uint16_t alt_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x368   0x9801             LDR      R0,[SP, #+4]
   \      0x36A   0x1981             ADDS     R1,R0,R6
   \      0x36C   0xB289             UXTH     R1,R1
   \      0x36E   0x6828             LDR      R0,[R5, #+0]
   \      0x370   0x....'....        BL       calculateModbusCRC
    916                }  				  
    917                break;
   \                     ??Modbus_ParseReceivedMessages_32: (+1)
   \      0x374   0xF000 0xFD68      BL       ??Modbus_ParseReceivedMessages_8
    918              }
    919              //case MODBUS_FUNCTION_CODE_READ_DISCRETE_INPUTS:
    920              case MODBUS_FUNCTION_CODE_READ_DISCRETE_INPUTS: {
    921                //if (ProcessMBCoilRegister(modbus_ProtocolBufTX+READ_RESPONSE_HEADER_LENGTH, register_address_u16, number_of_registers_u16, MB_READ_REGISTER) == MB_ILLEGAL_ADDRESS) {
    922                if (ProcessMBCoilRegister_New(modbus_ProtocolBufTX+READ_RESPONSE_HEADER_LENGTH, register_address_u16, number_of_registers_u16, MB_READ_REGISTER) == MB_ILLEGAL_ADDRESS) {
   \                     ??Modbus_ParseReceivedMessages_19: (+1)
   \      0x378   0x4D00             LDR      R5,??Modbus_ParseReceivedMessages_1
   \      0x37A   0xE005             B.N      ??Modbus_ParseReceivedMessages_36
   \                     ??Modbus_ParseReceivedMessages_1:
   \      0x37C   0x....'....        DC32     modbus_ProtocolBufTX
   \      0x380   0x0000'0BB8        DC32     0xbb8
   \      0x384   0x....'....        DC32     tt_ModbusLinkLostStop
   \                     ??Modbus_ParseReceivedMessages_36: (+1)
   \      0x388   0x2300             MOVS     R3,#+0
   \      0x38A   0x4668             MOV      R0,SP
   \      0x38C   0x8842             LDRH     R2,[R0, #+2]
   \      0x38E   0x4668             MOV      R0,SP
   \      0x390   0x8901             LDRH     R1,[R0, #+8]
   \      0x392   0x6828             LDR      R0,[R5, #+0]
   \      0x394   0x1CC0             ADDS     R0,R0,#+3
   \      0x396   0x....'....        BL       ProcessMBCoilRegister_New
   \      0x39A   0x2801             CMP      R0,#+1
   \      0x39C   0xD12D             BNE      ??Modbus_ParseReceivedMessages_37
    923                  // send exception code for bad address
    924                  responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \      0x39E   0x9401             STR      R4,[SP, #+4]
    925                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x3A0   0x9801             LDR      R0,[SP, #+4]
   \      0x3A2   0xB2C0             UXTB     R0,R0
   \      0x3A4   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x3A8   0x0006             MOVS     R6,R0
    926                  if (error_occurred) {
   \      0x3AA   0x0030             MOVS     R0,R6
   \      0x3AC   0xB2C0             UXTB     R0,R0
   \      0x3AE   0x2800             CMP      R0,#+0
   \      0x3B0   0xD001             BEQ      .+6
   \      0x3B2   0xF000 0xFD49      BL       ??Modbus_ParseReceivedMessages_13
    927                    return;
    928                  }
    929                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
    930                  // build header
    931                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_38: (+1)
   \      0x3B6   0x4668             MOV      R0,SP
   \      0x3B8   0x7800             LDRB     R0,[R0, #+0]
   \      0x3BA   0x6829             LDR      R1,[R5, #+0]
   \      0x3BC   0x7008             STRB     R0,[R1, #+0]
    932                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \      0x3BE   0x0038             MOVS     R0,R7
   \      0x3C0   0x3880             SUBS     R0,R0,#+128
   \      0x3C2   0x6829             LDR      R1,[R5, #+0]
   \      0x3C4   0x7048             STRB     R0,[R1, #+1]
    933                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) MODBUS_EXCEPTION_02;
   \      0x3C6   0x2002             MOVS     R0,#+2
   \      0x3C8   0x6829             LDR      R1,[R5, #+0]
   \      0x3CA   0x7088             STRB     R0,[R1, #+2]
    934                  // build CRC
    935                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x3CC   0x9801             LDR      R0,[SP, #+4]
   \      0x3CE   0x1E81             SUBS     R1,R0,#+2
   \      0x3D0   0xB289             UXTH     R1,R1
   \      0x3D2   0x6828             LDR      R0,[R5, #+0]
   \      0x3D4   0x....'....        BL       calculateModbusCRC
   \      0x3D8   0x0004             MOVS     R4,R0
    936                  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);								// crc LSB
   \      0x3DA   0x0020             MOVS     R0,R4
   \      0x3DC   0x6829             LDR      R1,[R5, #+0]
   \      0x3DE   0x70C8             STRB     R0,[R1, #+3]
    937                  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);								// crc MSB
   \      0x3E0   0x0020             MOVS     R0,R4
   \      0x3E2   0xB280             UXTH     R0,R0
   \      0x3E4   0x0A00             LSRS     R0,R0,#+8
   \      0x3E6   0x6829             LDR      R1,[R5, #+0]
   \      0x3E8   0x7108             STRB     R0,[R1, #+4]
    938                  // write to seq Mem structure
    939                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \      0x3EA   0xAA01             ADD      R2,SP,#+4
   \      0x3EC   0x6829             LDR      R1,[R5, #+0]
   \      0x3EE   0x488A             LDR      R0,??Modbus_ParseReceivedMessages_2
   \      0x3F0   0x6800             LDR      R0,[R0, #+0]
   \      0x3F2   0x6840             LDR      R0,[R0, #+4]
   \      0x3F4   0x....'....        BL       RingBuf_WriteBlock
   \      0x3F8   0xE054             B        ??Modbus_ParseReceivedMessages_39
    940                }
    941                else {
    942                  if (number_of_registers_u16 % 8 == 0)
   \                     ??Modbus_ParseReceivedMessages_37: (+1)
   \      0x3FA   0x2408             MOVS     R4,#+8
   \      0x3FC   0x4668             MOV      R0,SP
   \      0x3FE   0x8840             LDRH     R0,[R0, #+2]
   \      0x400   0x0021             MOVS     R1,R4
   \      0x402   0x....'....        BL       __aeabi_idivmod
   \      0x406   0x2900             CMP      R1,#+0
   \      0x408   0xD107             BNE      ??Modbus_ParseReceivedMessages_40
    943                    number_of_coil_bytes_u8 = number_of_registers_u16/8;
   \      0x40A   0x4668             MOV      R0,SP
   \      0x40C   0x8840             LDRH     R0,[R0, #+2]
   \      0x40E   0x0021             MOVS     R1,R4
   \      0x410   0x....'....        BL       __aeabi_idiv
   \      0x414   0x4669             MOV      R1,SP
   \      0x416   0x7048             STRB     R0,[R1, #+1]
   \      0x418   0xE007             B        ??Modbus_ParseReceivedMessages_41
    944                  else
    945                    number_of_coil_bytes_u8 = number_of_registers_u16/8 + 1;
   \                     ??Modbus_ParseReceivedMessages_40: (+1)
   \      0x41A   0x4668             MOV      R0,SP
   \      0x41C   0x8840             LDRH     R0,[R0, #+2]
   \      0x41E   0x0021             MOVS     R1,R4
   \      0x420   0x....'....        BL       __aeabi_idiv
   \      0x424   0x1C40             ADDS     R0,R0,#+1
   \      0x426   0x4669             MOV      R1,SP
   \      0x428   0x7048             STRB     R0,[R1, #+1]
    946                  // build response message and send
    947                  responseLength_u32 = READ_RESPONSE_HEADER_LENGTH + number_of_coil_bytes_u8 + CRC_LENGTH;
   \                     ??Modbus_ParseReceivedMessages_41: (+1)
   \      0x42A   0x4668             MOV      R0,SP
   \      0x42C   0x7840             LDRB     R0,[R0, #+1]
   \      0x42E   0x1D40             ADDS     R0,R0,#+5
   \      0x430   0x9001             STR      R0,[SP, #+4]
    948                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x432   0x9801             LDR      R0,[SP, #+4]
   \      0x434   0xB2C0             UXTB     R0,R0
   \      0x436   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x43A   0x4669             MOV      R1,SP
   \      0x43C   0x7288             STRB     R0,[R1, #+10]
    949                  if (error_occurred) {
   \      0x43E   0x4668             MOV      R0,SP
   \      0x440   0x7A80             LDRB     R0,[R0, #+10]
   \      0x442   0x2800             CMP      R0,#+0
   \      0x444   0xD001             BEQ      .+6
   \      0x446   0xF000 0xFCFF      BL       ??Modbus_ParseReceivedMessages_13
    950                    return;
    951                  }
    952                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;	
    953                  // build header
    954                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_42: (+1)
   \      0x44A   0x4668             MOV      R0,SP
   \      0x44C   0x7800             LDRB     R0,[R0, #+0]
   \      0x44E   0x6829             LDR      R1,[R5, #+0]
   \      0x450   0x7008             STRB     R0,[R1, #+0]
    955                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8;
   \      0x452   0x6828             LDR      R0,[R5, #+0]
   \      0x454   0x7047             STRB     R7,[R0, #+1]
    956                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) (number_of_coil_bytes_u8);								// 2 bytes per registers
   \      0x456   0x4668             MOV      R0,SP
   \      0x458   0x7840             LDRB     R0,[R0, #+1]
   \      0x45A   0x6829             LDR      R1,[R5, #+0]
   \      0x45C   0x7088             STRB     R0,[R1, #+2]
    957                  //modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (register_address_u16 >> 8);								// starting register
    958                  //modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (register_address_u16 >> 0);					
    959                  // build CRC
    960                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x45E   0x4E7F             LDR      R6,??Modbus_ParseReceivedMessages_3  ;; 0xfffe
   \      0x460   0x9801             LDR      R0,[SP, #+4]
   \      0x462   0x1981             ADDS     R1,R0,R6
   \      0x464   0xB289             UXTH     R1,R1
   \      0x466   0x6828             LDR      R0,[R5, #+0]
   \      0x468   0x....'....        BL       calculateModbusCRC
   \      0x46C   0x0004             MOVS     R4,R0
    961                  modbus_ProtocolBufTX[responseLength_u32 - 2] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x46E   0x0020             MOVS     R0,R4
   \      0x470   0x6829             LDR      R1,[R5, #+0]
   \      0x472   0x9A01             LDR      R2,[SP, #+4]
   \      0x474   0x1889             ADDS     R1,R1,R2
   \      0x476   0x1E89             SUBS     R1,R1,#+2
   \      0x478   0x7008             STRB     R0,[R1, #+0]
    962                  modbus_ProtocolBufTX[responseLength_u32 - 1] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x47A   0x0020             MOVS     R0,R4
   \      0x47C   0xB280             UXTH     R0,R0
   \      0x47E   0x0A00             LSRS     R0,R0,#+8
   \      0x480   0x6829             LDR      R1,[R5, #+0]
   \      0x482   0x9A01             LDR      R2,[SP, #+4]
   \      0x484   0x1889             ADDS     R1,R1,R2
   \      0x486   0x1E49             SUBS     R1,R1,#+1
   \      0x488   0x7008             STRB     R0,[R1, #+0]
    963                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf	
   \      0x48A   0xAA01             ADD      R2,SP,#+4
   \      0x48C   0x6829             LDR      R1,[R5, #+0]
   \      0x48E   0x4862             LDR      R0,??Modbus_ParseReceivedMessages_2
   \      0x490   0x6800             LDR      R0,[R0, #+0]
   \      0x492   0x6840             LDR      R0,[R0, #+4]
   \      0x494   0x....'....        BL       RingBuf_WriteBlock
    964                  uint16_t alt_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x498   0x9801             LDR      R0,[SP, #+4]
   \      0x49A   0x1981             ADDS     R1,R0,R6
   \      0x49C   0xB289             UXTH     R1,R1
   \      0x49E   0x6828             LDR      R0,[R5, #+0]
   \      0x4A0   0x....'....        BL       calculateModbusCRC
    965                }  
    966                break;
   \                     ??Modbus_ParseReceivedMessages_39: (+1)
   \      0x4A4   0xF000 0xFCD0      BL       ??Modbus_ParseReceivedMessages_8
    967              }			  
    968              //case MODBUS_FUNCTION_CODE_READ_HOLDING_REGISTERS: {
    969              case MODBUS_FUNCTION_CODE_READ_HOLDING_REGISTERS: {
    970                if (ProcessMBHoldingRegister(modbus_ProtocolBufTX+READ_RESPONSE_HEADER_LENGTH, register_address_u16, number_of_registers_u16, MB_READ_REGISTER) == MB_ILLEGAL_ADDRESS) {
   \                     ??Modbus_ParseReceivedMessages_20: (+1)
   \      0x4A8   0x4DD2             LDR      R5,??Modbus_ParseReceivedMessages_4
   \      0x4AA   0x2300             MOVS     R3,#+0
   \      0x4AC   0x4668             MOV      R0,SP
   \      0x4AE   0x8842             LDRH     R2,[R0, #+2]
   \      0x4B0   0x4668             MOV      R0,SP
   \      0x4B2   0x8901             LDRH     R1,[R0, #+8]
   \      0x4B4   0x6828             LDR      R0,[R5, #+0]
   \      0x4B6   0x1CC0             ADDS     R0,R0,#+3
   \      0x4B8   0x....'....        BL       ProcessMBHoldingRegister
   \      0x4BC   0x2801             CMP      R0,#+1
   \      0x4BE   0xD12D             BNE      ??Modbus_ParseReceivedMessages_43
    971                  // send exception code for bad address
    972                  responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \      0x4C0   0x9401             STR      R4,[SP, #+4]
    973                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x4C2   0x9801             LDR      R0,[SP, #+4]
   \      0x4C4   0xB2C0             UXTB     R0,R0
   \      0x4C6   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x4CA   0x0006             MOVS     R6,R0
    974                  if (error_occurred) {
   \      0x4CC   0x0030             MOVS     R0,R6
   \      0x4CE   0xB2C0             UXTB     R0,R0
   \      0x4D0   0x2800             CMP      R0,#+0
   \      0x4D2   0xD001             BEQ      .+6
   \      0x4D4   0xF000 0xFCB8      BL       ??Modbus_ParseReceivedMessages_13
    975                    return;
    976                  }
    977                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
    978                  // build header
    979                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_44: (+1)
   \      0x4D8   0x4668             MOV      R0,SP
   \      0x4DA   0x7800             LDRB     R0,[R0, #+0]
   \      0x4DC   0x6829             LDR      R1,[R5, #+0]
   \      0x4DE   0x7008             STRB     R0,[R1, #+0]
    980                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \      0x4E0   0x0038             MOVS     R0,R7
   \      0x4E2   0x3880             SUBS     R0,R0,#+128
   \      0x4E4   0x6829             LDR      R1,[R5, #+0]
   \      0x4E6   0x7048             STRB     R0,[R1, #+1]
    981                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) MODBUS_EXCEPTION_02;
   \      0x4E8   0x2002             MOVS     R0,#+2
   \      0x4EA   0x6829             LDR      R1,[R5, #+0]
   \      0x4EC   0x7088             STRB     R0,[R1, #+2]
    982                  // build CRC
    983                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x4EE   0x9801             LDR      R0,[SP, #+4]
   \      0x4F0   0x1E81             SUBS     R1,R0,#+2
   \      0x4F2   0xB289             UXTH     R1,R1
   \      0x4F4   0x6828             LDR      R0,[R5, #+0]
   \      0x4F6   0x....'....        BL       calculateModbusCRC
   \      0x4FA   0x0004             MOVS     R4,R0
    984                  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);								// crc LSB
   \      0x4FC   0x0020             MOVS     R0,R4
   \      0x4FE   0x6829             LDR      R1,[R5, #+0]
   \      0x500   0x70C8             STRB     R0,[R1, #+3]
    985                  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);								// crc MSB
   \      0x502   0x0020             MOVS     R0,R4
   \      0x504   0xB280             UXTH     R0,R0
   \      0x506   0x0A00             LSRS     R0,R0,#+8
   \      0x508   0x6829             LDR      R1,[R5, #+0]
   \      0x50A   0x7108             STRB     R0,[R1, #+4]
    986                  // write to seq Mem structure
    987                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \      0x50C   0xAA01             ADD      R2,SP,#+4
   \      0x50E   0x6829             LDR      R1,[R5, #+0]
   \      0x510   0x4841             LDR      R0,??Modbus_ParseReceivedMessages_2
   \      0x512   0x6800             LDR      R0,[R0, #+0]
   \      0x514   0x6840             LDR      R0,[R0, #+4]
   \      0x516   0x....'....        BL       RingBuf_WriteBlock
   \      0x51A   0xE040             B        ??Modbus_ParseReceivedMessages_45
    988                }
    989                else {
    990                  // build response message and send
    991                  responseLength_u32 = READ_RESPONSE_HEADER_LENGTH + 2*number_of_registers_u16 + CRC_LENGTH;
   \                     ??Modbus_ParseReceivedMessages_43: (+1)
   \      0x51C   0x4668             MOV      R0,SP
   \      0x51E   0x8840             LDRH     R0,[R0, #+2]
   \      0x520   0x2102             MOVS     R1,#+2
   \      0x522   0x4341             MULS     R1,R0,R1
   \      0x524   0x1D49             ADDS     R1,R1,#+5
   \      0x526   0x9101             STR      R1,[SP, #+4]
    992                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x528   0x9801             LDR      R0,[SP, #+4]
   \      0x52A   0xB2C0             UXTB     R0,R0
   \      0x52C   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x530   0x4669             MOV      R1,SP
   \      0x532   0x7288             STRB     R0,[R1, #+10]
    993                  if (error_occurred) {
   \      0x534   0x4668             MOV      R0,SP
   \      0x536   0x7A80             LDRB     R0,[R0, #+10]
   \      0x538   0x2800             CMP      R0,#+0
   \      0x53A   0xD001             BEQ      .+6
   \      0x53C   0xF000 0xFC84      BL       ??Modbus_ParseReceivedMessages_13
    994                    return;
    995                  }
    996                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;	
    997                  // build header
    998                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_46: (+1)
   \      0x540   0x4668             MOV      R0,SP
   \      0x542   0x7800             LDRB     R0,[R0, #+0]
   \      0x544   0x6829             LDR      R1,[R5, #+0]
   \      0x546   0x7008             STRB     R0,[R1, #+0]
    999                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8;
   \      0x548   0x6828             LDR      R0,[R5, #+0]
   \      0x54A   0x7047             STRB     R7,[R0, #+1]
   1000                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) (2*number_of_registers_u16);								// 2 bytes per registers
   \      0x54C   0x4668             MOV      R0,SP
   \      0x54E   0x8840             LDRH     R0,[R0, #+2]
   \      0x550   0x2102             MOVS     R1,#+2
   \      0x552   0x4348             MULS     R0,R1,R0
   \      0x554   0x6829             LDR      R1,[R5, #+0]
   \      0x556   0x7088             STRB     R0,[R1, #+2]
   1001                  //modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (register_address_u16 >> 8);								// starting register
   1002                  //modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (register_address_u16 >> 0);					
   1003                  // build CRC
   1004                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x558   0x4E40             LDR      R6,??Modbus_ParseReceivedMessages_3  ;; 0xfffe
   \      0x55A   0x9801             LDR      R0,[SP, #+4]
   \      0x55C   0x1981             ADDS     R1,R0,R6
   \      0x55E   0xB289             UXTH     R1,R1
   \      0x560   0x6828             LDR      R0,[R5, #+0]
   \      0x562   0x....'....        BL       calculateModbusCRC
   \      0x566   0x0004             MOVS     R4,R0
   1005                  modbus_ProtocolBufTX[responseLength_u32 - 2] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x568   0x0020             MOVS     R0,R4
   \      0x56A   0x6829             LDR      R1,[R5, #+0]
   \      0x56C   0x9A01             LDR      R2,[SP, #+4]
   \      0x56E   0x1889             ADDS     R1,R1,R2
   \      0x570   0x1E89             SUBS     R1,R1,#+2
   \      0x572   0x7008             STRB     R0,[R1, #+0]
   1006                  modbus_ProtocolBufTX[responseLength_u32 - 1] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x574   0x0020             MOVS     R0,R4
   \      0x576   0xB280             UXTH     R0,R0
   \      0x578   0x0A00             LSRS     R0,R0,#+8
   \      0x57A   0x6829             LDR      R1,[R5, #+0]
   \      0x57C   0x9A01             LDR      R2,[SP, #+4]
   \      0x57E   0x1889             ADDS     R1,R1,R2
   \      0x580   0x1E49             SUBS     R1,R1,#+1
   \      0x582   0x7008             STRB     R0,[R1, #+0]
   1007                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf	
   \      0x584   0xAA01             ADD      R2,SP,#+4
   \      0x586   0x6829             LDR      R1,[R5, #+0]
   \      0x588   0x4823             LDR      R0,??Modbus_ParseReceivedMessages_2
   \      0x58A   0x6800             LDR      R0,[R0, #+0]
   \      0x58C   0x6840             LDR      R0,[R0, #+4]
   \      0x58E   0x....'....        BL       RingBuf_WriteBlock
   1008                  uint16_t alt_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x592   0x9801             LDR      R0,[SP, #+4]
   \      0x594   0x1981             ADDS     R1,R0,R6
   \      0x596   0xB289             UXTH     R1,R1
   \      0x598   0x6828             LDR      R0,[R5, #+0]
   \      0x59A   0x....'....        BL       calculateModbusCRC
   1009                }  
   1010                break;
   \                     ??Modbus_ParseReceivedMessages_45: (+1)
   \      0x59E   0xF000 0xFC53      BL       ??Modbus_ParseReceivedMessages_8
   1011              }			  
   1012              //case MODBUS_FUNCTION_CODE_READ_INPUT_REGISTERS:
   1013              case MODBUS_FUNCTION_CODE_READ_INPUT_REGISTERS: {			
   1014                if (ProcessMBHoldingRegister(modbus_ProtocolBufTX+READ_RESPONSE_HEADER_LENGTH, register_address_u16, number_of_registers_u16, MB_READ_REGISTER) == MB_ILLEGAL_ADDRESS) {
   \                     ??Modbus_ParseReceivedMessages_21: (+1)
   \      0x5A2   0x4D94             LDR      R5,??Modbus_ParseReceivedMessages_4
   \      0x5A4   0x2300             MOVS     R3,#+0
   \      0x5A6   0x4668             MOV      R0,SP
   \      0x5A8   0x8842             LDRH     R2,[R0, #+2]
   \      0x5AA   0x4668             MOV      R0,SP
   \      0x5AC   0x8901             LDRH     R1,[R0, #+8]
   \      0x5AE   0x6828             LDR      R0,[R5, #+0]
   \      0x5B0   0x1CC0             ADDS     R0,R0,#+3
   \      0x5B2   0x....'....        BL       ProcessMBHoldingRegister
   \      0x5B6   0x2801             CMP      R0,#+1
   \      0x5B8   0xD130             BNE      ??Modbus_ParseReceivedMessages_47
   1015                  // send exception code for bad address
   1016                  responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \      0x5BA   0x9401             STR      R4,[SP, #+4]
   1017                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x5BC   0x9801             LDR      R0,[SP, #+4]
   \      0x5BE   0xB2C0             UXTB     R0,R0
   \      0x5C0   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x5C4   0x0006             MOVS     R6,R0
   1018                  if (error_occurred) {
   \      0x5C6   0x0030             MOVS     R0,R6
   \      0x5C8   0xB2C0             UXTB     R0,R0
   \      0x5CA   0x2800             CMP      R0,#+0
   \      0x5CC   0xD001             BEQ      .+6
   \      0x5CE   0xF000 0xFC3B      BL       ??Modbus_ParseReceivedMessages_13
   1019                    return;
   1020                  }
   1021                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
   1022                  // build header
   1023                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_48: (+1)
   \      0x5D2   0x4668             MOV      R0,SP
   \      0x5D4   0x7800             LDRB     R0,[R0, #+0]
   \      0x5D6   0x6829             LDR      R1,[R5, #+0]
   \      0x5D8   0x7008             STRB     R0,[R1, #+0]
   1024                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \      0x5DA   0x0038             MOVS     R0,R7
   \      0x5DC   0x3880             SUBS     R0,R0,#+128
   \      0x5DE   0x6829             LDR      R1,[R5, #+0]
   \      0x5E0   0x7048             STRB     R0,[R1, #+1]
   1025                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) MODBUS_EXCEPTION_02;
   \      0x5E2   0x2002             MOVS     R0,#+2
   \      0x5E4   0x6829             LDR      R1,[R5, #+0]
   \      0x5E6   0x7088             STRB     R0,[R1, #+2]
   1026                  // build CRC
   1027                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x5E8   0x9801             LDR      R0,[SP, #+4]
   \      0x5EA   0x1E81             SUBS     R1,R0,#+2
   \      0x5EC   0xB289             UXTH     R1,R1
   \      0x5EE   0x6828             LDR      R0,[R5, #+0]
   \      0x5F0   0x....'....        BL       calculateModbusCRC
   \      0x5F4   0x0004             MOVS     R4,R0
   1028                  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);								// crc LSB
   \      0x5F6   0x0020             MOVS     R0,R4
   \      0x5F8   0x6829             LDR      R1,[R5, #+0]
   \      0x5FA   0x70C8             STRB     R0,[R1, #+3]
   1029                  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);								// crc MSB
   \      0x5FC   0x0020             MOVS     R0,R4
   \      0x5FE   0xB280             UXTH     R0,R0
   \      0x600   0x0A00             LSRS     R0,R0,#+8
   \      0x602   0x6829             LDR      R1,[R5, #+0]
   \      0x604   0x7108             STRB     R0,[R1, #+4]
   1030                  // write to seq Mem structure
   1031                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \      0x606   0xAA01             ADD      R2,SP,#+4
   \      0x608   0x6829             LDR      R1,[R5, #+0]
   \      0x60A   0x4803             LDR      R0,??Modbus_ParseReceivedMessages_2
   \      0x60C   0x6800             LDR      R0,[R0, #+0]
   \      0x60E   0x6840             LDR      R0,[R0, #+4]
   \      0x610   0x....'....        BL       RingBuf_WriteBlock
   \      0x614   0xE046             B        ??Modbus_ParseReceivedMessages_49
   \      0x616   0xBF00             Nop
   \                     ??Modbus_ParseReceivedMessages_2:
   \      0x618   0x....'....        DC32     usart1Control_Modbus
   1032                }
   1033                else {
   1034                  // build response message and send
   1035                  responseLength_u32 = READ_RESPONSE_HEADER_LENGTH + 2*number_of_registers_u16 + CRC_LENGTH;
   \                     ??Modbus_ParseReceivedMessages_47: (+1)
   \      0x61C   0x4668             MOV      R0,SP
   \      0x61E   0x8840             LDRH     R0,[R0, #+2]
   \      0x620   0x2102             MOVS     R1,#+2
   \      0x622   0x4341             MULS     R1,R0,R1
   \      0x624   0x1D49             ADDS     R1,R1,#+5
   \      0x626   0x9101             STR      R1,[SP, #+4]
   1036                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x628   0x9801             LDR      R0,[SP, #+4]
   \      0x62A   0xB2C0             UXTB     R0,R0
   \      0x62C   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x630   0x4669             MOV      R1,SP
   \      0x632   0x7288             STRB     R0,[R1, #+10]
   1037                  if (error_occurred) {
   \      0x634   0x4668             MOV      R0,SP
   \      0x636   0x7A80             LDRB     R0,[R0, #+10]
   \      0x638   0x2800             CMP      R0,#+0
   \      0x63A   0xD001             BEQ      .+6
   \      0x63C   0xF000 0xFC04      BL       ??Modbus_ParseReceivedMessages_13
   1038                    return;
   1039                  }
   1040                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;	
   1041                  // build header
   1042                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_50: (+1)
   \      0x640   0x4668             MOV      R0,SP
   \      0x642   0x7800             LDRB     R0,[R0, #+0]
   \      0x644   0x6829             LDR      R1,[R5, #+0]
   \      0x646   0x7008             STRB     R0,[R1, #+0]
   1043                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8;
   \      0x648   0x6828             LDR      R0,[R5, #+0]
   \      0x64A   0x7047             STRB     R7,[R0, #+1]
   1044                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) (2*number_of_registers_u16);								// 2 bytes per registers
   \      0x64C   0x4668             MOV      R0,SP
   \      0x64E   0x8840             LDRH     R0,[R0, #+2]
   \      0x650   0x2102             MOVS     R1,#+2
   \      0x652   0x4348             MULS     R0,R1,R0
   \      0x654   0x6829             LDR      R1,[R5, #+0]
   \      0x656   0x7088             STRB     R0,[R1, #+2]
   1045                  //modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (register_address_u16 >> 8);								// starting register
   1046                  //modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (register_address_u16 >> 0);					
   1047                  // build CRC
   1048                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x658   0x4E00             LDR      R6,??Modbus_ParseReceivedMessages_3  ;; 0xfffe
   \      0x65A   0xE001             B.N      ??Modbus_ParseReceivedMessages_51
   \                     ??Modbus_ParseReceivedMessages_3:
   \      0x65C   0x0000'FFFE        DC32     0xfffe
   \                     ??Modbus_ParseReceivedMessages_51: (+1)
   \      0x660   0x9801             LDR      R0,[SP, #+4]
   \      0x662   0x1981             ADDS     R1,R0,R6
   \      0x664   0xB289             UXTH     R1,R1
   \      0x666   0x6828             LDR      R0,[R5, #+0]
   \      0x668   0x....'....        BL       calculateModbusCRC
   \      0x66C   0x0004             MOVS     R4,R0
   1049                  modbus_ProtocolBufTX[responseLength_u32 - 2] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x66E   0x0020             MOVS     R0,R4
   \      0x670   0x6829             LDR      R1,[R5, #+0]
   \      0x672   0x9A01             LDR      R2,[SP, #+4]
   \      0x674   0x1889             ADDS     R1,R1,R2
   \      0x676   0x1E89             SUBS     R1,R1,#+2
   \      0x678   0x7008             STRB     R0,[R1, #+0]
   1050                  modbus_ProtocolBufTX[responseLength_u32 - 1] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x67A   0x0020             MOVS     R0,R4
   \      0x67C   0xB280             UXTH     R0,R0
   \      0x67E   0x0A00             LSRS     R0,R0,#+8
   \      0x680   0x6829             LDR      R1,[R5, #+0]
   \      0x682   0x9A01             LDR      R2,[SP, #+4]
   \      0x684   0x1889             ADDS     R1,R1,R2
   \      0x686   0x1E49             SUBS     R1,R1,#+1
   \      0x688   0x7008             STRB     R0,[R1, #+0]
   1051                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf	
   \      0x68A   0xAA01             ADD      R2,SP,#+4
   \      0x68C   0x6829             LDR      R1,[R5, #+0]
   \      0x68E   0x48C7             LDR      R0,??Modbus_ParseReceivedMessages_5
   \      0x690   0x6800             LDR      R0,[R0, #+0]
   \      0x692   0x6840             LDR      R0,[R0, #+4]
   \      0x694   0x....'....        BL       RingBuf_WriteBlock
   1052                  uint16_t alt_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x698   0x9801             LDR      R0,[SP, #+4]
   \      0x69A   0x1981             ADDS     R1,R0,R6
   \      0x69C   0xB289             UXTH     R1,R1
   \      0x69E   0x6828             LDR      R0,[R5, #+0]
   \      0x6A0   0x....'....        BL       calculateModbusCRC
   1053                }
   1054                break;
   \                     ??Modbus_ParseReceivedMessages_49: (+1)
   \      0x6A4   0xE3D0             B        ??Modbus_ParseReceivedMessages_8
   1055              }
   1056              //case MODBUS_FUNCTION_CODE_WRITE_SINGLE_HOLDING_REGISTER:
   1057              case MODBUS_FUNCTION_CODE_WRITE_SINGLE_HOLDING_REGISTER: {
   1058                if (ProcessMBHoldingRegister(modbus_ProtocolBufRX+WRITE_SINGLE_HEADER_LENGTH, register_address_u16, 1, MB_WRITE_REGISTER) == MB_ILLEGAL_ADDRESS) {
   \                     ??Modbus_ParseReceivedMessages_22: (+1)
   \      0x6A6   0x2301             MOVS     R3,#+1
   \      0x6A8   0x2201             MOVS     R2,#+1
   \      0x6AA   0x4668             MOV      R0,SP
   \      0x6AC   0x8901             LDRH     R1,[R0, #+8]
   \      0x6AE   0x6828             LDR      R0,[R5, #+0]
   \      0x6B0   0x1D80             ADDS     R0,R0,#+6
   \      0x6B2   0x....'....        BL       ProcessMBHoldingRegister
   \      0x6B6   0x2801             CMP      R0,#+1
   \      0x6B8   0xD12D             BNE      ??Modbus_ParseReceivedMessages_52
   1059                  // send exception code for ilegal address
   1060                  responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \      0x6BA   0x9401             STR      R4,[SP, #+4]
   1061                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x6BC   0x9801             LDR      R0,[SP, #+4]
   \      0x6BE   0xB2C0             UXTB     R0,R0
   \      0x6C0   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x6C4   0x0006             MOVS     R6,R0
   1062                  if (error_occurred) {
   \      0x6C6   0x0030             MOVS     R0,R6
   \      0x6C8   0xB2C0             UXTB     R0,R0
   \      0x6CA   0x2800             CMP      R0,#+0
   \      0x6CC   0xD000             BEQ      .+4
   \      0x6CE   0xE3BB             B        ??Modbus_ParseReceivedMessages_13
   1063                    return;
   1064                  }
   1065                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
   1066                  // build header
   1067                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_53: (+1)
   \      0x6D0   0x4C48             LDR      R4,??Modbus_ParseReceivedMessages_4
   \      0x6D2   0x4668             MOV      R0,SP
   \      0x6D4   0x7800             LDRB     R0,[R0, #+0]
   \      0x6D6   0x6821             LDR      R1,[R4, #+0]
   \      0x6D8   0x7008             STRB     R0,[R1, #+0]
   1068                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \      0x6DA   0x0038             MOVS     R0,R7
   \      0x6DC   0x3880             SUBS     R0,R0,#+128
   \      0x6DE   0x6821             LDR      R1,[R4, #+0]
   \      0x6E0   0x7048             STRB     R0,[R1, #+1]
   1069                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) MODBUS_EXCEPTION_02;
   \      0x6E2   0x2002             MOVS     R0,#+2
   \      0x6E4   0x6821             LDR      R1,[R4, #+0]
   \      0x6E6   0x7088             STRB     R0,[R1, #+2]
   1070                  // build CRC
   1071                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x6E8   0x9801             LDR      R0,[SP, #+4]
   \      0x6EA   0x1E81             SUBS     R1,R0,#+2
   \      0x6EC   0xB289             UXTH     R1,R1
   \      0x6EE   0x6820             LDR      R0,[R4, #+0]
   \      0x6F0   0x....'....        BL       calculateModbusCRC
   \      0x6F4   0x0005             MOVS     R5,R0
   1072                  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x6F6   0x0028             MOVS     R0,R5
   \      0x6F8   0x6821             LDR      R1,[R4, #+0]
   \      0x6FA   0x70C8             STRB     R0,[R1, #+3]
   1073                  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x6FC   0x0028             MOVS     R0,R5
   \      0x6FE   0xB280             UXTH     R0,R0
   \      0x700   0x0A00             LSRS     R0,R0,#+8
   \      0x702   0x6821             LDR      R1,[R4, #+0]
   \      0x704   0x7108             STRB     R0,[R1, #+4]
   1074                  // write to seq Mem structure
   1075                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \      0x706   0xAA01             ADD      R2,SP,#+4
   \      0x708   0x6821             LDR      R1,[R4, #+0]
   \      0x70A   0x48A8             LDR      R0,??Modbus_ParseReceivedMessages_5
   \      0x70C   0x6800             LDR      R0,[R0, #+0]
   \      0x70E   0x6840             LDR      R0,[R0, #+4]
   \      0x710   0x....'....        BL       RingBuf_WriteBlock
   \      0x714   0xE03D             B        ??Modbus_ParseReceivedMessages_54
   1076                }
   1077                else {
   1078                  responseLength_u32 = WRITE_RESPONSE_HEADER_LENGTH + CRC_LENGTH;
   \                     ??Modbus_ParseReceivedMessages_52: (+1)
   \      0x716   0x2008             MOVS     R0,#+8
   \      0x718   0x9001             STR      R0,[SP, #+4]
   1079                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x71A   0x9801             LDR      R0,[SP, #+4]
   \      0x71C   0xB2C0             UXTB     R0,R0
   \      0x71E   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x722   0x4669             MOV      R1,SP
   \      0x724   0x7288             STRB     R0,[R1, #+10]
   1080                  if (error_occurred) {
   \      0x726   0x4668             MOV      R0,SP
   \      0x728   0x7A80             LDRB     R0,[R0, #+10]
   \      0x72A   0x2800             CMP      R0,#+0
   \      0x72C   0xD000             BEQ      .+4
   \      0x72E   0xE38B             B        ??Modbus_ParseReceivedMessages_13
   1081                    return;
   1082                  }
   1083                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;	
   1084                  // build header
   1085                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_55: (+1)
   \      0x730   0x4C30             LDR      R4,??Modbus_ParseReceivedMessages_4
   \      0x732   0x4668             MOV      R0,SP
   \      0x734   0x7800             LDRB     R0,[R0, #+0]
   \      0x736   0x6821             LDR      R1,[R4, #+0]
   \      0x738   0x7008             STRB     R0,[R1, #+0]
   1086                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8;
   \      0x73A   0x6820             LDR      R0,[R4, #+0]
   \      0x73C   0x7047             STRB     R7,[R0, #+1]
   1087                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) (register_address_u16 >> 8);				// starting register MSB/LSB
   \      0x73E   0x4668             MOV      R0,SP
   \      0x740   0x8900             LDRH     R0,[R0, #+8]
   \      0x742   0xB280             UXTH     R0,R0
   \      0x744   0x0A00             LSRS     R0,R0,#+8
   \      0x746   0x6821             LDR      R1,[R4, #+0]
   \      0x748   0x7088             STRB     R0,[R1, #+2]
   1088                  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (register_address_u16 >> 0);					
   \      0x74A   0x4668             MOV      R0,SP
   \      0x74C   0x8900             LDRH     R0,[R0, #+8]
   \      0x74E   0x6821             LDR      R1,[R4, #+0]
   \      0x750   0x70C8             STRB     R0,[R1, #+3]
   1089                  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (modbus_ProtocolBufRX[WRITE_SINGLE_HEADER_LENGTH]);			// number of registers written MSB/LSB
   \      0x752   0x6828             LDR      R0,[R5, #+0]
   \      0x754   0x7980             LDRB     R0,[R0, #+6]
   \      0x756   0x6821             LDR      R1,[R4, #+0]
   \      0x758   0x7108             STRB     R0,[R1, #+4]
   1090                  modbus_ProtocolBufTX[BYTE_5] = (uint8_t) (modbus_ProtocolBufRX[WRITE_SINGLE_HEADER_LENGTH+1]);				
   \      0x75A   0x6828             LDR      R0,[R5, #+0]
   \      0x75C   0x79C0             LDRB     R0,[R0, #+7]
   \      0x75E   0x6821             LDR      R1,[R4, #+0]
   \      0x760   0x7148             STRB     R0,[R1, #+5]
   1091                  // build CRC
   1092                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x762   0x9801             LDR      R0,[SP, #+4]
   \      0x764   0x1E81             SUBS     R1,R0,#+2
   \      0x766   0xB289             UXTH     R1,R1
   \      0x768   0x6820             LDR      R0,[R4, #+0]
   \      0x76A   0x....'....        BL       calculateModbusCRC
   \      0x76E   0x0005             MOVS     R5,R0
   1093                  modbus_ProtocolBufTX[BYTE_6] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x770   0x0028             MOVS     R0,R5
   \      0x772   0x6821             LDR      R1,[R4, #+0]
   \      0x774   0x7188             STRB     R0,[R1, #+6]
   1094                  modbus_ProtocolBufTX[BYTE_7] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x776   0x0028             MOVS     R0,R5
   \      0x778   0xB280             UXTH     R0,R0
   \      0x77A   0x0A00             LSRS     R0,R0,#+8
   \      0x77C   0x6821             LDR      R1,[R4, #+0]
   \      0x77E   0x71C8             STRB     R0,[R1, #+7]
   1095                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \      0x780   0xAA01             ADD      R2,SP,#+4
   \      0x782   0x6821             LDR      R1,[R4, #+0]
   \      0x784   0x4889             LDR      R0,??Modbus_ParseReceivedMessages_5
   \      0x786   0x6800             LDR      R0,[R0, #+0]
   \      0x788   0x6840             LDR      R0,[R0, #+4]
   \      0x78A   0x....'....        BL       RingBuf_WriteBlock
   1096                  
   1097                  UpdateMotorDemandMultiplexer(); // TODO: Don't call for every write (only when updates detected)
   \      0x78E   0x....'....        BL       UpdateMotorDemandMultiplexer
   1098                }
   1099                break;
   \                     ??Modbus_ParseReceivedMessages_54: (+1)
   \      0x792   0xE359             B        ??Modbus_ParseReceivedMessages_8
   1100              }			  
   1101              //case MODBUS_FUNCTION_CODE_WRITE_MULTIPLE_COILS:
   1102              case MODBUS_FUNCTION_CODE_WRITE_MULTIPLE_COILS:{
   1103                if (number_of_registers_u16 % 8 == 0)
   \                     ??Modbus_ParseReceivedMessages_23: (+1)
   \      0x794   0x2608             MOVS     R6,#+8
   \      0x796   0x4668             MOV      R0,SP
   \      0x798   0x8840             LDRH     R0,[R0, #+2]
   \      0x79A   0x0031             MOVS     R1,R6
   \      0x79C   0x....'....        BL       __aeabi_idivmod
   \      0x7A0   0x2900             CMP      R1,#+0
   \      0x7A2   0xD107             BNE      ??Modbus_ParseReceivedMessages_56
   1104                  number_of_coil_bytes_u8 = number_of_registers_u16/8;
   \      0x7A4   0x4668             MOV      R0,SP
   \      0x7A6   0x8840             LDRH     R0,[R0, #+2]
   \      0x7A8   0x0031             MOVS     R1,R6
   \      0x7AA   0x....'....        BL       __aeabi_idiv
   \      0x7AE   0x4669             MOV      R1,SP
   \      0x7B0   0x7048             STRB     R0,[R1, #+1]
   \      0x7B2   0xE007             B        ??Modbus_ParseReceivedMessages_57
   1105                else
   1106                  number_of_coil_bytes_u8 = number_of_registers_u16/8 + 1;			  
   \                     ??Modbus_ParseReceivedMessages_56: (+1)
   \      0x7B4   0x4668             MOV      R0,SP
   \      0x7B6   0x8840             LDRH     R0,[R0, #+2]
   \      0x7B8   0x0031             MOVS     R1,R6
   \      0x7BA   0x....'....        BL       __aeabi_idiv
   \      0x7BE   0x1C40             ADDS     R0,R0,#+1
   \      0x7C0   0x4669             MOV      R1,SP
   \      0x7C2   0x7048             STRB     R0,[R1, #+1]
   1107          //      if (ProcessMBCoilRegister(modbus_ProtocolBufRX+WRITE_HEADER_LENGTH, register_address_u16, number_of_registers_u16, MB_WRITE_REGISTER) == MB_ILLEGAL_ADDRESS) {
   1108                if (ProcessMBCoilRegister_New(modbus_ProtocolBufRX+WRITE_HEADER_LENGTH, register_address_u16, number_of_registers_u16, MB_WRITE_REGISTER) == MB_ILLEGAL_ADDRESS) {
   \                     ??Modbus_ParseReceivedMessages_57: (+1)
   \      0x7C4   0x2301             MOVS     R3,#+1
   \      0x7C6   0x4668             MOV      R0,SP
   \      0x7C8   0x8842             LDRH     R2,[R0, #+2]
   \      0x7CA   0x4668             MOV      R0,SP
   \      0x7CC   0x8901             LDRH     R1,[R0, #+8]
   \      0x7CE   0x6828             LDR      R0,[R5, #+0]
   \      0x7D0   0x1DC0             ADDS     R0,R0,#+7
   \      0x7D2   0x....'....        BL       ProcessMBCoilRegister_New
   \      0x7D6   0x2801             CMP      R0,#+1
   \      0x7D8   0xD130             BNE      ??Modbus_ParseReceivedMessages_58
   1109                  // send exception code for ilegal address
   1110                  responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \      0x7DA   0x9401             STR      R4,[SP, #+4]
   1111                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x7DC   0x9801             LDR      R0,[SP, #+4]
   \      0x7DE   0xB2C0             UXTB     R0,R0
   \      0x7E0   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x7E4   0x0006             MOVS     R6,R0
   1112                  if (error_occurred) {
   \      0x7E6   0x0030             MOVS     R0,R6
   \      0x7E8   0xB2C0             UXTB     R0,R0
   \      0x7EA   0x2800             CMP      R0,#+0
   \      0x7EC   0xD000             BEQ      .+4
   \      0x7EE   0xE32B             B        ??Modbus_ParseReceivedMessages_13
   1113                    return;
   1114                  }
   1115                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
   1116                  // build header
   1117                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_59: (+1)
   \      0x7F0   0x4C00             LDR      R4,??Modbus_ParseReceivedMessages_4
   \      0x7F2   0xE001             B.N      ??Modbus_ParseReceivedMessages_60
   \                     ??Modbus_ParseReceivedMessages_4:
   \      0x7F4   0x....'....        DC32     modbus_ProtocolBufTX
   \                     ??Modbus_ParseReceivedMessages_60: (+1)
   \      0x7F8   0x4668             MOV      R0,SP
   \      0x7FA   0x7800             LDRB     R0,[R0, #+0]
   \      0x7FC   0x6821             LDR      R1,[R4, #+0]
   \      0x7FE   0x7008             STRB     R0,[R1, #+0]
   1118                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \      0x800   0x0038             MOVS     R0,R7
   \      0x802   0x3880             SUBS     R0,R0,#+128
   \      0x804   0x6821             LDR      R1,[R4, #+0]
   \      0x806   0x7048             STRB     R0,[R1, #+1]
   1119                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) MODBUS_EXCEPTION_02;
   \      0x808   0x2002             MOVS     R0,#+2
   \      0x80A   0x6821             LDR      R1,[R4, #+0]
   \      0x80C   0x7088             STRB     R0,[R1, #+2]
   1120                  // build CRC
   1121                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x80E   0x9801             LDR      R0,[SP, #+4]
   \      0x810   0x1E81             SUBS     R1,R0,#+2
   \      0x812   0xB289             UXTH     R1,R1
   \      0x814   0x6820             LDR      R0,[R4, #+0]
   \      0x816   0x....'....        BL       calculateModbusCRC
   \      0x81A   0x0005             MOVS     R5,R0
   1122                  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x81C   0x0028             MOVS     R0,R5
   \      0x81E   0x6821             LDR      R1,[R4, #+0]
   \      0x820   0x70C8             STRB     R0,[R1, #+3]
   1123                  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x822   0x0028             MOVS     R0,R5
   \      0x824   0xB280             UXTH     R0,R0
   \      0x826   0x0A00             LSRS     R0,R0,#+8
   \      0x828   0x6821             LDR      R1,[R4, #+0]
   \      0x82A   0x7108             STRB     R0,[R1, #+4]
   1124                  // write to seq Mem structure
   1125                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \      0x82C   0xAA01             ADD      R2,SP,#+4
   \      0x82E   0x6821             LDR      R1,[R4, #+0]
   \      0x830   0x485E             LDR      R0,??Modbus_ParseReceivedMessages_5
   \      0x832   0x6800             LDR      R0,[R0, #+0]
   \      0x834   0x6840             LDR      R0,[R0, #+4]
   \      0x836   0x....'....        BL       RingBuf_WriteBlock
   \      0x83A   0xE03D             B        ??Modbus_ParseReceivedMessages_61
   1126                }
   1127                else {
   1128                  responseLength_u32 = WRITE_RESPONSE_HEADER_LENGTH + CRC_LENGTH;
   \                     ??Modbus_ParseReceivedMessages_58: (+1)
   \      0x83C   0x9601             STR      R6,[SP, #+4]
   1129                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x83E   0x9801             LDR      R0,[SP, #+4]
   \      0x840   0xB2C0             UXTB     R0,R0
   \      0x842   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x846   0x0006             MOVS     R6,R0
   1130                  if (error_occurred) {
   \      0x848   0x0030             MOVS     R0,R6
   \      0x84A   0xB2C0             UXTB     R0,R0
   \      0x84C   0x2800             CMP      R0,#+0
   \      0x84E   0xD000             BEQ      .+4
   \      0x850   0xE2FA             B        ??Modbus_ParseReceivedMessages_13
   1131                    return;
   1132                  }
   1133                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;	
   1134                  // build heade
   1135                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_62: (+1)
   \      0x852   0x4CCF             LDR      R4,??Modbus_ParseReceivedMessages_6
   \      0x854   0x4668             MOV      R0,SP
   \      0x856   0x7800             LDRB     R0,[R0, #+0]
   \      0x858   0x6821             LDR      R1,[R4, #+0]
   \      0x85A   0x7008             STRB     R0,[R1, #+0]
   1136                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8;
   \      0x85C   0x6820             LDR      R0,[R4, #+0]
   \      0x85E   0x7047             STRB     R7,[R0, #+1]
   1137                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) (register_address_u16 >> 8);				// starting register MSB/LSB
   \      0x860   0x4668             MOV      R0,SP
   \      0x862   0x8900             LDRH     R0,[R0, #+8]
   \      0x864   0xB280             UXTH     R0,R0
   \      0x866   0x0A00             LSRS     R0,R0,#+8
   \      0x868   0x6821             LDR      R1,[R4, #+0]
   \      0x86A   0x7088             STRB     R0,[R1, #+2]
   1138                  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (register_address_u16 >> 0);					
   \      0x86C   0x4668             MOV      R0,SP
   \      0x86E   0x8900             LDRH     R0,[R0, #+8]
   \      0x870   0x6821             LDR      R1,[R4, #+0]
   \      0x872   0x70C8             STRB     R0,[R1, #+3]
   1139                  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (number_of_registers_u16 >> 8);			// number of registers written MSB/LSB
   \      0x874   0x4668             MOV      R0,SP
   \      0x876   0x8840             LDRH     R0,[R0, #+2]
   \      0x878   0xB280             UXTH     R0,R0
   \      0x87A   0x0A00             LSRS     R0,R0,#+8
   \      0x87C   0x6821             LDR      R1,[R4, #+0]
   \      0x87E   0x7108             STRB     R0,[R1, #+4]
   1140                  modbus_ProtocolBufTX[BYTE_5] = (uint8_t) (number_of_registers_u16 >> 0);				
   \      0x880   0x4668             MOV      R0,SP
   \      0x882   0x8840             LDRH     R0,[R0, #+2]
   \      0x884   0x6821             LDR      R1,[R4, #+0]
   \      0x886   0x7148             STRB     R0,[R1, #+5]
   1141                  // build CRC
   1142                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x888   0x9801             LDR      R0,[SP, #+4]
   \      0x88A   0x1E81             SUBS     R1,R0,#+2
   \      0x88C   0xB289             UXTH     R1,R1
   \      0x88E   0x6820             LDR      R0,[R4, #+0]
   \      0x890   0x....'....        BL       calculateModbusCRC
   \      0x894   0x0005             MOVS     R5,R0
   1143                  modbus_ProtocolBufTX[BYTE_6] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x896   0x0028             MOVS     R0,R5
   \      0x898   0x6821             LDR      R1,[R4, #+0]
   \      0x89A   0x7188             STRB     R0,[R1, #+6]
   1144                  modbus_ProtocolBufTX[BYTE_7] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x89C   0x0028             MOVS     R0,R5
   \      0x89E   0xB280             UXTH     R0,R0
   \      0x8A0   0x0A00             LSRS     R0,R0,#+8
   \      0x8A2   0x6821             LDR      R1,[R4, #+0]
   \      0x8A4   0x71C8             STRB     R0,[R1, #+7]
   1145                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \      0x8A6   0xAA01             ADD      R2,SP,#+4
   \      0x8A8   0x6821             LDR      R1,[R4, #+0]
   \      0x8AA   0x4840             LDR      R0,??Modbus_ParseReceivedMessages_5
   \      0x8AC   0x6800             LDR      R0,[R0, #+0]
   \      0x8AE   0x6840             LDR      R0,[R0, #+4]
   \      0x8B0   0x....'....        BL       RingBuf_WriteBlock
   1146                  
   1147                  UpdateMotorDemandMultiplexer(); // TODO: Don't call for every write (only when updates detected)
   \      0x8B4   0x....'....        BL       UpdateMotorDemandMultiplexer
   1148                }				
   1149                break;
   \                     ??Modbus_ParseReceivedMessages_61: (+1)
   \      0x8B8   0xE2C6             B        ??Modbus_ParseReceivedMessages_8
   1150              }
   1151              //case MODBUS_FUNCTION_CODE_WRITE_HOLDING_REGISTERS: {
   1152              case MODBUS_FUNCTION_CODE_WRITE_HOLDING_REGISTERS: {
   1153                if (ProcessMBHoldingRegister(modbus_ProtocolBufRX+WRITE_HEADER_LENGTH, register_address_u16, number_of_registers_u16, MB_WRITE_REGISTER) == MB_ILLEGAL_ADDRESS) {
   \                     ??Modbus_ParseReceivedMessages_24: (+1)
   \      0x8BA   0x2301             MOVS     R3,#+1
   \      0x8BC   0x4668             MOV      R0,SP
   \      0x8BE   0x8842             LDRH     R2,[R0, #+2]
   \      0x8C0   0x4668             MOV      R0,SP
   \      0x8C2   0x8901             LDRH     R1,[R0, #+8]
   \      0x8C4   0x6828             LDR      R0,[R5, #+0]
   \      0x8C6   0x1DC0             ADDS     R0,R0,#+7
   \      0x8C8   0x....'....        BL       ProcessMBHoldingRegister
   \      0x8CC   0x2801             CMP      R0,#+1
   \      0x8CE   0xD12D             BNE      ??Modbus_ParseReceivedMessages_63
   1154                  // send exception code for ilegal address
   1155                  responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \      0x8D0   0x9401             STR      R4,[SP, #+4]
   1156                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x8D2   0x9801             LDR      R0,[SP, #+4]
   \      0x8D4   0xB2C0             UXTB     R0,R0
   \      0x8D6   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x8DA   0x0006             MOVS     R6,R0
   1157                  if (error_occurred) {
   \      0x8DC   0x0030             MOVS     R0,R6
   \      0x8DE   0xB2C0             UXTB     R0,R0
   \      0x8E0   0x2800             CMP      R0,#+0
   \      0x8E2   0xD000             BEQ      .+4
   \      0x8E4   0xE2B0             B        ??Modbus_ParseReceivedMessages_13
   1158                    return;
   1159                  }
   1160                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
   1161                  // build header
   1162                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_64: (+1)
   \      0x8E6   0x4CAA             LDR      R4,??Modbus_ParseReceivedMessages_6
   \      0x8E8   0x4668             MOV      R0,SP
   \      0x8EA   0x7800             LDRB     R0,[R0, #+0]
   \      0x8EC   0x6821             LDR      R1,[R4, #+0]
   \      0x8EE   0x7008             STRB     R0,[R1, #+0]
   1163                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \      0x8F0   0x0038             MOVS     R0,R7
   \      0x8F2   0x3880             SUBS     R0,R0,#+128
   \      0x8F4   0x6821             LDR      R1,[R4, #+0]
   \      0x8F6   0x7048             STRB     R0,[R1, #+1]
   1164                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) MODBUS_EXCEPTION_02;
   \      0x8F8   0x2002             MOVS     R0,#+2
   \      0x8FA   0x6821             LDR      R1,[R4, #+0]
   \      0x8FC   0x7088             STRB     R0,[R1, #+2]
   1165                  // build CRC
   1166                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x8FE   0x9801             LDR      R0,[SP, #+4]
   \      0x900   0x1E81             SUBS     R1,R0,#+2
   \      0x902   0xB289             UXTH     R1,R1
   \      0x904   0x6820             LDR      R0,[R4, #+0]
   \      0x906   0x....'....        BL       calculateModbusCRC
   \      0x90A   0x0005             MOVS     R5,R0
   1167                  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x90C   0x0028             MOVS     R0,R5
   \      0x90E   0x6821             LDR      R1,[R4, #+0]
   \      0x910   0x70C8             STRB     R0,[R1, #+3]
   1168                  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x912   0x0028             MOVS     R0,R5
   \      0x914   0xB280             UXTH     R0,R0
   \      0x916   0x0A00             LSRS     R0,R0,#+8
   \      0x918   0x6821             LDR      R1,[R4, #+0]
   \      0x91A   0x7108             STRB     R0,[R1, #+4]
   1169                  // write to seq Mem structure
   1170                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \      0x91C   0xAA01             ADD      R2,SP,#+4
   \      0x91E   0x6821             LDR      R1,[R4, #+0]
   \      0x920   0x4822             LDR      R0,??Modbus_ParseReceivedMessages_5
   \      0x922   0x6800             LDR      R0,[R0, #+0]
   \      0x924   0x6840             LDR      R0,[R0, #+4]
   \      0x926   0x....'....        BL       RingBuf_WriteBlock
   \      0x92A   0xE03E             B        ??Modbus_ParseReceivedMessages_65
   1171                }
   1172                else {
   1173                  responseLength_u32 = WRITE_RESPONSE_HEADER_LENGTH + CRC_LENGTH;
   \                     ??Modbus_ParseReceivedMessages_63: (+1)
   \      0x92C   0x2008             MOVS     R0,#+8
   \      0x92E   0x9001             STR      R0,[SP, #+4]
   1174                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x930   0x9801             LDR      R0,[SP, #+4]
   \      0x932   0xB2C0             UXTB     R0,R0
   \      0x934   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x938   0x0006             MOVS     R6,R0
   1175                  if (error_occurred) {
   \      0x93A   0x0030             MOVS     R0,R6
   \      0x93C   0xB2C0             UXTB     R0,R0
   \      0x93E   0x2800             CMP      R0,#+0
   \      0x940   0xD000             BEQ      .+4
   \      0x942   0xE281             B        ??Modbus_ParseReceivedMessages_13
   1176                    return;
   1177                  }
   1178                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;	
   1179                  // build header
   1180                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_66: (+1)
   \      0x944   0x4C92             LDR      R4,??Modbus_ParseReceivedMessages_6
   \      0x946   0x4668             MOV      R0,SP
   \      0x948   0x7800             LDRB     R0,[R0, #+0]
   \      0x94A   0x6821             LDR      R1,[R4, #+0]
   \      0x94C   0x7008             STRB     R0,[R1, #+0]
   1181                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8;
   \      0x94E   0x6820             LDR      R0,[R4, #+0]
   \      0x950   0x7047             STRB     R7,[R0, #+1]
   1182                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) (register_address_u16 >> 8);				// starting register MSB/LSB
   \      0x952   0x4668             MOV      R0,SP
   \      0x954   0x8900             LDRH     R0,[R0, #+8]
   \      0x956   0xB280             UXTH     R0,R0
   \      0x958   0x0A00             LSRS     R0,R0,#+8
   \      0x95A   0x6821             LDR      R1,[R4, #+0]
   \      0x95C   0x7088             STRB     R0,[R1, #+2]
   1183                  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (register_address_u16 >> 0);					
   \      0x95E   0x4668             MOV      R0,SP
   \      0x960   0x8900             LDRH     R0,[R0, #+8]
   \      0x962   0x6821             LDR      R1,[R4, #+0]
   \      0x964   0x70C8             STRB     R0,[R1, #+3]
   1184                  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (number_of_registers_u16 >> 8);			// number of registers written MSB/LSB
   \      0x966   0x4668             MOV      R0,SP
   \      0x968   0x8840             LDRH     R0,[R0, #+2]
   \      0x96A   0xB280             UXTH     R0,R0
   \      0x96C   0x0A00             LSRS     R0,R0,#+8
   \      0x96E   0x6821             LDR      R1,[R4, #+0]
   \      0x970   0x7108             STRB     R0,[R1, #+4]
   1185                  modbus_ProtocolBufTX[BYTE_5] = (uint8_t) (number_of_registers_u16 >> 0);				
   \      0x972   0x4668             MOV      R0,SP
   \      0x974   0x8840             LDRH     R0,[R0, #+2]
   \      0x976   0x6821             LDR      R1,[R4, #+0]
   \      0x978   0x7148             STRB     R0,[R1, #+5]
   1186                  // build CRC
   1187                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0x97A   0x9801             LDR      R0,[SP, #+4]
   \      0x97C   0x1E81             SUBS     R1,R0,#+2
   \      0x97E   0xB289             UXTH     R1,R1
   \      0x980   0x6820             LDR      R0,[R4, #+0]
   \      0x982   0x....'....        BL       calculateModbusCRC
   \      0x986   0x0005             MOVS     R5,R0
   1188                  modbus_ProtocolBufTX[BYTE_6] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x988   0x0028             MOVS     R0,R5
   \      0x98A   0x6821             LDR      R1,[R4, #+0]
   \      0x98C   0x7188             STRB     R0,[R1, #+6]
   1189                  modbus_ProtocolBufTX[BYTE_7] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x98E   0x0028             MOVS     R0,R5
   \      0x990   0xB280             UXTH     R0,R0
   \      0x992   0x0A00             LSRS     R0,R0,#+8
   \      0x994   0x6821             LDR      R1,[R4, #+0]
   \      0x996   0x71C8             STRB     R0,[R1, #+7]
   1190                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \      0x998   0xAA01             ADD      R2,SP,#+4
   \      0x99A   0x6821             LDR      R1,[R4, #+0]
   \      0x99C   0x4803             LDR      R0,??Modbus_ParseReceivedMessages_5
   \      0x99E   0x6800             LDR      R0,[R0, #+0]
   \      0x9A0   0x6840             LDR      R0,[R0, #+4]
   \      0x9A2   0x....'....        BL       RingBuf_WriteBlock
   1191                  
   1192                  UpdateMotorDemandMultiplexer(); // TODO: Don't call for every write (only when updates detected)
   \      0x9A6   0x....'....        BL       UpdateMotorDemandMultiplexer
   1193                }
   1194                break;
   \                     ??Modbus_ParseReceivedMessages_65: (+1)
   \      0x9AA   0xE24D             B        ??Modbus_ParseReceivedMessages_8
   \                     ??Modbus_ParseReceivedMessages_5:
   \      0x9AC   0x....'....        DC32     usart1Control_Modbus
   1195              }			  
   1196          	case MODBUS_FUNCTION_CODE_READ_RECORDS: {
   1197                uint16_t file_address_u16 			= modbus_ProtocolBufRX[BYTE_6]*BYTE_TO_WORD_MSB + modbus_ProtocolBufRX[BYTE_7]*BYTE_TO_WORD_LSB;
   \                     ??Modbus_ParseReceivedMessages_25: (+1)
   \      0x9B0   0x2080             MOVS     R0,#+128
   \      0x9B2   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \      0x9B4   0x6829             LDR      R1,[R5, #+0]
   \      0x9B6   0x7989             LDRB     R1,[R1, #+6]
   \      0x9B8   0x4341             MULS     R1,R0,R1
   \      0x9BA   0x682A             LDR      R2,[R5, #+0]
   \      0x9BC   0x79D2             LDRB     R2,[R2, #+7]
   \      0x9BE   0x1889             ADDS     R1,R1,R2
   \      0x9C0   0x466A             MOV      R2,SP
   \      0x9C2   0x8251             STRH     R1,[R2, #+18]
   1198                uint16_t number_of_file_words_u16		= modbus_ProtocolBufRX[BYTE_8]*BYTE_TO_WORD_MSB + modbus_ProtocolBufRX[BYTE_9]*BYTE_TO_WORD_LSB;		
   \      0x9C4   0x6829             LDR      R1,[R5, #+0]
   \      0x9C6   0x7A09             LDRB     R1,[R1, #+8]
   \      0x9C8   0x4341             MULS     R1,R0,R1
   \      0x9CA   0x6828             LDR      R0,[R5, #+0]
   \      0x9CC   0x7A40             LDRB     R0,[R0, #+9]
   \      0x9CE   0x1808             ADDS     R0,R1,R0
   \      0x9D0   0x4669             MOV      R1,SP
   \      0x9D2   0x8208             STRH     R0,[R1, #+16]
   1199          	  uint8_t  file_number_u8				= modbus_ProtocolBufRX[BYTE_5];
   \      0x9D4   0x6828             LDR      R0,[R5, #+0]
   \      0x9D6   0x7940             LDRB     R0,[R0, #+5]
   \      0x9D8   0x4669             MOV      R1,SP
   \      0x9DA   0x7288             STRB     R0,[R1, #+10]
   1200          	  
   1201          	  // read requet to EEPROM on the drive side
   1202          	  if((file_number_u8 == DATA_LOGGER_FILE_NUMBER) || (file_number_u8 == COMPONENT_DATA_FILE_NUMBER)) {
   \      0x9DC   0x4668             MOV      R0,SP
   \      0x9DE   0x7A80             LDRB     R0,[R0, #+10]
   \      0x9E0   0x2800             CMP      R0,#+0
   \      0x9E2   0xD003             BEQ      ??Modbus_ParseReceivedMessages_67
   \      0x9E4   0x4668             MOV      R0,SP
   \      0x9E6   0x7A80             LDRB     R0,[R0, #+10]
   \      0x9E8   0x2801             CMP      R0,#+1
   \      0x9EA   0xD140             BNE      ??Modbus_ParseReceivedMessages_68
   1203          		last_eeprom_request.device_address_u8 = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_67: (+1)
   \      0x9EC   0x48B8             LDR      R0,??Modbus_ParseReceivedMessages_7
   \      0x9EE   0x4669             MOV      R1,SP
   \      0x9F0   0x7809             LDRB     R1,[R1, #+0]
   \      0x9F2   0x7001             STRB     R1,[R0, #+0]
   1204          		last_eeprom_request.function_code_u8 = MODBUS_FUNCTION_CODE_READ_RECORDS;
   \      0x9F4   0x2114             MOVS     R1,#+20
   \      0x9F6   0x7041             STRB     R1,[R0, #+1]
   1205          		last_eeprom_request.length_u8 = number_of_file_words_u16;
   \      0x9F8   0x4669             MOV      R1,SP
   \      0x9FA   0x8A09             LDRH     R1,[R1, #+16]
   \      0x9FC   0x7081             STRB     R1,[R0, #+2]
   1206          		// test for exceptions
   1207          		switch(file_number_u8) {
   \      0x9FE   0x4669             MOV      R1,SP
   \      0xA00   0x7A89             LDRB     R1,[R1, #+10]
   \      0xA02   0x2900             CMP      R1,#+0
   \      0xA04   0xD002             BEQ      ??Modbus_ParseReceivedMessages_69
   \      0xA06   0x2901             CMP      R1,#+1
   \      0xA08   0xD00D             BEQ      ??Modbus_ParseReceivedMessages_70
   \      0xA0A   0xE01E             B        ??Modbus_ParseReceivedMessages_71
   1208          		  case DATA_LOGGER_FILE_NUMBER: {
   1209          			if((file_address_u16 < DATA_LOGGER_ADDRESS_MIN) || (file_address_u16 > DATA_LOGGER_ADDRESS_MAX)) {
                 			                     ^
Warning[Pe186]: pointless comparison of unsigned integer with zero
   \                     ??Modbus_ParseReceivedMessages_69: (+1)
   \      0xA0C   0x4669             MOV      R1,SP
   \      0xA0E   0x8A49             LDRH     R1,[R1, #+18]
   \      0xA10   0x2280             MOVS     R2,#+128
   \      0xA12   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \      0xA14   0x4291             CMP      R1,R2
   \      0xA16   0xDB04             BLT      ??Modbus_ParseReceivedMessages_72
   1210          			  last_eeprom_request.is_exception_u8 = TRUE;
   \      0xA18   0x2101             MOVS     R1,#+1
   \      0xA1A   0x70C1             STRB     R1,[R0, #+3]
   1211          			  last_eeprom_request.exception_type_u8 = MODBUS_EXCEPTION_03; // illegal data value
   \      0xA1C   0x2103             MOVS     R1,#+3
   \      0xA1E   0x7101             STRB     R1,[R0, #+4]
   \      0xA20   0xE000             B        ??Modbus_ParseReceivedMessages_73
   1212          			}
   1213          			else
   1214          			  last_eeprom_request.is_exception_u8 = FALSE;
   \                     ??Modbus_ParseReceivedMessages_72: (+1)
   \      0xA22   0x70C6             STRB     R6,[R0, #+3]
   1215          			break;
   \                     ??Modbus_ParseReceivedMessages_73: (+1)
   \      0xA24   0xE011             B        ??Modbus_ParseReceivedMessages_71
   1216          		  }  
   1217          		  case COMPONENT_DATA_FILE_NUMBER: {
   1218          			if((file_address_u16 < COMPONENT_DATA_ADDRESS_MIN) || (file_address_u16 > COMPONENT_DATA_ADDRESS_MAX)) {
   \                     ??Modbus_ParseReceivedMessages_70: (+1)
   \      0xA26   0x4669             MOV      R1,SP
   \      0xA28   0x8A49             LDRH     R1,[R1, #+18]
   \      0xA2A   0x2280             MOVS     R2,#+128
   \      0xA2C   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \      0xA2E   0x4291             CMP      R1,R2
   \      0xA30   0xDB05             BLT      ??Modbus_ParseReceivedMessages_74
   \      0xA32   0x4669             MOV      R1,SP
   \      0xA34   0x8A49             LDRH     R1,[R1, #+18]
   \      0xA36   0x22C0             MOVS     R2,#+192
   \      0xA38   0x0092             LSLS     R2,R2,#+2        ;; #+768
   \      0xA3A   0x4291             CMP      R1,R2
   \      0xA3C   0xDB04             BLT      ??Modbus_ParseReceivedMessages_75
   1219          			  last_eeprom_request.is_exception_u8 = TRUE;
   \                     ??Modbus_ParseReceivedMessages_74: (+1)
   \      0xA3E   0x2101             MOVS     R1,#+1
   \      0xA40   0x70C1             STRB     R1,[R0, #+3]
   1220          			  last_eeprom_request.exception_type_u8 = MODBUS_EXCEPTION_03; // illegal data value
   \      0xA42   0x2103             MOVS     R1,#+3
   \      0xA44   0x7101             STRB     R1,[R0, #+4]
   \      0xA46   0xE000             B        ??Modbus_ParseReceivedMessages_76
   1221          			}
   1222          			else
   1223          			  last_eeprom_request.is_exception_u8 = FALSE;
   \                     ??Modbus_ParseReceivedMessages_75: (+1)
   \      0xA48   0x70C6             STRB     R6,[R0, #+3]
   1224          			break;
   1225          		  }
   1226          		}
   1227          		if(last_eeprom_request.is_exception_u8 == FALSE) {
   \                     ??Modbus_ParseReceivedMessages_76: (+1)
   \                     ??Modbus_ParseReceivedMessages_71: (+1)
   \      0xA4A   0x78C0             LDRB     R0,[R0, #+3]
   \      0xA4C   0x2800             CMP      R0,#+0
   \      0xA4E   0xD109             BNE      ??Modbus_ParseReceivedMessages_77
   1228          		  Build_UPEEPROM_Request(file_address_u16, (uint8_t) (2*number_of_file_words_u16));
   \      0xA50   0x4668             MOV      R0,SP
   \      0xA52   0x8A01             LDRH     R1,[R0, #+16]
   \      0xA54   0x2002             MOVS     R0,#+2
   \      0xA56   0x4341             MULS     R1,R0,R1
   \      0xA58   0xB2C9             UXTB     R1,R1
   \      0xA5A   0x4668             MOV      R0,SP
   \      0xA5C   0x8A40             LDRH     R0,[R0, #+18]
   \      0xA5E   0x....'....        BL       Build_UPEEPROM_Request
   \      0xA62   0xE003             B        ??Modbus_ParseReceivedMessages_78
   1229          		}
   1230          		else
   1231          		  Modbus_PassEEPROMData((uint8_t*) (NULL), 0);
   \                     ??Modbus_ParseReceivedMessages_77: (+1)
   \      0xA64   0x2100             MOVS     R1,#+0
   \      0xA66   0x2000             MOVS     R0,#+0
   \      0xA68   0x....'....        BL       Modbus_PassEEPROMData
   1232          		return;
   \                     ??Modbus_ParseReceivedMessages_78: (+1)
   \      0xA6C   0xE1EC             B        ??Modbus_ParseReceivedMessages_13
   1233          	  }
   1234          
   1235          	  // read requet to EEPROM on the drive side
   1236          	  if(file_number_u8 == DRIVE_CONFIGURATION_FILE_NUMBER) {
   \                     ??Modbus_ParseReceivedMessages_68: (+1)
   \      0xA6E   0x4668             MOV      R0,SP
   \      0xA70   0x7A80             LDRB     R0,[R0, #+10]
   \      0xA72   0x2804             CMP      R0,#+4
   \      0xA74   0xD126             BNE      ??Modbus_ParseReceivedMessages_79
   1237          		last_drive_flash_request.device_address_u8 = slave_address_u8;
   \      0xA76   0x4897             LDR      R0,??Modbus_ParseReceivedMessages_7+0x4
   \      0xA78   0x4669             MOV      R1,SP
   \      0xA7A   0x7809             LDRB     R1,[R1, #+0]
   \      0xA7C   0x7001             STRB     R1,[R0, #+0]
   1238          		last_drive_flash_request.function_code_u8 = MODBUS_FUNCTION_CODE_READ_RECORDS;
   \      0xA7E   0x2114             MOVS     R1,#+20
   \      0xA80   0x7041             STRB     R1,[R0, #+1]
   1239          		last_drive_flash_request.length_u8 = number_of_file_words_u16;
   \      0xA82   0x4669             MOV      R1,SP
   \      0xA84   0x8A09             LDRH     R1,[R1, #+16]
   \      0xA86   0x7081             STRB     R1,[R0, #+2]
   1240          		// test for exceptions
   1241          		if((file_address_u16 < DRIVE_CONFIGURATION_ADDRESS_MIN) || (file_address_u16 > DRIVE_CONFIGURATION_ADDRESS_MAX)) {
                 		                     ^
Warning[Pe186]: pointless comparison of unsigned integer with zero
   \      0xA88   0x4669             MOV      R1,SP
   \      0xA8A   0x8A49             LDRH     R1,[R1, #+18]
   \      0xA8C   0x2280             MOVS     R2,#+128
   \      0xA8E   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \      0xA90   0x4291             CMP      R1,R2
   \      0xA92   0xDB04             BLT      ??Modbus_ParseReceivedMessages_80
   1242          		  last_drive_flash_request.is_exception_u8 = TRUE;
   \      0xA94   0x2101             MOVS     R1,#+1
   \      0xA96   0x70C1             STRB     R1,[R0, #+3]
   1243          		  last_drive_flash_request.exception_type_u8 = MODBUS_EXCEPTION_03; // illegal data value
   \      0xA98   0x2103             MOVS     R1,#+3
   \      0xA9A   0x7101             STRB     R1,[R0, #+4]
   \      0xA9C   0xE000             B        ??Modbus_ParseReceivedMessages_81
   1244          		}
   1245          		else
   1246          		  last_drive_flash_request.is_exception_u8 = FALSE;
   \                     ??Modbus_ParseReceivedMessages_80: (+1)
   \      0xA9E   0x70C6             STRB     R6,[R0, #+3]
   1247          
   1248          		if(last_drive_flash_request.is_exception_u8 == FALSE) {
   \                     ??Modbus_ParseReceivedMessages_81: (+1)
   \      0xAA0   0x78C0             LDRB     R0,[R0, #+3]
   \      0xAA2   0x2800             CMP      R0,#+0
   \      0xAA4   0xD109             BNE      ??Modbus_ParseReceivedMessages_82
   1249          			Build_UPDrive_Flash_Request(file_address_u16, (uint8_t) (2*number_of_file_words_u16));
   \      0xAA6   0x4668             MOV      R0,SP
   \      0xAA8   0x8A01             LDRH     R1,[R0, #+16]
   \      0xAAA   0x2002             MOVS     R0,#+2
   \      0xAAC   0x4341             MULS     R1,R0,R1
   \      0xAAE   0xB2C9             UXTB     R1,R1
   \      0xAB0   0x4668             MOV      R0,SP
   \      0xAB2   0x8A40             LDRH     R0,[R0, #+18]
   \      0xAB4   0x....'....        BL       Build_UPDrive_Flash_Request
   \      0xAB8   0xE003             B        ??Modbus_ParseReceivedMessages_83
   1250          		}
   1251          		else // generate exception response immediately
   1252          		  Modbus_PassDriveFlashData((uint8_t*) (NULL), 0);
   \                     ??Modbus_ParseReceivedMessages_82: (+1)
   \      0xABA   0x2100             MOVS     R1,#+0
   \      0xABC   0x2000             MOVS     R0,#+0
   \      0xABE   0x....'....        BL       Modbus_PassDriveFlashData
   1253          		return;
   \                     ??Modbus_ParseReceivedMessages_83: (+1)
   \      0xAC2   0xE1C1             B        ??Modbus_ParseReceivedMessages_13
   1254          	  }
   1255          	  	  
   1256          	  if (ProcessMBReadRecords(modbus_ProtocolBufRX+READ_RECORDS_HEADER_LENGTH, file_address_u16, number_of_file_words_u16, file_number_u8) == MB_ILLEGAL_ADDRESS) {
   \                     ??Modbus_ParseReceivedMessages_79: (+1)
   \      0xAC4   0x4668             MOV      R0,SP
   \      0xAC6   0x7A83             LDRB     R3,[R0, #+10]
   \      0xAC8   0x4668             MOV      R0,SP
   \      0xACA   0x8A02             LDRH     R2,[R0, #+16]
   \      0xACC   0x4668             MOV      R0,SP
   \      0xACE   0x8A41             LDRH     R1,[R0, #+18]
   \      0xAD0   0x6828             LDR      R0,[R5, #+0]
   \      0xAD2   0x300A             ADDS     R0,R0,#+10
   \      0xAD4   0x....'....        BL       ProcessMBReadRecords
   \      0xAD8   0x2801             CMP      R0,#+1
   \      0xADA   0xD12D             BNE      ??Modbus_ParseReceivedMessages_84
   1257          		// send exception code for ilegal address
   1258          		  responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \      0xADC   0x9401             STR      R4,[SP, #+4]
   1259          		  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0xADE   0x9801             LDR      R0,[SP, #+4]
   \      0xAE0   0xB2C0             UXTB     R0,R0
   \      0xAE2   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0xAE6   0x0006             MOVS     R6,R0
   1260          		  if (error_occurred) {
   \      0xAE8   0x0030             MOVS     R0,R6
   \      0xAEA   0xB2C0             UXTB     R0,R0
   \      0xAEC   0x2800             CMP      R0,#+0
   \      0xAEE   0xD000             BEQ      .+4
   \      0xAF0   0xE1AA             B        ??Modbus_ParseReceivedMessages_13
   1261          			return;
   1262          		  }
   1263          		  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
   1264          		  // build header
   1265          		  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_85: (+1)
   \      0xAF2   0x4C27             LDR      R4,??Modbus_ParseReceivedMessages_6
   \      0xAF4   0x4668             MOV      R0,SP
   \      0xAF6   0x7800             LDRB     R0,[R0, #+0]
   \      0xAF8   0x6821             LDR      R1,[R4, #+0]
   \      0xAFA   0x7008             STRB     R0,[R1, #+0]
   1266          		  modbus_ProtocolBufTX[BYTE_1] = function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \      0xAFC   0x0038             MOVS     R0,R7
   \      0xAFE   0x3880             SUBS     R0,R0,#+128
   \      0xB00   0x6821             LDR      R1,[R4, #+0]
   \      0xB02   0x7048             STRB     R0,[R1, #+1]
   1267          		  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) MODBUS_EXCEPTION_02;
   \      0xB04   0x2002             MOVS     R0,#+2
   \      0xB06   0x6821             LDR      R1,[R4, #+0]
   \      0xB08   0x7088             STRB     R0,[R1, #+2]
   1268          		  // build CRC
   1269          		  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0xB0A   0x9801             LDR      R0,[SP, #+4]
   \      0xB0C   0x1E81             SUBS     R1,R0,#+2
   \      0xB0E   0xB289             UXTH     R1,R1
   \      0xB10   0x6820             LDR      R0,[R4, #+0]
   \      0xB12   0x....'....        BL       calculateModbusCRC
   \      0xB16   0x0005             MOVS     R5,R0
   1270          		  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0xB18   0x0028             MOVS     R0,R5
   \      0xB1A   0x6821             LDR      R1,[R4, #+0]
   \      0xB1C   0x70C8             STRB     R0,[R1, #+3]
   1271          		  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0xB1E   0x0028             MOVS     R0,R5
   \      0xB20   0xB280             UXTH     R0,R0
   \      0xB22   0x0A00             LSRS     R0,R0,#+8
   \      0xB24   0x6821             LDR      R1,[R4, #+0]
   \      0xB26   0x7108             STRB     R0,[R1, #+4]
   1272          		  // write to seq Mem structure
   1273          		  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \      0xB28   0xAA01             ADD      R2,SP,#+4
   \      0xB2A   0x6821             LDR      R1,[R4, #+0]
   \      0xB2C   0x....             LDR      R0,??DataTable6
   \      0xB2E   0x6800             LDR      R0,[R0, #+0]
   \      0xB30   0x6840             LDR      R0,[R0, #+4]
   \      0xB32   0x....'....        BL       RingBuf_WriteBlock
   \      0xB36   0xE052             B        ??Modbus_ParseReceivedMessages_86
   1274          		}
   1275          		else {
   1276          		  responseLength_u32 = READ_RECORDS_RESPONSE_HEADER_LENGTH + (2*number_of_registers_u16)+ CRC_LENGTH;
   \                     ??Modbus_ParseReceivedMessages_84: (+1)
   \      0xB38   0x4668             MOV      R0,SP
   \      0xB3A   0x8840             LDRH     R0,[R0, #+2]
   \      0xB3C   0x2102             MOVS     R1,#+2
   \      0xB3E   0x4341             MULS     R1,R0,R1
   \      0xB40   0x1DC9             ADDS     R1,R1,#+7
   \      0xB42   0x9101             STR      R1,[SP, #+4]
   1277          		  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0xB44   0x9801             LDR      R0,[SP, #+4]
   \      0xB46   0xB2C0             UXTB     R0,R0
   \      0xB48   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0xB4C   0x4669             MOV      R1,SP
   \      0xB4E   0x72C8             STRB     R0,[R1, #+11]
   1278          		  if (error_occurred) {
   \      0xB50   0x4668             MOV      R0,SP
   \      0xB52   0x7AC0             LDRB     R0,[R0, #+11]
   \      0xB54   0x2800             CMP      R0,#+0
   \      0xB56   0xD000             BEQ      .+4
   \      0xB58   0xE176             B        ??Modbus_ParseReceivedMessages_13
   1279          			return;
   1280          		  }
   1281          		  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;	
   1282          		  // build header
   1283          		  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_87: (+1)
   \      0xB5A   0x4C0D             LDR      R4,??Modbus_ParseReceivedMessages_6
   \      0xB5C   0x4668             MOV      R0,SP
   \      0xB5E   0x7800             LDRB     R0,[R0, #+0]
   \      0xB60   0x6821             LDR      R1,[R4, #+0]
   \      0xB62   0x7008             STRB     R0,[R1, #+0]
   1284          		  modbus_ProtocolBufTX[BYTE_1] = function_code_u8;
   \      0xB64   0x6820             LDR      R0,[R4, #+0]
   \      0xB66   0x7047             STRB     R7,[R0, #+1]
   1285          		  modbus_ProtocolBufTX[BYTE_2] = (2*number_of_file_words_u16) + 3;	// total byte count for message in bytes
   \      0xB68   0x4668             MOV      R0,SP
   \      0xB6A   0x8A00             LDRH     R0,[R0, #+16]
   \      0xB6C   0x2102             MOVS     R1,#+2
   \      0xB6E   0x4341             MULS     R1,R0,R1
   \      0xB70   0x1CC9             ADDS     R1,R1,#+3
   \      0xB72   0x6820             LDR      R0,[R4, #+0]
   \      0xB74   0x7081             STRB     R1,[R0, #+2]
   1286          		  modbus_ProtocolBufTX[BYTE_3] = (2*number_of_file_words_u16) + 1;	// total byte count for data, counts hte number of bytes read/written to flash
   \      0xB76   0x4668             MOV      R0,SP
   \      0xB78   0x8A00             LDRH     R0,[R0, #+16]
   \      0xB7A   0x2102             MOVS     R1,#+2
   \      0xB7C   0x4341             MULS     R1,R0,R1
   \      0xB7E   0x1C49             ADDS     R1,R1,#+1
   \      0xB80   0x6820             LDR      R0,[R4, #+0]
   \      0xB82   0x70C1             STRB     R1,[R0, #+3]
   1287          		  modbus_ProtocolBufTX[BYTE_4] = MODBUS_REFERENCE_TYPE;	// Always 0x06
   \      0xB84   0x2006             MOVS     R0,#+6
   \      0xB86   0x6821             LDR      R1,[R4, #+0]
   \      0xB88   0x7108             STRB     R0,[R1, #+4]
   1288          		  
   1289          		  // build CRC
   1290          		  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0xB8A   0x....             LDR      R6,??DataTable6_1  ;; 0xfffe
   \      0xB8C   0xE002             B.N      ??Modbus_ParseReceivedMessages_88
   \      0xB8E   0xBF00             Nop
   \                     ??Modbus_ParseReceivedMessages_6:
   \      0xB90   0x....'....        DC32     modbus_ProtocolBufTX
   \                     ??Modbus_ParseReceivedMessages_88: (+1)
   \      0xB94   0x9801             LDR      R0,[SP, #+4]
   \      0xB96   0x1981             ADDS     R1,R0,R6
   \      0xB98   0xB289             UXTH     R1,R1
   \      0xB9A   0x6820             LDR      R0,[R4, #+0]
   \      0xB9C   0x....'....        BL       calculateModbusCRC
   \      0xBA0   0x0005             MOVS     R5,R0
   1291          		  modbus_ProtocolBufTX[responseLength_u32 - 2] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0xBA2   0x0028             MOVS     R0,R5
   \      0xBA4   0x6821             LDR      R1,[R4, #+0]
   \      0xBA6   0x9A01             LDR      R2,[SP, #+4]
   \      0xBA8   0x1889             ADDS     R1,R1,R2
   \      0xBAA   0x1E89             SUBS     R1,R1,#+2
   \      0xBAC   0x7008             STRB     R0,[R1, #+0]
   1292          		  modbus_ProtocolBufTX[responseLength_u32 - 1] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0xBAE   0x0028             MOVS     R0,R5
   \      0xBB0   0xB280             UXTH     R0,R0
   \      0xBB2   0x0A00             LSRS     R0,R0,#+8
   \      0xBB4   0x6821             LDR      R1,[R4, #+0]
   \      0xBB6   0x9A01             LDR      R2,[SP, #+4]
   \      0xBB8   0x1889             ADDS     R1,R1,R2
   \      0xBBA   0x1E49             SUBS     R1,R1,#+1
   \      0xBBC   0x7008             STRB     R0,[R1, #+0]
   1293          		  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf	
   \      0xBBE   0xAA01             ADD      R2,SP,#+4
   \      0xBC0   0x6821             LDR      R1,[R4, #+0]
   \      0xBC2   0x....             LDR      R0,??DataTable6
   \      0xBC4   0x6800             LDR      R0,[R0, #+0]
   \      0xBC6   0x6840             LDR      R0,[R0, #+4]
   \      0xBC8   0x....'....        BL       RingBuf_WriteBlock
   1294          		  uint16_t alt_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2); // debugging
   \      0xBCC   0x9801             LDR      R0,[SP, #+4]
   \      0xBCE   0x1981             ADDS     R1,R0,R6
   \      0xBD0   0xB289             UXTH     R1,R1
   \      0xBD2   0x6820             LDR      R0,[R4, #+0]
   \      0xBD4   0x....'....        BL       calculateModbusCRC
   \      0xBD8   0x0004             MOVS     R4,R0
   1295          		  		  
   1296          		  UpdateMotorDemandMultiplexer(); // TODO: Don't call for every write (only when updates detected)
   \      0xBDA   0x....'....        BL       UpdateMotorDemandMultiplexer
   1297                  } 
   1298          	  break;
   \                     ??Modbus_ParseReceivedMessages_86: (+1)
   \      0xBDE   0xE133             B        ??Modbus_ParseReceivedMessages_8
   1299          	}
   1300          	case MODBUS_FUNCTION_CODE_WRITE_RECORDS: { 
   1301                uint16_t file_address_u16 			= modbus_ProtocolBufRX[BYTE_6]*BYTE_TO_WORD_MSB + modbus_ProtocolBufRX[BYTE_7]*BYTE_TO_WORD_LSB;
   \                     ??Modbus_ParseReceivedMessages_26: (+1)
   \      0xBE0   0x2080             MOVS     R0,#+128
   \      0xBE2   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \      0xBE4   0x6829             LDR      R1,[R5, #+0]
   \      0xBE6   0x7989             LDRB     R1,[R1, #+6]
   \      0xBE8   0x4341             MULS     R1,R0,R1
   \      0xBEA   0x682A             LDR      R2,[R5, #+0]
   \      0xBEC   0x79D2             LDRB     R2,[R2, #+7]
   \      0xBEE   0x1889             ADDS     R1,R1,R2
   \      0xBF0   0x466A             MOV      R2,SP
   \      0xBF2   0x8211             STRH     R1,[R2, #+16]
   1302                uint16_t number_of_file_words_u16		= modbus_ProtocolBufRX[BYTE_8]*BYTE_TO_WORD_MSB + modbus_ProtocolBufRX[BYTE_9]*BYTE_TO_WORD_LSB;		
   \      0xBF4   0x6829             LDR      R1,[R5, #+0]
   \      0xBF6   0x7A09             LDRB     R1,[R1, #+8]
   \      0xBF8   0x4341             MULS     R1,R0,R1
   \      0xBFA   0x6828             LDR      R0,[R5, #+0]
   \      0xBFC   0x7A40             LDRB     R0,[R0, #+9]
   \      0xBFE   0x1808             ADDS     R0,R1,R0
   \      0xC00   0x4669             MOV      R1,SP
   \      0xC02   0x8248             STRH     R0,[R1, #+18]
   1303          	  uint8_t  file_number_u8				= modbus_ProtocolBufRX[BYTE_5];
   \      0xC04   0x6828             LDR      R0,[R5, #+0]
   \      0xC06   0x7940             LDRB     R0,[R0, #+5]
   \      0xC08   0x4669             MOV      R1,SP
   \      0xC0A   0x7288             STRB     R0,[R1, #+10]
   1304          	  
   1305          	  // read requet to EEPROM on the drive side
   1306          	  if((file_number_u8 == DATA_LOGGER_FILE_NUMBER) || (file_number_u8 == COMPONENT_DATA_FILE_NUMBER)) {
   \      0xC0C   0x4668             MOV      R0,SP
   \      0xC0E   0x7A80             LDRB     R0,[R0, #+10]
   \      0xC10   0x2800             CMP      R0,#+0
   \      0xC12   0xD003             BEQ      ??Modbus_ParseReceivedMessages_89
   \      0xC14   0x4668             MOV      R0,SP
   \      0xC16   0x7A80             LDRB     R0,[R0, #+10]
   \      0xC18   0x2801             CMP      R0,#+1
   \      0xC1A   0xD140             BNE      ??Modbus_ParseReceivedMessages_90
   1307          		last_eeprom_request.device_address_u8 = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_89: (+1)
   \      0xC1C   0x482C             LDR      R0,??Modbus_ParseReceivedMessages_7
   \      0xC1E   0x4669             MOV      R1,SP
   \      0xC20   0x7809             LDRB     R1,[R1, #+0]
   \      0xC22   0x7001             STRB     R1,[R0, #+0]
   1308          		last_eeprom_request.function_code_u8 = MODBUS_FUNCTION_CODE_WRITE_RECORDS;
   \      0xC24   0x2115             MOVS     R1,#+21
   \      0xC26   0x7041             STRB     R1,[R0, #+1]
   1309          		last_eeprom_request.length_u8 = number_of_file_words_u16;
   \      0xC28   0x4669             MOV      R1,SP
   \      0xC2A   0x8A49             LDRH     R1,[R1, #+18]
   \      0xC2C   0x7081             STRB     R1,[R0, #+2]
   1310          		// test for exceptions
   1311          		switch(file_number_u8) {
   \      0xC2E   0x4669             MOV      R1,SP
   \      0xC30   0x7A89             LDRB     R1,[R1, #+10]
   \      0xC32   0x2900             CMP      R1,#+0
   \      0xC34   0xD002             BEQ      ??Modbus_ParseReceivedMessages_91
   \      0xC36   0x2901             CMP      R1,#+1
   \      0xC38   0xD00D             BEQ      ??Modbus_ParseReceivedMessages_92
   \      0xC3A   0xE01E             B        ??Modbus_ParseReceivedMessages_93
   1312          		  case DATA_LOGGER_FILE_NUMBER: {
   1313          			if((file_address_u16 < DATA_LOGGER_ADDRESS_MIN) || (file_address_u16 > DATA_LOGGER_ADDRESS_MAX)) {
                 			                     ^
Warning[Pe186]: pointless comparison of unsigned integer with zero
   \                     ??Modbus_ParseReceivedMessages_91: (+1)
   \      0xC3C   0x4669             MOV      R1,SP
   \      0xC3E   0x8A09             LDRH     R1,[R1, #+16]
   \      0xC40   0x2280             MOVS     R2,#+128
   \      0xC42   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \      0xC44   0x4291             CMP      R1,R2
   \      0xC46   0xDB04             BLT      ??Modbus_ParseReceivedMessages_94
   1314          			  last_eeprom_request.is_exception_u8 = TRUE;
   \      0xC48   0x2101             MOVS     R1,#+1
   \      0xC4A   0x70C1             STRB     R1,[R0, #+3]
   1315          			  last_eeprom_request.exception_type_u8 = MODBUS_EXCEPTION_03; // illegal data value
   \      0xC4C   0x2103             MOVS     R1,#+3
   \      0xC4E   0x7101             STRB     R1,[R0, #+4]
   \      0xC50   0xE000             B        ??Modbus_ParseReceivedMessages_95
   1316          			}
   1317          			else
   1318          			  last_eeprom_request.is_exception_u8 = FALSE;
   \                     ??Modbus_ParseReceivedMessages_94: (+1)
   \      0xC52   0x70C6             STRB     R6,[R0, #+3]
   1319          			break;
   \                     ??Modbus_ParseReceivedMessages_95: (+1)
   \      0xC54   0xE011             B        ??Modbus_ParseReceivedMessages_93
   1320          		  }  
   1321          		  case COMPONENT_DATA_FILE_NUMBER: {
   1322          			if((file_address_u16 < COMPONENT_DATA_ADDRESS_MIN) || (file_address_u16 > COMPONENT_DATA_ADDRESS_MAX)) {
   \                     ??Modbus_ParseReceivedMessages_92: (+1)
   \      0xC56   0x4669             MOV      R1,SP
   \      0xC58   0x8A09             LDRH     R1,[R1, #+16]
   \      0xC5A   0x2280             MOVS     R2,#+128
   \      0xC5C   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \      0xC5E   0x4291             CMP      R1,R2
   \      0xC60   0xDB05             BLT      ??Modbus_ParseReceivedMessages_96
   \      0xC62   0x4669             MOV      R1,SP
   \      0xC64   0x8A09             LDRH     R1,[R1, #+16]
   \      0xC66   0x22C0             MOVS     R2,#+192
   \      0xC68   0x0092             LSLS     R2,R2,#+2        ;; #+768
   \      0xC6A   0x4291             CMP      R1,R2
   \      0xC6C   0xDB04             BLT      ??Modbus_ParseReceivedMessages_97
   1323          			  last_eeprom_request.is_exception_u8 = TRUE;
   \                     ??Modbus_ParseReceivedMessages_96: (+1)
   \      0xC6E   0x2101             MOVS     R1,#+1
   \      0xC70   0x70C1             STRB     R1,[R0, #+3]
   1324          			  last_eeprom_request.exception_type_u8 = MODBUS_EXCEPTION_03; // illegal data value
   \      0xC72   0x2103             MOVS     R1,#+3
   \      0xC74   0x7101             STRB     R1,[R0, #+4]
   \      0xC76   0xE000             B        ??Modbus_ParseReceivedMessages_98
   1325          			}
   1326          			else
   1327          			  last_eeprom_request.is_exception_u8 = FALSE;
   \                     ??Modbus_ParseReceivedMessages_97: (+1)
   \      0xC78   0x70C6             STRB     R6,[R0, #+3]
   1328          			break;
   1329          		  }
   1330          		}
   1331          		if(last_eeprom_request.is_exception_u8 == FALSE) {
   \                     ??Modbus_ParseReceivedMessages_98: (+1)
   \                     ??Modbus_ParseReceivedMessages_93: (+1)
   \      0xC7A   0x78C0             LDRB     R0,[R0, #+3]
   \      0xC7C   0x2800             CMP      R0,#+0
   \      0xC7E   0xD109             BNE      ??Modbus_ParseReceivedMessages_99
   1332          		  Build_UPEEPROM_Request(file_address_u16, (uint8_t) (2*number_of_file_words_u16));
   \      0xC80   0x4668             MOV      R0,SP
   \      0xC82   0x8A41             LDRH     R1,[R0, #+18]
   \      0xC84   0x2002             MOVS     R0,#+2
   \      0xC86   0x4341             MULS     R1,R0,R1
   \      0xC88   0xB2C9             UXTB     R1,R1
   \      0xC8A   0x4668             MOV      R0,SP
   \      0xC8C   0x8A00             LDRH     R0,[R0, #+16]
   \      0xC8E   0x....'....        BL       Build_UPEEPROM_Request
   \      0xC92   0xE003             B        ??Modbus_ParseReceivedMessages_100
   1333          		}
   1334          		else
   1335          		  Modbus_PassEEPROMData((uint8_t*) (NULL), 0);
   \                     ??Modbus_ParseReceivedMessages_99: (+1)
   \      0xC94   0x2100             MOVS     R1,#+0
   \      0xC96   0x2000             MOVS     R0,#+0
   \      0xC98   0x....'....        BL       Modbus_PassEEPROMData
   1336          		return;
   \                     ??Modbus_ParseReceivedMessages_100: (+1)
   \      0xC9C   0xE0D4             B        ??Modbus_ParseReceivedMessages_13
   1337          	  }
   1338          
   1339          	  // read requet to EEPROM on the drive side
   1340          	  if(file_number_u8 == DRIVE_CONFIGURATION_FILE_NUMBER) {
   \                     ??Modbus_ParseReceivedMessages_90: (+1)
   \      0xC9E   0x4668             MOV      R0,SP
   \      0xCA0   0x7A80             LDRB     R0,[R0, #+10]
   \      0xCA2   0x2804             CMP      R0,#+4
   \      0xCA4   0xD12B             BNE      ??Modbus_ParseReceivedMessages_101
   1341          		last_drive_flash_request.device_address_u8 = slave_address_u8;
   \      0xCA6   0x480B             LDR      R0,??Modbus_ParseReceivedMessages_7+0x4
   \      0xCA8   0x4669             MOV      R1,SP
   \      0xCAA   0x7809             LDRB     R1,[R1, #+0]
   \      0xCAC   0x7001             STRB     R1,[R0, #+0]
   1342          		last_drive_flash_request.function_code_u8 = MODBUS_FUNCTION_CODE_READ_RECORDS;
   \      0xCAE   0x2114             MOVS     R1,#+20
   \      0xCB0   0x7041             STRB     R1,[R0, #+1]
   1343          		last_drive_flash_request.length_u8 = number_of_file_words_u16;
   \      0xCB2   0x4669             MOV      R1,SP
   \      0xCB4   0x8A49             LDRH     R1,[R1, #+18]
   \      0xCB6   0x7081             STRB     R1,[R0, #+2]
   1344          		// test for exceptions
   1345          		if((file_address_u16 < DRIVE_CONFIGURATION_ADDRESS_MIN) || (file_address_u16 > DRIVE_CONFIGURATION_ADDRESS_MAX)) {
                 		                     ^
Warning[Pe186]: pointless comparison of unsigned integer with zero
   \      0xCB8   0x4669             MOV      R1,SP
   \      0xCBA   0x8A09             LDRH     R1,[R1, #+16]
   \      0xCBC   0x2280             MOVS     R2,#+128
   \      0xCBE   0x0092             LSLS     R2,R2,#+2        ;; #+512
   \      0xCC0   0x4291             CMP      R1,R2
   \      0xCC2   0xDB09             BLT      ??Modbus_ParseReceivedMessages_102
   1346          		  last_drive_flash_request.is_exception_u8 = TRUE;
   \      0xCC4   0x2101             MOVS     R1,#+1
   \      0xCC6   0x70C1             STRB     R1,[R0, #+3]
   1347          		  last_drive_flash_request.exception_type_u8 = MODBUS_EXCEPTION_03; // illegal data value
   \      0xCC8   0x2103             MOVS     R1,#+3
   \      0xCCA   0x7101             STRB     R1,[R0, #+4]
   \      0xCCC   0xE005             B        ??Modbus_ParseReceivedMessages_103
   \      0xCCE   0xBF00             Nop
   \                     ??Modbus_ParseReceivedMessages_7:
   \      0xCD0   0x....'....        DC32     last_eeprom_request
   \      0xCD4   0x....'....        DC32     last_drive_flash_request
   1348          		}
   1349          		else
   1350          		  last_drive_flash_request.is_exception_u8 = FALSE;
   \                     ??Modbus_ParseReceivedMessages_102: (+1)
   \      0xCD8   0x70C6             STRB     R6,[R0, #+3]
   1351          
   1352          		if(last_drive_flash_request.is_exception_u8 == FALSE) {
   \                     ??Modbus_ParseReceivedMessages_103: (+1)
   \      0xCDA   0x78C0             LDRB     R0,[R0, #+3]
   \      0xCDC   0x2800             CMP      R0,#+0
   \      0xCDE   0xD109             BNE      ??Modbus_ParseReceivedMessages_104
   1353          			Build_UPDrive_Flash_Request(file_address_u16, (uint8_t) (2*number_of_file_words_u16));
   \      0xCE0   0x4668             MOV      R0,SP
   \      0xCE2   0x8A41             LDRH     R1,[R0, #+18]
   \      0xCE4   0x2002             MOVS     R0,#+2
   \      0xCE6   0x4341             MULS     R1,R0,R1
   \      0xCE8   0xB2C9             UXTB     R1,R1
   \      0xCEA   0x4668             MOV      R0,SP
   \      0xCEC   0x8A00             LDRH     R0,[R0, #+16]
   \      0xCEE   0x....'....        BL       Build_UPDrive_Flash_Request
   \      0xCF2   0xE003             B        ??Modbus_ParseReceivedMessages_105
   1354          		}
   1355          		else // generate exception response immediately
   1356          		  Modbus_PassDriveFlashData((uint8_t*) (NULL), 0);
   \                     ??Modbus_ParseReceivedMessages_104: (+1)
   \      0xCF4   0x2100             MOVS     R1,#+0
   \      0xCF6   0x2000             MOVS     R0,#+0
   \      0xCF8   0x....'....        BL       Modbus_PassDriveFlashData
   1357          		return;
   \                     ??Modbus_ParseReceivedMessages_105: (+1)
   \      0xCFC   0xE0A4             B        ??Modbus_ParseReceivedMessages_13
   1358          	  }	  
   1359          	  
   1360          	  if (ProcessMBWriteRecords(modbus_ProtocolBufRX+WRITE_RECORDS_HEADER_LENGTH, file_address_u16, number_of_file_words_u16, file_number_u8) == MB_ILLEGAL_ADDRESS) {
   \                     ??Modbus_ParseReceivedMessages_101: (+1)
   \      0xCFE   0x4668             MOV      R0,SP
   \      0xD00   0x7A83             LDRB     R3,[R0, #+10]
   \      0xD02   0x4668             MOV      R0,SP
   \      0xD04   0x8A42             LDRH     R2,[R0, #+18]
   \      0xD06   0x4668             MOV      R0,SP
   \      0xD08   0x8A01             LDRH     R1,[R0, #+16]
   \      0xD0A   0x6828             LDR      R0,[R5, #+0]
   \      0xD0C   0x1C40             ADDS     R0,R0,#+1
   \      0xD0E   0x....'....        BL       ProcessMBWriteRecords
   \      0xD12   0x2801             CMP      R0,#+1
   \      0xD14   0xD12D             BNE      ??Modbus_ParseReceivedMessages_106
   1361          		  // send exception code for ilegal address
   1362          		  responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \      0xD16   0x9401             STR      R4,[SP, #+4]
   1363          		  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0xD18   0x9801             LDR      R0,[SP, #+4]
   \      0xD1A   0xB2C0             UXTB     R0,R0
   \      0xD1C   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0xD20   0x0006             MOVS     R6,R0
   1364          		  if (error_occurred) {
   \      0xD22   0x0030             MOVS     R0,R6
   \      0xD24   0xB2C0             UXTB     R0,R0
   \      0xD26   0x2800             CMP      R0,#+0
   \      0xD28   0xD000             BEQ      .+4
   \      0xD2A   0xE08D             B        ??Modbus_ParseReceivedMessages_13
   1365          			return;
   1366          		  }
   1367          		  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
   1368          		  // build header
   1369          		  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_107: (+1)
   \      0xD2C   0x....             LDR      R4,??DataTable6_2
   \      0xD2E   0x4668             MOV      R0,SP
   \      0xD30   0x7800             LDRB     R0,[R0, #+0]
   \      0xD32   0x6821             LDR      R1,[R4, #+0]
   \      0xD34   0x7008             STRB     R0,[R1, #+0]
   1370          		  modbus_ProtocolBufTX[BYTE_1] = function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \      0xD36   0x0038             MOVS     R0,R7
   \      0xD38   0x3880             SUBS     R0,R0,#+128
   \      0xD3A   0x6821             LDR      R1,[R4, #+0]
   \      0xD3C   0x7048             STRB     R0,[R1, #+1]
   1371          		  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) MODBUS_EXCEPTION_02;
   \      0xD3E   0x2002             MOVS     R0,#+2
   \      0xD40   0x6821             LDR      R1,[R4, #+0]
   \      0xD42   0x7088             STRB     R0,[R1, #+2]
   1372          		  // build CRC
   1373          		  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0xD44   0x9801             LDR      R0,[SP, #+4]
   \      0xD46   0x1E81             SUBS     R1,R0,#+2
   \      0xD48   0xB289             UXTH     R1,R1
   \      0xD4A   0x6820             LDR      R0,[R4, #+0]
   \      0xD4C   0x....'....        BL       calculateModbusCRC
   \      0xD50   0x0005             MOVS     R5,R0
   1374          		  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0xD52   0x0028             MOVS     R0,R5
   \      0xD54   0x6821             LDR      R1,[R4, #+0]
   \      0xD56   0x70C8             STRB     R0,[R1, #+3]
   1375          		  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0xD58   0x0028             MOVS     R0,R5
   \      0xD5A   0xB280             UXTH     R0,R0
   \      0xD5C   0x0A00             LSRS     R0,R0,#+8
   \      0xD5E   0x6821             LDR      R1,[R4, #+0]
   \      0xD60   0x7108             STRB     R0,[R1, #+4]
   1376          		  // write to seq Mem structure
   1377          		  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \      0xD62   0xAA01             ADD      R2,SP,#+4
   \      0xD64   0x6821             LDR      R1,[R4, #+0]
   \      0xD66   0x....             LDR      R0,??DataTable6
   \      0xD68   0x6800             LDR      R0,[R0, #+0]
   \      0xD6A   0x6840             LDR      R0,[R0, #+4]
   \      0xD6C   0x....'....        BL       RingBuf_WriteBlock
   \      0xD70   0xE03D             B        ??Modbus_ParseReceivedMessages_108
   1378          		}
   1379          		else {
   1380          		  responseLength_u32 = WRITE_RECORDS_RESPONSE_HEADER_LENGTH + CRC_LENGTH;
   \                     ??Modbus_ParseReceivedMessages_106: (+1)
   \      0xD72   0x2003             MOVS     R0,#+3
   \      0xD74   0x9001             STR      R0,[SP, #+4]
   1381          		  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0xD76   0x9801             LDR      R0,[SP, #+4]
   \      0xD78   0xB2C0             UXTB     R0,R0
   \      0xD7A   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0xD7E   0x0006             MOVS     R6,R0
   1382          		  if (error_occurred) {
   \      0xD80   0x0030             MOVS     R0,R6
   \      0xD82   0xB2C0             UXTB     R0,R0
   \      0xD84   0x2800             CMP      R0,#+0
   \      0xD86   0xD15F             BNE      ??Modbus_ParseReceivedMessages_13
   1383          			return;
   1384          		  }
   1385          		  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;	
   1386          		  // build header
   1387          		  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_109: (+1)
   \      0xD88   0x....             LDR      R4,??DataTable6_2
   \      0xD8A   0x4668             MOV      R0,SP
   \      0xD8C   0x7800             LDRB     R0,[R0, #+0]
   \      0xD8E   0x6821             LDR      R1,[R4, #+0]
   \      0xD90   0x7008             STRB     R0,[R1, #+0]
   1388          		  modbus_ProtocolBufTX[BYTE_1] = function_code_u8;
   \      0xD92   0x6820             LDR      R0,[R4, #+0]
   \      0xD94   0x7047             STRB     R7,[R0, #+1]
   1389          		  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) (register_address_u16 >> 8);				// starting register MSB/LSB
   \      0xD96   0x4668             MOV      R0,SP
   \      0xD98   0x8900             LDRH     R0,[R0, #+8]
   \      0xD9A   0xB280             UXTH     R0,R0
   \      0xD9C   0x0A00             LSRS     R0,R0,#+8
   \      0xD9E   0x6821             LDR      R1,[R4, #+0]
   \      0xDA0   0x7088             STRB     R0,[R1, #+2]
   1390          		  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (register_address_u16 >> 0);					
   \      0xDA2   0x4668             MOV      R0,SP
   \      0xDA4   0x8900             LDRH     R0,[R0, #+8]
   \      0xDA6   0x6821             LDR      R1,[R4, #+0]
   \      0xDA8   0x70C8             STRB     R0,[R1, #+3]
   1391          		  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (number_of_registers_u16 >> 8);			// number of registers written MSB/LSB
   \      0xDAA   0x4668             MOV      R0,SP
   \      0xDAC   0x8840             LDRH     R0,[R0, #+2]
   \      0xDAE   0xB280             UXTH     R0,R0
   \      0xDB0   0x0A00             LSRS     R0,R0,#+8
   \      0xDB2   0x6821             LDR      R1,[R4, #+0]
   \      0xDB4   0x7108             STRB     R0,[R1, #+4]
   1392          		  modbus_ProtocolBufTX[BYTE_5] = (uint8_t) (number_of_registers_u16 >> 0);				
   \      0xDB6   0x4668             MOV      R0,SP
   \      0xDB8   0x8840             LDRH     R0,[R0, #+2]
   \      0xDBA   0x6821             LDR      R1,[R4, #+0]
   \      0xDBC   0x7148             STRB     R0,[R1, #+5]
   1393          		  // build CRC
   1394          		  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0xDBE   0x9801             LDR      R0,[SP, #+4]
   \      0xDC0   0x1E81             SUBS     R1,R0,#+2
   \      0xDC2   0xB289             UXTH     R1,R1
   \      0xDC4   0x6820             LDR      R0,[R4, #+0]
   \      0xDC6   0x....'....        BL       calculateModbusCRC
   \      0xDCA   0x0005             MOVS     R5,R0
   1395          		  modbus_ProtocolBufTX[BYTE_6] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0xDCC   0x0028             MOVS     R0,R5
   \      0xDCE   0x6821             LDR      R1,[R4, #+0]
   \      0xDD0   0x7188             STRB     R0,[R1, #+6]
   1396          		  modbus_ProtocolBufTX[BYTE_7] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0xDD2   0x0028             MOVS     R0,R5
   \      0xDD4   0xB280             UXTH     R0,R0
   \      0xDD6   0x0A00             LSRS     R0,R0,#+8
   \      0xDD8   0x6821             LDR      R1,[R4, #+0]
   \      0xDDA   0x71C8             STRB     R0,[R1, #+7]
   1397          		  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \      0xDDC   0xAA01             ADD      R2,SP,#+4
   \      0xDDE   0x6821             LDR      R1,[R4, #+0]
   \      0xDE0   0x....             LDR      R0,??DataTable6
   \      0xDE2   0x6800             LDR      R0,[R0, #+0]
   \      0xDE4   0x6840             LDR      R0,[R0, #+4]
   \      0xDE6   0x....'....        BL       RingBuf_WriteBlock
   1398          		  
   1399          		  UpdateMotorDemandMultiplexer(); // TODO: Don't call for every write (only when updates detected)
   \      0xDEA   0x....'....        BL       UpdateMotorDemandMultiplexer
   1400          		}		  
   1401          	  break;
   \                     ??Modbus_ParseReceivedMessages_108: (+1)
   \      0xDEE   0xE02B             B        ??Modbus_ParseReceivedMessages_8
   1402          	}
   1403              default: 
   1404                {
   1405                  // function code is not supported, so send an exception
   1406                  responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \                     ??Modbus_ParseReceivedMessages_27: (+1)
   \      0xDF0   0x9401             STR      R4,[SP, #+4]
   1407                  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0xDF2   0x9801             LDR      R0,[SP, #+4]
   \      0xDF4   0xB2C0             UXTB     R0,R0
   \      0xDF6   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0xDFA   0x0006             MOVS     R6,R0
   1408                  if (error_occurred) {
   \      0xDFC   0x0030             MOVS     R0,R6
   \      0xDFE   0xB2C0             UXTB     R0,R0
   \      0xE00   0x2800             CMP      R0,#+0
   \      0xE02   0xD121             BNE      ??Modbus_ParseReceivedMessages_13
   1409                    return;
   1410                  }
   1411                  // if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
   1412                  // build header
   1413                  modbus_ProtocolBufTX[BYTE_0] = slave_address_u8;
   \                     ??Modbus_ParseReceivedMessages_110: (+1)
   \      0xE04   0x....             LDR      R4,??DataTable6_2
   \      0xE06   0x4668             MOV      R0,SP
   \      0xE08   0x7800             LDRB     R0,[R0, #+0]
   \      0xE0A   0x6821             LDR      R1,[R4, #+0]
   \      0xE0C   0x7008             STRB     R0,[R1, #+0]
   1414                  modbus_ProtocolBufTX[BYTE_1] = function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \      0xE0E   0x0038             MOVS     R0,R7
   \      0xE10   0x3880             SUBS     R0,R0,#+128
   \      0xE12   0x6821             LDR      R1,[R4, #+0]
   \      0xE14   0x7048             STRB     R0,[R1, #+1]
   1415                  modbus_ProtocolBufTX[BYTE_2] = (uint8_t) MODBUS_EXCEPTION_01;									// illegal function code
   \      0xE16   0x2001             MOVS     R0,#+1
   \      0xE18   0x6821             LDR      R1,[R4, #+0]
   \      0xE1A   0x7088             STRB     R0,[R1, #+2]
   1416                  // build CRC
   1417                  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \      0xE1C   0x9801             LDR      R0,[SP, #+4]
   \      0xE1E   0x1E81             SUBS     R1,R0,#+2
   \      0xE20   0xB289             UXTH     R1,R1
   \      0xE22   0x6820             LDR      R0,[R4, #+0]
   \      0xE24   0x....'....        BL       calculateModbusCRC
   \      0xE28   0x0005             MOVS     R5,R0
   1418                  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);								// crc LSB
   \      0xE2A   0x0028             MOVS     R0,R5
   \      0xE2C   0x6821             LDR      R1,[R4, #+0]
   \      0xE2E   0x70C8             STRB     R0,[R1, #+3]
   1419                  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);								// crc MSB
   \      0xE30   0x0028             MOVS     R0,R5
   \      0xE32   0xB280             UXTH     R0,R0
   \      0xE34   0x0A00             LSRS     R0,R0,#+8
   \      0xE36   0x6821             LDR      R1,[R4, #+0]
   \      0xE38   0x7108             STRB     R0,[R1, #+4]
   1420                  // write to seq Mem structure
   1421                  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf								  
   \      0xE3A   0xAA01             ADD      R2,SP,#+4
   \      0xE3C   0x6821             LDR      R1,[R4, #+0]
   \      0xE3E   0x....             LDR      R0,??DataTable6
   \      0xE40   0x6800             LDR      R0,[R0, #+0]
   \      0xE42   0x6840             LDR      R0,[R0, #+4]
   \      0xE44   0x....'....        BL       RingBuf_WriteBlock
   1422                  break;
   1423                }
   1424              }
   1425            }
   1426            // Minimize Size of Dynamically Allocated Buffers
   1427          #if ENABLE_MODBUS_PROTOCOLBUF_RX_FIXED_LEN <= 0
   1428            if((modbus_ProtocolBufRX = (uint8_t *) realloc(modbus_ProtocolBufRX,1)) == NULL) reallocError++;
   1429          #endif // ENABLE_MODBUS_PROTOCOLBUF_RX_FIXED_LEN <= 0
   1430          #if ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN <= 0
   1431            if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX,1)) == NULL) reallocError++;	
   1432          #endif //ENABLE_MODBUS_PROTOCOLBUF_TX_FIXED_LEN <= 0
   1433          }
   \                     ??Modbus_ParseReceivedMessages_8: (+1)
   \                     ??Modbus_ParseReceivedMessages_13: (+1)
   \      0xE48   0xB009             ADD      SP,SP,#+36
   \      0xE4A   0xBDF0             POP      {R4-R7,PC}       ;; return
   1434          

   \                                 In section .text, align 2, keep-with-next
   1435          MBErrorCode ProcessMBHoldingRegister(uint8_t * data_buffer_pu8, uint16_t starting_address_u16, uint16_t number_of_registers_u16, MBRegisterMode eMode) {
   \                     ProcessMBHoldingRegister: (+1)
   \        0x0   0xB5FB             PUSH     {R0,R1,R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0015             MOVS     R5,R2
   1436            MBErrorCode    eStatus = MB_ILLEGAL_ADDRESS;
   \        0x6   0x2601             MOVS     R6,#+1
   1437            ModbusMapBlock *block = find_modbus_block(starting_address_u16, number_of_registers_u16);
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0xB289             UXTH     R1,R1
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x8880             LDRH     R0,[R0, #+4]
   \       0x10   0x....'....        BL       find_modbus_block
   \       0x14   0x0001             MOVS     R1,R0
   1438            
   1439            if (block) {
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD03F             BEQ      ??ProcessMBHoldingRegister_0
   1440              //block_1 =(uint16_t) ( block->start_address_u16);
   1441              //offset_1 = starting_address_u16;
   1442              uint16_t index_u16 = starting_address_u16 - block->start_address_u16;
   \       0x1A   0x4668             MOV      R0,SP
   \       0x1C   0x8880             LDRH     R0,[R0, #+4]
   \       0x1E   0x888A             LDRH     R2,[R1, #+4]
   \       0x20   0x1A80             SUBS     R0,R0,R2
   1443              
   1444              while (number_of_registers_u16 > 0 ) {
   \                     ??ProcessMBHoldingRegister_1: (+1)
   \       0x22   0x002A             MOVS     R2,R5
   \       0x24   0xB292             UXTH     R2,R2
   \       0x26   0x2A00             CMP      R2,#+0
   \       0x28   0xD035             BEQ      ??ProcessMBHoldingRegister_2
   1445                if (eMode == MB_WRITE_REGISTER) {
   \       0x2A   0x466A             MOV      R2,SP
   \       0x2C   0x7A12             LDRB     R2,[R2, #+8]
   \       0x2E   0x2A01             CMP      R2,#+1
   \       0x30   0xD11C             BNE      ??ProcessMBHoldingRegister_3
   1446                  block->start_of_data_pu16[index_u16] = ((uint16_t)*data_buffer_pu8++) << 8;
   \       0x32   0x7822             LDRB     R2,[R4, #+0]
   \       0x34   0x0213             LSLS     R3,R2,#+8
   \       0x36   0x680F             LDR      R7,[R1, #+0]
   \       0x38   0x46BC             MOV      R12,R7
   \       0x3A   0x0007             MOVS     R7,R0
   \       0x3C   0xB2BF             UXTH     R7,R7
   \       0x3E   0x2202             MOVS     R2,#+2
   \       0x40   0x437A             MULS     R2,R7,R2
   \       0x42   0x4667             MOV      R7,R12
   \       0x44   0x52BB             STRH     R3,[R7, R2]
   \       0x46   0x1C62             ADDS     R2,R4,#+1
   1447                  block->start_of_data_pu16[index_u16] |= (uint16_t)*data_buffer_pu8++;
   \       0x48   0x680B             LDR      R3,[R1, #+0]
   \       0x4A   0x0004             MOVS     R4,R0
   \       0x4C   0xB2A4             UXTH     R4,R4
   \       0x4E   0x2702             MOVS     R7,#+2
   \       0x50   0x4367             MULS     R7,R4,R7
   \       0x52   0x5BDF             LDRH     R7,[R3, R7]
   \       0x54   0x7813             LDRB     R3,[R2, #+0]
   \       0x56   0x431F             ORRS     R7,R7,R3
   \       0x58   0x680C             LDR      R4,[R1, #+0]
   \       0x5A   0x46A4             MOV      R12,R4
   \       0x5C   0x0004             MOVS     R4,R0
   \       0x5E   0xB2A4             UXTH     R4,R4
   \       0x60   0x2302             MOVS     R3,#+2
   \       0x62   0x4363             MULS     R3,R4,R3
   \       0x64   0x4664             MOV      R4,R12
   \       0x66   0x52E7             STRH     R7,[R4, R3]
   \       0x68   0x1C54             ADDS     R4,R2,#+1
   \       0x6A   0xE011             B        ??ProcessMBHoldingRegister_4
   1448                }
   1449                else {
   1450                  *data_buffer_pu8++ = (uint8_t)(block->start_of_data_pu16[index_u16] >> 8);
   \                     ??ProcessMBHoldingRegister_3: (+1)
   \       0x6C   0x680A             LDR      R2,[R1, #+0]
   \       0x6E   0x0003             MOVS     R3,R0
   \       0x70   0xB29B             UXTH     R3,R3
   \       0x72   0x2702             MOVS     R7,#+2
   \       0x74   0x435F             MULS     R7,R3,R7
   \       0x76   0x5BD2             LDRH     R2,[R2, R7]
   \       0x78   0xB292             UXTH     R2,R2
   \       0x7A   0x0A12             LSRS     R2,R2,#+8
   \       0x7C   0x7022             STRB     R2,[R4, #+0]
   \       0x7E   0x1C62             ADDS     R2,R4,#+1
   1451                  *data_buffer_pu8++ = (uint8_t)(block->start_of_data_pu16[index_u16] & 0xff);
   \       0x80   0x680B             LDR      R3,[R1, #+0]
   \       0x82   0x0004             MOVS     R4,R0
   \       0x84   0xB2A4             UXTH     R4,R4
   \       0x86   0x2702             MOVS     R7,#+2
   \       0x88   0x4367             MULS     R7,R4,R7
   \       0x8A   0x5BDB             LDRH     R3,[R3, R7]
   \       0x8C   0x7013             STRB     R3,[R2, #+0]
   \       0x8E   0x1C54             ADDS     R4,R2,#+1
   1452                }
   1453                ++index_u16;
   \                     ??ProcessMBHoldingRegister_4: (+1)
   \       0x90   0x1C40             ADDS     R0,R0,#+1
   1454                --number_of_registers_u16;
   \       0x92   0x1E6D             SUBS     R5,R5,#+1
   \       0x94   0xE7C5             B        ??ProcessMBHoldingRegister_1
   1455              }
   1456              eStatus = MB_NO_ERROR;
   \                     ??ProcessMBHoldingRegister_2: (+1)
   \       0x96   0x2200             MOVS     R2,#+0
   \       0x98   0x0016             MOVS     R6,R2
   1457            }
   1458            return eStatus;
   \                     ??ProcessMBHoldingRegister_0: (+1)
   \       0x9A   0x0030             MOVS     R0,R6
   \       0x9C   0xB2C0             UXTB     R0,R0
   \       0x9E   0xBDFE             POP      {R1-R7,PC}       ;; return
   1459          }
   1460          

   \                                 In section .text, align 2, keep-with-next
   1461          MBErrorCode ProcessMBCoilRegister_New(uint8_t * data_buffer_pu8, uint16_t desired_coil_address_u16, uint16_t number_of_coils_u16, MBRegisterMode eMode) {
   \                     ProcessMBCoilRegister_New: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0xB090             SUB      SP,SP,#+64
   \        0x4   0x0005             MOVS     R5,R0
   1462            MBErrorCode    eStatus = MB_ILLEGAL_ADDRESS;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x4669             MOV      R1,SP
   \        0xA   0x72C8             STRB     R0,[R1, #+11]
   1463            ModbusCoilMapBlock *block = find_modbus_coil_block(desired_coil_address_u16, number_of_coils_u16);
   \        0xC   0xA811             ADD      R0,SP,#+68
   \        0xE   0x8801             LDRH     R1,[R0, #+0]
   \       0x10   0xA810             ADD      R0,SP,#+64
   \       0x12   0x8800             LDRH     R0,[R0, #+0]
   \       0x14   0x....'....        BL       find_modbus_coil_block
   \       0x18   0x9005             STR      R0,[SP, #+20]
   1464            uint8_t number_of_bytes_in_block_u8 = 0;		// number of bytes to represent all coils in this block
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x4669             MOV      R1,SP
   \       0x1E   0x7248             STRB     R0,[R1, #+9]
   1465            // TODO: Change the below into a pointer without fixed length MRM
   1466            uint8_t modbus_coil_data[6];					// a temporary array of all of the coils currently in this modbus block; will be used to access proper coils
   1467            uint8_t index_u8;
   1468            uint8_t mask_u8 = 0xff;
   \       0x20   0x20FF             MOVS     R0,#+255
   \       0x22   0x4669             MOV      R1,SP
   \       0x24   0x7208             STRB     R0,[R1, #+8]
   1469            
   1470            if (block) {	
   \       0x26   0x9805             LDR      R0,[SP, #+20]
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD100             BNE      .+4
   \       0x2C   0xE1AD             B        ??ProcessMBCoilRegister_New_0
   1471          	// Get all existing coil data from block
   1472          	for(index_u8=0; index_u8<(block->number_of_coil_registers_u8); index_u8++)
   \       0x2E   0x2600             MOVS     R6,#+0
   \                     ??ProcessMBCoilRegister_New_1: (+1)
   \       0x30   0x0030             MOVS     R0,R6
   \       0x32   0x9905             LDR      R1,[SP, #+20]
   \       0x34   0x7989             LDRB     R1,[R1, #+6]
   \       0x36   0xB2C0             UXTB     R0,R0
   \       0x38   0x4288             CMP      R0,R1
   \       0x3A   0xD222             BCS      ??ProcessMBCoilRegister_New_2
   1473          	{
   1474          		modbus_coil_data[index_u8*2] = (uint8_t)(block->start_of_coil_data_pu16[index_u8] & 0x00ff);	  // low byte of the first register
   \       0x3C   0xA80A             ADD      R0,SP,#+40
   \       0x3E   0x9905             LDR      R1,[SP, #+20]
   \       0x40   0x6809             LDR      R1,[R1, #+0]
   \       0x42   0x0032             MOVS     R2,R6
   \       0x44   0xB2D2             UXTB     R2,R2
   \       0x46   0x2302             MOVS     R3,#+2
   \       0x48   0x435A             MULS     R2,R3,R2
   \       0x4A   0x5A89             LDRH     R1,[R1, R2]
   \       0x4C   0x0032             MOVS     R2,R6
   \       0x4E   0xB2D2             UXTB     R2,R2
   \       0x50   0x2302             MOVS     R3,#+2
   \       0x52   0x435A             MULS     R2,R3,R2
   \       0x54   0x5481             STRB     R1,[R0, R2]
   1475          		modbus_coil_data[index_u8*2+1] = (uint8_t)(block->start_of_coil_data_pu16[index_u8] >> 8);  	  // high byte of the first register
   \       0x56   0x9905             LDR      R1,[SP, #+20]
   \       0x58   0x6809             LDR      R1,[R1, #+0]
   \       0x5A   0x0032             MOVS     R2,R6
   \       0x5C   0xB2D2             UXTB     R2,R2
   \       0x5E   0x2302             MOVS     R3,#+2
   \       0x60   0x435A             MULS     R2,R3,R2
   \       0x62   0x5A89             LDRH     R1,[R1, R2]
   \       0x64   0xB289             UXTH     R1,R1
   \       0x66   0x0A09             LSRS     R1,R1,#+8
   \       0x68   0x0032             MOVS     R2,R6
   \       0x6A   0xB2D2             UXTB     R2,R2
   \       0x6C   0x2302             MOVS     R3,#+2
   \       0x6E   0x435A             MULS     R2,R3,R2
   \       0x70   0x1880             ADDS     R0,R0,R2
   \       0x72   0x7041             STRB     R1,[R0, #+1]
   1476          		number_of_bytes_in_block_u8 += 2;												  // count bytes
   \       0x74   0x4668             MOV      R0,SP
   \       0x76   0x4669             MOV      R1,SP
   \       0x78   0x7A49             LDRB     R1,[R1, #+9]
   \       0x7A   0x1C89             ADDS     R1,R1,#+2
   \       0x7C   0x7241             STRB     R1,[R0, #+9]
   1477          	}
   \       0x7E   0x1C76             ADDS     R6,R6,#+1
   \       0x80   0xE7D6             B        ??ProcessMBCoilRegister_New_1
   1478          	
   1479          	// where to start indexing coils
   1480          	uint16_t coil_index_u16 = desired_coil_address_u16 - block->start_coil_address_u16;
   \                     ??ProcessMBCoilRegister_New_2: (+1)
   \       0x82   0xA810             ADD      R0,SP,#+64
   \       0x84   0x8800             LDRH     R0,[R0, #+0]
   \       0x86   0x9905             LDR      R1,[SP, #+20]
   \       0x88   0x8889             LDRH     R1,[R1, #+4]
   \       0x8A   0x1A40             SUBS     R0,R0,R1
   \       0x8C   0x4669             MOV      R1,SP
   \       0x8E   0x8208             STRH     R0,[R1, #+16]
   1481          	  
   1482          	uint16_t number_of_offset_bytes_u16 = (coil_index_u16 / 8);			// number of full bytes to shift
   \       0x90   0x4668             MOV      R0,SP
   \       0x92   0x8A00             LDRH     R0,[R0, #+16]
   \       0x94   0x2108             MOVS     R1,#+8
   \       0x96   0x....'....        BL       __aeabi_idiv
   \       0x9A   0x4669             MOV      R1,SP
   \       0x9C   0x81C8             STRH     R0,[R1, #+14]
   1483          	uint16_t number_of_offset_bits_u16 = (coil_index_u16 % 8);			// number of full bits to shift
   \       0x9E   0x4668             MOV      R0,SP
   \       0xA0   0x8A00             LDRH     R0,[R0, #+16]
   \       0xA2   0x2108             MOVS     R1,#+8
   \       0xA4   0x....'....        BL       __aeabi_idivmod
   \       0xA8   0x4668             MOV      R0,SP
   \       0xAA   0x8181             STRH     R1,[R0, #+12]
   1484          	number_of_bytes_in_block_u8 -= number_of_offset_bytes_u16;
   \       0xAC   0x4668             MOV      R0,SP
   \       0xAE   0x4669             MOV      R1,SP
   \       0xB0   0x7A49             LDRB     R1,[R1, #+9]
   \       0xB2   0x466A             MOV      R2,SP
   \       0xB4   0x89D2             LDRH     R2,[R2, #+14]
   \       0xB6   0x1A89             SUBS     R1,R1,R2
   \       0xB8   0x7241             STRB     R1,[R0, #+9]
   1485          
   1486          	if (eMode == MB_WRITE_REGISTER) {
   \       0xBA   0xA812             ADD      R0,SP,#+72
   \       0xBC   0x7800             LDRB     R0,[R0, #+0]
   \       0xBE   0x2801             CMP      R0,#+1
   \       0xC0   0xD000             BEQ      .+4
   \       0xC2   0xE0D0             B        ??ProcessMBCoilRegister_New_3
   1487          	  uint64_t current_coil_data_u64 = 0;
   \       0xC4   0x2000             MOVS     R0,#+0
   \       0xC6   0x2100             MOVS     R1,#+0
   \       0xC8   0xAA06             ADD      R2,SP,#+24
   \       0xCA   0xC203             STM      R2!,{R0,R1}
   \       0xCC   0x3A08             SUBS     R2,R2,#+8
   1488          	  uint64_t new_coil_data_u64 = 0;
   \       0xCE   0xAA0E             ADD      R2,SP,#+56
   \       0xD0   0xC203             STM      R2!,{R0,R1}
   \       0xD2   0x3A08             SUBS     R2,R2,#+8
   1489          	  uint64_t low_mask_u64 = 0x0000FFFFFFFFFFFF;
   \       0xD4   0x....             ADR      R0,??DataTable7
   \       0xD6   0xC803             LDM      R0,{R0,R1}
   \       0xD8   0xAA0C             ADD      R2,SP,#+48
   \       0xDA   0xC203             STM      R2!,{R0,R1}
   \       0xDC   0x3A08             SUBS     R2,R2,#+8
   1490          	  uint64_t mask_u64 = 0xFFFFFFFFFFFFFFFF;
   \       0xDE   0x....             ADR      R0,??DataTable7_1
   \       0xE0   0xC803             LDM      R0,{R0,R1}
   1491          	  mask_u64 <<= number_of_coils_u16 + coil_index_u16;
   \       0xE2   0xAA11             ADD      R2,SP,#+68
   \       0xE4   0x8812             LDRH     R2,[R2, #+0]
   \       0xE6   0x466B             MOV      R3,SP
   \       0xE8   0x8A1B             LDRH     R3,[R3, #+16]
   \       0xEA   0x18D2             ADDS     R2,R2,R3
   \       0xEC   0x....'....        BL       __aeabi_llsl
   \       0xF0   0xAA08             ADD      R2,SP,#+32
   \       0xF2   0xC203             STM      R2!,{R0,R1}
   \       0xF4   0x3A08             SUBS     R2,R2,#+8
   1492          	  low_mask_u64 = low_mask_u64 >> (48 - coil_index_u16);
   \       0xF6   0xA80C             ADD      R0,SP,#+48
   \       0xF8   0xC803             LDM      R0,{R0,R1}
   \       0xFA   0x2230             MOVS     R2,#+48
   \       0xFC   0x466B             MOV      R3,SP
   \       0xFE   0x8A1B             LDRH     R3,[R3, #+16]
   \      0x100   0x1AD2             SUBS     R2,R2,R3
   \      0x102   0x....'....        BL       __aeabi_llsr
   \      0x106   0xAA0C             ADD      R2,SP,#+48
   \      0x108   0xC203             STM      R2!,{R0,R1}
   \      0x10A   0x3A08             SUBS     R2,R2,#+8
   1493          	  mask_u64 = mask_u64 | low_mask_u64;
   \      0x10C   0xA808             ADD      R0,SP,#+32
   \      0x10E   0xC80C             LDM      R0!,{R2,R3}
   \      0x110   0x3808             SUBS     R0,R0,#+8
   \      0x112   0xA80C             ADD      R0,SP,#+48
   \      0x114   0xC803             LDM      R0,{R0,R1}
   \      0x116   0x4310             ORRS     R0,R0,R2
   \      0x118   0x4319             ORRS     R1,R1,R3
   \      0x11A   0xAA08             ADD      R2,SP,#+32
   \      0x11C   0xC203             STM      R2!,{R0,R1}
   \      0x11E   0x3A08             SUBS     R2,R2,#+8
   1494          		
   1495          	  uint16_t	modbus_register_u16 = 0;
   \      0x120   0x2000             MOVS     R0,#+0
   \      0x122   0x4669             MOV      R1,SP
   \      0x124   0x8248             STRH     R0,[R1, #+18]
   1496          	  for(index_u8=0; index_u8<3; index_u8++)
   \      0x126   0x2400             MOVS     R4,#+0
   \                     ??ProcessMBCoilRegister_New_4: (+1)
   \      0x128   0x0020             MOVS     R0,R4
   \      0x12A   0xB2C0             UXTB     R0,R0
   \      0x12C   0x2803             CMP      R0,#+3
   \      0x12E   0xDA19             BGE      ??ProcessMBCoilRegister_New_5
   1497          	  {
   1498          	      modbus_register_u16 = block->start_of_coil_data_pu16[index_u8];
   \      0x130   0x9805             LDR      R0,[SP, #+20]
   \      0x132   0x6800             LDR      R0,[R0, #+0]
   \      0x134   0x0021             MOVS     R1,R4
   \      0x136   0xB2C9             UXTB     R1,R1
   \      0x138   0x2202             MOVS     R2,#+2
   \      0x13A   0x4351             MULS     R1,R2,R1
   \      0x13C   0x5A40             LDRH     R0,[R0, R1]
   \      0x13E   0x4669             MOV      R1,SP
   \      0x140   0x8248             STRH     R0,[R1, #+18]
   1499          		  current_coil_data_u64 = current_coil_data_u64 | (((uint64_t) (modbus_register_u16)) << (16*index_u8));	// create new wrte block of 0's = full length of coil block
   \      0x142   0xA806             ADD      R0,SP,#+24
   \      0x144   0xC8C0             LDM      R0!,{R6,R7}
   \      0x146   0x3808             SUBS     R0,R0,#+8
   \      0x148   0x4668             MOV      R0,SP
   \      0x14A   0x8A40             LDRH     R0,[R0, #+18]
   \      0x14C   0x2100             MOVS     R1,#+0
   \      0x14E   0x2210             MOVS     R2,#+16
   \      0x150   0x4362             MULS     R2,R4,R2
   \      0x152   0x....'....        BL       __aeabi_llsl
   \      0x156   0x4330             ORRS     R0,R0,R6
   \      0x158   0x4339             ORRS     R1,R1,R7
   \      0x15A   0xAA06             ADD      R2,SP,#+24
   \      0x15C   0xC203             STM      R2!,{R0,R1}
   \      0x15E   0x3A08             SUBS     R2,R2,#+8
   1500          	  }
   \      0x160   0x1C64             ADDS     R4,R4,#+1
   \      0x162   0xE7E1             B        ??ProcessMBCoilRegister_New_4
   1501          
   1502          	  uint8_t number_of_bytes_to_write_u8 = 0;
   \                     ??ProcessMBCoilRegister_New_5: (+1)
   \      0x164   0x2000             MOVS     R0,#+0
   \      0x166   0x4669             MOV      R1,SP
   \      0x168   0x7288             STRB     R0,[R1, #+10]
   1503          	  if(((number_of_coils_u16 + number_of_offset_bits_u16) % 8) > 0)
   \      0x16A   0x2608             MOVS     R6,#+8
   \      0x16C   0xA811             ADD      R0,SP,#+68
   \      0x16E   0x8800             LDRH     R0,[R0, #+0]
   \      0x170   0x4669             MOV      R1,SP
   \      0x172   0x8989             LDRH     R1,[R1, #+12]
   \      0x174   0x1840             ADDS     R0,R0,R1
   \      0x176   0x0031             MOVS     R1,R6
   \      0x178   0x....'....        BL       __aeabi_idivmod
   \      0x17C   0x2901             CMP      R1,#+1
   \      0x17E   0xDB0B             BLT      ??ProcessMBCoilRegister_New_6
   1504          	  	number_of_bytes_to_write_u8 = (number_of_coils_u16 + number_of_offset_bits_u16)/8+1;	// add extra byte for spillover bits
   \      0x180   0xA811             ADD      R0,SP,#+68
   \      0x182   0x8800             LDRH     R0,[R0, #+0]
   \      0x184   0x4669             MOV      R1,SP
   \      0x186   0x8989             LDRH     R1,[R1, #+12]
   \      0x188   0x1840             ADDS     R0,R0,R1
   \      0x18A   0x0031             MOVS     R1,R6
   \      0x18C   0x....'....        BL       __aeabi_idiv
   \      0x190   0x1C40             ADDS     R0,R0,#+1
   \      0x192   0x4669             MOV      R1,SP
   \      0x194   0x7288             STRB     R0,[R1, #+10]
   \      0x196   0xE009             B        ??ProcessMBCoilRegister_New_7
   1505          	  else
   1506          		number_of_bytes_to_write_u8 = (number_of_coils_u16 + number_of_offset_bits_u16)/8;		// no bits spillover into next byte
   \                     ??ProcessMBCoilRegister_New_6: (+1)
   \      0x198   0xA811             ADD      R0,SP,#+68
   \      0x19A   0x8800             LDRH     R0,[R0, #+0]
   \      0x19C   0x4669             MOV      R1,SP
   \      0x19E   0x8989             LDRH     R1,[R1, #+12]
   \      0x1A0   0x1840             ADDS     R0,R0,R1
   \      0x1A2   0x0031             MOVS     R1,R6
   \      0x1A4   0x....'....        BL       __aeabi_idiv
   \      0x1A8   0x4669             MOV      R1,SP
   \      0x1AA   0x7288             STRB     R0,[R1, #+10]
   1507          	  if(number_of_bytes_to_write_u8 == 0)
   \                     ??ProcessMBCoilRegister_New_7: (+1)
   \      0x1AC   0x4668             MOV      R0,SP
   \      0x1AE   0x7A80             LDRB     R0,[R0, #+10]
   \      0x1B0   0x2800             CMP      R0,#+0
   \      0x1B2   0xD102             BNE      ??ProcessMBCoilRegister_New_8
   1508          		number_of_bytes_to_write_u8 = 1; // must have a minimum of one coil byte to write
   \      0x1B4   0x2001             MOVS     R0,#+1
   \      0x1B6   0x4669             MOV      R1,SP
   \      0x1B8   0x7288             STRB     R0,[R1, #+10]
   1509          	  
   1510          	  index_u8=number_of_offset_bytes_u16;
   \                     ??ProcessMBCoilRegister_New_8: (+1)
   \      0x1BA   0x4668             MOV      R0,SP
   \      0x1BC   0x89C6             LDRH     R6,[R0, #+14]
   1511          	  do {
   1512          		  new_coil_data_u64 = new_coil_data_u64 | (((uint64_t) (*data_buffer_pu8++)) << ((8*index_u8++) + number_of_offset_bits_u16)); 
   \                     ??ProcessMBCoilRegister_New_9: (+1)
   \      0x1BE   0xA80E             ADD      R0,SP,#+56
   \      0x1C0   0xC803             LDM      R0,{R0,R1}
   \      0x1C2   0x9000             STR      R0,[SP, #+0]
   \      0x1C4   0x9101             STR      R1,[SP, #+4]
   \      0x1C6   0x7828             LDRB     R0,[R5, #+0]
   \      0x1C8   0x2100             MOVS     R1,#+0
   \      0x1CA   0x0032             MOVS     R2,R6
   \      0x1CC   0xB2D2             UXTB     R2,R2
   \      0x1CE   0x2308             MOVS     R3,#+8
   \      0x1D0   0x435A             MULS     R2,R3,R2
   \      0x1D2   0x466B             MOV      R3,SP
   \      0x1D4   0x899B             LDRH     R3,[R3, #+12]
   \      0x1D6   0x18D2             ADDS     R2,R2,R3
   \      0x1D8   0x....'....        BL       __aeabi_llsl
   \      0x1DC   0x9A00             LDR      R2,[SP, #+0]
   \      0x1DE   0x9B01             LDR      R3,[SP, #+4]
   \      0x1E0   0x4310             ORRS     R0,R0,R2
   \      0x1E2   0x4319             ORRS     R1,R1,R3
   \      0x1E4   0xAA0E             ADD      R2,SP,#+56
   \      0x1E6   0xC203             STM      R2!,{R0,R1}
   \      0x1E8   0x3A08             SUBS     R2,R2,#+8
   \      0x1EA   0x1C76             ADDS     R6,R6,#+1
   \      0x1EC   0x1C6D             ADDS     R5,R5,#+1
   1513          	  } while(index_u8 < (number_of_offset_bytes_u16 + number_of_bytes_to_write_u8));
   \      0x1EE   0x0030             MOVS     R0,R6
   \      0x1F0   0xB2C0             UXTB     R0,R0
   \      0x1F2   0x4669             MOV      R1,SP
   \      0x1F4   0x89C9             LDRH     R1,[R1, #+14]
   \      0x1F6   0x466A             MOV      R2,SP
   \      0x1F8   0x7A92             LDRB     R2,[R2, #+10]
   \      0x1FA   0x1889             ADDS     R1,R1,R2
   \      0x1FC   0x4288             CMP      R0,R1
   \      0x1FE   0xDBDE             BLT      ??ProcessMBCoilRegister_New_9
   1514          	  
   1515          	  current_coil_data_u64 = ((current_coil_data_u64 & mask_u64) | (new_coil_data_u64 & ~mask_u64));
   \      0x200   0xA806             ADD      R0,SP,#+24
   \      0x202   0xC80C             LDM      R0!,{R2,R3}
   \      0x204   0x3808             SUBS     R0,R0,#+8
   \      0x206   0xA808             ADD      R0,SP,#+32
   \      0x208   0xC803             LDM      R0,{R0,R1}
   \      0x20A   0x4010             ANDS     R0,R0,R2
   \      0x20C   0x4019             ANDS     R1,R1,R3
   \      0x20E   0x9000             STR      R0,[SP, #+0]
   \      0x210   0x9101             STR      R1,[SP, #+4]
   \      0x212   0xA80E             ADD      R0,SP,#+56
   \      0x214   0xC80C             LDM      R0!,{R2,R3}
   \      0x216   0x3808             SUBS     R0,R0,#+8
   \      0x218   0xA808             ADD      R0,SP,#+32
   \      0x21A   0xC803             LDM      R0,{R0,R1}
   \      0x21C   0x43C0             MVNS     R0,R0
   \      0x21E   0x43C9             MVNS     R1,R1
   \      0x220   0x4010             ANDS     R0,R0,R2
   \      0x222   0x4019             ANDS     R1,R1,R3
   \      0x224   0x9A00             LDR      R2,[SP, #+0]
   \      0x226   0x9B01             LDR      R3,[SP, #+4]
   \      0x228   0x4310             ORRS     R0,R0,R2
   \      0x22A   0x4319             ORRS     R1,R1,R3
   \      0x22C   0xAA06             ADD      R2,SP,#+24
   \      0x22E   0xC203             STM      R2!,{R0,R1}
   \      0x230   0x3A08             SUBS     R2,R2,#+8
   1516          	  
   1517          	  for(index_u8=0; index_u8<(block->number_of_coil_registers_u8); index_u8++)
   \      0x232   0x2700             MOVS     R7,#+0
   \      0x234   0x003C             MOVS     R4,R7
   \                     ??ProcessMBCoilRegister_New_10: (+1)
   \      0x236   0x0020             MOVS     R0,R4
   \      0x238   0x9905             LDR      R1,[SP, #+20]
   \      0x23A   0x7989             LDRB     R1,[R1, #+6]
   \      0x23C   0xB2C0             UXTB     R0,R0
   \      0x23E   0x4288             CMP      R0,R1
   \      0x240   0xD20E             BCS      ??ProcessMBCoilRegister_New_11
   1518          		block->start_of_coil_data_pu16[index_u8] = (uint16_t) (((current_coil_data_u64)>>(16*index_u8)) & (0xFFFF));
   \      0x242   0xA806             ADD      R0,SP,#+24
   \      0x244   0xC803             LDM      R0,{R0,R1}
   \      0x246   0x2210             MOVS     R2,#+16
   \      0x248   0x4362             MULS     R2,R4,R2
   \      0x24A   0x....'....        BL       __aeabi_llsr
   \      0x24E   0x9905             LDR      R1,[SP, #+20]
   \      0x250   0x6809             LDR      R1,[R1, #+0]
   \      0x252   0x0022             MOVS     R2,R4
   \      0x254   0xB2D2             UXTB     R2,R2
   \      0x256   0x2302             MOVS     R3,#+2
   \      0x258   0x435A             MULS     R2,R3,R2
   \      0x25A   0x5288             STRH     R0,[R1, R2]
   \      0x25C   0x1C64             ADDS     R4,R4,#+1
   \      0x25E   0xE7EA             B        ??ProcessMBCoilRegister_New_10
   1519          	  
   1520          	  eStatus = MB_NO_ERROR;
   \                     ??ProcessMBCoilRegister_New_11: (+1)
   \      0x260   0x4668             MOV      R0,SP
   \      0x262   0x72C7             STRB     R7,[R0, #+11]
   \      0x264   0xE08E             B        ??ProcessMBCoilRegister_New_12
   1521              }
   1522              else {	  // performing a read
   1523          	  // byte shift
   1524          	  for(index_u8=0; index_u8<((block->number_of_coil_registers_u8*2) - number_of_offset_bytes_u16); index_u8++){
   \                     ??ProcessMBCoilRegister_New_3: (+1)
   \      0x266   0x2100             MOVS     R1,#+0
   \                     ??ProcessMBCoilRegister_New_13: (+1)
   \      0x268   0x0008             MOVS     R0,R1
   \      0x26A   0xB2C0             UXTB     R0,R0
   \      0x26C   0x9A05             LDR      R2,[SP, #+20]
   \      0x26E   0x7992             LDRB     R2,[R2, #+6]
   \      0x270   0x2302             MOVS     R3,#+2
   \      0x272   0x435A             MULS     R2,R3,R2
   \      0x274   0x466B             MOV      R3,SP
   \      0x276   0x89DB             LDRH     R3,[R3, #+14]
   \      0x278   0x1AD2             SUBS     R2,R2,R3
   \      0x27A   0x4290             CMP      R0,R2
   \      0x27C   0xDA0B             BGE      ??ProcessMBCoilRegister_New_14
   1525          		  modbus_coil_data[index_u8] = modbus_coil_data[index_u8+number_of_offset_bytes_u16];	  // shift data dwn by number_of_offset_bytes
   \      0x27E   0xA80A             ADD      R0,SP,#+40
   \      0x280   0x000A             MOVS     R2,R1
   \      0x282   0xB2D2             UXTB     R2,R2
   \      0x284   0x466B             MOV      R3,SP
   \      0x286   0x89DB             LDRH     R3,[R3, #+14]
   \      0x288   0x18D2             ADDS     R2,R2,R3
   \      0x28A   0x5C82             LDRB     R2,[R0, R2]
   \      0x28C   0x000B             MOVS     R3,R1
   \      0x28E   0xB2DB             UXTB     R3,R3
   \      0x290   0x54C2             STRB     R2,[R0, R3]
   1526          	  }
   \      0x292   0x1C49             ADDS     R1,R1,#+1
   \      0x294   0xE7E8             B        ??ProcessMBCoilRegister_New_13
   1527          	  
   1528          	  // bit shift8
   1529          	  mask_u8 = 0xFF;
   \                     ??ProcessMBCoilRegister_New_14: (+1)
   \      0x296   0x20FF             MOVS     R0,#+255
   \      0x298   0x0002             MOVS     R2,R0
   1530          	  mask_u8 >>= (8-number_of_offset_bits_u16);
   \      0x29A   0x2308             MOVS     R3,#+8
   \      0x29C   0x466C             MOV      R4,SP
   \      0x29E   0x89A4             LDRH     R4,[R4, #+12]
   \      0x2A0   0x1B1B             SUBS     R3,R3,R4
   \      0x2A2   0xB2D2             UXTB     R2,R2
   \      0x2A4   0x40DA             LSRS     R2,R2,R3
   \      0x2A6   0x466B             MOV      R3,SP
   \      0x2A8   0x721A             STRB     R2,[R3, #+8]
   1531          	  for(index_u8=0; index_u8<(number_of_bytes_in_block_u8); index_u8++)
   \      0x2AA   0x2600             MOVS     R6,#+0
   \                     ??ProcessMBCoilRegister_New_15: (+1)
   \      0x2AC   0x0031             MOVS     R1,R6
   \      0x2AE   0x466A             MOV      R2,SP
   \      0x2B0   0x7A52             LDRB     R2,[R2, #+9]
   \      0x2B2   0xB2C9             UXTB     R1,R1
   \      0x2B4   0x4291             CMP      R1,R2
   \      0x2B6   0xD234             BCS      ??ProcessMBCoilRegister_New_16
   1532          	  {
   1533          		  modbus_coil_data[index_u8]  = ((modbus_coil_data[index_u8])   >> number_of_offset_bits_u16);	  // shift data dwn by number_of_offset_bytes
   \      0x2B8   0xA90A             ADD      R1,SP,#+40
   \      0x2BA   0x0032             MOVS     R2,R6
   \      0x2BC   0xB2D2             UXTB     R2,R2
   \      0x2BE   0x5C8A             LDRB     R2,[R1, R2]
   \      0x2C0   0x466B             MOV      R3,SP
   \      0x2C2   0x899B             LDRH     R3,[R3, #+12]
   \      0x2C4   0x411A             ASRS     R2,R2,R3
   \      0x2C6   0x0033             MOVS     R3,R6
   \      0x2C8   0xB2DB             UXTB     R3,R3
   \      0x2CA   0x54CA             STRB     R2,[R1, R3]
   1534          		  if(index_u8 == number_of_bytes_in_block_u8-1)
   \      0x2CC   0x0032             MOVS     R2,R6
   \      0x2CE   0xB2D2             UXTB     R2,R2
   \      0x2D0   0x466B             MOV      R3,SP
   \      0x2D2   0x7A5B             LDRB     R3,[R3, #+9]
   \      0x2D4   0x1E5B             SUBS     R3,R3,#+1
   \      0x2D6   0x429A             CMP      R2,R3
   \      0x2D8   0xD10E             BNE      ??ProcessMBCoilRegister_New_17
   1535          		  	modbus_coil_data[index_u8] |= (((0xFF) & mask_u8) << (8-number_of_offset_bits_u16));	  				// shift data dwn by number_of_offset_bits		
   \      0x2DA   0x0032             MOVS     R2,R6
   \      0x2DC   0xB2D2             UXTB     R2,R2
   \      0x2DE   0x5C8A             LDRB     R2,[R1, R2]
   \      0x2E0   0x466B             MOV      R3,SP
   \      0x2E2   0x7A1C             LDRB     R4,[R3, #+8]
   \      0x2E4   0x2308             MOVS     R3,#+8
   \      0x2E6   0x466F             MOV      R7,SP
   \      0x2E8   0x89BF             LDRH     R7,[R7, #+12]
   \      0x2EA   0x1BDB             SUBS     R3,R3,R7
   \      0x2EC   0x409C             LSLS     R4,R4,R3
   \      0x2EE   0x4314             ORRS     R4,R4,R2
   \      0x2F0   0x0032             MOVS     R2,R6
   \      0x2F2   0xB2D2             UXTB     R2,R2
   \      0x2F4   0x548C             STRB     R4,[R1, R2]
   \      0x2F6   0xE012             B        ??ProcessMBCoilRegister_New_18
   1536          		  else
   1537          		  	modbus_coil_data[index_u8] |= (((modbus_coil_data[index_u8+1]) & mask_u8) << (8-number_of_offset_bits_u16));	  				// shift data dwn by number_of_offset_bits		
   \                     ??ProcessMBCoilRegister_New_17: (+1)
   \      0x2F8   0x0032             MOVS     R2,R6
   \      0x2FA   0xB2D2             UXTB     R2,R2
   \      0x2FC   0x5C8A             LDRB     R2,[R1, R2]
   \      0x2FE   0x0033             MOVS     R3,R6
   \      0x300   0xB2DB             UXTB     R3,R3
   \      0x302   0x18CB             ADDS     R3,R1,R3
   \      0x304   0x785C             LDRB     R4,[R3, #+1]
   \      0x306   0x466B             MOV      R3,SP
   \      0x308   0x7A1B             LDRB     R3,[R3, #+8]
   \      0x30A   0x4023             ANDS     R3,R3,R4
   \      0x30C   0x2408             MOVS     R4,#+8
   \      0x30E   0x466F             MOV      R7,SP
   \      0x310   0x89BF             LDRH     R7,[R7, #+12]
   \      0x312   0x1BE4             SUBS     R4,R4,R7
   \      0x314   0x40A3             LSLS     R3,R3,R4
   \      0x316   0x4313             ORRS     R3,R3,R2
   \      0x318   0x0032             MOVS     R2,R6
   \      0x31A   0xB2D2             UXTB     R2,R2
   \      0x31C   0x548B             STRB     R3,[R1, R2]
   1538          	  }
   \                     ??ProcessMBCoilRegister_New_18: (+1)
   \      0x31E   0x1C76             ADDS     R6,R6,#+1
   \      0x320   0xE7C4             B        ??ProcessMBCoilRegister_New_15
   1539          	  // pad last byte with proper number of 0's
   1540          	  mask_u8 = 0xFF;
   \                     ??ProcessMBCoilRegister_New_16: (+1)
   \      0x322   0x4669             MOV      R1,SP
   \      0x324   0x7208             STRB     R0,[R1, #+8]
   1541          	  uint8_t number_of_coils_in_result_u8 = number_of_coils_u16 / 8;
   \      0x326   0x2408             MOVS     R4,#+8
   \      0x328   0xA811             ADD      R0,SP,#+68
   \      0x32A   0x8800             LDRH     R0,[R0, #+0]
   \      0x32C   0x0021             MOVS     R1,R4
   \      0x32E   0x....'....        BL       __aeabi_idiv
   \      0x332   0x4669             MOV      R1,SP
   \      0x334   0x7108             STRB     R0,[R1, #+4]
   1542          	  mask_u8 >>= (8-(number_of_coils_u16 % 8));
   \      0x336   0x4668             MOV      R0,SP
   \      0x338   0x7A00             LDRB     R0,[R0, #+8]
   \      0x33A   0x9000             STR      R0,[SP, #+0]
   \      0x33C   0x2708             MOVS     R7,#+8
   \      0x33E   0xA811             ADD      R0,SP,#+68
   \      0x340   0x8800             LDRH     R0,[R0, #+0]
   \      0x342   0x0021             MOVS     R1,R4
   \      0x344   0x....'....        BL       __aeabi_idivmod
   \      0x348   0x1A79             SUBS     R1,R7,R1
   \      0x34A   0x9800             LDR      R0,[SP, #+0]
   \      0x34C   0xB2C0             UXTB     R0,R0
   \      0x34E   0x40C8             LSRS     R0,R0,R1
   \      0x350   0x4669             MOV      R1,SP
   \      0x352   0x7208             STRB     R0,[R1, #+8]
   1543          	  uint8_t old_value_u8 = modbus_coil_data[number_of_coils_in_result_u8];
   \      0x354   0xA80A             ADD      R0,SP,#+40
   \      0x356   0x4669             MOV      R1,SP
   \      0x358   0x7909             LDRB     R1,[R1, #+4]
   \      0x35A   0x5C41             LDRB     R1,[R0, R1]
   1544          	  modbus_coil_data[number_of_coils_in_result_u8] = (old_value_u8 & mask_u8);
   \      0x35C   0x466A             MOV      R2,SP
   \      0x35E   0x7A12             LDRB     R2,[R2, #+8]
   \      0x360   0x400A             ANDS     R2,R2,R1
   \      0x362   0x466B             MOV      R3,SP
   \      0x364   0x791B             LDRB     R3,[R3, #+4]
   \      0x366   0x54C2             STRB     R2,[R0, R3]
   1545          
   1546          	  for(index_u8=0; index_u8<(number_of_bytes_in_block_u8); index_u8++){
   \      0x368   0x2400             MOVS     R4,#+0
   \                     ??ProcessMBCoilRegister_New_19: (+1)
   \      0x36A   0x0022             MOVS     R2,R4
   \      0x36C   0x466B             MOV      R3,SP
   \      0x36E   0x7A5B             LDRB     R3,[R3, #+9]
   \      0x370   0xB2D2             UXTB     R2,R2
   \      0x372   0x429A             CMP      R2,R3
   \      0x374   0xD206             BCS      ??ProcessMBCoilRegister_New_12
   1547          		  *data_buffer_pu8++ = modbus_coil_data[index_u8];	  // shift data dwn by number_of_offset_bytes
   \      0x376   0x0022             MOVS     R2,R4
   \      0x378   0xB2D2             UXTB     R2,R2
   \      0x37A   0x5C82             LDRB     R2,[R0, R2]
   \      0x37C   0x702A             STRB     R2,[R5, #+0]
   \      0x37E   0x1C6D             ADDS     R5,R5,#+1
   1548          	  }	  
   \      0x380   0x1C64             ADDS     R4,R4,#+1
   \      0x382   0xE7F2             B        ??ProcessMBCoilRegister_New_19
   1549              }
   1550              eStatus = MB_NO_ERROR;
   \                     ??ProcessMBCoilRegister_New_12: (+1)
   \      0x384   0x2000             MOVS     R0,#+0
   \      0x386   0x4669             MOV      R1,SP
   \      0x388   0x72C8             STRB     R0,[R1, #+11]
   1551            }
   1552            return eStatus;
   \                     ??ProcessMBCoilRegister_New_0: (+1)
   \      0x38A   0x4668             MOV      R0,SP
   \      0x38C   0x7AC0             LDRB     R0,[R0, #+11]
   \      0x38E   0xB013             ADD      SP,SP,#+76
   \      0x390   0xBDF0             POP      {R4-R7,PC}       ;; return
   1553          }
   1554          

   \                                 In section .text, align 2, keep-with-next
   1555          MBErrorCode ProcessMBDiscreteRegister(uint8_t * data_buffer_pu8, uint16_t starting_address_u16, uint16_t number_of_registers_u16, MBRegisterMode eMode) {
   \                     ProcessMBDiscreteRegister: (+1)
   \        0x0   0xB5FB             PUSH     {R0,R1,R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x0015             MOVS     R5,R2
   1556            MBErrorCode    eStatus = MB_ILLEGAL_ADDRESS;
   \        0x6   0x2601             MOVS     R6,#+1
   1557            ModbusMapBlock *block = find_modbus_block(starting_address_u16, number_of_registers_u16);
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0xB289             UXTH     R1,R1
   \        0xC   0x4668             MOV      R0,SP
   \        0xE   0x8880             LDRH     R0,[R0, #+4]
   \       0x10   0x....'....        BL       find_modbus_block
   \       0x14   0x0001             MOVS     R1,R0
   1558            
   1559            if (block) {
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD03F             BEQ      ??ProcessMBDiscreteRegister_0
   1560              //block_1 =(uint16_t) ( block->start_address_u16);
   1561              //offset_1 = starting_address_u16;
   1562              uint16_t index_u16 = starting_address_u16 - block->start_address_u16;
   \       0x1A   0x4668             MOV      R0,SP
   \       0x1C   0x8880             LDRH     R0,[R0, #+4]
   \       0x1E   0x888A             LDRH     R2,[R1, #+4]
   \       0x20   0x1A80             SUBS     R0,R0,R2
   1563              
   1564              while (number_of_registers_u16 > 0 ) {
   \                     ??ProcessMBDiscreteRegister_1: (+1)
   \       0x22   0x002A             MOVS     R2,R5
   \       0x24   0xB292             UXTH     R2,R2
   \       0x26   0x2A00             CMP      R2,#+0
   \       0x28   0xD035             BEQ      ??ProcessMBDiscreteRegister_2
   1565                if (eMode == MB_WRITE_REGISTER) {
   \       0x2A   0x466A             MOV      R2,SP
   \       0x2C   0x7A12             LDRB     R2,[R2, #+8]
   \       0x2E   0x2A01             CMP      R2,#+1
   \       0x30   0xD11C             BNE      ??ProcessMBDiscreteRegister_3
   1566                  block->start_of_data_pu16[index_u16] = ((uint16_t)*data_buffer_pu8++) << 8;
   \       0x32   0x7822             LDRB     R2,[R4, #+0]
   \       0x34   0x0213             LSLS     R3,R2,#+8
   \       0x36   0x680F             LDR      R7,[R1, #+0]
   \       0x38   0x46BC             MOV      R12,R7
   \       0x3A   0x0007             MOVS     R7,R0
   \       0x3C   0xB2BF             UXTH     R7,R7
   \       0x3E   0x2202             MOVS     R2,#+2
   \       0x40   0x437A             MULS     R2,R7,R2
   \       0x42   0x4667             MOV      R7,R12
   \       0x44   0x52BB             STRH     R3,[R7, R2]
   \       0x46   0x1C62             ADDS     R2,R4,#+1
   1567                  block->start_of_data_pu16[index_u16] |= (uint16_t)*data_buffer_pu8++;
   \       0x48   0x680B             LDR      R3,[R1, #+0]
   \       0x4A   0x0004             MOVS     R4,R0
   \       0x4C   0xB2A4             UXTH     R4,R4
   \       0x4E   0x2702             MOVS     R7,#+2
   \       0x50   0x4367             MULS     R7,R4,R7
   \       0x52   0x5BDF             LDRH     R7,[R3, R7]
   \       0x54   0x7813             LDRB     R3,[R2, #+0]
   \       0x56   0x431F             ORRS     R7,R7,R3
   \       0x58   0x680C             LDR      R4,[R1, #+0]
   \       0x5A   0x46A4             MOV      R12,R4
   \       0x5C   0x0004             MOVS     R4,R0
   \       0x5E   0xB2A4             UXTH     R4,R4
   \       0x60   0x2302             MOVS     R3,#+2
   \       0x62   0x4363             MULS     R3,R4,R3
   \       0x64   0x4664             MOV      R4,R12
   \       0x66   0x52E7             STRH     R7,[R4, R3]
   \       0x68   0x1C54             ADDS     R4,R2,#+1
   \       0x6A   0xE011             B        ??ProcessMBDiscreteRegister_4
   1568                }
   1569                else {
   1570                  *data_buffer_pu8++ = (uint8_t)(block->start_of_data_pu16[index_u16] >> 8);
   \                     ??ProcessMBDiscreteRegister_3: (+1)
   \       0x6C   0x680A             LDR      R2,[R1, #+0]
   \       0x6E   0x0003             MOVS     R3,R0
   \       0x70   0xB29B             UXTH     R3,R3
   \       0x72   0x2702             MOVS     R7,#+2
   \       0x74   0x435F             MULS     R7,R3,R7
   \       0x76   0x5BD2             LDRH     R2,[R2, R7]
   \       0x78   0xB292             UXTH     R2,R2
   \       0x7A   0x0A12             LSRS     R2,R2,#+8
   \       0x7C   0x7022             STRB     R2,[R4, #+0]
   \       0x7E   0x1C62             ADDS     R2,R4,#+1
   1571                  *data_buffer_pu8++ = (uint8_t)(block->start_of_data_pu16[index_u16] & 0xff);
   \       0x80   0x680B             LDR      R3,[R1, #+0]
   \       0x82   0x0004             MOVS     R4,R0
   \       0x84   0xB2A4             UXTH     R4,R4
   \       0x86   0x2702             MOVS     R7,#+2
   \       0x88   0x4367             MULS     R7,R4,R7
   \       0x8A   0x5BDB             LDRH     R3,[R3, R7]
   \       0x8C   0x7013             STRB     R3,[R2, #+0]
   \       0x8E   0x1C54             ADDS     R4,R2,#+1
   1572                }
   1573                ++index_u16;
   \                     ??ProcessMBDiscreteRegister_4: (+1)
   \       0x90   0x1C40             ADDS     R0,R0,#+1
   1574                --number_of_registers_u16;
   \       0x92   0x1E6D             SUBS     R5,R5,#+1
   \       0x94   0xE7C5             B        ??ProcessMBDiscreteRegister_1
   1575              }
   1576              eStatus = MB_NO_ERROR;
   \                     ??ProcessMBDiscreteRegister_2: (+1)
   \       0x96   0x2200             MOVS     R2,#+0
   \       0x98   0x0016             MOVS     R6,R2
   1577            }
   1578            return eStatus;
   \                     ??ProcessMBDiscreteRegister_0: (+1)
   \       0x9A   0x0030             MOVS     R0,R6
   \       0x9C   0xB2C0             UXTB     R0,R0
   \       0x9E   0xBDFE             POP      {R1-R7,PC}       ;; return
   1579          }
   1580          

   \                                 In section .text, align 2, keep-with-next
   1581          MBErrorCode ProcessMBWriteRecords(uint8_t * data_buffer_pu8, uint16_t flash_offset_address_u16, uint16_t number_of_flash_words_u16, uint8_t file_number_u8) {
   \                     ProcessMBWriteRecords: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
   \        0x4   0x0017             MOVS     R7,R2
   \        0x6   0x001E             MOVS     R6,R3
   1582            MBErrorCode    eStatus = MB_ILLEGAL_ADDRESS;
   \        0x8   0x2401             MOVS     R4,#+1
   1583            uint8_t	*to_page_address_pu8;	// data page to perform the reading from
   1584            uint8_t	is_write_successful_u8;
   1585            //uint16_t	flash_page_offset_u16;	// offset to base page address to read the 8-byte block
   1586            //uint8_t 
   1587            //set up flash page address and ffset address based on info in mobus message
   1588            if(file_number_u8 == APP_FLASH_SETTINGS_PAGE) 
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0xB2C0             UXTB     R0,R0
   \        0xE   0x2801             CMP      R0,#+1
   \       0x10   0xD101             BNE      ??ProcessMBWriteRecords_0
   1589          	to_page_address_pu8 = (uint8_t*) (FLASH_USER_START_ADDR); 
   \       0x12   0x....             LDR      R5,??DataTable14  ;; 0x800f000
   \       0x14   0xE008             B        ??ProcessMBWriteRecords_1
   1590            else if(file_number_u8 == APP_FLASH_SETTINGS_MIRROR_PAGE) 
   \                     ??ProcessMBWriteRecords_0: (+1)
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0xB2C0             UXTB     R0,R0
   \       0x1A   0x2802             CMP      R0,#+2
   \       0x1C   0xD101             BNE      ??ProcessMBWriteRecords_2
   1591          	to_page_address_pu8 = (uint8_t*) (MIRROR_FLASH_BLOCK_SETTING_PAGE); 
   \       0x1E   0x....             LDR      R5,??DataTable18  ;; 0x800f800
   \       0x20   0xE002             B        ??ProcessMBWriteRecords_1
   1592            else
   1593          	return eStatus;	// illegal page selected
   \                     ??ProcessMBWriteRecords_2: (+1)
   \       0x22   0x0020             MOVS     R0,R4
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0xE024             B        ??ProcessMBWriteRecords_3
   1594            
   1595            if(flash_offset_address_u16 < PAGE_SIZE) {
   \                     ??ProcessMBWriteRecords_1: (+1)
   \       0x28   0x4668             MOV      R0,SP
   \       0x2A   0x8900             LDRH     R0,[R0, #+8]
   \       0x2C   0x2180             MOVS     R1,#+128
   \       0x2E   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x30   0x4288             CMP      R0,R1
   \       0x32   0xDA1C             BGE      ??ProcessMBWriteRecords_4
   1596          	if ((number_of_flash_words_u16 % 8) != 0)
   \       0x34   0x0038             MOVS     R0,R7
   \       0x36   0xB280             UXTH     R0,R0
   \       0x38   0x2108             MOVS     R1,#+8
   \       0x3A   0x....'....        BL       __aeabi_idivmod
   \       0x3E   0x2900             CMP      R1,#+0
   \       0x40   0xD002             BEQ      ??ProcessMBWriteRecords_5
   1597          	  return eStatus;	// illegal block of data - not a multiple of 64 bits
   \       0x42   0x0020             MOVS     R0,R4
   \       0x44   0xB2C0             UXTB     R0,R0
   \       0x46   0xE014             B        ??ProcessMBWriteRecords_3
   1598          	else {
   1599          		is_write_successful_u8 = flashBlockProgram(0, (uint32_t)to_page_address_pu8, data_buffer_pu8, (2*number_of_flash_words_u16));    //MRM - not sure if this is the correct function to call
   \                     ??ProcessMBWriteRecords_5: (+1)
   \       0x48   0x0038             MOVS     R0,R7
   \       0x4A   0xB280             UXTH     R0,R0
   \       0x4C   0x2302             MOVS     R3,#+2
   \       0x4E   0x4343             MULS     R3,R0,R3
   \       0x50   0x9A01             LDR      R2,[SP, #+4]
   \       0x52   0x0029             MOVS     R1,R5
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x....'....        BL       flashBlockProgram
   \       0x5A   0x0001             MOVS     R1,R0
   1600          		if((is_write_successful_u8))
   \       0x5C   0x0008             MOVS     R0,R1
   \       0x5E   0xB2C0             UXTB     R0,R0
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD001             BEQ      ??ProcessMBWriteRecords_6
   1601          		  eStatus = MB_NO_ERROR;	  		// data is good; consider alternate exception response
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0x0004             MOVS     R4,R0
   1602          	}
   1603            }
   1604            else
   1605          	return eStatus; // illegal offset selected
   1606            return eStatus;
   \                     ??ProcessMBWriteRecords_6: (+1)
   \       0x68   0x0020             MOVS     R0,R4
   \       0x6A   0xB2C0             UXTB     R0,R0
   \       0x6C   0xE001             B        ??ProcessMBWriteRecords_3
   \                     ??ProcessMBWriteRecords_4: (+1)
   \       0x6E   0x0020             MOVS     R0,R4
   \       0x70   0xB2C0             UXTB     R0,R0
   \                     ??ProcessMBWriteRecords_3: (+1)
   \       0x72   0xBDFE             POP      {R1-R7,PC}       ;; return
   1607          }
   1608          

   \                                 In section .text, align 2, keep-with-next
   1609          MBErrorCode ProcessMBReadRecords(uint8_t * data_buffer_pu8, uint16_t offset_address_u16, uint16_t number_of_registers_u16, uint8_t file_number_u8) {
   \                     ProcessMBReadRecords: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   1610            MBErrorCode    eStatus = MB_ILLEGAL_ADDRESS;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x4669             MOV      R1,SP
   \        0xA   0x7008             STRB     R0,[R1, #+0]
   1611            uint64_t	flash_data_u64;				// data block to be read from flash
   1612            uint64_t	byte_mask_u64;				// used to help parse bytes from 64-bit data
   1613            uint8_t	*from_page_address_pu8;		// data page to perform the reading from
   1614            uint16_t	block_index_u16 = 0;		// used to index through the data in the modbus packet
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x8048             STRH     R0,[R1, #+2]
   1615            uint8_t	byte_index_u8 = 0;			// for parsing 64-bit data into 8 bytes in buffer 
   \       0x12   0x2400             MOVS     R4,#+0
   1616          
   1617            //set up flash page address and ffset address based on info in mobus message
   1618            if(file_number_u8 == APP_FLASH_SETTINGS_PAGE) 
   \       0x14   0x4668             MOV      R0,SP
   \       0x16   0x7E00             LDRB     R0,[R0, #+24]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD102             BNE      ??ProcessMBReadRecords_0
   1619          	from_page_address_pu8 = (uint8_t*) (FLASH_USER_START_ADDR); 
   \       0x1C   0x....             LDR      R0,??DataTable14  ;; 0x800f000
   \       0x1E   0x9001             STR      R0,[SP, #+4]
   \       0x20   0xE009             B        ??ProcessMBReadRecords_1
   1620            else if(file_number_u8 == APP_FLASH_SETTINGS_MIRROR_PAGE) 
   \                     ??ProcessMBReadRecords_0: (+1)
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x7E00             LDRB     R0,[R0, #+24]
   \       0x26   0x2802             CMP      R0,#+2
   \       0x28   0xD102             BNE      ??ProcessMBReadRecords_2
   1621          	from_page_address_pu8 = (uint8_t*) (MIRROR_FLASH_BLOCK_SETTING_PAGE); 
   \       0x2A   0x....             LDR      R0,??DataTable18  ;; 0x800f800
   \       0x2C   0x9001             STR      R0,[SP, #+4]
   \       0x2E   0xE002             B        ??ProcessMBReadRecords_1
   1622            else
   1623          	return eStatus;	// illegal page selected
   \                     ??ProcessMBReadRecords_2: (+1)
   \       0x30   0x4668             MOV      R0,SP
   \       0x32   0x7800             LDRB     R0,[R0, #+0]
   \       0x34   0xE04C             B        ??ProcessMBReadRecords_3
   1624            
   1625            if(offset_address_u16 < PAGE_SIZE) {
   \                     ??ProcessMBReadRecords_1: (+1)
   \       0x36   0x4668             MOV      R0,SP
   \       0x38   0x8A00             LDRH     R0,[R0, #+16]
   \       0x3A   0x2180             MOVS     R1,#+128
   \       0x3C   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xDA44             BGE      ??ProcessMBReadRecords_4
   1626          	if ((number_of_registers_u16 % 8) != 0)
   \       0x42   0x4668             MOV      R0,SP
   \       0x44   0x8A80             LDRH     R0,[R0, #+20]
   \       0x46   0x2108             MOVS     R1,#+8
   \       0x48   0x....'....        BL       __aeabi_idivmod
   \       0x4C   0x2900             CMP      R1,#+0
   \       0x4E   0xD002             BEQ      ??ProcessMBReadRecords_5
   1627          	  return eStatus;	// illegal block of data - not a multiple of 64 bits
   \       0x50   0x4668             MOV      R0,SP
   \       0x52   0x7800             LDRB     R0,[R0, #+0]
   \       0x54   0xE03C             B        ??ProcessMBReadRecords_3
   1628          	else {
   1629          	  for(block_index_u16 = 0; block_index_u16 < (2*number_of_registers_u16); block_index_u16+=8) {
   \                     ??ProcessMBReadRecords_5: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x4669             MOV      R1,SP
   \       0x5A   0x8048             STRH     R0,[R1, #+2]
   \                     ??ProcessMBReadRecords_6: (+1)
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x8840             LDRH     R0,[R0, #+2]
   \       0x60   0x4669             MOV      R1,SP
   \       0x62   0x8A89             LDRH     R1,[R1, #+20]
   \       0x64   0x2202             MOVS     R2,#+2
   \       0x66   0x434A             MULS     R2,R1,R2
   \       0x68   0x4290             CMP      R0,R2
   \       0x6A   0xDA2C             BGE      ??ProcessMBReadRecords_7
   1630          		//take data_buffer values - 8 bytes and stuff them into uint64_t variable
   1631          		flash_data_u64 = FlashRead64Bits((uint8_t*) from_page_address_pu8, offset_address_u16 + block_index_u16); //no updated data then just read the old data
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x8A00             LDRH     R0,[R0, #+16]
   \       0x70   0x4669             MOV      R1,SP
   \       0x72   0x8849             LDRH     R1,[R1, #+2]
   \       0x74   0x1841             ADDS     R1,R0,R1
   \       0x76   0xB289             UXTH     R1,R1
   \       0x78   0x9801             LDR      R0,[SP, #+4]
   \       0x7A   0x....'....        BL       FlashRead64Bits
   \       0x7E   0xAA02             ADD      R2,SP,#+8
   \       0x80   0xC203             STM      R2!,{R0,R1}
   \       0x82   0x3A08             SUBS     R2,R2,#+8
   1632          		byte_mask_u64 = (uint64_t) (0xFF00000000000000);		// start with highest byte
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0x21FF             MOVS     R1,#+255
   \       0x88   0x0609             LSLS     R1,R1,#+24       ;; #-16777216
   \       0x8A   0x0006             MOVS     R6,R0
   \       0x8C   0x000F             MOVS     R7,R1
   1633          		for(byte_index_u8=0; byte_index_u8 < 8; byte_index_u8++) {
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0x0004             MOVS     R4,R0
   \                     ??ProcessMBReadRecords_8: (+1)
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0xB2C0             UXTB     R0,R0
   \       0x96   0x2808             CMP      R0,#+8
   \       0x98   0xDA0F             BGE      ??ProcessMBReadRecords_9
   1634          		  *data_buffer_pu8++ = (uint8_t) ( ((flash_data_u64 & byte_mask_u64) >> ((7-byte_index_u8) & (0xFF)) ) );
   \       0x9A   0xA802             ADD      R0,SP,#+8
   \       0x9C   0xC803             LDM      R0,{R0,R1}
   \       0x9E   0x4030             ANDS     R0,R0,R6
   \       0xA0   0x4039             ANDS     R1,R1,R7
   \       0xA2   0x2207             MOVS     R2,#+7
   \       0xA4   0x1B12             SUBS     R2,R2,R4
   \       0xA6   0x....'....        BL       __aeabi_llsr
   \       0xAA   0x7028             STRB     R0,[R5, #+0]
   \       0xAC   0x1C6D             ADDS     R5,R5,#+1
   1635          		  byte_mask_u64 >>= 8;
   \       0xAE   0x0A36             LSRS     R6,R6,#+8
   \       0xB0   0x0638             LSLS     R0,R7,#+24
   \       0xB2   0x4306             ORRS     R6,R6,R0
   \       0xB4   0x0A3F             LSRS     R7,R7,#+8
   1636          		}
   \       0xB6   0x1C64             ADDS     R4,R4,#+1
   \       0xB8   0xE7EB             B        ??ProcessMBReadRecords_8
   1637          	  }
   \                     ??ProcessMBReadRecords_9: (+1)
   \       0xBA   0x4668             MOV      R0,SP
   \       0xBC   0x8840             LDRH     R0,[R0, #+2]
   \       0xBE   0x3008             ADDS     R0,R0,#+8
   \       0xC0   0x4669             MOV      R1,SP
   \       0xC2   0x8048             STRH     R0,[R1, #+2]
   \       0xC4   0xE7CA             B        ??ProcessMBReadRecords_6
   1638          	  eStatus = MB_NO_ERROR;	  // data is good
   \                     ??ProcessMBReadRecords_7: (+1)
   \       0xC6   0x2000             MOVS     R0,#+0
   1639          	}
   1640            }
   1641            else
   1642          	return eStatus; // illegal offset selected
   1643          
   1644            return eStatus;	  
   \       0xC8   0xB2C0             UXTB     R0,R0
   \       0xCA   0xE001             B        ??ProcessMBReadRecords_3
   \                     ??ProcessMBReadRecords_4: (+1)
   \       0xCC   0x4668             MOV      R0,SP
   \       0xCE   0x7800             LDRB     R0,[R0, #+0]
   \                     ??ProcessMBReadRecords_3: (+1)
   \       0xD0   0xB007             ADD      SP,SP,#+28
   \       0xD2   0xBDF0             POP      {R4-R7,PC}       ;; return
   1645          }
   1646          

   \                                 In section .text, align 2, keep-with-next
   1647          MBErrorCode ProcessMBReadEEPROMRecords(uint8_t * data_buffer_pu8, uint16_t offset_address_u16, uint16_t number_of_registers_u16, uint8_t file_number_u8) {
   \                     ProcessMBReadEEPROMRecords: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0005             MOVS     R5,R0
   1648            MBErrorCode    eStatus = MB_ILLEGAL_ADDRESS;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x4669             MOV      R1,SP
   \        0xA   0x7008             STRB     R0,[R1, #+0]
   1649            uint64_t	flash_data_u64;				// data block to be read from flash
   1650            uint64_t	byte_mask_u64;				// used to help parse bytes from 64-bit data
   1651            uint8_t	*from_page_address_pu8;		// data page to perform the reading from
   1652            uint16_t	block_index_u16 = 0;		// used to index through the data in the modbus packet
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x8048             STRH     R0,[R1, #+2]
   1653            uint8_t	byte_index_u8 = 0;			// for parsing 64-bit data into 8 bytes in buffer 
   \       0x12   0x2400             MOVS     R4,#+0
   1654          
   1655            //set up flash page address and ffset address based on info in mobus message
   1656            
   1657            // check if EEPROM file number and addresses are correct for a read from eeprom
   1658            
   1659            if(file_number_u8 == APP_FLASH_SETTINGS_PAGE) 
   \       0x14   0x4668             MOV      R0,SP
   \       0x16   0x7E00             LDRB     R0,[R0, #+24]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD102             BNE      ??ProcessMBReadEEPROMRecords_0
   1660          	from_page_address_pu8 = (uint8_t*) (FLASH_USER_START_ADDR); 
   \       0x1C   0x....             LDR      R0,??DataTable14  ;; 0x800f000
   \       0x1E   0x9001             STR      R0,[SP, #+4]
   \       0x20   0xE009             B        ??ProcessMBReadEEPROMRecords_1
   1661            else if(file_number_u8 == APP_FLASH_SETTINGS_MIRROR_PAGE) 
   \                     ??ProcessMBReadEEPROMRecords_0: (+1)
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x7E00             LDRB     R0,[R0, #+24]
   \       0x26   0x2802             CMP      R0,#+2
   \       0x28   0xD102             BNE      ??ProcessMBReadEEPROMRecords_2
   1662          	from_page_address_pu8 = (uint8_t*) (MIRROR_FLASH_BLOCK_SETTING_PAGE); 
   \       0x2A   0x....             LDR      R0,??DataTable18  ;; 0x800f800
   \       0x2C   0x9001             STR      R0,[SP, #+4]
   \       0x2E   0xE002             B        ??ProcessMBReadEEPROMRecords_1
   1663            else
   1664          	return eStatus;	// illegal page selected
   \                     ??ProcessMBReadEEPROMRecords_2: (+1)
   \       0x30   0x4668             MOV      R0,SP
   \       0x32   0x7800             LDRB     R0,[R0, #+0]
   \       0x34   0xE04C             B        ??ProcessMBReadEEPROMRecords_3
   1665            
   1666            if(offset_address_u16 < PAGE_SIZE) {
   \                     ??ProcessMBReadEEPROMRecords_1: (+1)
   \       0x36   0x4668             MOV      R0,SP
   \       0x38   0x8A00             LDRH     R0,[R0, #+16]
   \       0x3A   0x2180             MOVS     R1,#+128
   \       0x3C   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0x3E   0x4288             CMP      R0,R1
   \       0x40   0xDA44             BGE      ??ProcessMBReadEEPROMRecords_4
   1667          	if ((number_of_registers_u16 % 8) != 0)
   \       0x42   0x4668             MOV      R0,SP
   \       0x44   0x8A80             LDRH     R0,[R0, #+20]
   \       0x46   0x2108             MOVS     R1,#+8
   \       0x48   0x....'....        BL       __aeabi_idivmod
   \       0x4C   0x2900             CMP      R1,#+0
   \       0x4E   0xD002             BEQ      ??ProcessMBReadEEPROMRecords_5
   1668          	  return eStatus;	// illegal block of data - not a multiple of 64 bits
   \       0x50   0x4668             MOV      R0,SP
   \       0x52   0x7800             LDRB     R0,[R0, #+0]
   \       0x54   0xE03C             B        ??ProcessMBReadEEPROMRecords_3
   1669          	else {
   1670          	  for(block_index_u16 = 0; block_index_u16 < (2*number_of_registers_u16); block_index_u16+=8) {
   \                     ??ProcessMBReadEEPROMRecords_5: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0x4669             MOV      R1,SP
   \       0x5A   0x8048             STRH     R0,[R1, #+2]
   \                     ??ProcessMBReadEEPROMRecords_6: (+1)
   \       0x5C   0x4668             MOV      R0,SP
   \       0x5E   0x8840             LDRH     R0,[R0, #+2]
   \       0x60   0x4669             MOV      R1,SP
   \       0x62   0x8A89             LDRH     R1,[R1, #+20]
   \       0x64   0x2202             MOVS     R2,#+2
   \       0x66   0x434A             MULS     R2,R1,R2
   \       0x68   0x4290             CMP      R0,R2
   \       0x6A   0xDA2C             BGE      ??ProcessMBReadEEPROMRecords_7
   1671          		//take data_buffer values - 8 bytes and stuff them into uint64_t variable
   1672          		flash_data_u64 = FlashRead64Bits((uint8_t*) from_page_address_pu8, offset_address_u16 + block_index_u16); //no updated data then just read the old data
   \       0x6C   0x4668             MOV      R0,SP
   \       0x6E   0x8A00             LDRH     R0,[R0, #+16]
   \       0x70   0x4669             MOV      R1,SP
   \       0x72   0x8849             LDRH     R1,[R1, #+2]
   \       0x74   0x1841             ADDS     R1,R0,R1
   \       0x76   0xB289             UXTH     R1,R1
   \       0x78   0x9801             LDR      R0,[SP, #+4]
   \       0x7A   0x....'....        BL       FlashRead64Bits
   \       0x7E   0xAA02             ADD      R2,SP,#+8
   \       0x80   0xC203             STM      R2!,{R0,R1}
   \       0x82   0x3A08             SUBS     R2,R2,#+8
   1673          		byte_mask_u64 = (uint64_t) (0xFF00000000000000);		// start with highest byte
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0x21FF             MOVS     R1,#+255
   \       0x88   0x0609             LSLS     R1,R1,#+24       ;; #-16777216
   \       0x8A   0x0006             MOVS     R6,R0
   \       0x8C   0x000F             MOVS     R7,R1
   1674          		for(byte_index_u8=0; byte_index_u8 < 8; byte_index_u8++) {
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0x0004             MOVS     R4,R0
   \                     ??ProcessMBReadEEPROMRecords_8: (+1)
   \       0x92   0x0020             MOVS     R0,R4
   \       0x94   0xB2C0             UXTB     R0,R0
   \       0x96   0x2808             CMP      R0,#+8
   \       0x98   0xDA0F             BGE      ??ProcessMBReadEEPROMRecords_9
   1675          		  *data_buffer_pu8++ = (uint8_t) ( ((flash_data_u64 & byte_mask_u64) >> ((7-byte_index_u8) & (0xFF)) ) );
   \       0x9A   0xA802             ADD      R0,SP,#+8
   \       0x9C   0xC803             LDM      R0,{R0,R1}
   \       0x9E   0x4030             ANDS     R0,R0,R6
   \       0xA0   0x4039             ANDS     R1,R1,R7
   \       0xA2   0x2207             MOVS     R2,#+7
   \       0xA4   0x1B12             SUBS     R2,R2,R4
   \       0xA6   0x....'....        BL       __aeabi_llsr
   \       0xAA   0x7028             STRB     R0,[R5, #+0]
   \       0xAC   0x1C6D             ADDS     R5,R5,#+1
   1676          		  byte_mask_u64 >>= 8;
   \       0xAE   0x0A36             LSRS     R6,R6,#+8
   \       0xB0   0x0638             LSLS     R0,R7,#+24
   \       0xB2   0x4306             ORRS     R6,R6,R0
   \       0xB4   0x0A3F             LSRS     R7,R7,#+8
   1677          		}
   \       0xB6   0x1C64             ADDS     R4,R4,#+1
   \       0xB8   0xE7EB             B        ??ProcessMBReadEEPROMRecords_8
   1678          	  }
   \                     ??ProcessMBReadEEPROMRecords_9: (+1)
   \       0xBA   0x4668             MOV      R0,SP
   \       0xBC   0x8840             LDRH     R0,[R0, #+2]
   \       0xBE   0x3008             ADDS     R0,R0,#+8
   \       0xC0   0x4669             MOV      R1,SP
   \       0xC2   0x8048             STRH     R0,[R1, #+2]
   \       0xC4   0xE7CA             B        ??ProcessMBReadEEPROMRecords_6
   1679          	  eStatus = MB_NO_ERROR;	  // data is good
   \                     ??ProcessMBReadEEPROMRecords_7: (+1)
   \       0xC6   0x2000             MOVS     R0,#+0
   1680          	}
   1681            }
   1682            else
   1683          	return eStatus; // illegal offset selected
   1684          
   1685            return eStatus;	  
   \       0xC8   0xB2C0             UXTB     R0,R0
   \       0xCA   0xE001             B        ??ProcessMBReadEEPROMRecords_3
   \                     ??ProcessMBReadEEPROMRecords_4: (+1)
   \       0xCC   0x4668             MOV      R0,SP
   \       0xCE   0x7800             LDRB     R0,[R0, #+0]
   \                     ??ProcessMBReadEEPROMRecords_3: (+1)
   \       0xD0   0xB007             ADD      SP,SP,#+28
   \       0xD2   0xBDF0             POP      {R4-R7,PC}       ;; return
   1686          }
   1687          
   1688          
   1689          //
   1690          // Given a modbus start address and number of registers,
   1691          // return the mapping block that contains those values, or 0 (null) if no match 
   1692          //

   \                                 In section .text, align 2, keep-with-next
   1693          ModbusMapBlock* find_modbus_block(uint16_t desired_address_u16, uint16_t number_of_registers_u16) {
   \                     find_modbus_block: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0002             MOVS     R2,R0
   1694            uint16_t block_index_u16;
   1695            for (block_index_u16 = 0; block_index_u16 < number_of_modbus_blocks_u16; ++block_index_u16)
   \        0x4   0x2300             MOVS     R3,#+0
   \                     ??find_modbus_block_0: (+1)
   \        0x6   0x0018             MOVS     R0,R3
   \        0x8   0x....             LDR      R4,??DataTable24
   \        0xA   0x8824             LDRH     R4,[R4, #+0]
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x42A0             CMP      R0,R4
   \       0x10   0xD216             BCS      ??find_modbus_block_1
   1696            {
   1697              ModbusMapBlock *block = masterBlocks[block_index_u16];
   \       0x12   0x....             LDR      R0,??DataTable25
   \       0x14   0x001C             MOVS     R4,R3
   \       0x16   0xB2A4             UXTH     R4,R4
   \       0x18   0x2504             MOVS     R5,#+4
   \       0x1A   0x4365             MULS     R5,R4,R5
   \       0x1C   0x5940             LDR      R0,[R0, R5]
   1698              if ((block->start_address_u16 <= desired_address_u16) && (desired_address_u16 + number_of_registers_u16 <= block->start_address_u16 + block->number_of_registers_u8))
   \       0x1E   0x0014             MOVS     R4,R2
   \       0x20   0x8885             LDRH     R5,[R0, #+4]
   \       0x22   0xB2A4             UXTH     R4,R4
   \       0x24   0x42AC             CMP      R4,R5
   \       0x26   0xD309             BCC      ??find_modbus_block_2
   \       0x28   0x8884             LDRH     R4,[R0, #+4]
   \       0x2A   0x7985             LDRB     R5,[R0, #+6]
   \       0x2C   0x1964             ADDS     R4,R4,R5
   \       0x2E   0x0015             MOVS     R5,R2
   \       0x30   0xB2AD             UXTH     R5,R5
   \       0x32   0x000E             MOVS     R6,R1
   \       0x34   0xB2B6             UXTH     R6,R6
   \       0x36   0x19AD             ADDS     R5,R5,R6
   \       0x38   0x42AC             CMP      R4,R5
   \       0x3A   0xDA02             BGE      ??find_modbus_block_3
   1699                return block;
   1700            }
   \                     ??find_modbus_block_2: (+1)
   \       0x3C   0x1C5B             ADDS     R3,R3,#+1
   \       0x3E   0xE7E2             B        ??find_modbus_block_0
   1701            return 0;
   \                     ??find_modbus_block_1: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \                     ??find_modbus_block_3: (+1)
   \       0x42   0xBD70             POP      {R4-R6,PC}       ;; return
   1702          }
   1703          
   1704          //
   1705          // Given a modbus start coil address and number of coils,
   1706          // return the mapping block that contains those values, or 0 (null) if no match 
   1707          //

   \                                 In section .text, align 2, keep-with-next
   1708          ModbusCoilMapBlock* find_modbus_coil_block(uint16_t desired_coil_address_u16, uint16_t number_of_coils_u16) {
   \                     find_modbus_coil_block: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0002             MOVS     R2,R0
   1709            uint16_t block_index_u16;
   1710            for (block_index_u16 = 0; block_index_u16 < number_of_modbus_coil_blocks_u16; ++block_index_u16)
   \        0x4   0x2300             MOVS     R3,#+0
   \                     ??find_modbus_coil_block_0: (+1)
   \        0x6   0x0018             MOVS     R0,R3
   \        0x8   0x....             LDR      R4,??DataTable25_1
   \        0xA   0x8824             LDRH     R4,[R4, #+0]
   \        0xC   0xB280             UXTH     R0,R0
   \        0xE   0x42A0             CMP      R0,R4
   \       0x10   0xD216             BCS      ??find_modbus_coil_block_1
   1711            {
   1712              ModbusCoilMapBlock *block = masterCoilBlocks[block_index_u16];
   \       0x12   0x....             LDR      R0,??DataTable25_2
   \       0x14   0x001C             MOVS     R4,R3
   \       0x16   0xB2A4             UXTH     R4,R4
   \       0x18   0x2504             MOVS     R5,#+4
   \       0x1A   0x4365             MULS     R5,R4,R5
   \       0x1C   0x5940             LDR      R0,[R0, R5]
   1713              if ((block->start_coil_address_u16 <= desired_coil_address_u16) && (desired_coil_address_u16 + number_of_coils_u16 <= block->start_coil_address_u16 + block->number_of_coils_u8))
   \       0x1E   0x0014             MOVS     R4,R2
   \       0x20   0x8885             LDRH     R5,[R0, #+4]
   \       0x22   0xB2A4             UXTH     R4,R4
   \       0x24   0x42AC             CMP      R4,R5
   \       0x26   0xD309             BCC      ??find_modbus_coil_block_2
   \       0x28   0x8884             LDRH     R4,[R0, #+4]
   \       0x2A   0x79C5             LDRB     R5,[R0, #+7]
   \       0x2C   0x1964             ADDS     R4,R4,R5
   \       0x2E   0x0015             MOVS     R5,R2
   \       0x30   0xB2AD             UXTH     R5,R5
   \       0x32   0x000E             MOVS     R6,R1
   \       0x34   0xB2B6             UXTH     R6,R6
   \       0x36   0x19AD             ADDS     R5,R5,R6
   \       0x38   0x42AC             CMP      R4,R5
   \       0x3A   0xDA02             BGE      ??find_modbus_coil_block_3
   1714                return block;
   1715            }
   \                     ??find_modbus_coil_block_2: (+1)
   \       0x3C   0x1C5B             ADDS     R3,R3,#+1
   \       0x3E   0xE7E2             B        ??find_modbus_coil_block_0
   1716            return 0;
   \                     ??find_modbus_coil_block_1: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \                     ??find_modbus_coil_block_3: (+1)
   \       0x42   0xBD70             POP      {R4-R6,PC}       ;; return
   1717          }
   1718          
   1719          // Compute the MODBUS RTU CRC

   \                                 In section .text, align 2, keep-with-next
   1720          uint16_t calculateModbusCRC(uint8_t *buf_pu8, uint16_t length_u16)
   1721          {
   \                     calculateModbusCRC: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x0002             MOVS     R2,R0
   1722            uint16_t crc_u16 = 0xFFFF;
   \        0x4   0x....             LDR      R0,??DataTable25_3  ;; 0xffff
   1723            
   1724            for (uint16_t pos_u16 = 0; pos_u16 < length_u16; pos_u16++) {
   \        0x6   0x2300             MOVS     R3,#+0
   \                     ??calculateModbusCRC_0: (+1)
   \        0x8   0x001C             MOVS     R4,R3
   \        0xA   0x000D             MOVS     R5,R1
   \        0xC   0xB2A4             UXTH     R4,R4
   \        0xE   0xB2AD             UXTH     R5,R5
   \       0x10   0x42AC             CMP      R4,R5
   \       0x12   0xD216             BCS      ??calculateModbusCRC_1
   1725              crc_u16 ^= (uint16_t)buf_pu8[pos_u16];          // XOR byte into least sig. byte of crc
   \       0x14   0x001C             MOVS     R4,R3
   \       0x16   0xB2A4             UXTH     R4,R4
   \       0x18   0x5D14             LDRB     R4,[R2, R4]
   \       0x1A   0x4060             EORS     R0,R0,R4
   1726              
   1727              for (uint8_t index_u8 = 8; index_u8 != 0; index_u8--) {    // Loop over each bit
   \       0x1C   0x2508             MOVS     R5,#+8
   \                     ??calculateModbusCRC_2: (+1)
   \       0x1E   0x002C             MOVS     R4,R5
   \       0x20   0xB2E4             UXTB     R4,R4
   \       0x22   0x2C00             CMP      R4,#+0
   \       0x24   0xD00B             BEQ      ??calculateModbusCRC_3
   1728                if ((crc_u16 & 0x0001) != 0) {      // If the LSB is set
   \       0x26   0x07C4             LSLS     R4,R0,#+31
   \       0x28   0xD505             BPL      ??calculateModbusCRC_4
   1729                  crc_u16 >>= 1;                    // Shift right and XOR 0xA001
   \       0x2A   0x0004             MOVS     R4,R0
   \       0x2C   0xB2A4             UXTH     R4,R4
   \       0x2E   0x0864             LSRS     R4,R4,#+1
   1730                  crc_u16 ^= 0xA001;
   \       0x30   0x....             LDR      R0,??DataTable25_4  ;; 0xa001
   \       0x32   0x4060             EORS     R0,R0,R4
   \       0x34   0xE001             B        ??calculateModbusCRC_5
   1731                }
   1732                else                            // Else LSB is not set
   1733                  crc_u16 >>= 1;                    // Just shift right
   \                     ??calculateModbusCRC_4: (+1)
   \       0x36   0xB280             UXTH     R0,R0
   \       0x38   0x0840             LSRS     R0,R0,#+1
   1734              }
   \                     ??calculateModbusCRC_5: (+1)
   \       0x3A   0x1E6D             SUBS     R5,R5,#+1
   \       0x3C   0xE7EF             B        ??calculateModbusCRC_2
   1735            }
   \                     ??calculateModbusCRC_3: (+1)
   \       0x3E   0x1C5B             ADDS     R3,R3,#+1
   \       0x40   0xE7E2             B        ??calculateModbusCRC_0
   1736            // Note, this number has low and high bytes swapped, so use it accordingly (or swap bytes)
   1737            return crc_u16;  
   \                     ??calculateModbusCRC_1: (+1)
   \       0x42   0xB280             UXTH     R0,R0
   \       0x44   0xBD30             POP      {R4,R5,PC}       ;; return
   1738          }
   1739          
   1740          // TODO: Move Register Storage to a Universal location to be used by universal protocol, modbus, and bluetooth modules
   1741          //
   1742          

   \                                 In section .text, align 2, keep-with-next
   1743          void Modbus_UpdateStoredStatus(uint8_t status){
   1744            drive_dynamic_control.drive_dynamic_data.state_u16 = status;
   \                     Modbus_UpdateStoredStatus: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x....             LDR      R2,??DataTable25_5
   \        0x6   0x8191             STRH     R1,[R2, #+12]
   1745          }
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1746          void Modbus_UpdateStoredFaults(uint16_t faults){
   1747            drive_dynamic_control.drive_dynamic_data.faults_u16 = faults;  
   \                     Modbus_UpdateStoredFaults: (+1)
   \        0x0   0x....             LDR      R1,??DataTable25_5
   \        0x2   0x81C8             STRH     R0,[R1, #+14]
   1748          }
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1749          void Modbus_UpdateStoredBusVoltage(uint16_t bus_voltage){
   1750            drive_dynamic_control.drive_dynamic_data.bus_voltage_u16 = bus_voltage;
   \                     Modbus_UpdateStoredBusVoltage: (+1)
   \        0x0   0x....             LDR      R1,??DataTable25_5
   \        0x2   0x8288             STRH     R0,[R1, #+20]
   1751          }
   \        0x4   0x4770             BX       LR               ;; return
   1752          //

   \                                 In section .text, align 2, keep-with-next
   1753          void Modbus_UpdateStoredDirection(uint8_t direction){
   1754            drive_dynamic_control.drive_dynamic_data.direction_u16 = direction;
   \                     Modbus_UpdateStoredDirection: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xB2C9             UXTB     R1,R1
   \        0x4   0x....             LDR      R2,??DataTable25_5
   \        0x6   0x8251             STRH     R1,[R2, #+18]
   1755          }
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1756          void Modbus_UpdateStoredMeasuredSpeed(int16_t measured_speed){
   1757            Actual_Measured_Speed=measured_speed;
   \                     Modbus_UpdateStoredMeasuredSpeed: (+1)
   \        0x0   0x....             LDR      R1,??DataTable25_6
   \        0x2   0x8008             STRH     R0,[R1, #+0]
   1758            drive_dynamic_control.drive_dynamic_data.measured_speed_u16 = measured_speed;
   \        0x4   0x....             LDR      R1,??DataTable25_5
   \        0x6   0x82C8             STRH     R0,[R1, #+22]
   1759          }
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1760          void Modbus_UpdateStoredTorque(int16_t torque){
   1761            drive_dynamic_control.drive_dynamic_data.measured_torque_u16 = torque;  
   \                     Modbus_UpdateStoredTorque: (+1)
   \        0x0   0x....             LDR      R1,??DataTable25_5
   \        0x2   0x8308             STRH     R0,[R1, #+24]
   1762          }
   \        0x4   0x4770             BX       LR               ;; return
   1763          //

   \                                 In section .text, align 2, keep-with-next
   1764          void Modbus_UpdateStoredPower(int16_t power){
   1765            drive_dynamic_control.drive_dynamic_data.shaft_power_u16 = power;  
   \                     Modbus_UpdateStoredPower: (+1)
   \        0x0   0x....             LDR      R1,??DataTable25_5
   \        0x2   0x8348             STRH     R0,[R1, #+26]
   1766          }
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1767          void Modbus_UpdateStoredTemperature(int16_t temperature){
   1768            drive_dynamic_control.drive_dynamic_data.ipm_temperature_u16 = temperature;
   \                     Modbus_UpdateStoredTemperature: (+1)
   \        0x0   0x....             LDR      R1,??DataTable25_5
   \        0x2   0x8388             STRH     R0,[R1, #+28]
   1769          }
   \        0x4   0x4770             BX       LR               ;; return
   1770          

   \                                 In section .text, align 2, keep-with-next
   1771          void Modbus_UpdateStoredRegalMCStatus(uint16_t regal_mc_status_data_u16)
   1772          {
   1773            drive_dynamic_control.drive_dynamic_data.regal_mc_state_u16 = regal_mc_status_data_u16;
   \                     Modbus_UpdateStoredRegalMCStatus: (+1)
   \        0x0   0x....             LDR      R1,??DataTable25_5
   \        0x2   0x8208             STRH     R0,[R1, #+16]
   1774          }
   \        0x4   0x4770             BX       LR               ;; return
   1775          

   \                                 In section .text, align 2, keep-with-next
   1776          void Modbus_UpdateStoredPhaseCurrentIa(int16_t current_ia_s16)
   1777          {
   1778            drive_dynamic_control.drive_dynamic_data.phase_current_ia_s16 = current_ia_s16;
   \                     Modbus_UpdateStoredPhaseCurrentIa: (+1)
   \        0x0   0x....             LDR      R1,??DataTable25_5
   \        0x2   0x83C8             STRH     R0,[R1, #+30]
   1779          }
   \        0x4   0x4770             BX       LR               ;; return
   1780          

   \                                 In section .text, align 2, keep-with-next
   1781          void Modbus_UpdateStoredPhaseCurrentIb(int16_t current_ib_s16)
   1782          {
   1783            drive_dynamic_control.drive_dynamic_data.phase_current_ib_s16 = current_ib_s16;  
   \                     Modbus_UpdateStoredPhaseCurrentIb: (+1)
   \        0x0   0x....             LDR      R1,??DataTable25_5
   \        0x2   0x8408             STRH     R0,[R1, #+32]
   1784          }
   \        0x4   0x4770             BX       LR               ;; return
   1785          
   1786          

   \                                 In section .text, align 2, keep-with-next
   1787          void Modbus_PassDriveFlashData(uint8_t *data_address_pu8, uint16_t length_u16) {
   \                     Modbus_PassDriveFlashData: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x0005             MOVS     R5,R0
   1788            	// pass data from UP buffer's data address of length length_u16 to MODBUS usart 
   1789          	uint32_t responseLength_u32 = 0;
   \        0x6   0x2700             MOVS     R7,#+0
   \        0x8   0x9700             STR      R7,[SP, #+0]
   1790          	uint8_t index_u8 = 0;
   \        0xA   0x003C             MOVS     R4,R7
   1791          	uint16_t crc_calculated_u16 = 0;
   \        0xC   0x0038             MOVS     R0,R7
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x80C8             STRH     R0,[R1, #+6]
   1792            
   1793          	// procss if an eception occurred
   1794          	if((last_drive_flash_request.is_exception_u8 == TRUE) || (data_address_pu8 == NULL))
   \       0x12   0x....             LDR      R6,??DataTable25_7
   \       0x14   0x78F0             LDRB     R0,[R6, #+3]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD001             BEQ      ??Modbus_PassDriveFlashData_0
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD12E             BNE      ??Modbus_PassDriveFlashData_1
   1795          	{
   1796          	  responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \                     ??Modbus_PassDriveFlashData_0: (+1)
   \       0x1E   0x2005             MOVS     R0,#+5
   \       0x20   0x9000             STR      R0,[SP, #+0]
   1797          	  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \       0x22   0x9800             LDR      R0,[SP, #+0]
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \       0x2A   0x4669             MOV      R1,SP
   \       0x2C   0x7108             STRB     R0,[R1, #+4]
   1798          	  if (error_occurred) {
   \       0x2E   0x4668             MOV      R0,SP
   \       0x30   0x7900             LDRB     R0,[R0, #+4]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD000             BEQ      .+4
   \       0x36   0xE0D2             B        ??Modbus_PassDriveFlashData_2
   1799          		return;
   1800          	  }
   1801          		// if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
   1802          	  // build header
   1803          	  modbus_ProtocolBufTX[BYTE_0] = last_drive_flash_request.device_address_u8;
   \                     ??Modbus_PassDriveFlashData_3: (+1)
   \       0x38   0x....             LDR      R7,??DataTable25_8
   \       0x3A   0x7830             LDRB     R0,[R6, #+0]
   \       0x3C   0x6839             LDR      R1,[R7, #+0]
   \       0x3E   0x7008             STRB     R0,[R1, #+0]
   1804          	  modbus_ProtocolBufTX[BYTE_1] = last_drive_flash_request.function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \       0x40   0x7870             LDRB     R0,[R6, #+1]
   \       0x42   0x3880             SUBS     R0,R0,#+128
   \       0x44   0x6839             LDR      R1,[R7, #+0]
   \       0x46   0x7048             STRB     R0,[R1, #+1]
   1805          	  modbus_ProtocolBufTX[BYTE_2] = last_drive_flash_request.exception_type_u8;
   \       0x48   0x7930             LDRB     R0,[R6, #+4]
   \       0x4A   0x6839             LDR      R1,[R7, #+0]
   \       0x4C   0x7088             STRB     R0,[R1, #+2]
   1806          	  // build CRC
   1807          	  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \       0x4E   0x9800             LDR      R0,[SP, #+0]
   \       0x50   0x1E81             SUBS     R1,R0,#+2
   \       0x52   0xB289             UXTH     R1,R1
   \       0x54   0x6838             LDR      R0,[R7, #+0]
   \       0x56   0x....'....        BL       calculateModbusCRC
   \       0x5A   0x0006             MOVS     R6,R0
   1808          	  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \       0x5C   0x0030             MOVS     R0,R6
   \       0x5E   0x6839             LDR      R1,[R7, #+0]
   \       0x60   0x70C8             STRB     R0,[R1, #+3]
   1809          	  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \       0x62   0x0030             MOVS     R0,R6
   \       0x64   0xB280             UXTH     R0,R0
   \       0x66   0x0A00             LSRS     R0,R0,#+8
   \       0x68   0x6839             LDR      R1,[R7, #+0]
   \       0x6A   0x7108             STRB     R0,[R1, #+4]
   1810          	  // write to seq Mem structure
   1811          	  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \       0x6C   0x466A             MOV      R2,SP
   \       0x6E   0x6839             LDR      R1,[R7, #+0]
   \       0x70   0x....             LDR      R0,??DataTable26
   \       0x72   0x6800             LDR      R0,[R0, #+0]
   \       0x74   0x6840             LDR      R0,[R0, #+4]
   \       0x76   0x....'....        BL       RingBuf_WriteBlock
   \       0x7A   0xE0B0             B        ??Modbus_PassDriveFlashData_4
   1812          	}
   1813          	else {
   1814          	  if(last_drive_flash_request.function_code_u8 == MODBUS_FUNCTION_CODE_READ_RECORDS) {
   \                     ??Modbus_PassDriveFlashData_1: (+1)
   \       0x7C   0x7870             LDRB     R0,[R6, #+1]
   \       0x7E   0x2814             CMP      R0,#+20
   \       0x80   0xD159             BNE      ??Modbus_PassDriveFlashData_5
   1815          		responseLength_u32 = READ_RECORDS_RESPONSE_HEADER_LENGTH + (2*length_u16)+ CRC_LENGTH;
   \       0x82   0x4668             MOV      R0,SP
   \       0x84   0x8900             LDRH     R0,[R0, #+8]
   \       0x86   0x2102             MOVS     R1,#+2
   \       0x88   0x4341             MULS     R1,R0,R1
   \       0x8A   0x1DC9             ADDS     R1,R1,#+7
   \       0x8C   0x9100             STR      R1,[SP, #+0]
   1816          		uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \       0x8E   0x9800             LDR      R0,[SP, #+0]
   \       0x90   0xB2C0             UXTB     R0,R0
   \       0x92   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \       0x96   0x4669             MOV      R1,SP
   \       0x98   0x7108             STRB     R0,[R1, #+4]
   1817          		if (error_occurred) {
   \       0x9A   0x4668             MOV      R0,SP
   \       0x9C   0x7900             LDRB     R0,[R0, #+4]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD000             BEQ      .+4
   \       0xA2   0xE09C             B        ??Modbus_PassDriveFlashData_2
   1818          		  return;
   1819          		}
   1820          		// build header
   1821          		modbus_ProtocolBufTX[BYTE_0] = last_drive_flash_request.device_address_u8;
   \                     ??Modbus_PassDriveFlashData_6: (+1)
   \       0xA4   0x7830             LDRB     R0,[R6, #+0]
   \       0xA6   0x....             LDR      R1,??DataTable25_8
   \       0xA8   0x6809             LDR      R1,[R1, #+0]
   \       0xAA   0x7008             STRB     R0,[R1, #+0]
   1822          		modbus_ProtocolBufTX[BYTE_1] = last_drive_flash_request.function_code_u8;
   \       0xAC   0x7870             LDRB     R0,[R6, #+1]
   \       0xAE   0x....             LDR      R1,??DataTable25_8
   \       0xB0   0x6809             LDR      R1,[R1, #+0]
   \       0xB2   0x7048             STRB     R0,[R1, #+1]
   1823          		modbus_ProtocolBufTX[BYTE_2] = (2*last_drive_flash_request.length_u8) + 3;	// total byte count for message in bytes
   \       0xB4   0x78B0             LDRB     R0,[R6, #+2]
   \       0xB6   0x2102             MOVS     R1,#+2
   \       0xB8   0x4348             MULS     R0,R1,R0
   \       0xBA   0x1CC0             ADDS     R0,R0,#+3
   \       0xBC   0x....             LDR      R1,??DataTable25_8
   \       0xBE   0x6809             LDR      R1,[R1, #+0]
   \       0xC0   0x7088             STRB     R0,[R1, #+2]
   1824          		modbus_ProtocolBufTX[BYTE_3] = (2*last_drive_flash_request.length_u8) + 1;	// total byte count for data, counts hte number of bytes read/written to flash
   \       0xC2   0x78B0             LDRB     R0,[R6, #+2]
   \       0xC4   0x2102             MOVS     R1,#+2
   \       0xC6   0x4348             MULS     R0,R1,R0
   \       0xC8   0x1C40             ADDS     R0,R0,#+1
   \       0xCA   0x....             LDR      R1,??DataTable25_8
   \       0xCC   0x6809             LDR      R1,[R1, #+0]
   \       0xCE   0x70C8             STRB     R0,[R1, #+3]
   1825          		modbus_ProtocolBufTX[BYTE_4] = MODBUS_REFERENCE_TYPE;	// Always 0x06
   \       0xD0   0x2006             MOVS     R0,#+6
   \       0xD2   0x....             LDR      R1,??DataTable25_8
   \       0xD4   0x6809             LDR      R1,[R1, #+0]
   \       0xD6   0x7108             STRB     R0,[R1, #+4]
   1826          		
   1827          		// fill modbus TX with UP data from EEPROM command
   1828          		for(index_u8 = 0; index_u8 < length_u16; index_u8++)
   \       0xD8   0x003C             MOVS     R4,R7
   \                     ??Modbus_PassDriveFlashData_7: (+1)
   \       0xDA   0x0020             MOVS     R0,R4
   \       0xDC   0xB2C0             UXTB     R0,R0
   \       0xDE   0x4669             MOV      R1,SP
   \       0xE0   0x8909             LDRH     R1,[R1, #+8]
   \       0xE2   0xB280             UXTH     R0,R0
   \       0xE4   0x4288             CMP      R0,R1
   \       0xE6   0xD208             BCS      ??Modbus_PassDriveFlashData_8
   1829          		  modbus_ProtocolBufTX[index_u8] = (*data_address_pu8++);
   \       0xE8   0x7828             LDRB     R0,[R5, #+0]
   \       0xEA   0x....             LDR      R1,??DataTable25_8
   \       0xEC   0x6809             LDR      R1,[R1, #+0]
   \       0xEE   0x0022             MOVS     R2,R4
   \       0xF0   0xB2D2             UXTB     R2,R2
   \       0xF2   0x5488             STRB     R0,[R1, R2]
   \       0xF4   0x1C6D             ADDS     R5,R5,#+1
   \       0xF6   0x1C64             ADDS     R4,R4,#+1
   \       0xF8   0xE7EF             B        ??Modbus_PassDriveFlashData_7
   1830          		
   1831          		// build CRC
   1832          		crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \                     ??Modbus_PassDriveFlashData_8: (+1)
   \       0xFA   0x....             LDR      R7,??DataTable25_8
   \       0xFC   0x9800             LDR      R0,[SP, #+0]
   \       0xFE   0x1E81             SUBS     R1,R0,#+2
   \      0x100   0xB289             UXTH     R1,R1
   \      0x102   0x6838             LDR      R0,[R7, #+0]
   \      0x104   0x....'....        BL       calculateModbusCRC
   \      0x108   0x0006             MOVS     R6,R0
   1833          		modbus_ProtocolBufTX[responseLength_u32 - 2] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x10A   0x0030             MOVS     R0,R6
   \      0x10C   0x6839             LDR      R1,[R7, #+0]
   \      0x10E   0x9A00             LDR      R2,[SP, #+0]
   \      0x110   0x1889             ADDS     R1,R1,R2
   \      0x112   0x1E89             SUBS     R1,R1,#+2
   \      0x114   0x7008             STRB     R0,[R1, #+0]
   1834          		modbus_ProtocolBufTX[responseLength_u32 - 1] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x116   0x0030             MOVS     R0,R6
   \      0x118   0xB280             UXTH     R0,R0
   \      0x11A   0x0A00             LSRS     R0,R0,#+8
   \      0x11C   0x6839             LDR      R1,[R7, #+0]
   \      0x11E   0x9A00             LDR      R2,[SP, #+0]
   \      0x120   0x1889             ADDS     R1,R1,R2
   \      0x122   0x1E49             SUBS     R1,R1,#+1
   \      0x124   0x7008             STRB     R0,[R1, #+0]
   1835          		RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf	
   \      0x126   0x466A             MOV      R2,SP
   \      0x128   0x6839             LDR      R1,[R7, #+0]
   \      0x12A   0x....             LDR      R0,??DataTable26
   \      0x12C   0x6800             LDR      R0,[R0, #+0]
   \      0x12E   0x6840             LDR      R0,[R0, #+4]
   \      0x130   0x....'....        BL       RingBuf_WriteBlock
   \      0x134   0xE053             B        ??Modbus_PassDriveFlashData_4
   1836          		//uint16_t alt_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u16 - 2); // debugging
   1837          	  }
   1838          	  else {
   1839          		responseLength_u32 = WRITE_RECORDS_RESPONSE_HEADER_LENGTH /*+ (2*length_u16) */ + CRC_LENGTH;
   \                     ??Modbus_PassDriveFlashData_5: (+1)
   \      0x136   0x2003             MOVS     R0,#+3
   \      0x138   0x9000             STR      R0,[SP, #+0]
   1840          		uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x13A   0x9800             LDR      R0,[SP, #+0]
   \      0x13C   0xB2C0             UXTB     R0,R0
   \      0x13E   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x142   0x4669             MOV      R1,SP
   \      0x144   0x7108             STRB     R0,[R1, #+4]
   1841          		if (error_occurred) {
   \      0x146   0x4668             MOV      R0,SP
   \      0x148   0x7900             LDRB     R0,[R0, #+4]
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xD147             BNE      ??Modbus_PassDriveFlashData_2
   1842          		  return;
   1843          		}
   1844          		// build header
   1845          		modbus_ProtocolBufTX[BYTE_0] = last_drive_flash_request.device_address_u8;
   \                     ??Modbus_PassDriveFlashData_9: (+1)
   \      0x14E   0x7830             LDRB     R0,[R6, #+0]
   \      0x150   0x....             LDR      R1,??DataTable25_8
   \      0x152   0x6809             LDR      R1,[R1, #+0]
   \      0x154   0x7008             STRB     R0,[R1, #+0]
   1846          		modbus_ProtocolBufTX[BYTE_1] = last_drive_flash_request.function_code_u8;
   \      0x156   0x7870             LDRB     R0,[R6, #+1]
   \      0x158   0x....             LDR      R1,??DataTable25_8
   \      0x15A   0x6809             LDR      R1,[R1, #+0]
   \      0x15C   0x7048             STRB     R0,[R1, #+1]
   1847          		modbus_ProtocolBufTX[BYTE_2] = (2*last_drive_flash_request.length_u8) + 3;	// total byte count for message in bytes
   \      0x15E   0x78B0             LDRB     R0,[R6, #+2]
   \      0x160   0x2102             MOVS     R1,#+2
   \      0x162   0x4348             MULS     R0,R1,R0
   \      0x164   0x1CC0             ADDS     R0,R0,#+3
   \      0x166   0x....             LDR      R1,??DataTable25_8
   \      0x168   0x6809             LDR      R1,[R1, #+0]
   \      0x16A   0x7088             STRB     R0,[R1, #+2]
   1848          		modbus_ProtocolBufTX[BYTE_3] = (2*last_drive_flash_request.length_u8) + 1;	// total byte count for data, counts hte number of bytes read/written to flash
   \      0x16C   0x78B0             LDRB     R0,[R6, #+2]
   \      0x16E   0x2102             MOVS     R1,#+2
   \      0x170   0x4348             MULS     R0,R1,R0
   \      0x172   0x1C40             ADDS     R0,R0,#+1
   \      0x174   0x....             LDR      R1,??DataTable25_8
   \      0x176   0x6809             LDR      R1,[R1, #+0]
   \      0x178   0x70C8             STRB     R0,[R1, #+3]
   1849          		modbus_ProtocolBufTX[BYTE_4] = MODBUS_REFERENCE_TYPE;	// Always 0x06
   \      0x17A   0x2006             MOVS     R0,#+6
   \      0x17C   0x....             LDR      R1,??DataTable25_8
   \      0x17E   0x6809             LDR      R1,[R1, #+0]
   \      0x180   0x7108             STRB     R0,[R1, #+4]
   1850          		
   1851          		// fill modbus TX with UP data from EEPROM command
   1852          		for(index_u8 = 0; index_u8 < length_u16; index_u8++)
   \      0x182   0x003C             MOVS     R4,R7
   \                     ??Modbus_PassDriveFlashData_10: (+1)
   \      0x184   0x0020             MOVS     R0,R4
   \      0x186   0xB2C0             UXTB     R0,R0
   \      0x188   0x4669             MOV      R1,SP
   \      0x18A   0x8909             LDRH     R1,[R1, #+8]
   \      0x18C   0xB280             UXTH     R0,R0
   \      0x18E   0x4288             CMP      R0,R1
   \      0x190   0xD208             BCS      ??Modbus_PassDriveFlashData_11
   1853          		  modbus_ProtocolBufTX[index_u8] = (*data_address_pu8++);
   \      0x192   0x7828             LDRB     R0,[R5, #+0]
   \      0x194   0x....             LDR      R1,??DataTable25_8
   \      0x196   0x6809             LDR      R1,[R1, #+0]
   \      0x198   0x0022             MOVS     R2,R4
   \      0x19A   0xB2D2             UXTB     R2,R2
   \      0x19C   0x5488             STRB     R0,[R1, R2]
   \      0x19E   0x1C6D             ADDS     R5,R5,#+1
   \      0x1A0   0x1C64             ADDS     R4,R4,#+1
   \      0x1A2   0xE7EF             B        ??Modbus_PassDriveFlashData_10
   1854          		
   1855          		// build CRC
   1856          		crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \                     ??Modbus_PassDriveFlashData_11: (+1)
   \      0x1A4   0x....             LDR      R7,??DataTable25_8
   \      0x1A6   0x9800             LDR      R0,[SP, #+0]
   \      0x1A8   0x1E81             SUBS     R1,R0,#+2
   \      0x1AA   0xB289             UXTH     R1,R1
   \      0x1AC   0x6838             LDR      R0,[R7, #+0]
   \      0x1AE   0x....'....        BL       calculateModbusCRC
   \      0x1B2   0x0006             MOVS     R6,R0
   1857          		modbus_ProtocolBufTX[responseLength_u32 - 2] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x1B4   0x0030             MOVS     R0,R6
   \      0x1B6   0x6839             LDR      R1,[R7, #+0]
   \      0x1B8   0x9A00             LDR      R2,[SP, #+0]
   \      0x1BA   0x1889             ADDS     R1,R1,R2
   \      0x1BC   0x1E89             SUBS     R1,R1,#+2
   \      0x1BE   0x7008             STRB     R0,[R1, #+0]
   1858          		modbus_ProtocolBufTX[responseLength_u32 - 1] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x1C0   0x0030             MOVS     R0,R6
   \      0x1C2   0xB280             UXTH     R0,R0
   \      0x1C4   0x0A00             LSRS     R0,R0,#+8
   \      0x1C6   0x6839             LDR      R1,[R7, #+0]
   \      0x1C8   0x9A00             LDR      R2,[SP, #+0]
   \      0x1CA   0x1889             ADDS     R1,R1,R2
   \      0x1CC   0x1E49             SUBS     R1,R1,#+1
   \      0x1CE   0x7008             STRB     R0,[R1, #+0]
   1859          		RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf	
   \      0x1D0   0x466A             MOV      R2,SP
   \      0x1D2   0x6839             LDR      R1,[R7, #+0]
   \      0x1D4   0x....             LDR      R0,??DataTable26
   \      0x1D6   0x6800             LDR      R0,[R0, #+0]
   \      0x1D8   0x6840             LDR      R0,[R0, #+4]
   \      0x1DA   0x....'....        BL       RingBuf_WriteBlock
   1860          		//uint16_t alt_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u16 - 2); // debugging		
   1861          	  }
   1862          	}
   1863          }
   \                     ??Modbus_PassDriveFlashData_4: (+1)
   \                     ??Modbus_PassDriveFlashData_2: (+1)
   \      0x1DE   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   1864          

   \                                 In section .text, align 2, keep-with-next
   1865          void Modbus_PassEEPROMData(uint8_t* data_address_pu8, uint16_t length_u16) {
   \                     Modbus_PassEEPROMData: (+1)
   \        0x0   0xB5F2             PUSH     {R1,R4-R7,LR}
   \        0x2   0xB082             SUB      SP,SP,#+8
   \        0x4   0x0005             MOVS     R5,R0
   1866          	// pass data from UP buffer's data address of length length_u16 to MODBUS usart 
   1867          	uint32_t responseLength_u32 = 0;
   \        0x6   0x2700             MOVS     R7,#+0
   \        0x8   0x9700             STR      R7,[SP, #+0]
   1868          	uint8_t index_u8 = 0;
   \        0xA   0x003C             MOVS     R4,R7
   1869          	uint16_t crc_calculated_u16 = 0;
   \        0xC   0x0038             MOVS     R0,R7
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x80C8             STRH     R0,[R1, #+6]
   1870            
   1871          	// procss if an eception occurred
   1872          	if((last_eeprom_request.is_exception_u8 == TRUE) || (data_address_pu8 == NULL))
   \       0x12   0x....             LDR      R6,??DataTable29
   \       0x14   0x78F0             LDRB     R0,[R6, #+3]
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD001             BEQ      ??Modbus_PassEEPROMData_0
   \       0x1A   0x2D00             CMP      R5,#+0
   \       0x1C   0xD12E             BNE      ??Modbus_PassEEPROMData_1
   1873          	{
   1874          	  responseLength_u32 = EXCEPTION_RESPONSE_LENGTH;
   \                     ??Modbus_PassEEPROMData_0: (+1)
   \       0x1E   0x2005             MOVS     R0,#+5
   \       0x20   0x9000             STR      R0,[SP, #+0]
   1875          	  uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \       0x22   0x9800             LDR      R0,[SP, #+0]
   \       0x24   0xB2C0             UXTB     R0,R0
   \       0x26   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \       0x2A   0x4669             MOV      R1,SP
   \       0x2C   0x7108             STRB     R0,[R1, #+4]
   1876          	  if (error_occurred) {
   \       0x2E   0x4668             MOV      R0,SP
   \       0x30   0x7900             LDRB     R0,[R0, #+4]
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD000             BEQ      .+4
   \       0x36   0xE0D2             B        ??Modbus_PassEEPROMData_2
   1877          		return;
   1878          	  }
   1879          		// if((modbus_ProtocolBufTX = (uint8_t *) realloc(modbus_ProtocolBufTX, responseLength_u32)) == NULL) reallocError++;
   1880          	  // build header
   1881          	  modbus_ProtocolBufTX[BYTE_0] = last_eeprom_request.device_address_u8;
   \                     ??Modbus_PassEEPROMData_3: (+1)
   \       0x38   0x....             LDR      R7,??DataTable29_1
   \       0x3A   0x7830             LDRB     R0,[R6, #+0]
   \       0x3C   0x6839             LDR      R1,[R7, #+0]
   \       0x3E   0x7008             STRB     R0,[R1, #+0]
   1882          	  modbus_ProtocolBufTX[BYTE_1] = last_eeprom_request.function_code_u8 + EXCEPTION_FUNCTION_CODE_OFFSET;
   \       0x40   0x7870             LDRB     R0,[R6, #+1]
   \       0x42   0x3880             SUBS     R0,R0,#+128
   \       0x44   0x6839             LDR      R1,[R7, #+0]
   \       0x46   0x7048             STRB     R0,[R1, #+1]
   1883          	  modbus_ProtocolBufTX[BYTE_2] = last_eeprom_request.exception_type_u8;
   \       0x48   0x7930             LDRB     R0,[R6, #+4]
   \       0x4A   0x6839             LDR      R1,[R7, #+0]
   \       0x4C   0x7088             STRB     R0,[R1, #+2]
   1884          	  // build CRC
   1885          	  crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \       0x4E   0x9800             LDR      R0,[SP, #+0]
   \       0x50   0x1E81             SUBS     R1,R0,#+2
   \       0x52   0xB289             UXTH     R1,R1
   \       0x54   0x6838             LDR      R0,[R7, #+0]
   \       0x56   0x....'....        BL       calculateModbusCRC
   \       0x5A   0x0006             MOVS     R6,R0
   1886          	  modbus_ProtocolBufTX[BYTE_3] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \       0x5C   0x0030             MOVS     R0,R6
   \       0x5E   0x6839             LDR      R1,[R7, #+0]
   \       0x60   0x70C8             STRB     R0,[R1, #+3]
   1887          	  modbus_ProtocolBufTX[BYTE_4] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \       0x62   0x0030             MOVS     R0,R6
   \       0x64   0xB280             UXTH     R0,R0
   \       0x66   0x0A00             LSRS     R0,R0,#+8
   \       0x68   0x6839             LDR      R1,[R7, #+0]
   \       0x6A   0x7108             STRB     R0,[R1, #+4]
   1888          	  // write to seq Mem structure
   1889          	  RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf					
   \       0x6C   0x466A             MOV      R2,SP
   \       0x6E   0x6839             LDR      R1,[R7, #+0]
   \       0x70   0x....             LDR      R0,??DataTable26
   \       0x72   0x6800             LDR      R0,[R0, #+0]
   \       0x74   0x6840             LDR      R0,[R0, #+4]
   \       0x76   0x....'....        BL       RingBuf_WriteBlock
   \       0x7A   0xE0B0             B        ??Modbus_PassEEPROMData_4
   1890          	}
   1891          	else {
   1892          	  if(last_eeprom_request.function_code_u8 == MODBUS_FUNCTION_CODE_READ_RECORDS) {
   \                     ??Modbus_PassEEPROMData_1: (+1)
   \       0x7C   0x7870             LDRB     R0,[R6, #+1]
   \       0x7E   0x2814             CMP      R0,#+20
   \       0x80   0xD159             BNE      ??Modbus_PassEEPROMData_5
   1893          		responseLength_u32 = READ_RECORDS_RESPONSE_HEADER_LENGTH + (2*length_u16)+ CRC_LENGTH;
   \       0x82   0x4668             MOV      R0,SP
   \       0x84   0x8900             LDRH     R0,[R0, #+8]
   \       0x86   0x2102             MOVS     R1,#+2
   \       0x88   0x4341             MULS     R1,R0,R1
   \       0x8A   0x1DC9             ADDS     R1,R1,#+7
   \       0x8C   0x9100             STR      R1,[SP, #+0]
   1894          		uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \       0x8E   0x9800             LDR      R0,[SP, #+0]
   \       0x90   0xB2C0             UXTB     R0,R0
   \       0x92   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \       0x96   0x4669             MOV      R1,SP
   \       0x98   0x7108             STRB     R0,[R1, #+4]
   1895          		if (error_occurred) {
   \       0x9A   0x4668             MOV      R0,SP
   \       0x9C   0x7900             LDRB     R0,[R0, #+4]
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD000             BEQ      .+4
   \       0xA2   0xE09C             B        ??Modbus_PassEEPROMData_2
   1896          		  return;
   1897          		}
   1898          		// build header
   1899          		modbus_ProtocolBufTX[BYTE_0] = last_eeprom_request.device_address_u8;
   \                     ??Modbus_PassEEPROMData_6: (+1)
   \       0xA4   0x7830             LDRB     R0,[R6, #+0]
   \       0xA6   0x....             LDR      R1,??DataTable29_1
   \       0xA8   0x6809             LDR      R1,[R1, #+0]
   \       0xAA   0x7008             STRB     R0,[R1, #+0]
   1900          		modbus_ProtocolBufTX[BYTE_1] = last_eeprom_request.function_code_u8;
   \       0xAC   0x7870             LDRB     R0,[R6, #+1]
   \       0xAE   0x....             LDR      R1,??DataTable29_1
   \       0xB0   0x6809             LDR      R1,[R1, #+0]
   \       0xB2   0x7048             STRB     R0,[R1, #+1]
   1901          		modbus_ProtocolBufTX[BYTE_2] = (2*last_eeprom_request.length_u8) + 3;	// total byte count for message in bytes
   \       0xB4   0x78B0             LDRB     R0,[R6, #+2]
   \       0xB6   0x2102             MOVS     R1,#+2
   \       0xB8   0x4348             MULS     R0,R1,R0
   \       0xBA   0x1CC0             ADDS     R0,R0,#+3
   \       0xBC   0x....             LDR      R1,??DataTable29_1
   \       0xBE   0x6809             LDR      R1,[R1, #+0]
   \       0xC0   0x7088             STRB     R0,[R1, #+2]
   1902          		modbus_ProtocolBufTX[BYTE_3] = (2*last_eeprom_request.length_u8) + 1;	// total byte count for data, counts hte number of bytes read/written to flash
   \       0xC2   0x78B0             LDRB     R0,[R6, #+2]
   \       0xC4   0x2102             MOVS     R1,#+2
   \       0xC6   0x4348             MULS     R0,R1,R0
   \       0xC8   0x1C40             ADDS     R0,R0,#+1
   \       0xCA   0x....             LDR      R1,??DataTable29_1
   \       0xCC   0x6809             LDR      R1,[R1, #+0]
   \       0xCE   0x70C8             STRB     R0,[R1, #+3]
   1903          		modbus_ProtocolBufTX[BYTE_4] = MODBUS_REFERENCE_TYPE;	// Always 0x06
   \       0xD0   0x2006             MOVS     R0,#+6
   \       0xD2   0x....             LDR      R1,??DataTable29_1
   \       0xD4   0x6809             LDR      R1,[R1, #+0]
   \       0xD6   0x7108             STRB     R0,[R1, #+4]
   1904          		
   1905          		// fill modbus TX with UP data from EEPROM command
   1906          		for(index_u8 = 0; index_u8 < length_u16; index_u8++)
   \       0xD8   0x003C             MOVS     R4,R7
   \                     ??Modbus_PassEEPROMData_7: (+1)
   \       0xDA   0x0020             MOVS     R0,R4
   \       0xDC   0xB2C0             UXTB     R0,R0
   \       0xDE   0x4669             MOV      R1,SP
   \       0xE0   0x8909             LDRH     R1,[R1, #+8]
   \       0xE2   0xB280             UXTH     R0,R0
   \       0xE4   0x4288             CMP      R0,R1
   \       0xE6   0xD208             BCS      ??Modbus_PassEEPROMData_8
   1907          		  modbus_ProtocolBufTX[index_u8] = (*data_address_pu8++);
   \       0xE8   0x7828             LDRB     R0,[R5, #+0]
   \       0xEA   0x....             LDR      R1,??DataTable29_1
   \       0xEC   0x6809             LDR      R1,[R1, #+0]
   \       0xEE   0x0022             MOVS     R2,R4
   \       0xF0   0xB2D2             UXTB     R2,R2
   \       0xF2   0x5488             STRB     R0,[R1, R2]
   \       0xF4   0x1C6D             ADDS     R5,R5,#+1
   \       0xF6   0x1C64             ADDS     R4,R4,#+1
   \       0xF8   0xE7EF             B        ??Modbus_PassEEPROMData_7
   1908          		
   1909          		// build CRC
   1910          		crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \                     ??Modbus_PassEEPROMData_8: (+1)
   \       0xFA   0x....             LDR      R7,??DataTable29_1
   \       0xFC   0x9800             LDR      R0,[SP, #+0]
   \       0xFE   0x1E81             SUBS     R1,R0,#+2
   \      0x100   0xB289             UXTH     R1,R1
   \      0x102   0x6838             LDR      R0,[R7, #+0]
   \      0x104   0x....'....        BL       calculateModbusCRC
   \      0x108   0x0006             MOVS     R6,R0
   1911          		modbus_ProtocolBufTX[responseLength_u32 - 2] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x10A   0x0030             MOVS     R0,R6
   \      0x10C   0x6839             LDR      R1,[R7, #+0]
   \      0x10E   0x9A00             LDR      R2,[SP, #+0]
   \      0x110   0x1889             ADDS     R1,R1,R2
   \      0x112   0x1E89             SUBS     R1,R1,#+2
   \      0x114   0x7008             STRB     R0,[R1, #+0]
   1912          		modbus_ProtocolBufTX[responseLength_u32 - 1] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x116   0x0030             MOVS     R0,R6
   \      0x118   0xB280             UXTH     R0,R0
   \      0x11A   0x0A00             LSRS     R0,R0,#+8
   \      0x11C   0x6839             LDR      R1,[R7, #+0]
   \      0x11E   0x9A00             LDR      R2,[SP, #+0]
   \      0x120   0x1889             ADDS     R1,R1,R2
   \      0x122   0x1E49             SUBS     R1,R1,#+1
   \      0x124   0x7008             STRB     R0,[R1, #+0]
   1913          		RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf	
   \      0x126   0x466A             MOV      R2,SP
   \      0x128   0x6839             LDR      R1,[R7, #+0]
   \      0x12A   0x....             LDR      R0,??DataTable26
   \      0x12C   0x6800             LDR      R0,[R0, #+0]
   \      0x12E   0x6840             LDR      R0,[R0, #+4]
   \      0x130   0x....'....        BL       RingBuf_WriteBlock
   \      0x134   0xE053             B        ??Modbus_PassEEPROMData_4
   1914          		//uint16_t alt_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u16 - 2); // debugging
   1915          	  }
   1916          	  else {
   1917          		responseLength_u32 = WRITE_RECORDS_RESPONSE_HEADER_LENGTH /*+ (2*length_u16) */ + CRC_LENGTH;
   \                     ??Modbus_PassEEPROMData_5: (+1)
   \      0x136   0x2003             MOVS     R0,#+3
   \      0x138   0x9000             STR      R0,[SP, #+0]
   1918          		uint8_t error_occurred = Modbus_ReallocateTxBufferForLength(responseLength_u32);
   \      0x13A   0x9800             LDR      R0,[SP, #+0]
   \      0x13C   0xB2C0             UXTB     R0,R0
   \      0x13E   0x....'....        BL       Modbus_ReallocateTxBufferForLength
   \      0x142   0x4669             MOV      R1,SP
   \      0x144   0x7108             STRB     R0,[R1, #+4]
   1919          		if (error_occurred) {
   \      0x146   0x4668             MOV      R0,SP
   \      0x148   0x7900             LDRB     R0,[R0, #+4]
   \      0x14A   0x2800             CMP      R0,#+0
   \      0x14C   0xD147             BNE      ??Modbus_PassEEPROMData_2
   1920          		  return;
   1921          		}
   1922          		// build header
   1923          		modbus_ProtocolBufTX[BYTE_0] = last_eeprom_request.device_address_u8;
   \                     ??Modbus_PassEEPROMData_9: (+1)
   \      0x14E   0x7830             LDRB     R0,[R6, #+0]
   \      0x150   0x....             LDR      R1,??DataTable29_1
   \      0x152   0x6809             LDR      R1,[R1, #+0]
   \      0x154   0x7008             STRB     R0,[R1, #+0]
   1924          		modbus_ProtocolBufTX[BYTE_1] = last_eeprom_request.function_code_u8;
   \      0x156   0x7870             LDRB     R0,[R6, #+1]
   \      0x158   0x....             LDR      R1,??DataTable29_1
   \      0x15A   0x6809             LDR      R1,[R1, #+0]
   \      0x15C   0x7048             STRB     R0,[R1, #+1]
   1925          		modbus_ProtocolBufTX[BYTE_2] = (2*last_eeprom_request.length_u8) + 3;	// total byte count for message in bytes
   \      0x15E   0x78B0             LDRB     R0,[R6, #+2]
   \      0x160   0x2102             MOVS     R1,#+2
   \      0x162   0x4348             MULS     R0,R1,R0
   \      0x164   0x1CC0             ADDS     R0,R0,#+3
   \      0x166   0x....             LDR      R1,??DataTable29_1
   \      0x168   0x6809             LDR      R1,[R1, #+0]
   \      0x16A   0x7088             STRB     R0,[R1, #+2]
   1926          		modbus_ProtocolBufTX[BYTE_3] = (2*last_eeprom_request.length_u8) + 1;	// total byte count for data, counts hte number of bytes read/written to flash
   \      0x16C   0x78B0             LDRB     R0,[R6, #+2]
   \      0x16E   0x2102             MOVS     R1,#+2
   \      0x170   0x4348             MULS     R0,R1,R0
   \      0x172   0x1C40             ADDS     R0,R0,#+1
   \      0x174   0x....             LDR      R1,??DataTable29_1
   \      0x176   0x6809             LDR      R1,[R1, #+0]
   \      0x178   0x70C8             STRB     R0,[R1, #+3]
   1927          		modbus_ProtocolBufTX[BYTE_4] = MODBUS_REFERENCE_TYPE;	// Always 0x06
   \      0x17A   0x2006             MOVS     R0,#+6
   \      0x17C   0x....             LDR      R1,??DataTable29_1
   \      0x17E   0x6809             LDR      R1,[R1, #+0]
   \      0x180   0x7108             STRB     R0,[R1, #+4]
   1928          		
   1929          		// fill modbus TX with UP data from EEPROM command
   1930          		for(index_u8 = 0; index_u8 < length_u16; index_u8++)
   \      0x182   0x003C             MOVS     R4,R7
   \                     ??Modbus_PassEEPROMData_10: (+1)
   \      0x184   0x0020             MOVS     R0,R4
   \      0x186   0xB2C0             UXTB     R0,R0
   \      0x188   0x4669             MOV      R1,SP
   \      0x18A   0x8909             LDRH     R1,[R1, #+8]
   \      0x18C   0xB280             UXTH     R0,R0
   \      0x18E   0x4288             CMP      R0,R1
   \      0x190   0xD208             BCS      ??Modbus_PassEEPROMData_11
   1931          		  modbus_ProtocolBufTX[index_u8] = (*data_address_pu8++);
   \      0x192   0x7828             LDRB     R0,[R5, #+0]
   \      0x194   0x....             LDR      R1,??DataTable29_1
   \      0x196   0x6809             LDR      R1,[R1, #+0]
   \      0x198   0x0022             MOVS     R2,R4
   \      0x19A   0xB2D2             UXTB     R2,R2
   \      0x19C   0x5488             STRB     R0,[R1, R2]
   \      0x19E   0x1C6D             ADDS     R5,R5,#+1
   \      0x1A0   0x1C64             ADDS     R4,R4,#+1
   \      0x1A2   0xE7EF             B        ??Modbus_PassEEPROMData_10
   1932          		
   1933          		// build CRC
   1934          		crc_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u32 - 2);
   \                     ??Modbus_PassEEPROMData_11: (+1)
   \      0x1A4   0x....             LDR      R7,??DataTable29_1
   \      0x1A6   0x9800             LDR      R0,[SP, #+0]
   \      0x1A8   0x1E81             SUBS     R1,R0,#+2
   \      0x1AA   0xB289             UXTH     R1,R1
   \      0x1AC   0x6838             LDR      R0,[R7, #+0]
   \      0x1AE   0x....'....        BL       calculateModbusCRC
   \      0x1B2   0x0006             MOVS     R6,R0
   1935          		modbus_ProtocolBufTX[responseLength_u32 - 2] = (uint8_t) (crc_calculated_u16 >> 0);					// crc LSB
   \      0x1B4   0x0030             MOVS     R0,R6
   \      0x1B6   0x6839             LDR      R1,[R7, #+0]
   \      0x1B8   0x9A00             LDR      R2,[SP, #+0]
   \      0x1BA   0x1889             ADDS     R1,R1,R2
   \      0x1BC   0x1E89             SUBS     R1,R1,#+2
   \      0x1BE   0x7008             STRB     R0,[R1, #+0]
   1936          		modbus_ProtocolBufTX[responseLength_u32 - 1] = (uint8_t) (crc_calculated_u16 >> 8);					// crc MSB
   \      0x1C0   0x0030             MOVS     R0,R6
   \      0x1C2   0xB280             UXTH     R0,R0
   \      0x1C4   0x0A00             LSRS     R0,R0,#+8
   \      0x1C6   0x6839             LDR      R1,[R7, #+0]
   \      0x1C8   0x9A00             LDR      R2,[SP, #+0]
   \      0x1CA   0x1889             ADDS     R1,R1,R2
   \      0x1CC   0x1E49             SUBS     R1,R1,#+1
   \      0x1CE   0x7008             STRB     R0,[R1, #+0]
   1937          		RingBuf_WriteBlock((*usart1Control_Modbus).seqMemTX, modbus_ProtocolBufTX, &responseLength_u32); 	//extract the whole frame into he temporary modbus_ProtocolBuf	
   \      0x1D0   0x466A             MOV      R2,SP
   \      0x1D2   0x6839             LDR      R1,[R7, #+0]
   \      0x1D4   0x....             LDR      R0,??DataTable26
   \      0x1D6   0x6800             LDR      R0,[R0, #+0]
   \      0x1D8   0x6840             LDR      R0,[R0, #+4]
   \      0x1DA   0x....'....        BL       RingBuf_WriteBlock
   1938          		//uint16_t alt_calculated_u16 = calculateModbusCRC(modbus_ProtocolBufTX, responseLength_u16 - 2); // debugging		
   1939          	  }
   1940          	}
   1941          }
   \                     ??Modbus_PassEEPROMData_4: (+1)
   \                     ??Modbus_PassEEPROMData_2: (+1)
   \      0x1DE   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   1942          
   1943          // Bootloader Features (START)
   1944          // TODO: In this section, move to their own file
   1945          #define UTILITY_FUNCTION_ID_JUMP_TO_PARTITION 1 
   1946          #define UTILITY_SECURITY_CODE 99
   1947          #define PARTITION_ID_BOOTLOADER 1

   \                                 In section .text, align 2, keep-with-next
   1948          void Utility_ExecuteOperation(uint8_t function_id, uint8_t function_parameter, uint8_t function_subparameter) {
   \                     Utility_ExecuteOperation: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   \        0x6   0x0016             MOVS     R6,R2
   1949            switch (function_id)
   \        0x8   0x0020             MOVS     R0,R4
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD10A             BNE      ??Utility_ExecuteOperation_0
   1950            {
   1951              case UTILITY_FUNCTION_ID_JUMP_TO_PARTITION:
   1952                { // function_parameter = partition id, function_subparameter = sercurity code
   1953                  if (function_subparameter ==  UTILITY_SECURITY_CODE) { // only execute if security code was entered
   \       0x10   0x0030             MOVS     R0,R6
   \       0x12   0xB2C0             UXTB     R0,R0
   \       0x14   0x2863             CMP      R0,#+99
   \       0x16   0xD105             BNE      ??Utility_ExecuteOperation_1
   1954                    if (function_parameter == PARTITION_ID_BOOTLOADER) {
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x2801             CMP      R0,#+1
   \       0x1E   0xD101             BNE      ??Utility_ExecuteOperation_1
   1955                      Modbus_JumpToBootloader();
   \       0x20   0x....'....        BL       Modbus_JumpToBootloader
   1956                    }
   1957                  }
   1958                  break;
   \                     ??Utility_ExecuteOperation_1: (+1)
   \       0x24   0xE7FF             B        ??Utility_ExecuteOperation_2
   1959                }
   1960              default:
   1961                {
   1962                  break;
   1963                }
   1964          
   1965            }
   1966          }
   \                     ??Utility_ExecuteOperation_0: (+1)
   \                     ??Utility_ExecuteOperation_2: (+1)
   \       0x26   0xBD70             POP      {R4-R6,PC}       ;; return
   1967          

   \                                 In section .text, align 2, keep-with-next
   1968          void Build_UPDrive_Flash_Request(uint16_t data_address_u16, uint8_t length_u8) {
   \                     Build_UPDrive_Flash_Request: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1969          	// Send update speed command to motor control
   1970          	uint8_t requestFlashTx[9];		// UP message 0x80 is length 9
   1971              uint32_t tx_length_u32;
   1972          	
   1973          	requestFlashTx[0] = 0x55;		// standard header from master
   \        0x8   0xA801             ADD      R0,SP,#+4
   \        0xA   0x2155             MOVS     R1,#+85
   \        0xC   0x7001             STRB     R1,[R0, #+0]
   1974          	requestFlashTx[1] = 0x02;		// length of data = 2 because only one address, which is a word
   \        0xE   0x2102             MOVS     R1,#+2
   \       0x10   0x7041             STRB     R1,[R0, #+1]
   1975          	requestFlashTx[2] = 0x79;		// command to read data from drve side flash
   \       0x12   0x2179             MOVS     R1,#+121
   \       0x14   0x7081             STRB     R1,[R0, #+2]
   1976          	requestFlashTx[3] = 0x00;
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x70C1             STRB     R1,[R0, #+3]
   1977          	requestFlashTx[4] = 0x00;
   \       0x1A   0x7101             STRB     R1,[R0, #+4]
   1978          	requestFlashTx[5] = (uint8_t) ((data_address_u16 >> 8) & (0xFF));
   \       0x1C   0x0021             MOVS     R1,R4
   \       0x1E   0xB289             UXTH     R1,R1
   \       0x20   0x0A09             LSRS     R1,R1,#+8
   \       0x22   0x7141             STRB     R1,[R0, #+5]
   1979          	requestFlashTx[6] = (uint8_t) ((data_address_u16 >> 0) & (0xFF));
   \       0x24   0x0021             MOVS     R1,R4
   \       0x26   0x7181             STRB     R1,[R0, #+6]
   1980          	requestFlashTx[7] = 0xCC;
   \       0x28   0x21CC             MOVS     R1,#+204
   \       0x2A   0x71C1             STRB     R1,[R0, #+7]
   1981          	requestFlashTx[8] = 0xCC;
   \       0x2C   0x7201             STRB     R1,[R0, #+8]
   1982          	
   1983          	tx_length_u32 = UP_HEADER_LENGTH + 2;
   \       0x2E   0x2009             MOVS     R0,#+9
   \       0x30   0x9000             STR      R0,[SP, #+0]
   1984          	RingBuf_WriteBlock((*usart2Control_AppLocal).seqMemTX_u32, requestFlashTx, &tx_length_u32);
   \       0x32   0x466A             MOV      R2,SP
   \       0x34   0xA901             ADD      R1,SP,#+4
   \       0x36   0x....             LDR      R0,??DataTable29_2
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x6880             LDR      R0,[R0, #+8]
   \       0x3C   0x....'....        BL       RingBuf_WriteBlock
   1985          }
   \       0x40   0xB005             ADD      SP,SP,#+20
   \       0x42   0xBD30             POP      {R4,R5,PC}       ;; return
   1986          

   \                                 In section .text, align 2, keep-with-next
   1987          void Build_UPEEPROM_Request(uint16_t data_address_u16, uint8_t length_u8) {
   \                     Build_UPEEPROM_Request: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
   1988          	// Send update speed command to motor control
   1989          	uint8_t requestEEPROMTx[9];		// UP message 0x80 is length 9
   1990              uint32_t tx_length_u32;
   1991          	
   1992          	requestEEPROMTx[0] = 0x55;		// standard header from master
   \        0x8   0xA801             ADD      R0,SP,#+4
   \        0xA   0x2155             MOVS     R1,#+85
   \        0xC   0x7001             STRB     R1,[R0, #+0]
   1993          	requestEEPROMTx[1] = 0x02;		// length of data = 2 because only one address, which is a word
   \        0xE   0x2102             MOVS     R1,#+2
   \       0x10   0x7041             STRB     R1,[R0, #+1]
   1994          	requestEEPROMTx[2] = 0x80;		// command to read data from EEPROM
   \       0x12   0x2180             MOVS     R1,#+128
   \       0x14   0x7081             STRB     R1,[R0, #+2]
   1995          	requestEEPROMTx[3] = 0x00;
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x70C1             STRB     R1,[R0, #+3]
   1996          	requestEEPROMTx[4] = 0x00;
   \       0x1A   0x7101             STRB     R1,[R0, #+4]
   1997          	requestEEPROMTx[5] = (uint8_t) ((data_address_u16 >> 8) & (0xFF));
   \       0x1C   0x0021             MOVS     R1,R4
   \       0x1E   0xB289             UXTH     R1,R1
   \       0x20   0x0A09             LSRS     R1,R1,#+8
   \       0x22   0x7141             STRB     R1,[R0, #+5]
   1998          	requestEEPROMTx[6] = (uint8_t) ((data_address_u16 >> 0) & (0xFF));
   \       0x24   0x0021             MOVS     R1,R4
   \       0x26   0x7181             STRB     R1,[R0, #+6]
   1999          	requestEEPROMTx[7] = 0xCC;
   \       0x28   0x21CC             MOVS     R1,#+204
   \       0x2A   0x71C1             STRB     R1,[R0, #+7]
   2000          	requestEEPROMTx[8] = 0xCC;
   \       0x2C   0x7201             STRB     R1,[R0, #+8]
   2001          	
   2002          	tx_length_u32 = UP_HEADER_LENGTH + 2;
   \       0x2E   0x2009             MOVS     R0,#+9
   \       0x30   0x9000             STR      R0,[SP, #+0]
   2003          	RingBuf_WriteBlock((*usart2Control_AppLocal).seqMemTX_u32, requestEEPROMTx, &tx_length_u32);
   \       0x32   0x466A             MOV      R2,SP
   \       0x34   0xA901             ADD      R1,SP,#+4
   \       0x36   0x....             LDR      R0,??DataTable29_2
   \       0x38   0x6800             LDR      R0,[R0, #+0]
   \       0x3A   0x6880             LDR      R0,[R0, #+8]
   \       0x3C   0x....'....        BL       RingBuf_WriteBlock
   2004          }
   \       0x40   0xB005             ADD      SP,SP,#+20
   \       0x42   0xBD30             POP      {R4,R5,PC}       ;; return
   2005          

   \                                 In section .text, align 2, keep-with-next
   2006          void Modbus_WatchDogInitialize(void) { // REVIEW: This is not currently used, as watchdog is initialized in application.
   \                     Modbus_WatchDogInitialize: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   2007              LL_IWDG_Enable(IWDG);
   \        0x2   0x....             LDR      R5,??DataTable29_3  ;; 0x40003000
   \        0x4   0x0028             MOVS     R0,R5
   \        0x6   0x....'....        BL       LL_IWDG_Enable
   2008              LL_IWDG_EnableWriteAccess(IWDG);
   \        0xA   0x0028             MOVS     R0,R5
   \        0xC   0x....'....        BL       LL_IWDG_EnableWriteAccess
   2009              LL_IWDG_SetPrescaler(IWDG, LL_IWDG_PRESCALER_4);
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x0028             MOVS     R0,R5
   \       0x14   0x....'....        BL       LL_IWDG_SetPrescaler
   2010              //LL_IWDG_SetWindow(IWDG, 4095);
   2011              LL_IWDG_SetReloadCounter(IWDG, 4095);
   \       0x18   0x....             LDR      R4,??DataTable29_4  ;; 0xfff
   \       0x1A   0x0021             MOVS     R1,R4
   \       0x1C   0x0028             MOVS     R0,R5
   \       0x1E   0x....'....        BL       LL_IWDG_SetReloadCounter
   2012              while (LL_IWDG_IsReady(IWDG) != 1) {
   \                     ??Modbus_WatchDogInitialize_0: (+1)
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0x....'....        BL       LL_IWDG_IsReady
   \       0x28   0x2801             CMP      R0,#+1
   \       0x2A   0xD1FA             BNE      ??Modbus_WatchDogInitialize_0
   2013              }
   2014          //    LL_IWDG_ReloadCounter(IWDG);
   2015              LL_IWDG_SetWindow(IWDG, 4095);
   \       0x2C   0x0021             MOVS     R1,R4
   \       0x2E   0x0028             MOVS     R0,R5
   \       0x30   0x....'....        BL       LL_IWDG_SetWindow
   2016          }
   \       0x34   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2017          // !errorTemporary: Watchdog Timer (END)

   \                                 In section .text, align 2, keep-with-next
   2018          void Modbus_JumpToBootloader(void) {
   \                     Modbus_JumpToBootloader: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2019              // Reboot via Watchdog Reset: 
   2020          	// - This works, when bootloader starts at address 0x08000000
   2021              Modbus_WatchDogInitialize();
   \        0x2   0x....'....        BL       Modbus_WatchDogInitialize
   2022              while (1) {}
   \                     ??Modbus_JumpToBootloader_0: (+1)
   \        0x6   0xE7FE             B        ??Modbus_JumpToBootloader_0
   2023          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \        0x0   0x0000'CCCC        DC32     0xcccc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \        0x0   0x0000'5555        DC32     0x5555

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \        0x0   0x....'....        DC32     drive_dynamic_control

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \        0x0   0x....'....        DC32     hi_is_harmonic_injection_allowed_hi_u8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \        0x0   0x....'....        DC32     modbusRegisters5000s

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \        0x0   0x....'....        DC32     hi_angle_multiplier_hi_u8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \        0x0   0x....'....        DC32     hi_angle_offset_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \        0x0   0x....'....        DC32     hi_is_phase_inverted_u8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \        0x0   0x....'....        DC32     hi_min_speed_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \        0x0   0x....'....        DC32     hi_max_speed_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \        0x0   0x....'....        DC32     hi_amplitude_s16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \        0x0   0x....'....        DC32     module_digital_inputs_start_of_inputs_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \        0x0   0x....'....        DC32     BlockDigitalInputs_Inputs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \        0x0   0x....'....        DC32     module_digital_inputs_start_of_holdings_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \        0x0   0x....'....        DC32     BlockDigitalInputs_Holdings

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \        0x0   0x....'....        DC32     module_digital_outputs_start_of_discretes_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \        0x0   0x....'....        DC32     module_digital_outputs_start_of_inputs_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \        0x0   0x....'....        DC32     BlockDigitalOutputs_Inputs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \        0x0   0x....'....        DC32     module_digital_outputs_start_of_holdings_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \        0x0   0x....'....        DC32     BlockDigitalOutputs_Holdings

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     modbus_RTU_Control

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x0000'FFFB        DC32     0xfffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x0000'FFF7        DC32     0xfff7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x....'....        DC32     BlockAnalog0TO10V_Inputs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0x....'....        DC32     module_analog_inputs_0TO10_start_of_holdings_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \        0x0   0x....'....        DC32     BlockAnalog0TO10V_Holdings

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \        0x0   0x....'....        DC32     BlockDigitalInputs_Discrete

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \        0x0   0x....'....        DC32     module_digital_inputs_start_of_discretes_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \        0x0   0x....'....        DC32     module_pwm_input_start_of_coils_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \        0x0   0x....'....        DC32     BlockPWMInputs_Coils

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \        0x0   0x....'....        DC32     module_pwm_input_start_of_discretes_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \        0x0   0x....'....        DC32     BlockPWMInputs_Discrete

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \        0x0   0x....'....        DC32     module_pwm_input_start_of_inputs_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \        0x0   0x....'....        DC32     BlockPWMInputs_Inputs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \        0x0   0x....'....        DC32     module_pwm_input_start_of_holdings_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \        0x0   0x....'....        DC32     BlockPWMInputs_Holdings

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \        0x0   0x....'....        DC32     module_modbus_rtu_start_of_coils_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \        0x0   0x....'....        DC32     BlockModbusRTU_Coils

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \        0x0   0x....'....        DC32     module_modbus_rtu_start_of_inputs_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \        0x0   0x....'....        DC32     BlockModbusRTU_Inputs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \        0x0   0x....'....        DC32     module_modbus_rtu_start_of_holdings_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \        0x0   0x....'....        DC32     BlockModbusRTU_Holdings

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_22:
   \        0x0   0x....'....        DC32     module_analog_inputs_4TO20_start_of_coils_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_23:
   \        0x0   0x....'....        DC32     BlockAnalog4TO20_Coils

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_24:
   \        0x0   0x....'....        DC32     module_analog_inputs_4TO20_start_of_discretes_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_25:
   \        0x0   0x....'....        DC32     BlockAnalog4TO20_Discrete

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_26:
   \        0x0   0x....'....        DC32     module_analog_inputs_4TO20_start_of_inputs_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_27:
   \        0x0   0x....'....        DC32     BlockAnalog4TO20_Inputs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_28:
   \        0x0   0x....'....        DC32     module_analog_inputs_4TO20_start_of_holdings_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_29:
   \        0x0   0x....'....        DC32     BlockAnalog4TO20_Holdings

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_30:
   \        0x0   0x....'....        DC32     module_motor_communication_start_of_discretes_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_31:
   \        0x0   0x....'....        DC32     BlockMotorCommunication_Discrete

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_32:
   \        0x0   0x....'....        DC32     module_motor_communication_start_of_inputs_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_33:
   \        0x0   0x....'....        DC32     BlockMotorCommunication_Inputs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_34:
   \        0x0   0x....'....        DC32     module_motor_communication_start_of_holdings_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_35:
   \        0x0   0x....'....        DC32     BlockMotorCommunication_Holdings

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_36:
   \        0x0   0x....'....        DC32     module_demand_multiplexer_start_of_inputs_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_37:
   \        0x0   0x....'....        DC32     BlockDemandMultiplexer_Inputs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_38:
   \        0x0   0x....'....        DC32     module_demand_multiplexer_start_of_holdings_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_39:
   \        0x0   0x....'....        DC32     BlockDemandMultiplexer_Holdings

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_40:
   \        0x0   0x....'....        DC32     module_drive_dynamic_start_of_coils_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_41:
   \        0x0   0x....'....        DC32     BlockDriveDynamic_Coils

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_42:
   \        0x0   0x....'....        DC32     module_drive_dynamic_start_of_discretes_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_43:
   \        0x0   0x....'....        DC32     BlockDriveDynamic_Discretes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_44:
   \        0x0   0x....'....        DC32     module_drive_dynamic_start_of_inputs_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_45:
   \        0x0   0x....'....        DC32     BlockDriveDynamic_Inputs

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_46:
   \        0x0   0x....'....        DC32     module_drive_dynamic_start_of_holdings_pu16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_47:
   \        0x0   0x....'....        DC32     BlockDriveDynamic_Holdings

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_48:
   \        0x0   0x....'....        DC32     last_eeprom_request

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_49:
   \        0x0   0x....'....        DC32     tt_ModbusLinkLostStop

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_50:
   \        0x0   0x....'....        DC32     processInfoTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_51:
   \        0x0   0x....'....        DC32     module_Control_StructMem_u32

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     usart1Control_Modbus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x0000'FFFE        DC32     0xfffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x....'....        DC32     modbus_ProtocolBufTX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \        0x0   0xFFFF'FFFF        DC32     0xFFFFFFFF,0xFFFF

   \              0x0000'FFFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \        0x0   0xFFFF'FFFF        DC32     0xFFFFFFFF,0xFFFFFFFF

   \              0xFFFF'FFFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x0800'F000        DC32     0x800f000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x0800'F800        DC32     0x800f800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \        0x0   0x....'....        DC32     number_of_modbus_blocks_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \        0x0   0x....'....        DC32     masterBlocks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \        0x0   0x....'....        DC32     number_of_modbus_coil_blocks_u16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \        0x0   0x....'....        DC32     masterCoilBlocks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \        0x0   0x0000'FFFF        DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \        0x0   0x0000'A001        DC32     0xa001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \        0x0   0x....'....        DC32     drive_dynamic_control

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_6:
   \        0x0   0x....'....        DC32     Actual_Measured_Speed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_7:
   \        0x0   0x....'....        DC32     last_drive_flash_request

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_8:
   \        0x0   0x....'....        DC32     modbus_ProtocolBufTX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x....'....        DC32     usart1Control_Modbus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \        0x0   0x....'....        DC32     last_eeprom_request

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \        0x0   0x....'....        DC32     modbus_ProtocolBufTX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_2:
   \        0x0   0x....'....        DC32     usart2Control_AppLocal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_3:
   \        0x0   0x4000'3000        DC32     0x40003000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_4:
   \        0x0   0x0000'0FFF        DC32     0xfff
   2024          // Bootloader Features (END)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   AssignModuleMemModbus
        16   -> StructMem_CreateInstance
        16   -> getProcessInfoIndex
        16 __aeabi_uwrite4
      32   Build_UPDrive_Flash_Request
        32   -> RingBuf_WriteBlock
      32   Build_UPEEPROM_Request
        32   -> RingBuf_WriteBlock
       0   LL_IWDG_Enable
       0   LL_IWDG_EnableWriteAccess
       4   LL_IWDG_IsReady
       0   LL_IWDG_SetPrescaler
       0   LL_IWDG_SetReloadCounter
       0   LL_IWDG_SetWindow
       8   Modbus_JumpToBootloader
         8   -> Modbus_WatchDogInitialize
      56   Modbus_ParseReceivedMessages
        56   -> Build_UPDrive_Flash_Request
        56   -> Build_UPEEPROM_Request
        56   -> Modbus_PassDriveFlashData
        56   -> Modbus_PassEEPROMData
        56   -> Modbus_ReallocateRxBufferForLength
        56   -> Modbus_ReallocateTxBufferForLength
        56   -> ProcessMBCoilRegister_New
        56   -> ProcessMBHoldingRegister
        56   -> ProcessMBReadRecords
        56   -> ProcessMBWriteRecords
        56   -> RingBuf_GetUsedNumOfElements
        56   -> RingBuf_ReadBlock
        56   -> RingBuf_WriteBlock
        56   -> UpdateMotorDemandMultiplexer
        56   -> Utility_ExecuteOperation
        56   -> calculateModbusCRC
        56   -> getSysCount
        56 __aeabi_idiv
        56 __aeabi_idivmod
      32   Modbus_PassDriveFlashData
        32   -> Modbus_ReallocateTxBufferForLength
        32   -> RingBuf_WriteBlock
        32   -> calculateModbusCRC
      32   Modbus_PassEEPROMData
        32   -> Modbus_ReallocateTxBufferForLength
        32   -> RingBuf_WriteBlock
        32   -> calculateModbusCRC
       4   Modbus_ReallocateRxBufferForLength
       4   Modbus_ReallocateTxBufferForLength
       0   Modbus_UpdateStoredBusVoltage
       0   Modbus_UpdateStoredDirection
       0   Modbus_UpdateStoredFaults
       0   Modbus_UpdateStoredMeasuredSpeed
       0   Modbus_UpdateStoredPhaseCurrentIa
       0   Modbus_UpdateStoredPhaseCurrentIb
       0   Modbus_UpdateStoredPower
       0   Modbus_UpdateStoredRegalMCStatus
       0   Modbus_UpdateStoredStatus
       0   Modbus_UpdateStoredTemperature
       0   Modbus_UpdateStoredTorque
      16   Modbus_WatchDogInitialize
        16   -> LL_IWDG_Enable
        16   -> LL_IWDG_EnableWriteAccess
        16   -> LL_IWDG_IsReady
        16   -> LL_IWDG_SetPrescaler
        16   -> LL_IWDG_SetReloadCounter
        16   -> LL_IWDG_SetWindow
      96   ProcessMBCoilRegister_New
        96   -> find_modbus_coil_block
        96 __aeabi_idiv
        96 __aeabi_idivmod
        96 __aeabi_llsl
        96 __aeabi_llsr
      32   ProcessMBDiscreteRegister
        32   -> find_modbus_block
      32   ProcessMBHoldingRegister
        32   -> find_modbus_block
      48   ProcessMBReadEEPROMRecords
        48   -> FlashRead64Bits
        48 __aeabi_idivmod
        48 __aeabi_llsr
      48   ProcessMBReadRecords
        48   -> FlashRead64Bits
        48 __aeabi_idivmod
        48 __aeabi_llsr
      32   ProcessMBWriteRecords
        32   -> flashBlockProgram
        32 __aeabi_idivmod
      32   UpdateHarmonicInjectionParameters
        32   -> HarmonicInjection_ModbusUpdate
      32   UpdateMotorDemandMultiplexer
        32   -> MotorDemandMux_ModbusUpdate
      16   Utility_ExecuteOperation
        16   -> Modbus_JumpToBootloader
      12   calculateModbusCRC
      16   find_modbus_block
      16   find_modbus_coil_block
      48   moduleModbus
        48   -> Modbus_ParseReceivedMessages
        48   -> MotorDemandMux_ModbusUpdate
        48   -> getProcessInfoIndex
        48   -> getSysCount
        48 __aeabi_uread4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable18
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable25_8
       4  ??DataTable26
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_2
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_22
       4  ??DataTable5_23
       4  ??DataTable5_24
       4  ??DataTable5_25
       4  ??DataTable5_26
       4  ??DataTable5_27
       4  ??DataTable5_28
       4  ??DataTable5_29
       4  ??DataTable5_3
       4  ??DataTable5_30
       4  ??DataTable5_31
       4  ??DataTable5_32
       4  ??DataTable5_33
       4  ??DataTable5_34
       4  ??DataTable5_35
       4  ??DataTable5_36
       4  ??DataTable5_37
       4  ??DataTable5_38
       4  ??DataTable5_39
       4  ??DataTable5_4
       4  ??DataTable5_40
       4  ??DataTable5_41
       4  ??DataTable5_42
       4  ??DataTable5_43
       4  ??DataTable5_44
       4  ??DataTable5_45
       4  ??DataTable5_46
       4  ??DataTable5_47
       4  ??DataTable5_48
       4  ??DataTable5_49
       4  ??DataTable5_5
       4  ??DataTable5_50
       4  ??DataTable5_51
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       8  ??DataTable7
       8  ??DataTable7_1
      60  AssignModuleMemModbus
       8  BlockAnalog0TO10V_Coils
       8  BlockAnalog0TO10V_Discrete
       8  BlockAnalog0TO10V_Holdings
       8  BlockAnalog0TO10V_Inputs
       8  BlockAnalog4TO20_Coils
       8  BlockAnalog4TO20_Discrete
       8  BlockAnalog4TO20_Holdings
       8  BlockAnalog4TO20_Inputs
       8  BlockDemandMultiplexer_Holdings
       8  BlockDemandMultiplexer_Inputs
       8  BlockDigitalInputs_Discrete
       8  BlockDigitalInputs_Holdings
       8  BlockDigitalInputs_Inputs
       8  BlockDigitalOutputs_Discrete
       8  BlockDigitalOutputs_Holdings
       8  BlockDigitalOutputs_Inputs
       8  BlockDriveDynamic_Coils
       8  BlockDriveDynamic_Discretes
       8  BlockDriveDynamic_Holdings
       8  BlockDriveDynamic_Inputs
       8  BlockHarmonic
       8  BlockModbusRTU_Coils
       8  BlockModbusRTU_Holdings
       8  BlockModbusRTU_Inputs
       8  BlockMotorCommunication_Discrete
       8  BlockMotorCommunication_Holdings
       8  BlockMotorCommunication_Inputs
       8  BlockPWMInputs_Coils
       8  BlockPWMInputs_Discrete
       8  BlockPWMInputs_Holdings
       8  BlockPWMInputs_Inputs
      68  Build_UPDrive_Flash_Request
      68  Build_UPEEPROM_Request
       6  LL_IWDG_Enable
       6  LL_IWDG_EnableWriteAccess
      20  LL_IWDG_IsReady
       8  LL_IWDG_SetPrescaler
       8  LL_IWDG_SetReloadCounter
       8  LL_IWDG_SetWindow
       8  Modbus_JumpToBootloader
   3'660  Modbus_ParseReceivedMessages
     480  Modbus_PassDriveFlashData
     480  Modbus_PassEEPROMData
      20  Modbus_ReallocateRxBufferForLength
      20  Modbus_ReallocateTxBufferForLength
       6  Modbus_UpdateStoredBusVoltage
      10  Modbus_UpdateStoredDirection
       6  Modbus_UpdateStoredFaults
      10  Modbus_UpdateStoredMeasuredSpeed
       6  Modbus_UpdateStoredPhaseCurrentIa
       6  Modbus_UpdateStoredPhaseCurrentIb
       6  Modbus_UpdateStoredPower
       6  Modbus_UpdateStoredRegalMCStatus
      10  Modbus_UpdateStoredStatus
       6  Modbus_UpdateStoredTemperature
       6  Modbus_UpdateStoredTorque
      54  Modbus_WatchDogInitialize
     914  ProcessMBCoilRegister_New
     160  ProcessMBDiscreteRegister
     160  ProcessMBHoldingRegister
     212  ProcessMBReadEEPROMRecords
     212  ProcessMBReadRecords
     116  ProcessMBWriteRecords
     192  UpdateHarmonicInjectionParameters
      46  UpdateMotorDemandMultiplexer
      40  Utility_ExecuteOperation
      12  application_id_control
      70  calculateModbusCRC
      36  drive_dynamic_control
      68  find_modbus_block
      68  find_modbus_coil_block
      80  fixedModbus_ProtocolBufRX
       1  fixedModbus_ProtocolBufRX_Length
      80  fixedModbus_ProtocolBufTX
       1  fixedModbus_ProtocolBufTX_Length
      16  hi_amplitude_s16
       8  hi_angle_multiplier_hi_u8
      16  hi_angle_offset_u16
       1  hi_is_harmonic_injection_allowed_hi_u8
       8  hi_is_phase_inverted_u8
      16  hi_max_speed_u16
      16  hi_min_speed_u16
       8  last_drive_flash_request
       8  last_eeprom_request
      72  masterBlocks
      48  masterCoilBlocks
       2  modbusRegisters5000s
       4  modbus_ProtocolBufRX
       4  modbus_ProtocolBufTX
      16  modbus_RTU_Control
      16  modbus_RTU_control
       1  modbus_message_counter_u8
     612  moduleModbus
       4  module_Control_StructMem_u32
       4  module_analog_inputs_0TO10_start_of_coils_pu16
       4  module_analog_inputs_0TO10_start_of_discretes_pu16
       4  module_analog_inputs_0TO10_start_of_holdings_pu16
       4  module_analog_inputs_0TO10_start_of_inputs_pu16
       4  module_analog_inputs_4TO20_start_of_coils_pu16
       4  module_analog_inputs_4TO20_start_of_discretes_pu16
       4  module_analog_inputs_4TO20_start_of_holdings_pu16
       4  module_analog_inputs_4TO20_start_of_inputs_pu16
       4  module_application_id_start_of_coils_pu16
       4  module_application_id_start_of_discretes_pu16
       4  module_application_id_start_of_holdings_pu16
       4  module_application_id_start_of_inputs_pu16
       4  module_demand_multiplexer_start_of_coils_pu16
       4  module_demand_multiplexer_start_of_discretes_pu16
       4  module_demand_multiplexer_start_of_holdings_pu16
       4  module_demand_multiplexer_start_of_inputs_pu16
       4  module_digital_inputs_start_of_coils_pu16
       4  module_digital_inputs_start_of_discretes_pu16
       4  module_digital_inputs_start_of_holdings_pu16
       4  module_digital_inputs_start_of_inputs_pu16
       4  module_digital_outputs_start_of_coils_pu16
       4  module_digital_outputs_start_of_discretes_pu16
       4  module_digital_outputs_start_of_holdings_pu16
       4  module_digital_outputs_start_of_inputs_pu16
       4  module_drive_dynamic_start_of_coils_pu16
       4  module_drive_dynamic_start_of_discretes_pu16
       4  module_drive_dynamic_start_of_holdings_pu16
       4  module_drive_dynamic_start_of_inputs_pu16
       4  module_drive_start_of_coils_pu16
       4  module_drive_start_of_discretes_pu16
       4  module_drive_start_of_holdings_pu16
       4  module_drive_start_of_inputs_pu16
       4  module_modbus_rtu_start_of_coils_pu16
       4  module_modbus_rtu_start_of_discretes_pu16
       4  module_modbus_rtu_start_of_holdings_pu16
       4  module_modbus_rtu_start_of_inputs_pu16
       4  module_motor_communication_start_of_coils_pu16
       4  module_motor_communication_start_of_discretes_pu16
       4  module_motor_communication_start_of_holdings_pu16
       4  module_motor_communication_start_of_inputs_pu16
       4  module_pwm_input_start_of_coils_pu16
       4  module_pwm_input_start_of_discretes_pu16
       4  module_pwm_input_start_of_holdings_pu16
       4  module_pwm_input_start_of_inputs_pu16
       4  module_start_of_coils_pu16
       4  module_start_of_discretes_pu16
       4  module_start_of_holdings_pu16
       4  module_start_of_inputs_pu16
       4  module_test_start_of_coils_pu16
       4  module_test_start_of_discretes_pu16
       4  module_test_start_of_holdings_pu16
       4  module_test_start_of_inputs_pu16
       2  number_of_modbus_blocks_u16
       2  number_of_modbus_coil_blocks_u16
       8  tt_ModbusLinkLostStop
       4  usart1Control_Modbus
       2  void_drive_start_of_coils_pu16
       2  void_drive_start_of_discretes_pu16
       2  void_drive_start_of_holdings_pu16
       2  void_drive_start_of_inputs_pu16
       2  void_start_of_coils_pu16
       2  void_start_of_discretes_pu16
       2  void_start_of_holdings_pu16
       2  void_start_of_inputs_pu16

 
   406 bytes in section .bss
   556 bytes in section .data
 8'310 bytes in section .text
 
 8'310 bytes of CODE memory
   962 bytes of DATA memory

Errors: none
Warnings: 4

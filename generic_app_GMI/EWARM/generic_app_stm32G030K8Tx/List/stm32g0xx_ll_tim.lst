###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         04/Feb/2022  12:58:59
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_ll_tim.c
#    Command line      =
#        -f C:\Users\610126~1\AppData\Local\Temp\EW135F.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_ll_tim.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\stm32g0xx_ll_tim.lst
#    Object file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\stm32g0xx_ll_tim.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_ll_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32g0xx_ll_tim.c
      4            * @author  MCD Application Team
      5            * @brief   TIM LL module driver.
      6            ******************************************************************************
      7            * @attention
      8            *
      9            * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics.
     10            * All rights reserved.</center></h2>
     11            *
     12            * This software component is licensed by ST under BSD 3-Clause license,
     13            * the "License"; You may not use this file except in compliance with the
     14            * License. You may obtain a copy of the License at:
     15            *                        opensource.org/licenses/BSD-3-Clause
     16            *
     17            ******************************************************************************
     18            */
     19          #if defined(USE_FULL_LL_DRIVER)
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32g0xx_ll_tim.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_TIM_SetPrescaler(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_SetPrescaler: (+1)
   \        0x0   0x6281             STR      R1,[R0, #+40]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_TIM_SetAutoReload(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_SetAutoReload: (+1)
   \        0x0   0x62C1             STR      R1,[R0, #+44]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_TIM_SetRepetitionCounter(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_SetRepetitionCounter: (+1)
   \        0x0   0x6301             STR      R1,[R0, #+48]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_TIM_OC_SetCompareCH1(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_OC_SetCompareCH1: (+1)
   \        0x0   0x6341             STR      R1,[R0, #+52]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_OC_SetCompareCH2: (+1)
   \        0x0   0x6381             STR      R1,[R0, #+56]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_TIM_OC_SetCompareCH3(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_OC_SetCompareCH3: (+1)
   \        0x0   0x63C1             STR      R1,[R0, #+60]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_TIM_OC_SetCompareCH4(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_OC_SetCompareCH4: (+1)
   \        0x0   0x6401             STR      R1,[R0, #+64]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_TIM_OC_SetCompareCH5(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_OC_SetCompareCH5: (+1)
   \        0x0   0x6D82             LDR      R2,[R0, #+88]
   \        0x2   0x6581             STR      R1,[R0, #+88]
   \        0x4   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_TIM_OC_SetCompareCH6(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_OC_SetCompareCH6: (+1)
   \        0x0   0x65C1             STR      R1,[R0, #+92]
   \        0x2   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_TIM_SetEncoderMode(TIM_TypeDef *, uint32_t)
   \                     LL_TIM_SetEncoderMode: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   \        0x2   0x....             LDR      R3,??DataTable8  ;; 0xfffefff8
   \        0x4   0x4013             ANDS     R3,R3,R2
   \        0x6   0x430B             ORRS     R3,R3,R1
   \        0x8   0x6083             STR      R3,[R0, #+8]
   \        0xA   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *)
   \                     LL_TIM_GenerateEvent_UPDATE: (+1)
   \        0x0   0x6941             LDR      R1,[R0, #+20]
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x430A             ORRS     R2,R2,R1
   \        0x6   0x6142             STR      R2,[R0, #+20]
   \        0x8   0x4770             BX       LR               ;; return
     23          #include "stm32g0xx_ll_bus.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_APB1_GRP1_ForceReset(uint32_t)
   \                     LL_APB1_GRP1_ForceReset: (+1)
   \        0x0   0x....             LDR      R1,??DataTable8_1  ;; 0x4002102c
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x4302             ORRS     R2,R2,R0
   \        0x6   0x600A             STR      R2,[R1, #+0]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_APB1_GRP1_ReleaseReset(uint32_t)
   \                     LL_APB1_GRP1_ReleaseReset: (+1)
   \        0x0   0x....             LDR      R1,??DataTable8_1  ;; 0x4002102c
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x4382             BICS     R2,R2,R0
   \        0x6   0x600A             STR      R2,[R1, #+0]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_APB2_GRP1_ForceReset(uint32_t)
   \                     LL_APB2_GRP1_ForceReset: (+1)
   \        0x0   0x....             LDR      R1,??DataTable8_2  ;; 0x40021030
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x4302             ORRS     R2,R2,R0
   \        0x6   0x600A             STR      R2,[R1, #+0]
   \        0x8   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void LL_APB2_GRP1_ReleaseReset(uint32_t)
   \                     LL_APB2_GRP1_ReleaseReset: (+1)
   \        0x0   0x....             LDR      R1,??DataTable8_2  ;; 0x40021030
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x4382             BICS     R2,R2,R0
   \        0x6   0x600A             STR      R2,[R1, #+0]
   \        0x8   0x4770             BX       LR               ;; return
     24          
     25          #ifdef  USE_FULL_ASSERT
     26          #include "stm32_assert.h"
     27          #else
     28          #define assert_param(expr) ((void)0U)
     29          #endif /* USE_FULL_ASSERT */
     30          
     31          /** @addtogroup STM32G0xx_LL_Driver
     32            * @{
     33            */
     34          
     35          #if defined (TIM1) || defined (TIM2) || defined (TIM3) ||  defined (TIM14) ||  defined (TIM15) || defined (TIM16) || defined (TIM17) || defined (TIM6) || defined (TIM7)
     36          
     37          /** @addtogroup TIM_LL
     38            * @{
     39            */
     40          
     41          /* Private types -------------------------------------------------------------*/
     42          /* Private variables ---------------------------------------------------------*/
     43          /* Private constants ---------------------------------------------------------*/
     44          /* Private macros ------------------------------------------------------------*/
     45          /** @addtogroup TIM_LL_Private_Macros
     46            * @{
     47            */
     48          #define IS_LL_TIM_COUNTERMODE(__VALUE__) (((__VALUE__) == LL_TIM_COUNTERMODE_UP) \
     49                                                    || ((__VALUE__) == LL_TIM_COUNTERMODE_DOWN) \
     50                                                    || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_UP) \
     51                                                    || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_DOWN) \
     52                                                    || ((__VALUE__) == LL_TIM_COUNTERMODE_CENTER_UP_DOWN))
     53          
     54          #define IS_LL_TIM_CLOCKDIVISION(__VALUE__) (((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV1) \
     55                                                      || ((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV2) \
     56                                                      || ((__VALUE__) == LL_TIM_CLOCKDIVISION_DIV4))
     57          
     58          #define IS_LL_TIM_OCMODE(__VALUE__) (((__VALUE__) == LL_TIM_OCMODE_FROZEN) \
     59                                               || ((__VALUE__) == LL_TIM_OCMODE_ACTIVE) \
     60                                               || ((__VALUE__) == LL_TIM_OCMODE_INACTIVE) \
     61                                               || ((__VALUE__) == LL_TIM_OCMODE_TOGGLE) \
     62                                               || ((__VALUE__) == LL_TIM_OCMODE_FORCED_INACTIVE) \
     63                                               || ((__VALUE__) == LL_TIM_OCMODE_FORCED_ACTIVE) \
     64                                               || ((__VALUE__) == LL_TIM_OCMODE_PWM1) \
     65                                               || ((__VALUE__) == LL_TIM_OCMODE_PWM2) \
     66                                               || ((__VALUE__) == LL_TIM_OCMODE_RETRIG_OPM1) \
     67                                               || ((__VALUE__) == LL_TIM_OCMODE_RETRIG_OPM2) \
     68                                               || ((__VALUE__) == LL_TIM_OCMODE_COMBINED_PWM1) \
     69                                               || ((__VALUE__) == LL_TIM_OCMODE_COMBINED_PWM2) \
     70                                               || ((__VALUE__) == LL_TIM_OCMODE_ASSYMETRIC_PWM1) \
     71                                               || ((__VALUE__) == LL_TIM_OCMODE_ASSYMETRIC_PWM2))
     72          
     73          #define IS_LL_TIM_OCSTATE(__VALUE__) (((__VALUE__) == LL_TIM_OCSTATE_DISABLE) \
     74                                                || ((__VALUE__) == LL_TIM_OCSTATE_ENABLE))
     75          
     76          #define IS_LL_TIM_OCPOLARITY(__VALUE__) (((__VALUE__) == LL_TIM_OCPOLARITY_HIGH) \
     77                                                   || ((__VALUE__) == LL_TIM_OCPOLARITY_LOW))
     78          
     79          #define IS_LL_TIM_OCIDLESTATE(__VALUE__) (((__VALUE__) == LL_TIM_OCIDLESTATE_LOW) \
     80                                                    || ((__VALUE__) == LL_TIM_OCIDLESTATE_HIGH))
     81          
     82          #define IS_LL_TIM_ACTIVEINPUT(__VALUE__) (((__VALUE__) == LL_TIM_ACTIVEINPUT_DIRECTTI) \
     83                                                    || ((__VALUE__) == LL_TIM_ACTIVEINPUT_INDIRECTTI) \
     84                                                    || ((__VALUE__) == LL_TIM_ACTIVEINPUT_TRC))
     85          
     86          #define IS_LL_TIM_ICPSC(__VALUE__) (((__VALUE__) == LL_TIM_ICPSC_DIV1) \
     87                                              || ((__VALUE__) == LL_TIM_ICPSC_DIV2) \
     88                                              || ((__VALUE__) == LL_TIM_ICPSC_DIV4) \
     89                                              || ((__VALUE__) == LL_TIM_ICPSC_DIV8))
     90          
     91          #define IS_LL_TIM_IC_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_IC_FILTER_FDIV1) \
     92                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N2) \
     93                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N4) \
     94                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV1_N8) \
     95                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV2_N6) \
     96                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV2_N8) \
     97                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV4_N6) \
     98                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV4_N8) \
     99                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV8_N6) \
    100                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV8_N8) \
    101                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N5) \
    102                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N6) \
    103                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV16_N8) \
    104                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N5) \
    105                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N6) \
    106                                                  || ((__VALUE__) == LL_TIM_IC_FILTER_FDIV32_N8))
    107          
    108          #define IS_LL_TIM_IC_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_IC_POLARITY_RISING) \
    109                                                    || ((__VALUE__) == LL_TIM_IC_POLARITY_FALLING) \
    110                                                    || ((__VALUE__) == LL_TIM_IC_POLARITY_BOTHEDGE))
    111          
    112          #define IS_LL_TIM_ENCODERMODE(__VALUE__) (((__VALUE__) == LL_TIM_ENCODERMODE_X2_TI1) \
    113                                                    || ((__VALUE__) == LL_TIM_ENCODERMODE_X2_TI2) \
    114                                                    || ((__VALUE__) == LL_TIM_ENCODERMODE_X4_TI12))
    115          
    116          #define IS_LL_TIM_IC_POLARITY_ENCODER(__VALUE__) (((__VALUE__) == LL_TIM_IC_POLARITY_RISING) \
    117                                                            || ((__VALUE__) == LL_TIM_IC_POLARITY_FALLING))
    118          
    119          #define IS_LL_TIM_OSSR_STATE(__VALUE__) (((__VALUE__) == LL_TIM_OSSR_DISABLE) \
    120                                                   || ((__VALUE__) == LL_TIM_OSSR_ENABLE))
    121          
    122          #define IS_LL_TIM_OSSI_STATE(__VALUE__) (((__VALUE__) == LL_TIM_OSSI_DISABLE) \
    123                                                   || ((__VALUE__) == LL_TIM_OSSI_ENABLE))
    124          
    125          #define IS_LL_TIM_LOCK_LEVEL(__VALUE__) (((__VALUE__) == LL_TIM_LOCKLEVEL_OFF) \
    126                                                   || ((__VALUE__) == LL_TIM_LOCKLEVEL_1)   \
    127                                                   || ((__VALUE__) == LL_TIM_LOCKLEVEL_2)   \
    128                                                   || ((__VALUE__) == LL_TIM_LOCKLEVEL_3))
    129          
    130          #define IS_LL_TIM_BREAK_STATE(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_DISABLE) \
    131                                                    || ((__VALUE__) == LL_TIM_BREAK_ENABLE))
    132          
    133          #define IS_LL_TIM_BREAK_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_POLARITY_LOW) \
    134                                                       || ((__VALUE__) == LL_TIM_BREAK_POLARITY_HIGH))
    135          
    136          #define IS_LL_TIM_BREAK_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1)     \
    137                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1_N2)  \
    138                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1_N4)  \
    139                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV1_N8)  \
    140                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV2_N6)  \
    141                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV2_N8)  \
    142                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV4_N6)  \
    143                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV4_N8)  \
    144                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV8_N6)  \
    145                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV8_N8)  \
    146                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV16_N5) \
    147                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV16_N6) \
    148                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV16_N8) \
    149                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV32_N5) \
    150                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV32_N6) \
    151                                                     || ((__VALUE__) == LL_TIM_BREAK_FILTER_FDIV32_N8))
    152          
    153          #define IS_LL_TIM_BREAK_AFMODE(__VALUE__) (((__VALUE__) == LL_TIM_BREAK_AFMODE_INPUT)          \
    154                                                     || ((__VALUE__) == LL_TIM_BREAK_AFMODE_BIDIRECTIONAL))
    155          
    156          #define IS_LL_TIM_BREAK2_STATE(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_DISABLE) \
    157                                                     || ((__VALUE__) == LL_TIM_BREAK2_ENABLE))
    158          
    159          #define IS_LL_TIM_BREAK2_POLARITY(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_POLARITY_LOW) \
    160                                                        || ((__VALUE__) == LL_TIM_BREAK2_POLARITY_HIGH))
    161          
    162          #define IS_LL_TIM_BREAK2_FILTER(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1)    \
    163                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1_N2)  \
    164                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1_N4)  \
    165                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV1_N8)  \
    166                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV2_N6)  \
    167                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV2_N8)  \
    168                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV4_N6)  \
    169                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV4_N8)  \
    170                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV8_N6)  \
    171                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV8_N8)  \
    172                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV16_N5) \
    173                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV16_N6) \
    174                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV16_N8) \
    175                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV32_N5) \
    176                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV32_N6) \
    177                                                      || ((__VALUE__) == LL_TIM_BREAK2_FILTER_FDIV32_N8))
    178          
    179          #define IS_LL_TIM_BREAK2_AFMODE(__VALUE__) (((__VALUE__) == LL_TIM_BREAK2_AFMODE_INPUT)       \
    180                                                      || ((__VALUE__) == LL_TIM_BREAK2_AFMODE_BIDIRECTIONAL))
    181          
    182          #define IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(__VALUE__) (((__VALUE__) == LL_TIM_AUTOMATICOUTPUT_DISABLE) \
    183                                                               || ((__VALUE__) == LL_TIM_AUTOMATICOUTPUT_ENABLE))
    184          /**
    185            * @}
    186            */
    187          
    188          
    189          /* Private function prototypes -----------------------------------------------*/
    190          /** @defgroup TIM_LL_Private_Functions TIM Private Functions
    191            * @{
    192            */
    193          static ErrorStatus OC1Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
    194          static ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
    195          static ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
    196          static ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
    197          static ErrorStatus OC5Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
    198          static ErrorStatus OC6Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct);
    199          static ErrorStatus IC1Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
    200          static ErrorStatus IC2Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
    201          static ErrorStatus IC3Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
    202          static ErrorStatus IC4Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct);
    203          /**
    204            * @}
    205            */
    206          
    207          /* Exported functions --------------------------------------------------------*/
    208          /** @addtogroup TIM_LL_Exported_Functions
    209            * @{
    210            */
    211          
    212          /** @addtogroup TIM_LL_EF_Init
    213            * @{
    214            */
    215          
    216          /**
    217            * @brief  Set TIMx registers to their reset values.
    218            * @param  TIMx Timer instance
    219            * @retval An ErrorStatus enumeration value:
    220            *          - SUCCESS: TIMx registers are de-initialized
    221            *          - ERROR: invalid TIMx instance
    222            */

   \                                 In section .text, align 2, keep-with-next
    223          ErrorStatus LL_TIM_DeInit(TIM_TypeDef *TIMx)
    224          {
   \                     LL_TIM_DeInit: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    225            ErrorStatus result = SUCCESS;
   \        0x4   0x2500             MOVS     R5,#+0
    226          
    227            /* Check the parameters */
    228            assert_param(IS_TIM_INSTANCE(TIMx));
    229          
    230            if (TIMx == TIM1)
   \        0x6   0x....             LDR      R0,??DataTable8_3  ;; 0x40012c00
   \        0x8   0x4284             CMP      R4,R0
   \        0xA   0xD108             BNE      ??LL_TIM_DeInit_0
    231            {
    232              LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM1);
   \        0xC   0x2680             MOVS     R6,#+128
   \        0xE   0x0136             LSLS     R6,R6,#+4        ;; #+2048
   \       0x10   0x0030             MOVS     R0,R6
   \       0x12   0x....'....        BL       LL_APB2_GRP1_ForceReset
    233              LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM1);
   \       0x16   0x0030             MOVS     R0,R6
   \       0x18   0x....'....        BL       LL_APB2_GRP1_ReleaseReset
   \       0x1C   0xE02F             B        ??LL_TIM_DeInit_1
    234            }
    235          #if defined(TIM2)
    236            else if (TIMx == TIM2)
    237            {
    238              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM2);
    239              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM2);
    240            }
    241          #endif
    242          #if defined(TIM3)
    243            else if (TIMx == TIM3)
   \                     ??LL_TIM_DeInit_0: (+1)
   \       0x1E   0x....             LDR      R0,??DataTable9  ;; 0x40000400
   \       0x20   0x4284             CMP      R4,R0
   \       0x22   0xD106             BNE      ??LL_TIM_DeInit_2
    244            {
    245              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM3);
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0x....'....        BL       LL_APB1_GRP1_ForceReset
    246              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM3);
   \       0x2A   0x2002             MOVS     R0,#+2
   \       0x2C   0x....'....        BL       LL_APB1_GRP1_ReleaseReset
   \       0x30   0xE025             B        ??LL_TIM_DeInit_1
    247            }
    248          #endif
    249          #if defined(TIM6)
    250            else if (TIMx == TIM6)
    251            {
    252              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM6);
    253              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM6);
    254            }
    255          #endif
    256          #if defined(TIM7)
    257            else if (TIMx == TIM7)
    258            {
    259              LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM7);
    260              LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM7);
    261            }
    262          #endif
    263            else if (TIMx == TIM14)
   \                     ??LL_TIM_DeInit_2: (+1)
   \       0x32   0x....             LDR      R0,??DataTable9_1  ;; 0x40002000
   \       0x34   0x4284             CMP      R4,R0
   \       0x36   0xD108             BNE      ??LL_TIM_DeInit_3
    264            {
    265              LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM14);
   \       0x38   0x2680             MOVS     R6,#+128
   \       0x3A   0x0236             LSLS     R6,R6,#+8        ;; #+32768
   \       0x3C   0x0030             MOVS     R0,R6
   \       0x3E   0x....'....        BL       LL_APB2_GRP1_ForceReset
    266              LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM14);
   \       0x42   0x0030             MOVS     R0,R6
   \       0x44   0x....'....        BL       LL_APB2_GRP1_ReleaseReset
   \       0x48   0xE019             B        ??LL_TIM_DeInit_1
    267            }
    268          #if defined(TIM15)
    269            else if (TIMx == TIM15)
    270            {
    271              LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM15);
    272              LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM15);
    273            }
    274          #endif
    275            else if (TIMx == TIM16)
   \                     ??LL_TIM_DeInit_3: (+1)
   \       0x4A   0x....             LDR      R0,??DataTable9_2  ;; 0x40014400
   \       0x4C   0x4284             CMP      R4,R0
   \       0x4E   0xD108             BNE      ??LL_TIM_DeInit_4
    276            {
    277              LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM16);
   \       0x50   0x2680             MOVS     R6,#+128
   \       0x52   0x02B6             LSLS     R6,R6,#+10       ;; #+131072
   \       0x54   0x0030             MOVS     R0,R6
   \       0x56   0x....'....        BL       LL_APB2_GRP1_ForceReset
    278              LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM16);
   \       0x5A   0x0030             MOVS     R0,R6
   \       0x5C   0x....'....        BL       LL_APB2_GRP1_ReleaseReset
   \       0x60   0xE00D             B        ??LL_TIM_DeInit_1
    279            }
    280          #if defined(TIM17)
    281            else if (TIMx == TIM17)
   \                     ??LL_TIM_DeInit_4: (+1)
   \       0x62   0x....             LDR      R0,??DataTable9_3  ;; 0x40014800
   \       0x64   0x4284             CMP      R4,R0
   \       0x66   0xD108             BNE      ??LL_TIM_DeInit_5
    282            {
    283              LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM17);
   \       0x68   0x2680             MOVS     R6,#+128
   \       0x6A   0x02F6             LSLS     R6,R6,#+11       ;; #+262144
   \       0x6C   0x0030             MOVS     R0,R6
   \       0x6E   0x....'....        BL       LL_APB2_GRP1_ForceReset
    284              LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM17);
   \       0x72   0x0030             MOVS     R0,R6
   \       0x74   0x....'....        BL       LL_APB2_GRP1_ReleaseReset
   \       0x78   0xE001             B        ??LL_TIM_DeInit_1
    285            }
    286          #endif
    287            else
    288            {
    289              result = ERROR;
   \                     ??LL_TIM_DeInit_5: (+1)
   \       0x7A   0x2001             MOVS     R0,#+1
   \       0x7C   0x0005             MOVS     R5,R0
    290            }
    291          
    292            return result;
   \                     ??LL_TIM_DeInit_1: (+1)
   \       0x7E   0x0028             MOVS     R0,R5
   \       0x80   0xB2C0             UXTB     R0,R0
   \       0x82   0xBD70             POP      {R4-R6,PC}       ;; return
    293          }
    294          
    295          /**
    296            * @brief  Set the fields of the time base unit configuration data structure
    297            *         to their default values.
    298            * @param  TIM_InitStruct pointer to a @ref LL_TIM_InitTypeDef structure (time base unit configuration data structure)
    299            * @retval None
    300            */

   \                                 In section .text, align 2, keep-with-next
    301          void LL_TIM_StructInit(LL_TIM_InitTypeDef *TIM_InitStruct)
    302          {
    303            /* Set the default configuration */
    304            TIM_InitStruct->Prescaler         = (uint16_t)0x0000;
   \                     LL_TIM_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x000A             MOVS     R2,R1
   \        0x4   0x8002             STRH     R2,[R0, #+0]
    305            TIM_InitStruct->CounterMode       = LL_TIM_COUNTERMODE_UP;
   \        0x6   0x6041             STR      R1,[R0, #+4]
    306            TIM_InitStruct->Autoreload        = 0xFFFFFFFFU;
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x43D2             MVNS     R2,R2            ;; #-1
   \        0xC   0x6082             STR      R2,[R0, #+8]
    307            TIM_InitStruct->ClockDivision     = LL_TIM_CLOCKDIVISION_DIV1;
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    308            TIM_InitStruct->RepetitionCounter = (uint8_t)0x00;
   \       0x10   0x7401             STRB     R1,[R0, #+16]
    309          }
   \       0x12   0x4770             BX       LR               ;; return
    310          
    311          /**
    312            * @brief  Configure the TIMx time base unit.
    313            * @param  TIMx Timer Instance
    314            * @param  TIM_InitStruct pointer to a @ref LL_TIM_InitTypeDef structure (TIMx time base unit configuration data structure)
    315            * @retval An ErrorStatus enumeration value:
    316            *          - SUCCESS: TIMx registers are de-initialized
    317            *          - ERROR: not applicable
    318            */

   \                                 In section .text, align 2, keep-with-next
    319          ErrorStatus LL_TIM_Init(TIM_TypeDef *TIMx, LL_TIM_InitTypeDef *TIM_InitStruct)
    320          {
   \                     LL_TIM_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
    321            uint32_t tmpcr1;
    322          
    323            /* Check the parameters */
    324            assert_param(IS_TIM_INSTANCE(TIMx));
    325            assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
    326            assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));
    327          
    328            tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
   \        0x6   0x6825             LDR      R5,[R4, #+0]
    329          
    330            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   \        0x8   0x....             LDR      R7,??DataTable8_3  ;; 0x40012c00
   \        0xA   0x42BC             CMP      R4,R7
   \        0xC   0xD002             BEQ      ??LL_TIM_Init_0
   \        0xE   0x....             LDR      R0,??DataTable9  ;; 0x40000400
   \       0x10   0x4284             CMP      R4,R0
   \       0x12   0xD104             BNE      ??LL_TIM_Init_1
    331            {
    332              /* Select the Counter Mode */
    333              MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
   \                     ??LL_TIM_Init_0: (+1)
   \       0x14   0x2070             MOVS     R0,#+112
   \       0x16   0x4385             BICS     R5,R5,R0
   \       0x18   0x0028             MOVS     R0,R5
   \       0x1A   0x6875             LDR      R5,[R6, #+4]
   \       0x1C   0x4305             ORRS     R5,R5,R0
    334            }
    335          
    336            if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   \                     ??LL_TIM_Init_1: (+1)
   \       0x1E   0x42BC             CMP      R4,R7
   \       0x20   0xD00B             BEQ      ??LL_TIM_Init_2
   \       0x22   0x....             LDR      R0,??DataTable9  ;; 0x40000400
   \       0x24   0x4284             CMP      R4,R0
   \       0x26   0xD008             BEQ      ??LL_TIM_Init_2
   \       0x28   0x....             LDR      R0,??DataTable9_1  ;; 0x40002000
   \       0x2A   0x4284             CMP      R4,R0
   \       0x2C   0xD005             BEQ      ??LL_TIM_Init_2
   \       0x2E   0x....             LDR      R0,??DataTable9_2  ;; 0x40014400
   \       0x30   0x4284             CMP      R4,R0
   \       0x32   0xD002             BEQ      ??LL_TIM_Init_2
   \       0x34   0x....             LDR      R0,??DataTable9_3  ;; 0x40014800
   \       0x36   0x4284             CMP      R4,R0
   \       0x38   0xD103             BNE      ??LL_TIM_Init_3
    337            {
    338              /* Set the clock division */
    339              MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
   \                     ??LL_TIM_Init_2: (+1)
   \       0x3A   0x....             LDR      R0,??DataTable9_4  ;; 0xfffffcff
   \       0x3C   0x4028             ANDS     R0,R0,R5
   \       0x3E   0x68F5             LDR      R5,[R6, #+12]
   \       0x40   0x4305             ORRS     R5,R5,R0
    340            }
    341          
    342            /* Write to TIMx CR1 */
    343            LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
   \                     ??LL_TIM_Init_3: (+1)
   \       0x42   0x6025             STR      R5,[R4, #+0]
    344          
    345            /* Set the Autoreload value */
    346            LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
   \       0x44   0x68B1             LDR      R1,[R6, #+8]
   \       0x46   0x0020             MOVS     R0,R4
   \       0x48   0x....'....        BL       LL_TIM_SetAutoReload
    347          
    348            /* Set the Prescaler value */
    349            LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
   \       0x4C   0x8831             LDRH     R1,[R6, #+0]
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x....'....        BL       LL_TIM_SetPrescaler
    350          
    351            if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   \       0x54   0x42BC             CMP      R4,R7
   \       0x56   0xD005             BEQ      ??LL_TIM_Init_4
   \       0x58   0x....             LDR      R0,??DataTable9_2  ;; 0x40014400
   \       0x5A   0x4284             CMP      R4,R0
   \       0x5C   0xD002             BEQ      ??LL_TIM_Init_4
   \       0x5E   0x....             LDR      R0,??DataTable9_3  ;; 0x40014800
   \       0x60   0x4284             CMP      R4,R0
   \       0x62   0xD103             BNE      ??LL_TIM_Init_5
    352            {
    353              /* Set the Repetition Counter value */
    354              LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
   \                     ??LL_TIM_Init_4: (+1)
   \       0x64   0x7C31             LDRB     R1,[R6, #+16]
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0x....'....        BL       LL_TIM_SetRepetitionCounter
    355            }
    356          
    357            /* Generate an update event to reload the Prescaler
    358               and the repetition counter value (if applicable) immediately */
    359            LL_TIM_GenerateEvent_UPDATE(TIMx);
   \                     ??LL_TIM_Init_5: (+1)
   \       0x6C   0x0020             MOVS     R0,R4
   \       0x6E   0x....'....        BL       LL_TIM_GenerateEvent_UPDATE
    360          
    361            return SUCCESS;
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    362          }
    363          
    364          /**
    365            * @brief  Set the fields of the TIMx output channel configuration data
    366            *         structure to their default values.
    367            * @param  TIM_OC_InitStruct pointer to a @ref LL_TIM_OC_InitTypeDef structure (the output channel configuration data structure)
    368            * @retval None
    369            */

   \                                 In section .text, align 2, keep-with-next
    370          void LL_TIM_OC_StructInit(LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)
    371          {
    372            /* Set the default configuration */
    373            TIM_OC_InitStruct->OCMode       = LL_TIM_OCMODE_FROZEN;
   \                     LL_TIM_OC_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    374            TIM_OC_InitStruct->OCState      = LL_TIM_OCSTATE_DISABLE;
   \        0x4   0x6041             STR      R1,[R0, #+4]
    375            TIM_OC_InitStruct->OCNState     = LL_TIM_OCSTATE_DISABLE;
   \        0x6   0x6081             STR      R1,[R0, #+8]
    376            TIM_OC_InitStruct->CompareValue = 0x00000000U;
   \        0x8   0x60C1             STR      R1,[R0, #+12]
    377            TIM_OC_InitStruct->OCPolarity   = LL_TIM_OCPOLARITY_HIGH;
   \        0xA   0x6101             STR      R1,[R0, #+16]
    378            TIM_OC_InitStruct->OCNPolarity  = LL_TIM_OCPOLARITY_HIGH;
   \        0xC   0x6141             STR      R1,[R0, #+20]
    379            TIM_OC_InitStruct->OCIdleState  = LL_TIM_OCIDLESTATE_LOW;
   \        0xE   0x6181             STR      R1,[R0, #+24]
    380            TIM_OC_InitStruct->OCNIdleState = LL_TIM_OCIDLESTATE_LOW;
   \       0x10   0x61C1             STR      R1,[R0, #+28]
    381          }
   \       0x12   0x4770             BX       LR               ;; return
    382          
    383          /**
    384            * @brief  Configure the TIMx output channel.
    385            * @param  TIMx Timer Instance
    386            * @param  Channel This parameter can be one of the following values:
    387            *         @arg @ref LL_TIM_CHANNEL_CH1
    388            *         @arg @ref LL_TIM_CHANNEL_CH2
    389            *         @arg @ref LL_TIM_CHANNEL_CH3
    390            *         @arg @ref LL_TIM_CHANNEL_CH4
    391            *         @arg @ref LL_TIM_CHANNEL_CH5
    392            *         @arg @ref LL_TIM_CHANNEL_CH6
    393            * @param  TIM_OC_InitStruct pointer to a @ref LL_TIM_OC_InitTypeDef structure (TIMx output channel configuration data structure)
    394            * @retval An ErrorStatus enumeration value:
    395            *          - SUCCESS: TIMx output channel is initialized
    396            *          - ERROR: TIMx output channel is not initialized
    397            */

   \                                 In section .text, align 2, keep-with-next
    398          ErrorStatus LL_TIM_OC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)
    399          {
   \                     LL_TIM_OC_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
   \        0x6   0x0016             MOVS     R6,R2
    400            ErrorStatus result = ERROR;
   \        0x8   0x2501             MOVS     R5,#+1
    401          
    402            switch (Channel)
   \        0xA   0x0038             MOVS     R0,R7
   \        0xC   0x1E40             SUBS     R0,R0,#+1
   \        0xE   0xD010             BEQ      ??LL_TIM_OC_Init_0
   \       0x10   0x380F             SUBS     R0,R0,#+15
   \       0x12   0xD014             BEQ      ??LL_TIM_OC_Init_1
   \       0x14   0x38F0             SUBS     R0,R0,#+240
   \       0x16   0xD018             BEQ      ??LL_TIM_OC_Init_2
   \       0x18   0x21F0             MOVS     R1,#+240
   \       0x1A   0x0109             LSLS     R1,R1,#+4        ;; #+3840
   \       0x1C   0x1A40             SUBS     R0,R0,R1
   \       0x1E   0xD01A             BEQ      ??LL_TIM_OC_Init_3
   \       0x20   0x21F0             MOVS     R1,#+240
   \       0x22   0x0209             LSLS     R1,R1,#+8        ;; #+61440
   \       0x24   0x1A40             SUBS     R0,R0,R1
   \       0x26   0xD01C             BEQ      ??LL_TIM_OC_Init_4
   \       0x28   0x21F0             MOVS     R1,#+240
   \       0x2A   0x0309             LSLS     R1,R1,#+12       ;; #+983040
   \       0x2C   0x1A40             SUBS     R0,R0,R1
   \       0x2E   0xD01E             BEQ      ??LL_TIM_OC_Init_5
   \       0x30   0xE023             B        ??LL_TIM_OC_Init_6
    403            {
    404              case LL_TIM_CHANNEL_CH1:
    405                result = OC1Config(TIMx, TIM_OC_InitStruct);
   \                     ??LL_TIM_OC_Init_0: (+1)
   \       0x32   0x0031             MOVS     R1,R6
   \       0x34   0x0020             MOVS     R0,R4
   \       0x36   0x....'....        BL       OC1Config
   \       0x3A   0x0005             MOVS     R5,R0
    406                break;
   \       0x3C   0xE01D             B        ??LL_TIM_OC_Init_7
    407              case LL_TIM_CHANNEL_CH2:
    408                result = OC2Config(TIMx, TIM_OC_InitStruct);
   \                     ??LL_TIM_OC_Init_1: (+1)
   \       0x3E   0x0031             MOVS     R1,R6
   \       0x40   0x0020             MOVS     R0,R4
   \       0x42   0x....'....        BL       OC2Config
   \       0x46   0x0005             MOVS     R5,R0
    409                break;
   \       0x48   0xE017             B        ??LL_TIM_OC_Init_7
    410              case LL_TIM_CHANNEL_CH3:
    411                result = OC3Config(TIMx, TIM_OC_InitStruct);
   \                     ??LL_TIM_OC_Init_2: (+1)
   \       0x4A   0x0031             MOVS     R1,R6
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0x....'....        BL       OC3Config
   \       0x52   0x0005             MOVS     R5,R0
    412                break;
   \       0x54   0xE011             B        ??LL_TIM_OC_Init_7
    413              case LL_TIM_CHANNEL_CH4:
    414                result = OC4Config(TIMx, TIM_OC_InitStruct);
   \                     ??LL_TIM_OC_Init_3: (+1)
   \       0x56   0x0031             MOVS     R1,R6
   \       0x58   0x0020             MOVS     R0,R4
   \       0x5A   0x....'....        BL       OC4Config
   \       0x5E   0x0005             MOVS     R5,R0
    415                break;
   \       0x60   0xE00B             B        ??LL_TIM_OC_Init_7
    416              case LL_TIM_CHANNEL_CH5:
    417                result = OC5Config(TIMx, TIM_OC_InitStruct);
   \                     ??LL_TIM_OC_Init_4: (+1)
   \       0x62   0x0031             MOVS     R1,R6
   \       0x64   0x0020             MOVS     R0,R4
   \       0x66   0x....'....        BL       OC5Config
   \       0x6A   0x0005             MOVS     R5,R0
    418                break;
   \       0x6C   0xE005             B        ??LL_TIM_OC_Init_7
    419              case LL_TIM_CHANNEL_CH6:
    420                result = OC6Config(TIMx, TIM_OC_InitStruct);
   \                     ??LL_TIM_OC_Init_5: (+1)
   \       0x6E   0x0031             MOVS     R1,R6
   \       0x70   0x0020             MOVS     R0,R4
   \       0x72   0x....'....        BL       OC6Config
   \       0x76   0x0005             MOVS     R5,R0
    421                break;
   \       0x78   0xE7FF             B        ??LL_TIM_OC_Init_7
    422              default:
    423                break;
    424            }
    425          
    426            return result;
   \                     ??LL_TIM_OC_Init_6: (+1)
   \                     ??LL_TIM_OC_Init_7: (+1)
   \       0x7A   0x0028             MOVS     R0,R5
   \       0x7C   0xB2C0             UXTB     R0,R0
   \       0x7E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    427          }
    428          
    429          /**
    430            * @brief  Set the fields of the TIMx input channel configuration data
    431            *         structure to their default values.
    432            * @param  TIM_ICInitStruct pointer to a @ref LL_TIM_IC_InitTypeDef structure (the input channel configuration data structure)
    433            * @retval None
    434            */

   \                                 In section .text, align 2, keep-with-next
    435          void LL_TIM_IC_StructInit(LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
    436          {
    437            /* Set the default configuration */
    438            TIM_ICInitStruct->ICPolarity    = LL_TIM_IC_POLARITY_RISING;
   \                     LL_TIM_IC_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    439            TIM_ICInitStruct->ICActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \        0x8   0x6042             STR      R2,[R0, #+4]
    440            TIM_ICInitStruct->ICPrescaler   = LL_TIM_ICPSC_DIV1;
   \        0xA   0x6081             STR      R1,[R0, #+8]
    441            TIM_ICInitStruct->ICFilter      = LL_TIM_IC_FILTER_FDIV1;
   \        0xC   0x60C1             STR      R1,[R0, #+12]
    442          }
   \        0xE   0x4770             BX       LR               ;; return
    443          
    444          /**
    445            * @brief  Configure the TIMx input channel.
    446            * @param  TIMx Timer Instance
    447            * @param  Channel This parameter can be one of the following values:
    448            *         @arg @ref LL_TIM_CHANNEL_CH1
    449            *         @arg @ref LL_TIM_CHANNEL_CH2
    450            *         @arg @ref LL_TIM_CHANNEL_CH3
    451            *         @arg @ref LL_TIM_CHANNEL_CH4
    452            * @param  TIM_IC_InitStruct pointer to a @ref LL_TIM_IC_InitTypeDef structure (TIMx input channel configuration data structure)
    453            * @retval An ErrorStatus enumeration value:
    454            *          - SUCCESS: TIMx output channel is initialized
    455            *          - ERROR: TIMx output channel is not initialized
    456            */

   \                                 In section .text, align 2, keep-with-next
    457          ErrorStatus LL_TIM_IC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_IC_InitTypeDef *TIM_IC_InitStruct)
    458          {
   \                     LL_TIM_IC_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0017             MOVS     R7,R2
    459            ErrorStatus result = ERROR;
   \        0x8   0x2501             MOVS     R5,#+1
    460          
    461            switch (Channel)
   \        0xA   0x0030             MOVS     R0,R6
   \        0xC   0x1E40             SUBS     R0,R0,#+1
   \        0xE   0xD008             BEQ      ??LL_TIM_IC_Init_0
   \       0x10   0x380F             SUBS     R0,R0,#+15
   \       0x12   0xD00C             BEQ      ??LL_TIM_IC_Init_1
   \       0x14   0x38F0             SUBS     R0,R0,#+240
   \       0x16   0xD010             BEQ      ??LL_TIM_IC_Init_2
   \       0x18   0x21F0             MOVS     R1,#+240
   \       0x1A   0x0109             LSLS     R1,R1,#+4        ;; #+3840
   \       0x1C   0x1A40             SUBS     R0,R0,R1
   \       0x1E   0xD012             BEQ      ??LL_TIM_IC_Init_3
   \       0x20   0xE017             B        ??LL_TIM_IC_Init_4
    462            {
    463              case LL_TIM_CHANNEL_CH1:
    464                result = IC1Config(TIMx, TIM_IC_InitStruct);
   \                     ??LL_TIM_IC_Init_0: (+1)
   \       0x22   0x0039             MOVS     R1,R7
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0x....'....        BL       IC1Config
   \       0x2A   0x0005             MOVS     R5,R0
    465                break;
   \       0x2C   0xE011             B        ??LL_TIM_IC_Init_5
    466              case LL_TIM_CHANNEL_CH2:
    467                result = IC2Config(TIMx, TIM_IC_InitStruct);
   \                     ??LL_TIM_IC_Init_1: (+1)
   \       0x2E   0x0039             MOVS     R1,R7
   \       0x30   0x0020             MOVS     R0,R4
   \       0x32   0x....'....        BL       IC2Config
   \       0x36   0x0005             MOVS     R5,R0
    468                break;
   \       0x38   0xE00B             B        ??LL_TIM_IC_Init_5
    469              case LL_TIM_CHANNEL_CH3:
    470                result = IC3Config(TIMx, TIM_IC_InitStruct);
   \                     ??LL_TIM_IC_Init_2: (+1)
   \       0x3A   0x0039             MOVS     R1,R7
   \       0x3C   0x0020             MOVS     R0,R4
   \       0x3E   0x....'....        BL       IC3Config
   \       0x42   0x0005             MOVS     R5,R0
    471                break;
   \       0x44   0xE005             B        ??LL_TIM_IC_Init_5
    472              case LL_TIM_CHANNEL_CH4:
    473                result = IC4Config(TIMx, TIM_IC_InitStruct);
   \                     ??LL_TIM_IC_Init_3: (+1)
   \       0x46   0x0039             MOVS     R1,R7
   \       0x48   0x0020             MOVS     R0,R4
   \       0x4A   0x....'....        BL       IC4Config
   \       0x4E   0x0005             MOVS     R5,R0
    474                break;
   \       0x50   0xE7FF             B        ??LL_TIM_IC_Init_5
    475              default:
    476                break;
    477            }
    478          
    479            return result;
   \                     ??LL_TIM_IC_Init_4: (+1)
   \                     ??LL_TIM_IC_Init_5: (+1)
   \       0x52   0x0028             MOVS     R0,R5
   \       0x54   0xB2C0             UXTB     R0,R0
   \       0x56   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    480          }
    481          
    482          /**
    483            * @brief  Fills each TIM_EncoderInitStruct field with its default value
    484            * @param  TIM_EncoderInitStruct pointer to a @ref LL_TIM_ENCODER_InitTypeDef structure (encoder interface configuration data structure)
    485            * @retval None
    486            */

   \                                 In section .text, align 2, keep-with-next
    487          void LL_TIM_ENCODER_StructInit(LL_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct)
    488          {
    489            /* Set the default configuration */
    490            TIM_EncoderInitStruct->EncoderMode    = LL_TIM_ENCODERMODE_X2_TI1;
   \                     LL_TIM_ENCODER_StructInit: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x6001             STR      R1,[R0, #+0]
    491            TIM_EncoderInitStruct->IC1Polarity    = LL_TIM_IC_POLARITY_RISING;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x6041             STR      R1,[R0, #+4]
    492            TIM_EncoderInitStruct->IC1ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;
   \        0x8   0x2280             MOVS     R2,#+128
   \        0xA   0x0252             LSLS     R2,R2,#+9        ;; #+65536
   \        0xC   0x6082             STR      R2,[R0, #+8]
    493            TIM_EncoderInitStruct->IC1Prescaler   = LL_TIM_ICPSC_DIV1;
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    494            TIM_EncoderInitStruct->IC1Filter      = LL_TIM_IC_FILTER_FDIV1;
   \       0x10   0x6101             STR      R1,[R0, #+16]
    495            TIM_EncoderInitStruct->IC2Polarity    = LL_TIM_IC_POLARITY_RISING;
   \       0x12   0x6141             STR      R1,[R0, #+20]
    496            TIM_EncoderInitStruct->IC2ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;
   \       0x14   0x6182             STR      R2,[R0, #+24]
    497            TIM_EncoderInitStruct->IC2Prescaler   = LL_TIM_ICPSC_DIV1;
   \       0x16   0x61C1             STR      R1,[R0, #+28]
    498            TIM_EncoderInitStruct->IC2Filter      = LL_TIM_IC_FILTER_FDIV1;
   \       0x18   0x6201             STR      R1,[R0, #+32]
    499          }
   \       0x1A   0x4770             BX       LR               ;; return
    500          
    501          /**
    502            * @brief  Configure the encoder interface of the timer instance.
    503            * @param  TIMx Timer Instance
    504            * @param  TIM_EncoderInitStruct pointer to a @ref LL_TIM_ENCODER_InitTypeDef structure (TIMx encoder interface configuration data structure)
    505            * @retval An ErrorStatus enumeration value:
    506            *          - SUCCESS: TIMx registers are de-initialized
    507            *          - ERROR: not applicable
    508            */

   \                                 In section .text, align 2, keep-with-next
    509          ErrorStatus LL_TIM_ENCODER_Init(TIM_TypeDef *TIMx, LL_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct)
    510          {
   \                     LL_TIM_ENCODER_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    511            uint32_t tmpccmr1;
    512            uint32_t tmpccer;
    513          
    514            /* Check the parameters */
    515            assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx));
    516            assert_param(IS_LL_TIM_ENCODERMODE(TIM_EncoderInitStruct->EncoderMode));
    517            assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_EncoderInitStruct->IC1Polarity));
    518            assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_EncoderInitStruct->IC1ActiveInput));
    519            assert_param(IS_LL_TIM_ICPSC(TIM_EncoderInitStruct->IC1Prescaler));
    520            assert_param(IS_LL_TIM_IC_FILTER(TIM_EncoderInitStruct->IC1Filter));
    521            assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_EncoderInitStruct->IC2Polarity));
    522            assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_EncoderInitStruct->IC2ActiveInput));
    523            assert_param(IS_LL_TIM_ICPSC(TIM_EncoderInitStruct->IC2Prescaler));
    524            assert_param(IS_LL_TIM_IC_FILTER(TIM_EncoderInitStruct->IC2Filter));
    525          
    526            /* Disable the CC1 and CC2: Reset the CC1E and CC2E Bits */
    527            TIMx->CCER &= (uint32_t)~(TIM_CCER_CC1E | TIM_CCER_CC2E);
   \        0x6   0x6A20             LDR      R0,[R4, #+32]
   \        0x8   0x2111             MOVS     R1,#+17
   \        0xA   0x4388             BICS     R0,R0,R1
   \        0xC   0x6220             STR      R0,[R4, #+32]
    528          
    529            /* Get the TIMx CCMR1 register value */
    530            tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
   \        0xE   0x69A1             LDR      R1,[R4, #+24]
    531          
    532            /* Get the TIMx CCER register value */
    533            tmpccer = LL_TIM_ReadReg(TIMx, CCER);
   \       0x10   0x6A20             LDR      R0,[R4, #+32]
    534          
    535            /* Configure TI1 */
    536            tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC1S | TIM_CCMR1_IC1F  | TIM_CCMR1_IC1PSC);
   \       0x12   0x22FF             MOVS     R2,#+255
   \       0x14   0x4391             BICS     R1,R1,R2
    537            tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1ActiveInput >> 16U);
   \       0x16   0x68AA             LDR      R2,[R5, #+8]
   \       0x18   0x0C12             LSRS     R2,R2,#+16
   \       0x1A   0x430A             ORRS     R2,R2,R1
    538            tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1Filter >> 16U);
   \       0x1C   0x6929             LDR      R1,[R5, #+16]
   \       0x1E   0x0C09             LSRS     R1,R1,#+16
   \       0x20   0x4311             ORRS     R1,R1,R2
    539            tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1Prescaler >> 16U);
   \       0x22   0x68EA             LDR      R2,[R5, #+12]
   \       0x24   0x0C12             LSRS     R2,R2,#+16
   \       0x26   0x430A             ORRS     R2,R2,R1
    540          
    541            /* Configure TI2 */
    542            tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC2S | TIM_CCMR1_IC2F  | TIM_CCMR1_IC2PSC);
   \       0x28   0x....             LDR      R1,??DataTable13  ;; 0xffff00ff
   \       0x2A   0x4011             ANDS     R1,R1,R2
    543            tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2ActiveInput >> 8U);
   \       0x2C   0x69AA             LDR      R2,[R5, #+24]
   \       0x2E   0x0A12             LSRS     R2,R2,#+8
   \       0x30   0x430A             ORRS     R2,R2,R1
    544            tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2Filter >> 8U);
   \       0x32   0x6A29             LDR      R1,[R5, #+32]
   \       0x34   0x0A09             LSRS     R1,R1,#+8
   \       0x36   0x4311             ORRS     R1,R1,R2
    545            tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2Prescaler >> 8U);
   \       0x38   0x69EA             LDR      R2,[R5, #+28]
   \       0x3A   0x0A17             LSRS     R7,R2,#+8
   \       0x3C   0x430F             ORRS     R7,R7,R1
    546          
    547            /* Set TI1 and TI2 polarity and enable TI1 and TI2 */
    548            tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP | TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \       0x3E   0x21AA             MOVS     R1,#+170
   \       0x40   0x4388             BICS     R0,R0,R1
    549            tmpccer |= (uint32_t)(TIM_EncoderInitStruct->IC1Polarity);
   \       0x42   0x6869             LDR      R1,[R5, #+4]
   \       0x44   0x4301             ORRS     R1,R1,R0
    550            tmpccer |= (uint32_t)(TIM_EncoderInitStruct->IC2Polarity << 4U);
   \       0x46   0x6968             LDR      R0,[R5, #+20]
   \       0x48   0x0100             LSLS     R0,R0,#+4
   \       0x4A   0x4308             ORRS     R0,R0,R1
    551            tmpccer |= (uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E);
   \       0x4C   0x2611             MOVS     R6,#+17
   \       0x4E   0x4306             ORRS     R6,R6,R0
    552          
    553            /* Set encoder mode */
    554            LL_TIM_SetEncoderMode(TIMx, TIM_EncoderInitStruct->EncoderMode);
   \       0x50   0x6829             LDR      R1,[R5, #+0]
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x....'....        BL       LL_TIM_SetEncoderMode
    555          
    556            /* Write to TIMx CCMR1 */
    557            LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
   \       0x58   0x61A7             STR      R7,[R4, #+24]
    558          
    559            /* Write to TIMx CCER */
    560            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   \       0x5A   0x6226             STR      R6,[R4, #+32]
    561          
    562            return SUCCESS;
   \       0x5C   0x2000             MOVS     R0,#+0
   \       0x5E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    563          }
    564          
    565          /**
    566            * @brief  Set the fields of the TIMx Hall sensor interface configuration data
    567            *         structure to their default values.
    568            * @param  TIM_HallSensorInitStruct pointer to a @ref LL_TIM_HALLSENSOR_InitTypeDef structure (HALL sensor interface configuration data structure)
    569            * @retval None
    570            */

   \                                 In section .text, align 2, keep-with-next
    571          void LL_TIM_HALLSENSOR_StructInit(LL_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct)
    572          {
    573            /* Set the default configuration */
    574            TIM_HallSensorInitStruct->IC1Polarity       = LL_TIM_IC_POLARITY_RISING;
   \                     LL_TIM_HALLSENSOR_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    575            TIM_HallSensorInitStruct->IC1Prescaler      = LL_TIM_ICPSC_DIV1;
   \        0x4   0x6041             STR      R1,[R0, #+4]
    576            TIM_HallSensorInitStruct->IC1Filter         = LL_TIM_IC_FILTER_FDIV1;
   \        0x6   0x6081             STR      R1,[R0, #+8]
    577            TIM_HallSensorInitStruct->CommutationDelay  = 0U;
   \        0x8   0x60C1             STR      R1,[R0, #+12]
    578          }
   \        0xA   0x4770             BX       LR               ;; return
    579          
    580          /**
    581            * @brief  Configure the Hall sensor interface of the timer instance.
    582            * @note TIMx CH1, CH2 and CH3 inputs connected through a XOR
    583            *       to the TI1 input channel
    584            * @note TIMx slave mode controller is configured in reset mode.
    585                    Selected internal trigger is TI1F_ED.
    586            * @note Channel 1 is configured as input, IC1 is mapped on TRC.
    587            * @note Captured value stored in TIMx_CCR1 correspond to the time elapsed
    588            *       between 2 changes on the inputs. It gives information about motor speed.
    589            * @note Channel 2 is configured in output PWM 2 mode.
    590            * @note Compare value stored in TIMx_CCR2 corresponds to the commutation delay.
    591            * @note OC2REF is selected as trigger output on TRGO.
    592            * @note LL_TIM_IC_POLARITY_BOTHEDGE must not be used for TI1 when it is used
    593            *       when TIMx operates in Hall sensor interface mode.
    594            * @param  TIMx Timer Instance
    595            * @param  TIM_HallSensorInitStruct pointer to a @ref LL_TIM_HALLSENSOR_InitTypeDef structure (TIMx HALL sensor interface configuration data structure)
    596            * @retval An ErrorStatus enumeration value:
    597            *          - SUCCESS: TIMx registers are de-initialized
    598            *          - ERROR: not applicable
    599            */

   \                                 In section .text, align 2, keep-with-next
    600          ErrorStatus LL_TIM_HALLSENSOR_Init(TIM_TypeDef *TIMx, LL_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct)
    601          {
   \                     LL_TIM_HALLSENSOR_Init: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    602            uint32_t tmpcr2;
    603            uint32_t tmpccmr1;
    604            uint32_t tmpccer;
    605            uint32_t tmpsmcr;
    606          
    607            /* Check the parameters */
    608            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(TIMx));
    609            assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_HallSensorInitStruct->IC1Polarity));
    610            assert_param(IS_LL_TIM_ICPSC(TIM_HallSensorInitStruct->IC1Prescaler));
    611            assert_param(IS_LL_TIM_IC_FILTER(TIM_HallSensorInitStruct->IC1Filter));
    612          
    613            /* Disable the CC1 and CC2: Reset the CC1E and CC2E Bits */
    614            TIMx->CCER &= (uint32_t)~(TIM_CCER_CC1E | TIM_CCER_CC2E);
   \        0x6   0x6A20             LDR      R0,[R4, #+32]
   \        0x8   0x2111             MOVS     R1,#+17
   \        0xA   0x4388             BICS     R0,R0,R1
   \        0xC   0x6220             STR      R0,[R4, #+32]
    615          
    616            /* Get the TIMx CR2 register value */
    617            tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
   \        0xE   0x6863             LDR      R3,[R4, #+4]
    618          
    619            /* Get the TIMx CCMR1 register value */
    620            tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
   \       0x10   0x69A1             LDR      R1,[R4, #+24]
    621          
    622            /* Get the TIMx CCER register value */
    623            tmpccer = LL_TIM_ReadReg(TIMx, CCER);
   \       0x12   0x6A20             LDR      R0,[R4, #+32]
    624          
    625            /* Get the TIMx SMCR register value */
    626            tmpsmcr = LL_TIM_ReadReg(TIMx, SMCR);
   \       0x14   0x68A2             LDR      R2,[R4, #+8]
    627          
    628            /* Connect TIMx_CH1, CH2 and CH3 pins to the TI1 input */
    629            tmpcr2 |= TIM_CR2_TI1S;
   \       0x16   0x2680             MOVS     R6,#+128
   \       0x18   0x431E             ORRS     R6,R6,R3
    630          
    631            /* OC2REF signal is used as trigger output (TRGO) */
    632            tmpcr2 |= LL_TIM_TRGO_OC2REF;
   \       0x1A   0x2350             MOVS     R3,#+80
   \       0x1C   0x4333             ORRS     R3,R3,R6
   \       0x1E   0x9301             STR      R3,[SP, #+4]
    633          
    634            /* Configure the slave mode controller */
    635            tmpsmcr &= (uint32_t)~(TIM_SMCR_TS | TIM_SMCR_SMS);
   \       0x20   0x....             LDR      R3,??DataTable13_1  ;; 0xffceff88
   \       0x22   0x4013             ANDS     R3,R3,R2
    636            tmpsmcr |= LL_TIM_TS_TI1F_ED;
   \       0x24   0x2240             MOVS     R2,#+64
   \       0x26   0x431A             ORRS     R2,R2,R3
    637            tmpsmcr |= LL_TIM_SLAVEMODE_RESET;
   \       0x28   0x2604             MOVS     R6,#+4
   \       0x2A   0x4316             ORRS     R6,R6,R2
    638          
    639            /* Configure input channel 1 */
    640            tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC1S | TIM_CCMR1_IC1F  | TIM_CCMR1_IC1PSC);
   \       0x2C   0x22FF             MOVS     R2,#+255
   \       0x2E   0x4391             BICS     R1,R1,R2
    641            tmpccmr1 |= (uint32_t)(LL_TIM_ACTIVEINPUT_TRC >> 16U);
   \       0x30   0x2203             MOVS     R2,#+3
   \       0x32   0x430A             ORRS     R2,R2,R1
    642            tmpccmr1 |= (uint32_t)(TIM_HallSensorInitStruct->IC1Filter >> 16U);
   \       0x34   0x68A9             LDR      R1,[R5, #+8]
   \       0x36   0x0C09             LSRS     R1,R1,#+16
   \       0x38   0x4311             ORRS     R1,R1,R2
    643            tmpccmr1 |= (uint32_t)(TIM_HallSensorInitStruct->IC1Prescaler >> 16U);
   \       0x3A   0x686A             LDR      R2,[R5, #+4]
   \       0x3C   0x0C12             LSRS     R2,R2,#+16
   \       0x3E   0x430A             ORRS     R2,R2,R1
    644          
    645            /* Configure input channel 2 */
    646            tmpccmr1 &= (uint32_t)~(TIM_CCMR1_OC2M | TIM_CCMR1_OC2FE  | TIM_CCMR1_OC2PE  | TIM_CCMR1_OC2CE);
   \       0x40   0x....             LDR      R1,??DataTable14  ;; 0xfeff03ff
   \       0x42   0x4011             ANDS     R1,R1,R2
    647            tmpccmr1 |= (uint32_t)(LL_TIM_OCMODE_PWM2 << 8U);
   \       0x44   0x22E0             MOVS     R2,#+224
   \       0x46   0x01D2             LSLS     R2,R2,#+7        ;; #+28672
   \       0x48   0x430A             ORRS     R2,R2,R1
   \       0x4A   0x9200             STR      R2,[SP, #+0]
    648          
    649            /* Set Channel 1 polarity and enable Channel 1 and Channel2 */
    650            tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP | TIM_CCER_CC2P | TIM_CCER_CC2NP);
   \       0x4C   0x21AA             MOVS     R1,#+170
   \       0x4E   0x4388             BICS     R0,R0,R1
    651            tmpccer |= (uint32_t)(TIM_HallSensorInitStruct->IC1Polarity);
   \       0x50   0x6829             LDR      R1,[R5, #+0]
   \       0x52   0x4301             ORRS     R1,R1,R0
    652            tmpccer |= (uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E);
   \       0x54   0x2711             MOVS     R7,#+17
   \       0x56   0x430F             ORRS     R7,R7,R1
    653          
    654            /* Write to TIMx CR2 */
    655            LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
   \       0x58   0x9801             LDR      R0,[SP, #+4]
   \       0x5A   0x6060             STR      R0,[R4, #+4]
    656          
    657            /* Write to TIMx SMCR */
    658            LL_TIM_WriteReg(TIMx, SMCR, tmpsmcr);
   \       0x5C   0x60A6             STR      R6,[R4, #+8]
    659          
    660            /* Write to TIMx CCMR1 */
    661            LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
   \       0x5E   0x9800             LDR      R0,[SP, #+0]
   \       0x60   0x61A0             STR      R0,[R4, #+24]
    662          
    663            /* Write to TIMx CCER */
    664            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   \       0x62   0x6227             STR      R7,[R4, #+32]
    665          
    666            /* Write to TIMx CCR2 */
    667            LL_TIM_OC_SetCompareCH2(TIMx, TIM_HallSensorInitStruct->CommutationDelay);
   \       0x64   0x68E9             LDR      R1,[R5, #+12]
   \       0x66   0x0020             MOVS     R0,R4
   \       0x68   0x....'....        BL       LL_TIM_OC_SetCompareCH2
    668          
    669            return SUCCESS;
   \       0x6C   0x2000             MOVS     R0,#+0
   \       0x6E   0xBDFE             POP      {R1-R7,PC}       ;; return
    670          }
    671          
    672          /**
    673            * @brief  Set the fields of the Break and Dead Time configuration data structure
    674            *         to their default values.
    675            * @param  TIM_BDTRInitStruct pointer to a @ref LL_TIM_BDTR_InitTypeDef structure (Break and Dead Time configuration data structure)
    676            * @retval None
    677            */

   \                                 In section .text, align 2, keep-with-next
    678          void LL_TIM_BDTR_StructInit(LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct)
    679          {
    680            /* Set the default configuration */
    681            TIM_BDTRInitStruct->OSSRState       = LL_TIM_OSSR_DISABLE;
   \                     LL_TIM_BDTR_StructInit: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x6001             STR      R1,[R0, #+0]
    682            TIM_BDTRInitStruct->OSSIState       = LL_TIM_OSSI_DISABLE;
   \        0x4   0x6041             STR      R1,[R0, #+4]
    683            TIM_BDTRInitStruct->LockLevel       = LL_TIM_LOCKLEVEL_OFF;
   \        0x6   0x6081             STR      R1,[R0, #+8]
    684            TIM_BDTRInitStruct->DeadTime        = (uint8_t)0x00;
   \        0x8   0x000A             MOVS     R2,R1
   \        0xA   0x7302             STRB     R2,[R0, #+12]
    685            TIM_BDTRInitStruct->BreakState      = LL_TIM_BREAK_DISABLE;
   \        0xC   0x000A             MOVS     R2,R1
   \        0xE   0x81C2             STRH     R2,[R0, #+14]
    686            TIM_BDTRInitStruct->BreakPolarity   = LL_TIM_BREAK_POLARITY_LOW;
   \       0x10   0x6101             STR      R1,[R0, #+16]
    687            TIM_BDTRInitStruct->BreakFilter     = LL_TIM_BREAK_FILTER_FDIV1;
   \       0x12   0x6141             STR      R1,[R0, #+20]
    688            TIM_BDTRInitStruct->BreakAFMode     = LL_TIM_BREAK_AFMODE_INPUT;
   \       0x14   0x6181             STR      R1,[R0, #+24]
    689            TIM_BDTRInitStruct->Break2State     = LL_TIM_BREAK2_DISABLE;
   \       0x16   0x61C1             STR      R1,[R0, #+28]
    690            TIM_BDTRInitStruct->Break2Polarity  = LL_TIM_BREAK2_POLARITY_LOW;
   \       0x18   0x6201             STR      R1,[R0, #+32]
    691            TIM_BDTRInitStruct->Break2Filter    = LL_TIM_BREAK2_FILTER_FDIV1;
   \       0x1A   0x6241             STR      R1,[R0, #+36]
    692            TIM_BDTRInitStruct->Break2AFMode    = LL_TIM_BREAK2_AFMODE_INPUT;
   \       0x1C   0x6281             STR      R1,[R0, #+40]
    693            TIM_BDTRInitStruct->AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;
   \       0x1E   0x62C1             STR      R1,[R0, #+44]
    694          }
   \       0x20   0x4770             BX       LR               ;; return
    695          
    696          /**
    697            * @brief  Configure the Break and Dead Time feature of the timer instance.
    698            * @note As the bits BK2P, BK2E, BK2F[3:0], BKF[3:0], AOE, BKP, BKE, OSSI, OSSR
    699            *  and DTG[7:0] can be write-locked depending on the LOCK configuration, it
    700            *  can be necessary to configure all of them during the first write access to
    701            *  the TIMx_BDTR register.
    702            * @note Macro IS_TIM_BREAK_INSTANCE(TIMx) can be used to check whether or not
    703            *       a timer instance provides a break input.
    704            * @note Macro IS_TIM_BKIN2_INSTANCE(TIMx) can be used to check whether or not
    705            *       a timer instance provides a second break input.
    706            * @param  TIMx Timer Instance
    707            * @param  TIM_BDTRInitStruct pointer to a @ref LL_TIM_BDTR_InitTypeDef structure (Break and Dead Time configuration data structure)
    708            * @retval An ErrorStatus enumeration value:
    709            *          - SUCCESS: Break and Dead Time is initialized
    710            *          - ERROR: not applicable
    711            */

   \                                 In section .text, align 2, keep-with-next
    712          ErrorStatus LL_TIM_BDTR_Init(TIM_TypeDef *TIMx, LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct)
    713          {
   \                     LL_TIM_BDTR_Init: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x0002             MOVS     R2,R0
    714            uint32_t tmpbdtr = 0;
   \        0x4   0x2000             MOVS     R0,#+0
    715          
    716            /* Check the parameters */
    717            assert_param(IS_TIM_BREAK_INSTANCE(TIMx));
    718            assert_param(IS_LL_TIM_OSSR_STATE(TIM_BDTRInitStruct->OSSRState));
    719            assert_param(IS_LL_TIM_OSSI_STATE(TIM_BDTRInitStruct->OSSIState));
    720            assert_param(IS_LL_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->LockLevel));
    721            assert_param(IS_LL_TIM_BREAK_STATE(TIM_BDTRInitStruct->BreakState));
    722            assert_param(IS_LL_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->BreakPolarity));
    723            assert_param(IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->AutomaticOutput));
    724          
    725            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
    726            the OSSI State, the dead time value and the Automatic Output Enable Bit */
    727          
    728            /* Set the BDTR bits */
    729            MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, TIM_BDTRInitStruct->DeadTime);
   \        0x6   0x23FF             MOVS     R3,#+255
   \        0x8   0x4398             BICS     R0,R0,R3
   \        0xA   0x7B0B             LDRB     R3,[R1, #+12]
   \        0xC   0x4303             ORRS     R3,R3,R0
    730            MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, TIM_BDTRInitStruct->LockLevel);
   \        0xE   0x....             LDR      R4,??DataTable14_1  ;; 0xfffffcff
   \       0x10   0x401C             ANDS     R4,R4,R3
   \       0x12   0x6888             LDR      R0,[R1, #+8]
   \       0x14   0x4320             ORRS     R0,R0,R4
    731            MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, TIM_BDTRInitStruct->OSSIState);
   \       0x16   0x....             LDR      R3,??DataTable14_2  ;; 0xfffffbff
   \       0x18   0x4003             ANDS     R3,R3,R0
   \       0x1A   0x6848             LDR      R0,[R1, #+4]
   \       0x1C   0x4318             ORRS     R0,R0,R3
    732            MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, TIM_BDTRInitStruct->OSSRState);
   \       0x1E   0x....             LDR      R3,??DataTable14_3  ;; 0xfffff7ff
   \       0x20   0x4003             ANDS     R3,R3,R0
   \       0x22   0x6808             LDR      R0,[R1, #+0]
   \       0x24   0x4318             ORRS     R0,R0,R3
    733            MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, TIM_BDTRInitStruct->BreakState);
   \       0x26   0x....             LDR      R3,??DataTable14_4  ;; 0xffffefff
   \       0x28   0x4003             ANDS     R3,R3,R0
   \       0x2A   0x89C8             LDRH     R0,[R1, #+14]
   \       0x2C   0x4303             ORRS     R3,R3,R0
    734            MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, TIM_BDTRInitStruct->BreakPolarity);
   \       0x2E   0x....             LDR      R4,??DataTable14_5  ;; 0xffffdfff
   \       0x30   0x401C             ANDS     R4,R4,R3
   \       0x32   0x6908             LDR      R0,[R1, #+16]
   \       0x34   0x4320             ORRS     R0,R0,R4
    735            MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, TIM_BDTRInitStruct->AutomaticOutput);
   \       0x36   0x....             LDR      R3,??DataTable14_6  ;; 0xffffbfff
   \       0x38   0x4003             ANDS     R3,R3,R0
   \       0x3A   0x6AC8             LDR      R0,[R1, #+44]
   \       0x3C   0x4318             ORRS     R0,R0,R3
    736            MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, TIM_BDTRInitStruct->AutomaticOutput);
   \       0x3E   0x....             LDR      R4,??DataTable15  ;; 0xffff7fff
   \       0x40   0x4004             ANDS     R4,R4,R0
   \       0x42   0x6ACB             LDR      R3,[R1, #+44]
   \       0x44   0x4323             ORRS     R3,R3,R4
    737            if (IS_TIM_ADVANCED_INSTANCE(TIMx))
   \       0x46   0x....             LDR      R4,??DataTable15_1  ;; 0x40012c00
   \       0x48   0x42A2             CMP      R2,R4
   \       0x4A   0xD107             BNE      ??LL_TIM_BDTR_Init_0
    738            {
    739              assert_param(IS_LL_TIM_BREAK_FILTER(TIM_BDTRInitStruct->BreakFilter));
    740              assert_param(IS_LL_TIM_BREAK_AFMODE(TIM_BDTRInitStruct->BreakAFMode));
    741              MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, TIM_BDTRInitStruct->BreakFilter);
   \       0x4C   0x....             LDR      R5,??DataTable15_2  ;; 0xfff0ffff
   \       0x4E   0x401D             ANDS     R5,R5,R3
   \       0x50   0x6948             LDR      R0,[R1, #+20]
   \       0x52   0x4328             ORRS     R0,R0,R5
    742              MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, TIM_BDTRInitStruct->BreakAFMode);
   \       0x54   0x....             LDR      R5,??DataTable15_3  ;; 0xefffffff
   \       0x56   0x4005             ANDS     R5,R5,R0
   \       0x58   0x698B             LDR      R3,[R1, #+24]
   \       0x5A   0x432B             ORRS     R3,R3,R5
    743            }
    744          
    745            if (IS_TIM_BKIN2_INSTANCE(TIMx))
   \                     ??LL_TIM_BDTR_Init_0: (+1)
   \       0x5C   0x42A2             CMP      R2,R4
   \       0x5E   0xD10F             BNE      ??LL_TIM_BDTR_Init_1
    746            {
    747              assert_param(IS_LL_TIM_BREAK2_STATE(TIM_BDTRInitStruct->Break2State));
    748              assert_param(IS_LL_TIM_BREAK2_POLARITY(TIM_BDTRInitStruct->Break2Polarity));
    749              assert_param(IS_LL_TIM_BREAK2_FILTER(TIM_BDTRInitStruct->Break2Filter));
    750              assert_param(IS_LL_TIM_BREAK2_AFMODE(TIM_BDTRInitStruct->Break2AFMode));
    751          
    752              /* Set the BREAK2 input related BDTR bit-fields */
    753              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (TIM_BDTRInitStruct->Break2Filter));
   \       0x60   0x....             LDR      R4,??DataTable15_4  ;; 0xff0fffff
   \       0x62   0x401C             ANDS     R4,R4,R3
   \       0x64   0x6A48             LDR      R0,[R1, #+36]
   \       0x66   0x4320             ORRS     R0,R0,R4
    754              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, TIM_BDTRInitStruct->Break2State);
   \       0x68   0x....             LDR      R3,??DataTable15_5  ;; 0xfeffffff
   \       0x6A   0x4003             ANDS     R3,R3,R0
   \       0x6C   0x69C8             LDR      R0,[R1, #+28]
   \       0x6E   0x4318             ORRS     R0,R0,R3
    755              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, TIM_BDTRInitStruct->Break2Polarity);
   \       0x70   0x....             LDR      R3,??DataTable15_6  ;; 0xfdffffff
   \       0x72   0x4003             ANDS     R3,R3,R0
   \       0x74   0x6A08             LDR      R0,[R1, #+32]
   \       0x76   0x4318             ORRS     R0,R0,R3
    756              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, TIM_BDTRInitStruct->Break2AFMode);
   \       0x78   0x....             LDR      R4,??DataTable16  ;; 0xdfffffff
   \       0x7A   0x4004             ANDS     R4,R4,R0
   \       0x7C   0x6A8B             LDR      R3,[R1, #+40]
   \       0x7E   0x4323             ORRS     R3,R3,R4
    757            }
    758          
    759            /* Set TIMx_BDTR */
    760            LL_TIM_WriteReg(TIMx, BDTR, tmpbdtr);
   \                     ??LL_TIM_BDTR_Init_1: (+1)
   \       0x80   0x6453             STR      R3,[R2, #+68]
    761          
    762            return SUCCESS;
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xBD30             POP      {R4,R5,PC}       ;; return
    763          }
    764          /**
    765            * @}
    766            */
    767          
    768          /**
    769            * @}
    770            */
    771          
    772          /** @addtogroup TIM_LL_Private_Functions TIM Private Functions
    773            *  @brief   Private functions
    774            * @{
    775            */
    776          /**
    777            * @brief  Configure the TIMx output channel 1.
    778            * @param  TIMx Timer Instance
    779            * @param  TIM_OCInitStruct pointer to the the TIMx output channel 1 configuration data structure
    780            * @retval An ErrorStatus enumeration value:
    781            *          - SUCCESS: TIMx registers are de-initialized
    782            *          - ERROR: not applicable
    783            */

   \                                 In section .text, align 2, keep-with-next
    784          static ErrorStatus OC1Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
    785          {
   \                     OC1Config: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
    786            uint32_t tmpccmr1;
    787            uint32_t tmpccer;
    788            uint32_t tmpcr2;
    789          
    790            /* Check the parameters */
    791            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
    792            assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
    793            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
    794            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
    795            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
    796            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
    797          
    798            /* Disable the Channel 1: Reset the CC1E Bit */
    799            CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
   \        0x6   0x6A20             LDR      R0,[R4, #+32]
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA   0x4388             BICS     R0,R0,R1
   \        0xC   0x6220             STR      R0,[R4, #+32]
    800          
    801            /* Get the TIMx CCER register value */
    802            tmpccer = LL_TIM_ReadReg(TIMx, CCER);
   \        0xE   0x6A20             LDR      R0,[R4, #+32]
    803          
    804            /* Get the TIMx CR2 register value */
    805            tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
   \       0x10   0x6866             LDR      R6,[R4, #+4]
    806          
    807            /* Get the TIMx CCMR1 register value */
    808            tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
   \       0x12   0x69A1             LDR      R1,[R4, #+24]
    809          
    810            /* Reset Capture/Compare selection Bits */
    811            CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);
   \       0x14   0x2203             MOVS     R2,#+3
   \       0x16   0x4391             BICS     R1,R1,R2
    812          
    813            /* Set the Output Compare Mode */
    814            MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
   \       0x18   0x....             LDR      R2,??DataTable16_1  ;; 0xfffeff8f
   \       0x1A   0x400A             ANDS     R2,R2,R1
   \       0x1C   0x6839             LDR      R1,[R7, #+0]
   \       0x1E   0x4311             ORRS     R1,R1,R2
   \       0x20   0x9100             STR      R1,[SP, #+0]
    815          
    816            /* Set the Output Compare Polarity */
    817            MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);
   \       0x22   0x2102             MOVS     R1,#+2
   \       0x24   0x4388             BICS     R0,R0,R1
   \       0x26   0x6939             LDR      R1,[R7, #+16]
   \       0x28   0x4301             ORRS     R1,R1,R0
    818          
    819            /* Set the Output State */
    820            MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0x4381             BICS     R1,R1,R0
   \       0x2E   0x687D             LDR      R5,[R7, #+4]
   \       0x30   0x430D             ORRS     R5,R5,R1
    821          
    822            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x32   0x....             LDR      R0,??DataTable15_1  ;; 0x40012c00
   \       0x34   0x4284             CMP      R4,R0
   \       0x36   0xD005             BEQ      ??OC1Config_0
   \       0x38   0x....             LDR      R0,??DataTable17  ;; 0x40014400
   \       0x3A   0x4284             CMP      R4,R0
   \       0x3C   0xD002             BEQ      ??OC1Config_0
   \       0x3E   0x....             LDR      R0,??DataTable18  ;; 0x40014800
   \       0x40   0x4284             CMP      R4,R0
   \       0x42   0xD112             BNE      ??OC1Config_1
    823            {
    824              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    825              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
    826          
    827              /* Set the complementary output Polarity */
    828              MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);
   \                     ??OC1Config_0: (+1)
   \       0x44   0x2008             MOVS     R0,#+8
   \       0x46   0x4385             BICS     R5,R5,R0
   \       0x48   0x6978             LDR      R0,[R7, #+20]
   \       0x4A   0x0080             LSLS     R0,R0,#+2
   \       0x4C   0x4328             ORRS     R0,R0,R5
    829          
    830              /* Set the complementary output State */
    831              MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);
   \       0x4E   0x2104             MOVS     R1,#+4
   \       0x50   0x4388             BICS     R0,R0,R1
   \       0x52   0x68B9             LDR      R1,[R7, #+8]
   \       0x54   0x008D             LSLS     R5,R1,#+2
   \       0x56   0x4305             ORRS     R5,R5,R0
    832          
    833              /* Set the Output Idle state */
    834              MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);
   \       0x58   0x....             LDR      R1,??DataTable16_2  ;; 0xfffffeff
   \       0x5A   0x4031             ANDS     R1,R1,R6
   \       0x5C   0x69B8             LDR      R0,[R7, #+24]
   \       0x5E   0x4308             ORRS     R0,R0,R1
    835          
    836              /* Set the complementary output Idle state */
    837              MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);
   \       0x60   0x....             LDR      R1,??DataTable18_1  ;; 0xfffffdff
   \       0x62   0x4001             ANDS     R1,R1,R0
   \       0x64   0x69F8             LDR      R0,[R7, #+28]
   \       0x66   0x0046             LSLS     R6,R0,#+1
   \       0x68   0x430E             ORRS     R6,R6,R1
    838            }
    839          
    840            /* Write to TIMx CR2 */
    841            LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
   \                     ??OC1Config_1: (+1)
   \       0x6A   0x6066             STR      R6,[R4, #+4]
    842          
    843            /* Write to TIMx CCMR1 */
    844            LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
   \       0x6C   0x9800             LDR      R0,[SP, #+0]
   \       0x6E   0x61A0             STR      R0,[R4, #+24]
    845          
    846            /* Set the Capture Compare Register value */
    847            LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);
   \       0x70   0x68F9             LDR      R1,[R7, #+12]
   \       0x72   0x0020             MOVS     R0,R4
   \       0x74   0x....'....        BL       LL_TIM_OC_SetCompareCH1
    848          
    849            /* Write to TIMx CCER */
    850            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   \       0x78   0x6225             STR      R5,[R4, #+32]
    851          
    852            return SUCCESS;
   \       0x7A   0x2000             MOVS     R0,#+0
   \       0x7C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    853          }
    854          
    855          /**
    856            * @brief  Configure the TIMx output channel 2.
    857            * @param  TIMx Timer Instance
    858            * @param  TIM_OCInitStruct pointer to the the TIMx output channel 2 configuration data structure
    859            * @retval An ErrorStatus enumeration value:
    860            *          - SUCCESS: TIMx registers are de-initialized
    861            *          - ERROR: not applicable
    862            */

   \                                 In section .text, align 2, keep-with-next
    863          static ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
    864          {
   \                     OC2Config: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
    865            uint32_t tmpccmr1;
    866            uint32_t tmpccer;
    867            uint32_t tmpcr2;
    868          
    869            /* Check the parameters */
    870            assert_param(IS_TIM_CC2_INSTANCE(TIMx));
    871            assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
    872            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
    873            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
    874            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
    875            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
    876          
    877            /* Disable the Channel 2: Reset the CC2E Bit */
    878            CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
   \        0x6   0x2010             MOVS     R0,#+16
   \        0x8   0x43C0             MVNS     R0,R0            ;; #-17
   \        0xA   0x6A21             LDR      R1,[R4, #+32]
   \        0xC   0x4001             ANDS     R1,R1,R0
   \        0xE   0x6221             STR      R1,[R4, #+32]
    879          
    880            /* Get the TIMx CCER register value */
    881            tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
   \       0x10   0x6A21             LDR      R1,[R4, #+32]
    882          
    883            /* Get the TIMx CR2 register value */
    884            tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
   \       0x12   0x6866             LDR      R6,[R4, #+4]
    885          
    886            /* Get the TIMx CCMR1 register value */
    887            tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
   \       0x14   0x69A2             LDR      R2,[R4, #+24]
    888          
    889            /* Reset Capture/Compare selection Bits */
    890            CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);
   \       0x16   0x....             LDR      R3,??DataTable14_1  ;; 0xfffffcff
   \       0x18   0x4013             ANDS     R3,R3,R2
    891          
    892            /* Select the Output Compare Mode */
    893            MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
   \       0x1A   0x....             LDR      R2,??DataTable18_2  ;; 0xfeff8fff
   \       0x1C   0x401A             ANDS     R2,R2,R3
   \       0x1E   0x683B             LDR      R3,[R7, #+0]
   \       0x20   0x021B             LSLS     R3,R3,#+8
   \       0x22   0x4313             ORRS     R3,R3,R2
   \       0x24   0x9300             STR      R3,[SP, #+0]
    894          
    895            /* Set the Output Compare Polarity */
    896            MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);
   \       0x26   0x2220             MOVS     R2,#+32
   \       0x28   0x4391             BICS     R1,R1,R2
   \       0x2A   0x693A             LDR      R2,[R7, #+16]
   \       0x2C   0x0112             LSLS     R2,R2,#+4
   \       0x2E   0x430A             ORRS     R2,R2,R1
    897          
    898            /* Set the Output State */
    899            MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);
   \       0x30   0x4010             ANDS     R0,R0,R2
   \       0x32   0x6879             LDR      R1,[R7, #+4]
   \       0x34   0x010D             LSLS     R5,R1,#+4
   \       0x36   0x4305             ORRS     R5,R5,R0
    900          
    901            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x38   0x....             LDR      R0,??DataTable15_1  ;; 0x40012c00
   \       0x3A   0x4284             CMP      R4,R0
   \       0x3C   0xD005             BEQ      ??OC2Config_0
   \       0x3E   0x....             LDR      R0,??DataTable17  ;; 0x40014400
   \       0x40   0x4284             CMP      R4,R0
   \       0x42   0xD002             BEQ      ??OC2Config_0
   \       0x44   0x....             LDR      R0,??DataTable18  ;; 0x40014800
   \       0x46   0x4284             CMP      R4,R0
   \       0x48   0xD113             BNE      ??OC2Config_1
    902            {
    903              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    904              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
    905          
    906              /* Set the complementary output Polarity */
    907              MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);
   \                     ??OC2Config_0: (+1)
   \       0x4A   0x2080             MOVS     R0,#+128
   \       0x4C   0x4385             BICS     R5,R5,R0
   \       0x4E   0x6978             LDR      R0,[R7, #+20]
   \       0x50   0x0180             LSLS     R0,R0,#+6
   \       0x52   0x4328             ORRS     R0,R0,R5
    908          
    909              /* Set the complementary output State */
    910              MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);
   \       0x54   0x2140             MOVS     R1,#+64
   \       0x56   0x4388             BICS     R0,R0,R1
   \       0x58   0x68B9             LDR      R1,[R7, #+8]
   \       0x5A   0x018D             LSLS     R5,R1,#+6
   \       0x5C   0x4305             ORRS     R5,R5,R0
    911          
    912              /* Set the Output Idle state */
    913              MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);
   \       0x5E   0x....             LDR      R1,??DataTable14_2  ;; 0xfffffbff
   \       0x60   0x4031             ANDS     R1,R1,R6
   \       0x62   0x69B8             LDR      R0,[R7, #+24]
   \       0x64   0x0080             LSLS     R0,R0,#+2
   \       0x66   0x4308             ORRS     R0,R0,R1
    914          
    915              /* Set the complementary output Idle state */
    916              MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);
   \       0x68   0x....             LDR      R1,??DataTable14_3  ;; 0xfffff7ff
   \       0x6A   0x4001             ANDS     R1,R1,R0
   \       0x6C   0x69F8             LDR      R0,[R7, #+28]
   \       0x6E   0x00C6             LSLS     R6,R0,#+3
   \       0x70   0x430E             ORRS     R6,R6,R1
    917            }
    918          
    919            /* Write to TIMx CR2 */
    920            LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
   \                     ??OC2Config_1: (+1)
   \       0x72   0x6066             STR      R6,[R4, #+4]
    921          
    922            /* Write to TIMx CCMR1 */
    923            LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
   \       0x74   0x9800             LDR      R0,[SP, #+0]
   \       0x76   0x61A0             STR      R0,[R4, #+24]
    924          
    925            /* Set the Capture Compare Register value */
    926            LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);
   \       0x78   0x68F9             LDR      R1,[R7, #+12]
   \       0x7A   0x0020             MOVS     R0,R4
   \       0x7C   0x....'....        BL       LL_TIM_OC_SetCompareCH2
    927          
    928            /* Write to TIMx CCER */
    929            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   \       0x80   0x6225             STR      R5,[R4, #+32]
    930          
    931            return SUCCESS;
   \       0x82   0x2000             MOVS     R0,#+0
   \       0x84   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    932          }
    933          
    934          /**
    935            * @brief  Configure the TIMx output channel 3.
    936            * @param  TIMx Timer Instance
    937            * @param  TIM_OCInitStruct pointer to the the TIMx output channel 3 configuration data structure
    938            * @retval An ErrorStatus enumeration value:
    939            *          - SUCCESS: TIMx registers are de-initialized
    940            *          - ERROR: not applicable
    941            */

   \                                 In section .text, align 2, keep-with-next
    942          static ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
    943          {
   \                     OC3Config: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
    944            uint32_t tmpccmr2;
    945            uint32_t tmpccer;
    946            uint32_t tmpcr2;
    947          
    948            /* Check the parameters */
    949            assert_param(IS_TIM_CC3_INSTANCE(TIMx));
    950            assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
    951            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
    952            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
    953            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
    954            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
    955          
    956            /* Disable the Channel 3: Reset the CC3E Bit */
    957            CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
   \        0x6   0x....             LDR      R0,??DataTable16_2  ;; 0xfffffeff
   \        0x8   0x6A21             LDR      R1,[R4, #+32]
   \        0xA   0x4001             ANDS     R1,R1,R0
   \        0xC   0x6221             STR      R1,[R4, #+32]
    958          
    959            /* Get the TIMx CCER register value */
    960            tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
   \        0xE   0x6A21             LDR      R1,[R4, #+32]
    961          
    962            /* Get the TIMx CR2 register value */
    963            tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
   \       0x10   0x6866             LDR      R6,[R4, #+4]
    964          
    965            /* Get the TIMx CCMR2 register value */
    966            tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
   \       0x12   0x69E2             LDR      R2,[R4, #+28]
    967          
    968            /* Reset Capture/Compare selection Bits */
    969            CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);
   \       0x14   0x2303             MOVS     R3,#+3
   \       0x16   0x439A             BICS     R2,R2,R3
    970          
    971            /* Select the Output Compare Mode */
    972            MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
   \       0x18   0x....             LDR      R3,??DataTable16_1  ;; 0xfffeff8f
   \       0x1A   0x4013             ANDS     R3,R3,R2
   \       0x1C   0x683A             LDR      R2,[R7, #+0]
   \       0x1E   0x431A             ORRS     R2,R2,R3
   \       0x20   0x9200             STR      R2,[SP, #+0]
    973          
    974            /* Set the Output Compare Polarity */
    975            MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);
   \       0x22   0x....             LDR      R2,??DataTable18_1  ;; 0xfffffdff
   \       0x24   0x400A             ANDS     R2,R2,R1
   \       0x26   0x6939             LDR      R1,[R7, #+16]
   \       0x28   0x0209             LSLS     R1,R1,#+8
   \       0x2A   0x4311             ORRS     R1,R1,R2
    976          
    977            /* Set the Output State */
    978            MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);
   \       0x2C   0x4008             ANDS     R0,R0,R1
   \       0x2E   0x6879             LDR      R1,[R7, #+4]
   \       0x30   0x020D             LSLS     R5,R1,#+8
   \       0x32   0x4305             ORRS     R5,R5,R0
    979          
    980            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x34   0x....             LDR      R0,??DataTable15_1  ;; 0x40012c00
   \       0x36   0x4284             CMP      R4,R0
   \       0x38   0xD005             BEQ      ??OC3Config_0
   \       0x3A   0x....             LDR      R0,??DataTable17  ;; 0x40014400
   \       0x3C   0x4284             CMP      R4,R0
   \       0x3E   0xD002             BEQ      ??OC3Config_0
   \       0x40   0x....             LDR      R0,??DataTable18  ;; 0x40014800
   \       0x42   0x4284             CMP      R4,R0
   \       0x44   0xD113             BNE      ??OC3Config_1
    981            {
    982              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
    983              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
    984          
    985              /* Set the complementary output Polarity */
    986              MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);
   \                     ??OC3Config_0: (+1)
   \       0x46   0x....             LDR      R1,??DataTable14_3  ;; 0xfffff7ff
   \       0x48   0x4029             ANDS     R1,R1,R5
   \       0x4A   0x6978             LDR      R0,[R7, #+20]
   \       0x4C   0x0280             LSLS     R0,R0,#+10
   \       0x4E   0x4308             ORRS     R0,R0,R1
    987          
    988              /* Set the complementary output State */
    989              MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);
   \       0x50   0x....             LDR      R1,??DataTable14_2  ;; 0xfffffbff
   \       0x52   0x4001             ANDS     R1,R1,R0
   \       0x54   0x68B8             LDR      R0,[R7, #+8]
   \       0x56   0x0285             LSLS     R5,R0,#+10
   \       0x58   0x430D             ORRS     R5,R5,R1
    990          
    991              /* Set the Output Idle state */
    992              MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);
   \       0x5A   0x....             LDR      R1,??DataTable14_4  ;; 0xffffefff
   \       0x5C   0x4031             ANDS     R1,R1,R6
   \       0x5E   0x69B8             LDR      R0,[R7, #+24]
   \       0x60   0x0100             LSLS     R0,R0,#+4
   \       0x62   0x4308             ORRS     R0,R0,R1
    993          
    994              /* Set the complementary output Idle state */
    995              MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);
   \       0x64   0x....             LDR      R1,??DataTable14_5  ;; 0xffffdfff
   \       0x66   0x4001             ANDS     R1,R1,R0
   \       0x68   0x69F8             LDR      R0,[R7, #+28]
   \       0x6A   0x0146             LSLS     R6,R0,#+5
   \       0x6C   0x430E             ORRS     R6,R6,R1
    996            }
    997          
    998            /* Write to TIMx CR2 */
    999            LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
   \                     ??OC3Config_1: (+1)
   \       0x6E   0x6066             STR      R6,[R4, #+4]
   1000          
   1001            /* Write to TIMx CCMR2 */
   1002            LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
   \       0x70   0x9800             LDR      R0,[SP, #+0]
   \       0x72   0x61E0             STR      R0,[R4, #+28]
   1003          
   1004            /* Set the Capture Compare Register value */
   1005            LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);
   \       0x74   0x68F9             LDR      R1,[R7, #+12]
   \       0x76   0x0020             MOVS     R0,R4
   \       0x78   0x....'....        BL       LL_TIM_OC_SetCompareCH3
   1006          
   1007            /* Write to TIMx CCER */
   1008            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   \       0x7C   0x6225             STR      R5,[R4, #+32]
   1009          
   1010            return SUCCESS;
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1011          }
   1012          
   1013          /**
   1014            * @brief  Configure the TIMx output channel 4.
   1015            * @param  TIMx Timer Instance
   1016            * @param  TIM_OCInitStruct pointer to the the TIMx output channel 4 configuration data structure
   1017            * @retval An ErrorStatus enumeration value:
   1018            *          - SUCCESS: TIMx registers are de-initialized
   1019            *          - ERROR: not applicable
   1020            */

   \                                 In section .text, align 2, keep-with-next
   1021          static ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
   1022          {
   \                     OC4Config: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
   1023            uint32_t tmpccmr2;
   1024            uint32_t tmpccer;
   1025            uint32_t tmpcr2;
   1026          
   1027            /* Check the parameters */
   1028            assert_param(IS_TIM_CC4_INSTANCE(TIMx));
   1029            assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
   1030            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
   1031            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
   1032            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
   1033            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
   1034          
   1035            /* Disable the Channel 4: Reset the CC4E Bit */
   1036            CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
   \        0x6   0x....             LDR      R0,??DataTable14_4  ;; 0xffffefff
   \        0x8   0x6A21             LDR      R1,[R4, #+32]
   \        0xA   0x4001             ANDS     R1,R1,R0
   \        0xC   0x6221             STR      R1,[R4, #+32]
   1037          
   1038            /* Get the TIMx CCER register value */
   1039            tmpccer = LL_TIM_ReadReg(TIMx, CCER);
   \        0xE   0x6A21             LDR      R1,[R4, #+32]
   1040          
   1041            /* Get the TIMx CR2 register value */
   1042            tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);
   \       0x10   0x6865             LDR      R5,[R4, #+4]
   1043          
   1044            /* Get the TIMx CCMR2 register value */
   1045            tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
   \       0x12   0x69E2             LDR      R2,[R4, #+28]
   1046          
   1047            /* Reset Capture/Compare selection Bits */
   1048            CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);
   \       0x14   0x....             LDR      R3,??DataTable14_1  ;; 0xfffffcff
   \       0x16   0x4013             ANDS     R3,R3,R2
   1049          
   1050            /* Select the Output Compare Mode */
   1051            MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
   \       0x18   0x....             LDR      R2,??DataTable18_2  ;; 0xfeff8fff
   \       0x1A   0x401A             ANDS     R2,R2,R3
   \       0x1C   0x6833             LDR      R3,[R6, #+0]
   \       0x1E   0x021B             LSLS     R3,R3,#+8
   \       0x20   0x4313             ORRS     R3,R3,R2
   \       0x22   0x9300             STR      R3,[SP, #+0]
   1052          
   1053            /* Set the Output Compare Polarity */
   1054            MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);
   \       0x24   0x....             LDR      R2,??DataTable14_5  ;; 0xffffdfff
   \       0x26   0x400A             ANDS     R2,R2,R1
   \       0x28   0x6931             LDR      R1,[R6, #+16]
   \       0x2A   0x0309             LSLS     R1,R1,#+12
   \       0x2C   0x4311             ORRS     R1,R1,R2
   1055          
   1056            /* Set the Output State */
   1057            MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);
   \       0x2E   0x4008             ANDS     R0,R0,R1
   \       0x30   0x6871             LDR      R1,[R6, #+4]
   \       0x32   0x030F             LSLS     R7,R1,#+12
   \       0x34   0x4307             ORRS     R7,R7,R0
   1058          
   1059            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x36   0x....             LDR      R0,??DataTable15_1  ;; 0x40012c00
   \       0x38   0x4284             CMP      R4,R0
   \       0x3A   0xD005             BEQ      ??OC4Config_0
   \       0x3C   0x....             LDR      R0,??DataTable17  ;; 0x40014400
   \       0x3E   0x4284             CMP      R4,R0
   \       0x40   0xD002             BEQ      ??OC4Config_0
   \       0x42   0x....             LDR      R0,??DataTable18  ;; 0x40014800
   \       0x44   0x4284             CMP      R4,R0
   \       0x46   0xD104             BNE      ??OC4Config_1
   1060            {
   1061              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
   1062              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
   1063          
   1064              /* Set the Output Idle state */
   1065              MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);
   \                     ??OC4Config_0: (+1)
   \       0x48   0x....             LDR      R0,??DataTable14_6  ;; 0xffffbfff
   \       0x4A   0x4028             ANDS     R0,R0,R5
   \       0x4C   0x69B1             LDR      R1,[R6, #+24]
   \       0x4E   0x018D             LSLS     R5,R1,#+6
   \       0x50   0x4305             ORRS     R5,R5,R0
   1066            }
   1067          
   1068            /* Write to TIMx CR2 */
   1069            LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
   \                     ??OC4Config_1: (+1)
   \       0x52   0x6065             STR      R5,[R4, #+4]
   1070          
   1071            /* Write to TIMx CCMR2 */
   1072            LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
   \       0x54   0x9800             LDR      R0,[SP, #+0]
   \       0x56   0x61E0             STR      R0,[R4, #+28]
   1073          
   1074            /* Set the Capture Compare Register value */
   1075            LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);
   \       0x58   0x68F1             LDR      R1,[R6, #+12]
   \       0x5A   0x0020             MOVS     R0,R4
   \       0x5C   0x....'....        BL       LL_TIM_OC_SetCompareCH4
   1076          
   1077            /* Write to TIMx CCER */
   1078            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   \       0x60   0x6227             STR      R7,[R4, #+32]
   1079          
   1080            return SUCCESS;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1081          }
   1082          
   1083          /**
   1084            * @brief  Configure the TIMx output channel 5.
   1085            * @param  TIMx Timer Instance
   1086            * @param  TIM_OCInitStruct pointer to the the TIMx output channel 5 configuration data structure
   1087            * @retval An ErrorStatus enumeration value:
   1088            *          - SUCCESS: TIMx registers are de-initialized
   1089            *          - ERROR: not applicable
   1090            */

   \                                 In section .text, align 2, keep-with-next
   1091          static ErrorStatus OC5Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
   1092          {
   \                     OC5Config: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1093            uint32_t tmpccmr3;
   1094            uint32_t tmpccer;
   1095          
   1096            /* Check the parameters */
   1097            assert_param(IS_TIM_CC5_INSTANCE(TIMx));
   1098            assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
   1099            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
   1100            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
   1101            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
   1102            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
   1103          
   1104            /* Disable the Channel 5: Reset the CC5E Bit */
   1105            CLEAR_BIT(TIMx->CCER, TIM_CCER_CC5E);
   \        0x6   0x....             LDR      R0,??DataTable19  ;; 0xfffeffff
   \        0x8   0x6A21             LDR      R1,[R4, #+32]
   \        0xA   0x4001             ANDS     R1,R1,R0
   \        0xC   0x6221             STR      R1,[R4, #+32]
   1106          
   1107            /* Get the TIMx CCER register value */
   1108            tmpccer = LL_TIM_ReadReg(TIMx, CCER);
   \        0xE   0x6A22             LDR      R2,[R4, #+32]
   1109          
   1110            /* Get the TIMx CCMR3 register value */
   1111            tmpccmr3 = LL_TIM_ReadReg(TIMx, CCMR3);
   \       0x10   0x6D61             LDR      R1,[R4, #+84]
   1112          
   1113            /* Select the Output Compare Mode */
   1114            MODIFY_REG(tmpccmr3, TIM_CCMR3_OC5M, TIM_OCInitStruct->OCMode);
   \       0x12   0x....             LDR      R3,??DataTable16_1  ;; 0xfffeff8f
   \       0x14   0x400B             ANDS     R3,R3,R1
   \       0x16   0x682F             LDR      R7,[R5, #+0]
   \       0x18   0x431F             ORRS     R7,R7,R3
   1115          
   1116            /* Set the Output Compare Polarity */
   1117            MODIFY_REG(tmpccer, TIM_CCER_CC5P, TIM_OCInitStruct->OCPolarity << 16U);
   \       0x1A   0x....             LDR      R3,??DataTable19_1  ;; 0xfffdffff
   \       0x1C   0x4013             ANDS     R3,R3,R2
   \       0x1E   0x6929             LDR      R1,[R5, #+16]
   \       0x20   0x0409             LSLS     R1,R1,#+16
   \       0x22   0x4319             ORRS     R1,R1,R3
   1118          
   1119            /* Set the Output State */
   1120            MODIFY_REG(tmpccer, TIM_CCER_CC5E, TIM_OCInitStruct->OCState << 16U);
   \       0x24   0x4001             ANDS     R1,R1,R0
   \       0x26   0x686A             LDR      R2,[R5, #+4]
   \       0x28   0x0416             LSLS     R6,R2,#+16
   \       0x2A   0x430E             ORRS     R6,R6,R1
   1121          
   1122            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x2C   0x....             LDR      R1,??DataTable15_1  ;; 0x40012c00
   \       0x2E   0x428C             CMP      R4,R1
   \       0x30   0xD005             BEQ      ??OC5Config_0
   \       0x32   0x....             LDR      R1,??DataTable17  ;; 0x40014400
   \       0x34   0x428C             CMP      R4,R1
   \       0x36   0xD002             BEQ      ??OC5Config_0
   \       0x38   0x....             LDR      R1,??DataTable18  ;; 0x40014800
   \       0x3A   0x428C             CMP      R4,R1
   \       0x3C   0xD105             BNE      ??OC5Config_1
   1123            {
   1124              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
   1125              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
   1126          
   1127              /* Set the Output Idle state */
   1128              MODIFY_REG(TIMx->CR2, TIM_CR2_OIS5, TIM_OCInitStruct->OCIdleState << 8U);
   \                     ??OC5Config_0: (+1)
   \       0x3E   0x6861             LDR      R1,[R4, #+4]
   \       0x40   0x4008             ANDS     R0,R0,R1
   \       0x42   0x69A9             LDR      R1,[R5, #+24]
   \       0x44   0x0209             LSLS     R1,R1,#+8
   \       0x46   0x4301             ORRS     R1,R1,R0
   \       0x48   0x6061             STR      R1,[R4, #+4]
   1129          
   1130            }
   1131          
   1132            /* Write to TIMx CCMR3 */
   1133            LL_TIM_WriteReg(TIMx, CCMR3, tmpccmr3);
   \                     ??OC5Config_1: (+1)
   \       0x4A   0x6567             STR      R7,[R4, #+84]
   1134          
   1135            /* Set the Capture Compare Register value */
   1136            LL_TIM_OC_SetCompareCH5(TIMx, TIM_OCInitStruct->CompareValue);
   \       0x4C   0x68E9             LDR      R1,[R5, #+12]
   \       0x4E   0x0020             MOVS     R0,R4
   \       0x50   0x....'....        BL       LL_TIM_OC_SetCompareCH5
   1137          
   1138            /* Write to TIMx CCER */
   1139            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   \       0x54   0x6226             STR      R6,[R4, #+32]
   1140          
   1141            return SUCCESS;
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1142          }
   1143          
   1144          /**
   1145            * @brief  Configure the TIMx output channel 6.
   1146            * @param  TIMx Timer Instance
   1147            * @param  TIM_OCInitStruct pointer to the the TIMx output channel 6 configuration data structure
   1148            * @retval An ErrorStatus enumeration value:
   1149            *          - SUCCESS: TIMx registers are de-initialized
   1150            *          - ERROR: not applicable
   1151            */

   \                                 In section .text, align 2, keep-with-next
   1152          static ErrorStatus OC6Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
   1153          {
   \                     OC6Config: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1154            uint32_t tmpccmr3;
   1155            uint32_t tmpccer;
   1156          
   1157            /* Check the parameters */
   1158            assert_param(IS_TIM_CC6_INSTANCE(TIMx));
   1159            assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
   1160            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
   1161            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
   1162            assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
   1163            assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
   1164          
   1165            /* Disable the Channel 5: Reset the CC6E Bit */
   1166            CLEAR_BIT(TIMx->CCER, TIM_CCER_CC6E);
   \        0x6   0x....             LDR      R0,??DataTable19_2  ;; 0xffefffff
   \        0x8   0x6A21             LDR      R1,[R4, #+32]
   \        0xA   0x4001             ANDS     R1,R1,R0
   \        0xC   0x6221             STR      R1,[R4, #+32]
   1167          
   1168            /* Get the TIMx CCER register value */
   1169            tmpccer = LL_TIM_ReadReg(TIMx, CCER);
   \        0xE   0x6A21             LDR      R1,[R4, #+32]
   1170          
   1171            /* Get the TIMx CCMR3 register value */
   1172            tmpccmr3 = LL_TIM_ReadReg(TIMx, CCMR3);
   \       0x10   0x6D62             LDR      R2,[R4, #+84]
   1173          
   1174            /* Select the Output Compare Mode */
   1175            MODIFY_REG(tmpccmr3, TIM_CCMR3_OC6M, TIM_OCInitStruct->OCMode << 8U);
   \       0x12   0x....             LDR      R3,??DataTable18_2  ;; 0xfeff8fff
   \       0x14   0x4013             ANDS     R3,R3,R2
   \       0x16   0x682A             LDR      R2,[R5, #+0]
   \       0x18   0x0217             LSLS     R7,R2,#+8
   \       0x1A   0x431F             ORRS     R7,R7,R3
   1176          
   1177            /* Set the Output Compare Polarity */
   1178            MODIFY_REG(tmpccer, TIM_CCER_CC6P, TIM_OCInitStruct->OCPolarity << 20U);
   \       0x1C   0x....             LDR      R2,??DataTable19_3  ;; 0xffdfffff
   \       0x1E   0x400A             ANDS     R2,R2,R1
   \       0x20   0x6929             LDR      R1,[R5, #+16]
   \       0x22   0x0509             LSLS     R1,R1,#+20
   \       0x24   0x4311             ORRS     R1,R1,R2
   1179          
   1180            /* Set the Output State */
   1181            MODIFY_REG(tmpccer, TIM_CCER_CC6E, TIM_OCInitStruct->OCState << 20U);
   \       0x26   0x4008             ANDS     R0,R0,R1
   \       0x28   0x6869             LDR      R1,[R5, #+4]
   \       0x2A   0x050E             LSLS     R6,R1,#+20
   \       0x2C   0x4306             ORRS     R6,R6,R0
   1182          
   1183            if (IS_TIM_BREAK_INSTANCE(TIMx))
   \       0x2E   0x....             LDR      R0,??DataTable19_4  ;; 0x40012c00
   \       0x30   0x4284             CMP      R4,R0
   \       0x32   0xD005             BEQ      ??OC6Config_0
   \       0x34   0x....             LDR      R0,??DataTable17  ;; 0x40014400
   \       0x36   0x4284             CMP      R4,R0
   \       0x38   0xD002             BEQ      ??OC6Config_0
   \       0x3A   0x....             LDR      R0,??DataTable18  ;; 0x40014800
   \       0x3C   0x4284             CMP      R4,R0
   \       0x3E   0xD106             BNE      ??OC6Config_1
   1184            {
   1185              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
   1186              assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
   1187          
   1188              /* Set the Output Idle state */
   1189              MODIFY_REG(TIMx->CR2, TIM_CR2_OIS6, TIM_OCInitStruct->OCIdleState << 10U);
   \                     ??OC6Config_0: (+1)
   \       0x40   0x6860             LDR      R0,[R4, #+4]
   \       0x42   0x....             LDR      R1,??DataTable19_5  ;; 0xfffbffff
   \       0x44   0x4001             ANDS     R1,R1,R0
   \       0x46   0x69A8             LDR      R0,[R5, #+24]
   \       0x48   0x0280             LSLS     R0,R0,#+10
   \       0x4A   0x4308             ORRS     R0,R0,R1
   \       0x4C   0x6060             STR      R0,[R4, #+4]
   1190            }
   1191          
   1192            /* Write to TIMx CCMR3 */
   1193            LL_TIM_WriteReg(TIMx, CCMR3, tmpccmr3);
   \                     ??OC6Config_1: (+1)
   \       0x4E   0x6567             STR      R7,[R4, #+84]
   1194          
   1195            /* Set the Capture Compare Register value */
   1196            LL_TIM_OC_SetCompareCH6(TIMx, TIM_OCInitStruct->CompareValue);
   \       0x50   0x68E9             LDR      R1,[R5, #+12]
   \       0x52   0x0020             MOVS     R0,R4
   \       0x54   0x....'....        BL       LL_TIM_OC_SetCompareCH6
   1197          
   1198            /* Write to TIMx CCER */
   1199            LL_TIM_WriteReg(TIMx, CCER, tmpccer);
   \       0x58   0x6226             STR      R6,[R4, #+32]
   1200          
   1201            return SUCCESS;
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1202          }
   1203          
   1204          /**
   1205            * @brief  Configure the TIMx input channel 1.
   1206            * @param  TIMx Timer Instance
   1207            * @param  TIM_ICInitStruct pointer to the the TIMx input channel 1 configuration data structure
   1208            * @retval An ErrorStatus enumeration value:
   1209            *          - SUCCESS: TIMx registers are de-initialized
   1210            *          - ERROR: not applicable
   1211            */

   \                                 In section .text, align 2, keep-with-next
   1212          static ErrorStatus IC1Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
   1213          {
   \                     IC1Config: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
   1214            /* Check the parameters */
   1215            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   1216            assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
   1217            assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
   1218            assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
   1219            assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
   1220          
   1221            /* Disable the Channel 1: Reset the CC1E Bit */
   1222            TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
   \        0x4   0x6A10             LDR      R0,[R2, #+32]
   \        0x6   0x2301             MOVS     R3,#+1
   \        0x8   0x4398             BICS     R0,R0,R3
   \        0xA   0x6210             STR      R0,[R2, #+32]
   1223          
   1224            /* Select the Input and set the filter and the prescaler value */
   1225            MODIFY_REG(TIMx->CCMR1,
   1226                       (TIM_CCMR1_CC1S | TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC),
   1227                       (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 16U);
   \        0xC   0x6990             LDR      R0,[R2, #+24]
   \        0xE   0x23FF             MOVS     R3,#+255
   \       0x10   0x4398             BICS     R0,R0,R3
   \       0x12   0x684B             LDR      R3,[R1, #+4]
   \       0x14   0x68CC             LDR      R4,[R1, #+12]
   \       0x16   0x431C             ORRS     R4,R4,R3
   \       0x18   0x688B             LDR      R3,[R1, #+8]
   \       0x1A   0x4323             ORRS     R3,R3,R4
   \       0x1C   0x0C1B             LSRS     R3,R3,#+16
   \       0x1E   0x4303             ORRS     R3,R3,R0
   \       0x20   0x6193             STR      R3,[R2, #+24]
   1228          
   1229            /* Select the Polarity and set the CC1E Bit */
   1230            MODIFY_REG(TIMx->CCER,
   1231                       (TIM_CCER_CC1P | TIM_CCER_CC1NP),
   1232                       (TIM_ICInitStruct->ICPolarity | TIM_CCER_CC1E));
   \       0x22   0x6A10             LDR      R0,[R2, #+32]
   \       0x24   0x230A             MOVS     R3,#+10
   \       0x26   0x4398             BICS     R0,R0,R3
   \       0x28   0x680B             LDR      R3,[R1, #+0]
   \       0x2A   0x4303             ORRS     R3,R3,R0
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0x4318             ORRS     R0,R0,R3
   \       0x30   0x6210             STR      R0,[R2, #+32]
   1233          
   1234            return SUCCESS;
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBC10             POP      {R4}
   \       0x36   0x4770             BX       LR               ;; return
   1235          }
   1236          
   1237          /**
   1238            * @brief  Configure the TIMx input channel 2.
   1239            * @param  TIMx Timer Instance
   1240            * @param  TIM_ICInitStruct pointer to the the TIMx input channel 2 configuration data structure
   1241            * @retval An ErrorStatus enumeration value:
   1242            *          - SUCCESS: TIMx registers are de-initialized
   1243            *          - ERROR: not applicable
   1244            */

   \                                 In section .text, align 2, keep-with-next
   1245          static ErrorStatus IC2Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
   1246          {
   \                     IC2Config: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
   1247            /* Check the parameters */
   1248            assert_param(IS_TIM_CC2_INSTANCE(TIMx));
   1249            assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
   1250            assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
   1251            assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
   1252            assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
   1253          
   1254            /* Disable the Channel 2: Reset the CC2E Bit */
   1255            TIMx->CCER &= (uint32_t)~TIM_CCER_CC2E;
   \        0x4   0x6A10             LDR      R0,[R2, #+32]
   \        0x6   0x2310             MOVS     R3,#+16
   \        0x8   0x4398             BICS     R0,R0,R3
   \        0xA   0x6210             STR      R0,[R2, #+32]
   1256          
   1257            /* Select the Input and set the filter and the prescaler value */
   1258            MODIFY_REG(TIMx->CCMR1,
   1259                       (TIM_CCMR1_CC2S | TIM_CCMR1_IC2F | TIM_CCMR1_IC2PSC),
   1260                       (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 8U);
   \        0xC   0x6990             LDR      R0,[R2, #+24]
   \        0xE   0x....             LDR      R3,??DataTable19_6  ;; 0xffff00ff
   \       0x10   0x4003             ANDS     R3,R3,R0
   \       0x12   0x6848             LDR      R0,[R1, #+4]
   \       0x14   0x68CC             LDR      R4,[R1, #+12]
   \       0x16   0x4304             ORRS     R4,R4,R0
   \       0x18   0x6888             LDR      R0,[R1, #+8]
   \       0x1A   0x4320             ORRS     R0,R0,R4
   \       0x1C   0x0A00             LSRS     R0,R0,#+8
   \       0x1E   0x4318             ORRS     R0,R0,R3
   \       0x20   0x6190             STR      R0,[R2, #+24]
   1261          
   1262            /* Select the Polarity and set the CC2E Bit */
   1263            MODIFY_REG(TIMx->CCER,
   1264                       (TIM_CCER_CC2P | TIM_CCER_CC2NP),
   1265                       ((TIM_ICInitStruct->ICPolarity << 4U) | TIM_CCER_CC2E));
   \       0x22   0x6A10             LDR      R0,[R2, #+32]
   \       0x24   0x23A0             MOVS     R3,#+160
   \       0x26   0x4398             BICS     R0,R0,R3
   \       0x28   0x680B             LDR      R3,[R1, #+0]
   \       0x2A   0x011B             LSLS     R3,R3,#+4
   \       0x2C   0x4303             ORRS     R3,R3,R0
   \       0x2E   0x2010             MOVS     R0,#+16
   \       0x30   0x4318             ORRS     R0,R0,R3
   \       0x32   0x6210             STR      R0,[R2, #+32]
   1266          
   1267            return SUCCESS;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0xBC10             POP      {R4}
   \       0x38   0x4770             BX       LR               ;; return
   1268          }
   1269          
   1270          /**
   1271            * @brief  Configure the TIMx input channel 3.
   1272            * @param  TIMx Timer Instance
   1273            * @param  TIM_ICInitStruct pointer to the the TIMx input channel 3 configuration data structure
   1274            * @retval An ErrorStatus enumeration value:
   1275            *          - SUCCESS: TIMx registers are de-initialized
   1276            *          - ERROR: not applicable
   1277            */

   \                                 In section .text, align 2, keep-with-next
   1278          static ErrorStatus IC3Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
   1279          {
   \                     IC3Config: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
   1280            /* Check the parameters */
   1281            assert_param(IS_TIM_CC3_INSTANCE(TIMx));
   1282            assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
   1283            assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
   1284            assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
   1285            assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
   1286          
   1287            /* Disable the Channel 3: Reset the CC3E Bit */
   1288            TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;
   \        0x4   0x6A10             LDR      R0,[R2, #+32]
   \        0x6   0x....             LDR      R3,??DataTable19_7  ;; 0xfffffeff
   \        0x8   0x4003             ANDS     R3,R3,R0
   \        0xA   0x6213             STR      R3,[R2, #+32]
   1289          
   1290            /* Select the Input and set the filter and the prescaler value */
   1291            MODIFY_REG(TIMx->CCMR2,
   1292                       (TIM_CCMR2_CC3S | TIM_CCMR2_IC3F | TIM_CCMR2_IC3PSC),
   1293                       (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 16U);
   \        0xC   0x69D0             LDR      R0,[R2, #+28]
   \        0xE   0x23FF             MOVS     R3,#+255
   \       0x10   0x4398             BICS     R0,R0,R3
   \       0x12   0x684B             LDR      R3,[R1, #+4]
   \       0x14   0x68CC             LDR      R4,[R1, #+12]
   \       0x16   0x431C             ORRS     R4,R4,R3
   \       0x18   0x688B             LDR      R3,[R1, #+8]
   \       0x1A   0x4323             ORRS     R3,R3,R4
   \       0x1C   0x0C1B             LSRS     R3,R3,#+16
   \       0x1E   0x4303             ORRS     R3,R3,R0
   \       0x20   0x61D3             STR      R3,[R2, #+28]
   1294          
   1295            /* Select the Polarity and set the CC3E Bit */
   1296            MODIFY_REG(TIMx->CCER,
   1297                       (TIM_CCER_CC3P | TIM_CCER_CC3NP),
   1298                       ((TIM_ICInitStruct->ICPolarity << 8U) | TIM_CCER_CC3E));
   \       0x22   0x6A10             LDR      R0,[R2, #+32]
   \       0x24   0x....             LDR      R3,??DataTable19_8  ;; 0xfffff5ff
   \       0x26   0x4003             ANDS     R3,R3,R0
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   \       0x2A   0x0200             LSLS     R0,R0,#+8
   \       0x2C   0x4318             ORRS     R0,R0,R3
   \       0x2E   0x2380             MOVS     R3,#+128
   \       0x30   0x005B             LSLS     R3,R3,#+1        ;; #+256
   \       0x32   0x4303             ORRS     R3,R3,R0
   \       0x34   0x6213             STR      R3,[R2, #+32]
   1299          
   1300            return SUCCESS;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBC10             POP      {R4}
   \       0x3A   0x4770             BX       LR               ;; return
   1301          }
   1302          
   1303          /**
   1304            * @brief  Configure the TIMx input channel 4.
   1305            * @param  TIMx Timer Instance
   1306            * @param  TIM_ICInitStruct pointer to the the TIMx input channel 4 configuration data structure
   1307            * @retval An ErrorStatus enumeration value:
   1308            *          - SUCCESS: TIMx registers are de-initialized
   1309            *          - ERROR: not applicable
   1310            */

   \                                 In section .text, align 2, keep-with-next
   1311          static ErrorStatus IC4Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
   1312          {
   \                     IC4Config: (+1)
   \        0x0   0xB410             PUSH     {R4}
   \        0x2   0x0002             MOVS     R2,R0
   1313            /* Check the parameters */
   1314            assert_param(IS_TIM_CC4_INSTANCE(TIMx));
   1315            assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
   1316            assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
   1317            assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
   1318            assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
   1319          
   1320            /* Disable the Channel 4: Reset the CC4E Bit */
   1321            TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;
   \        0x4   0x6A10             LDR      R0,[R2, #+32]
   \        0x6   0x....             LDR      R3,??DataTable19_9  ;; 0xffffefff
   \        0x8   0x4003             ANDS     R3,R3,R0
   \        0xA   0x6213             STR      R3,[R2, #+32]
   1322          
   1323            /* Select the Input and set the filter and the prescaler value */
   1324            MODIFY_REG(TIMx->CCMR2,
   1325                       (TIM_CCMR2_CC4S | TIM_CCMR2_IC4F | TIM_CCMR2_IC4PSC),
   1326                       (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 8U);
   \        0xC   0x69D0             LDR      R0,[R2, #+28]
   \        0xE   0x....             LDR      R3,??DataTable19_6  ;; 0xffff00ff
   \       0x10   0x4003             ANDS     R3,R3,R0
   \       0x12   0x6848             LDR      R0,[R1, #+4]
   \       0x14   0x68CC             LDR      R4,[R1, #+12]
   \       0x16   0x4304             ORRS     R4,R4,R0
   \       0x18   0x6888             LDR      R0,[R1, #+8]
   \       0x1A   0x4320             ORRS     R0,R0,R4
   \       0x1C   0x0A00             LSRS     R0,R0,#+8
   \       0x1E   0x4318             ORRS     R0,R0,R3
   \       0x20   0x61D0             STR      R0,[R2, #+28]
   1327          
   1328            /* Select the Polarity and set the CC2E Bit */
   1329            MODIFY_REG(TIMx->CCER,
   1330                       (TIM_CCER_CC4P | TIM_CCER_CC4NP),
   1331                       ((TIM_ICInitStruct->ICPolarity << 12U) | TIM_CCER_CC4E));
   \       0x22   0x6A10             LDR      R0,[R2, #+32]
   \       0x24   0x....             LDR      R3,??DataTable19_10  ;; 0xffff5fff
   \       0x26   0x4003             ANDS     R3,R3,R0
   \       0x28   0x6808             LDR      R0,[R1, #+0]
   \       0x2A   0x0300             LSLS     R0,R0,#+12
   \       0x2C   0x4318             ORRS     R0,R0,R3
   \       0x2E   0x2380             MOVS     R3,#+128
   \       0x30   0x015B             LSLS     R3,R3,#+5        ;; #+4096
   \       0x32   0x4303             ORRS     R3,R3,R0
   \       0x34   0x6213             STR      R3,[R2, #+32]
   1332          
   1333            return SUCCESS;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBC10             POP      {R4}
   \       0x3A   0x4770             BX       LR               ;; return
   1334          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0xFFFE'FFF8        DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \        0x0   0x4002'102C        DC32     0x4002102c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \        0x0   0x4002'1030        DC32     0x40021030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0x4000'0400        DC32     0x40000400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x4000'2000        DC32     0x40002000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \        0x0   0xFFFF'FCFF        DC32     0xfffffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0xFFFF'00FF        DC32     0xffff00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0xFFCE'FF88        DC32     0xffceff88

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0xFEFF'03FF        DC32     0xfeff03ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0xFFFF'FCFF        DC32     0xfffffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0xFFFF'F7FF        DC32     0xfffff7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0xFFFF'EFFF        DC32     0xffffefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0xFFFF'DFFF        DC32     0xffffdfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0xFFFF'BFFF        DC32     0xffffbfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \        0x0   0xFFFF'7FFF        DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \        0x0   0xFFF0'FFFF        DC32     0xfff0ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \        0x0   0xEFFF'FFFF        DC32     0xefffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \        0x0   0xFF0F'FFFF        DC32     0xff0fffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \        0x0   0xFEFF'FFFF        DC32     0xfeffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \        0x0   0xFDFF'FFFF        DC32     0xfdffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0xDFFF'FFFF        DC32     0xdfffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0xFFFE'FF8F        DC32     0xfffeff8f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x4001'4400        DC32     0x40014400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x4001'4800        DC32     0x40014800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \        0x0   0xFEFF'8FFF        DC32     0xfeff8fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0xFFFE'FFFF        DC32     0xfffeffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0xFFFD'FFFF        DC32     0xfffdffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \        0x0   0xFFEF'FFFF        DC32     0xffefffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \        0x0   0xFFDF'FFFF        DC32     0xffdfffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \        0x0   0xFFFB'FFFF        DC32     0xfffbffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \        0x0   0xFFFF'00FF        DC32     0xffff00ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \        0x0   0xFFFF'FEFF        DC32     0xfffffeff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \        0x0   0xFFFF'F5FF        DC32     0xfffff5ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \        0x0   0xFFFF'EFFF        DC32     0xffffefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_10:
   \        0x0   0xFFFF'5FFF        DC32     0xffff5fff
   1335          
   1336          
   1337          /**
   1338            * @}
   1339            */
   1340          
   1341          /**
   1342            * @}
   1343            */
   1344          
   1345          #endif /* TIM1 || TIM2 || TIM3 ||  TIM14 || TIM15 || TIM16 || TIM17 || TIM6 || TIM7 */
   1346          
   1347          /**
   1348            * @}
   1349            */
   1350          
   1351          #endif /* USE_FULL_LL_DRIVER */
   1352          
   1353          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   IC1Config
       4   IC2Config
       4   IC3Config
       4   IC4Config
       0   LL_APB1_GRP1_ForceReset
       0   LL_APB1_GRP1_ReleaseReset
       0   LL_APB2_GRP1_ForceReset
       0   LL_APB2_GRP1_ReleaseReset
      12   LL_TIM_BDTR_Init
       0   LL_TIM_BDTR_StructInit
      16   LL_TIM_DeInit
        16   -> LL_APB1_GRP1_ForceReset
        16   -> LL_APB1_GRP1_ReleaseReset
        16   -> LL_APB2_GRP1_ForceReset
        16   -> LL_APB2_GRP1_ReleaseReset
      24   LL_TIM_ENCODER_Init
        24   -> LL_TIM_SetEncoderMode
       0   LL_TIM_ENCODER_StructInit
       0   LL_TIM_GenerateEvent_UPDATE
      32   LL_TIM_HALLSENSOR_Init
        32   -> LL_TIM_OC_SetCompareCH2
       0   LL_TIM_HALLSENSOR_StructInit
      24   LL_TIM_IC_Init
        24   -> IC1Config
        24   -> IC2Config
        24   -> IC3Config
        24   -> IC4Config
       0   LL_TIM_IC_StructInit
      24   LL_TIM_Init
        24   -> LL_TIM_GenerateEvent_UPDATE
        24   -> LL_TIM_SetAutoReload
        24   -> LL_TIM_SetPrescaler
        24   -> LL_TIM_SetRepetitionCounter
      24   LL_TIM_OC_Init
        24   -> OC1Config
        24   -> OC2Config
        24   -> OC3Config
        24   -> OC4Config
        24   -> OC5Config
        24   -> OC6Config
       0   LL_TIM_OC_SetCompareCH1
       0   LL_TIM_OC_SetCompareCH2
       0   LL_TIM_OC_SetCompareCH3
       0   LL_TIM_OC_SetCompareCH4
       0   LL_TIM_OC_SetCompareCH5
       0   LL_TIM_OC_SetCompareCH6
       0   LL_TIM_OC_StructInit
       0   LL_TIM_SetAutoReload
       0   LL_TIM_SetEncoderMode
       0   LL_TIM_SetPrescaler
       0   LL_TIM_SetRepetitionCounter
       0   LL_TIM_StructInit
      24   OC1Config
        24   -> LL_TIM_OC_SetCompareCH1
      24   OC2Config
        24   -> LL_TIM_OC_SetCompareCH2
      24   OC3Config
        24   -> LL_TIM_OC_SetCompareCH3
      24   OC4Config
        24   -> LL_TIM_OC_SetCompareCH4
      24   OC5Config
        24   -> LL_TIM_OC_SetCompareCH5
      24   OC6Config
        24   -> LL_TIM_OC_SetCompareCH6


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
      56  IC1Config
      58  IC2Config
      60  IC3Config
      60  IC4Config
      10  LL_APB1_GRP1_ForceReset
      10  LL_APB1_GRP1_ReleaseReset
      10  LL_APB2_GRP1_ForceReset
      10  LL_APB2_GRP1_ReleaseReset
     134  LL_TIM_BDTR_Init
      34  LL_TIM_BDTR_StructInit
     132  LL_TIM_DeInit
      96  LL_TIM_ENCODER_Init
      28  LL_TIM_ENCODER_StructInit
      10  LL_TIM_GenerateEvent_UPDATE
     112  LL_TIM_HALLSENSOR_Init
      12  LL_TIM_HALLSENSOR_StructInit
      88  LL_TIM_IC_Init
      16  LL_TIM_IC_StructInit
     118  LL_TIM_Init
     128  LL_TIM_OC_Init
       4  LL_TIM_OC_SetCompareCH1
       4  LL_TIM_OC_SetCompareCH2
       4  LL_TIM_OC_SetCompareCH3
       4  LL_TIM_OC_SetCompareCH4
       6  LL_TIM_OC_SetCompareCH5
       4  LL_TIM_OC_SetCompareCH6
      20  LL_TIM_OC_StructInit
       4  LL_TIM_SetAutoReload
      12  LL_TIM_SetEncoderMode
       4  LL_TIM_SetPrescaler
       4  LL_TIM_SetRepetitionCounter
      20  LL_TIM_StructInit
     126  OC1Config
     134  OC2Config
     130  OC3Config
     102  OC4Config
      90  OC5Config
      94  OC6Config

 
 2'120 bytes in section .text
 
 2'120 bytes of CODE memory

Errors: none
Warnings: none

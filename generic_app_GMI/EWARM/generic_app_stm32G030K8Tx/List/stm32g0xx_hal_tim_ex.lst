###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         04/Feb/2022  12:58:57
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode             
#    Endian            =  little
#    Source file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_tim_ex.c
#    Command line      =
#        -f C:\Users\610126~1\AppData\Local\Temp\EWA00.tmp
#        (C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_tim_ex.c
#        -D USE_FULL_LL_DRIVER -D STM32G030xx -D USE_HAL_DRIVER -lC
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List
#        -o
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.4\arm\inc\c\DLib_Config_Full.h"
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Device/ST/STM32G0xx/Source\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/CMSIS/Include\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Kernel\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Drivers\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Memory\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Features\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../FlexMouse/Regal\\
#        -I
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM/../Drivers/STM32G0xx_HAL_Driver/Inc/Legacy\\
#        -On)
#    Locale            =  C
#    List file         =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\List\stm32g0xx_hal_tim_ex.lst
#    Object file       =
#        C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\EWARM\generic_app_stm32G030K8Tx\Obj\stm32g0xx_hal_tim_ex.o
#    Runtime model:       
#      __SystemLibrary =  DLib
#      __dlib_version  =  6
#
###############################################################################

C:\Project_data\ECM_data\symax_safetycore\Symax-sri_safetycore_unit_test\symax_sri_app-DQ_Test_6_Relay_Testing\generic_app_GMI\Drivers\STM32G0xx_HAL_Driver\Src\stm32g0xx_hal_tim_ex.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32g0xx_hal_tim_ex.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver.
      6            *          This file provides firmware functions to manage the following
      7            *          functionalities of the Timer Extended peripheral:
      8            *           + Time Hall Sensor Interface Initialization
      9            *           + Time Hall Sensor Interface Start
     10            *           + Time Complementary signal break and dead time configuration
     11            *           + Time Master and Slave synchronization configuration
     12            *           + Time Output Compare/PWM Channel Configuration (for channels 5 and 6)
     13            *           + Time OCRef clear configuration
     14            *           + Timer remapping capabilities configuration
     15            @verbatim
     16            ==============================================================================
     17                                ##### TIMER Extended features #####
     18            ==============================================================================
     19            [..]
     20              The Timer Extended features include:
     21              (#) Complementary outputs with programmable dead-time for :
     22                  (++) Output Compare
     23                  (++) PWM generation (Edge and Center-aligned Mode)
     24                  (++) One-pulse mode output
     25              (#) Synchronization circuit to control the timer with external signals and to
     26                  interconnect several timers together.
     27              (#) Break input to put the timer output signals in reset state or in a known state.
     28              (#) Supports incremental (quadrature) encoder and hall-sensor circuitry for
     29                  positioning purposes
     30          
     31                      ##### How to use this driver #####
     32            ==============================================================================
     33              [..]
     34               (#) Initialize the TIM low level resources by implementing the following functions
     35                   depending on the selected feature:
     36                     (++) Hall Sensor output : HAL_TIMEx_HallSensor_MspInit()
     37          
     38               (#) Initialize the TIM low level resources :
     39                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     40                  (##) TIM pins configuration
     41                      (+++) Enable the clock for the TIM GPIOs using the following function:
     42                        __HAL_RCC_GPIOx_CLK_ENABLE();
     43                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     44          
     45               (#) The external Clock can be configured, if needed (the default clock is the
     46                   internal clock from the APBx), using the following function:
     47                   HAL_TIM_ConfigClockSource, the clock configuration should be done before
     48                   any start function.
     49          
     50               (#) Configure the TIM in the desired functioning mode using one of the
     51                   initialization function of this driver:
     52                    (++) HAL_TIMEx_HallSensor_Init() and HAL_TIMEx_ConfigCommutEvent(): to use the
     53                         Timer Hall Sensor Interface and the commutation event with the corresponding
     54                         Interrupt and DMA request if needed (Note that One Timer is used to interface
     55                         with the Hall sensor Interface and another Timer should be used to use
     56                         the commutation event).
     57          
     58               (#) Activate the TIM peripheral using one of the start functions:
     59                     (++) Complementary Output Compare : HAL_TIMEx_OCN_Start(), HAL_TIMEx_OCN_Start_DMA(), HAL_TIMEx_OC_Start_IT()
     60                     (++) Complementary PWM generation : HAL_TIMEx_PWMN_Start(), HAL_TIMEx_PWMN_Start_DMA(), HAL_TIMEx_PWMN_Start_IT()
     61                     (++) Complementary One-pulse mode output : HAL_TIMEx_OnePulseN_Start(), HAL_TIMEx_OnePulseN_Start_IT()
     62                     (++) Hall Sensor output : HAL_TIMEx_HallSensor_Start(), HAL_TIMEx_HallSensor_Start_DMA(), HAL_TIMEx_HallSensor_Start_IT().
     63          
     64            @endverbatim
     65            ******************************************************************************
     66            * @attention
     67            *
     68            * <h2><center>&copy; Copyright (c) 2018 STMicroelectronics.
     69            * All rights reserved.</center></h2>
     70            *
     71            * This software component is licensed by ST under BSD 3-Clause license,
     72            * the "License"; You may not use this file except in compliance with the
     73            * License. You may obtain a copy of the License at:
     74            *                        opensource.org/licenses/BSD-3-Clause
     75            *
     76            ******************************************************************************
     77            */
     78          
     79          /* Includes ------------------------------------------------------------------*/
     80          #include "stm32g0xx_hal.h"
     81          
     82          /** @addtogroup STM32G0xx_HAL_Driver
     83            * @{
     84            */
     85          
     86          /** @defgroup TIMEx TIMEx
     87            * @brief TIM Extended HAL module driver
     88            * @{
     89            */
     90          
     91          #ifdef HAL_TIM_MODULE_ENABLED
     92          
     93          /* Private typedef -----------------------------------------------------------*/
     94          /* Private define ------------------------------------------------------------*/
     95          /* Private constants ---------------------------------------------------------*/
     96          /** @defgroup TIMEx_Private_Constants TIM Extended Private Constants
     97            * @{
     98            */
     99          /* Timeout for break input rearm */
    100          #define TIM_BREAKINPUT_REARM_TIMEOUT    5UL /* 5 milliseconds */
    101          /**
    102            * @}
    103            */
    104          /* End of private constants --------------------------------------------------*/
    105          
    106          /* Private macro -------------------------------------------------------------*/
    107          /* Private variables ---------------------------------------------------------*/
    108          /* Private function prototypes -----------------------------------------------*/
    109          static void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState);
    110          
    111          /* Exported functions --------------------------------------------------------*/
    112          /** @defgroup TIMEx_Exported_Functions TIM Extended Exported Functions
    113            * @{
    114            */
    115          
    116          /** @defgroup TIMEx_Exported_Functions_Group1 Extended Timer Hall Sensor functions
    117            * @brief    Timer Hall Sensor functions
    118            *
    119          @verbatim
    120            ==============================================================================
    121                                ##### Timer Hall Sensor functions #####
    122            ==============================================================================
    123            [..]
    124              This section provides functions allowing to:
    125              (+) Initialize and configure TIM HAL Sensor.
    126              (+) De-initialize TIM HAL Sensor.
    127              (+) Start the Hall Sensor Interface.
    128              (+) Stop the Hall Sensor Interface.
    129              (+) Start the Hall Sensor Interface and enable interrupts.
    130              (+) Stop the Hall Sensor Interface and disable interrupts.
    131              (+) Start the Hall Sensor Interface and enable DMA transfers.
    132              (+) Stop the Hall Sensor Interface and disable DMA transfers.
    133          
    134          @endverbatim
    135            * @{
    136            */
    137          /**
    138            * @brief  Initializes the TIM Hall Sensor Interface and initialize the associated handle.
    139            * @param  htim TIM Hall Sensor Interface handle
    140            * @param  sConfig TIM Hall Sensor configuration structure
    141            * @retval HAL status
    142            */

   \                                 In section .text, align 2, keep-with-next
    143          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Init(TIM_HandleTypeDef *htim, TIM_HallSensor_InitTypeDef *sConfig)
    144          {
   \                     HAL_TIMEx_HallSensor_Init: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB087             SUB      SP,SP,#+28
   \        0x4   0x0004             MOVS     R4,R0
   \        0x6   0x000D             MOVS     R5,R1
    145            TIM_OC_InitTypeDef OC_Config;
    146          
    147            /* Check the TIM handle allocation */
    148            if (htim == NULL)
   \        0x8   0x2C00             CMP      R4,#+0
   \        0xA   0xD101             BNE      ??HAL_TIMEx_HallSensor_Init_0
    149            {
    150              return HAL_ERROR;
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0xE05E             B        ??HAL_TIMEx_HallSensor_Init_1
    151            }
    152          
    153            /* Check the parameters */
    154            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    155            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    156            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    157            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    158            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
    159            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
    160            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
    161          
    162            if (htim->State == HAL_TIM_STATE_RESET)
   \                     ??HAL_TIMEx_HallSensor_Init_0: (+1)
   \       0x10   0x203D             MOVS     R0,#+61
   \       0x12   0x5C20             LDRB     R0,[R4, R0]
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD105             BNE      ??HAL_TIMEx_HallSensor_Init_2
    163            {
    164              /* Allocate lock resource and initialize it */
    165              htim->Lock = HAL_UNLOCKED;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x213C             MOVS     R1,#+60
   \       0x1C   0x5460             STRB     R0,[R4, R1]
    166          
    167          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    168              /* Reset interrupt callbacks to legacy week callbacks */
    169              TIM_ResetCallback(htim);
    170          
    171              if (htim->HallSensor_MspInitCallback == NULL)
    172              {
    173                htim->HallSensor_MspInitCallback = HAL_TIMEx_HallSensor_MspInit;
    174              }
    175              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    176              htim->HallSensor_MspInitCallback(htim);
    177          #else
    178              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    179              HAL_TIMEx_HallSensor_MspInit(htim);
   \       0x1E   0x0020             MOVS     R0,R4
   \       0x20   0x....'....        BL       HAL_TIMEx_HallSensor_MspInit
    180          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    181            }
    182          
    183            /* Set the TIM state */
    184            htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_HallSensor_Init_2: (+1)
   \       0x24   0x2002             MOVS     R0,#+2
   \       0x26   0x213D             MOVS     R1,#+61
   \       0x28   0x5460             STRB     R0,[R4, R1]
    185          
    186            /* Configure the Time base in the Encoder Mode */
    187            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   \       0x2A   0x1D21             ADDS     R1,R4,#+4
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x....'....        BL       TIM_Base_SetConfig
    188          
    189            /* Configure the Channel 1 as Input Channel to interface with the three Outputs of the  Hall sensor */
    190            TIM_TI1_SetConfig(htim->Instance, sConfig->IC1Polarity, TIM_ICSELECTION_TRC, sConfig->IC1Filter);
   \       0x32   0x68AB             LDR      R3,[R5, #+8]
   \       0x34   0x2203             MOVS     R2,#+3
   \       0x36   0x6829             LDR      R1,[R5, #+0]
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x....'....        BL       TIM_TI1_SetConfig
    191          
    192            /* Reset the IC1PSC Bits */
    193            htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6980             LDR      R0,[R0, #+24]
   \       0x42   0x210C             MOVS     R1,#+12
   \       0x44   0x4388             BICS     R0,R0,R1
   \       0x46   0x6821             LDR      R1,[R4, #+0]
   \       0x48   0x6188             STR      R0,[R1, #+24]
    194            /* Set the IC1PSC value */
    195            htim->Instance->CCMR1 |= sConfig->IC1Prescaler;
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6980             LDR      R0,[R0, #+24]
   \       0x4E   0x6869             LDR      R1,[R5, #+4]
   \       0x50   0x4301             ORRS     R1,R1,R0
   \       0x52   0x6820             LDR      R0,[R4, #+0]
   \       0x54   0x6181             STR      R1,[R0, #+24]
    196          
    197            /* Enable the Hall sensor interface (XOR function of the three inputs) */
    198            htim->Instance->CR2 |= TIM_CR2_TI1S;
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6840             LDR      R0,[R0, #+4]
   \       0x5A   0x2180             MOVS     R1,#+128
   \       0x5C   0x4301             ORRS     R1,R1,R0
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6041             STR      R1,[R0, #+4]
    199          
    200            /* Select the TIM_TS_TI1F_ED signal as Input trigger for the TIM */
    201            htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x6880             LDR      R0,[R0, #+8]
   \       0x66   0x....             LDR      R1,??DataTable8  ;; 0xffcfff8f
   \       0x68   0x4001             ANDS     R1,R1,R0
   \       0x6A   0x6820             LDR      R0,[R4, #+0]
   \       0x6C   0x6081             STR      R1,[R0, #+8]
    202            htim->Instance->SMCR |= TIM_TS_TI1F_ED;
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x6880             LDR      R0,[R0, #+8]
   \       0x72   0x2140             MOVS     R1,#+64
   \       0x74   0x4301             ORRS     R1,R1,R0
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6081             STR      R1,[R0, #+8]
    203          
    204            /* Use the TIM_TS_TI1F_ED signal to reset the TIM counter each edge detection */
    205            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x6880             LDR      R0,[R0, #+8]
   \       0x7E   0x....             LDR      R1,??DataTable9  ;; 0xfffefff8
   \       0x80   0x4001             ANDS     R1,R1,R0
   \       0x82   0x6820             LDR      R0,[R4, #+0]
   \       0x84   0x6081             STR      R1,[R0, #+8]
    206            htim->Instance->SMCR |= TIM_SLAVEMODE_RESET;
   \       0x86   0x6820             LDR      R0,[R4, #+0]
   \       0x88   0x6880             LDR      R0,[R0, #+8]
   \       0x8A   0x2104             MOVS     R1,#+4
   \       0x8C   0x4301             ORRS     R1,R1,R0
   \       0x8E   0x6820             LDR      R0,[R4, #+0]
   \       0x90   0x6081             STR      R1,[R0, #+8]
    207          
    208            /* Program channel 2 in PWM 2 mode with the desired Commutation_Delay*/
    209            OC_Config.OCFastMode = TIM_OCFAST_DISABLE;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x9004             STR      R0,[SP, #+16]
    210            OC_Config.OCIdleState = TIM_OCIDLESTATE_RESET;
   \       0x96   0x9005             STR      R0,[SP, #+20]
    211            OC_Config.OCMode = TIM_OCMODE_PWM2;
   \       0x98   0x2170             MOVS     R1,#+112
   \       0x9A   0x9100             STR      R1,[SP, #+0]
    212            OC_Config.OCNIdleState = TIM_OCNIDLESTATE_RESET;
   \       0x9C   0x9006             STR      R0,[SP, #+24]
    213            OC_Config.OCNPolarity = TIM_OCNPOLARITY_HIGH;
   \       0x9E   0x9003             STR      R0,[SP, #+12]
    214            OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;
   \       0xA0   0x9002             STR      R0,[SP, #+8]
    215            OC_Config.Pulse = sConfig->Commutation_Delay;
   \       0xA2   0x68E8             LDR      R0,[R5, #+12]
   \       0xA4   0x9001             STR      R0,[SP, #+4]
    216          
    217            TIM_OC2_SetConfig(htim->Instance, &OC_Config);
   \       0xA6   0x4669             MOV      R1,SP
   \       0xA8   0x6820             LDR      R0,[R4, #+0]
   \       0xAA   0x....'....        BL       TIM_OC2_SetConfig
    218          
    219            /* Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
    220              register to 101 */
    221            htim->Instance->CR2 &= ~TIM_CR2_MMS;
   \       0xAE   0x6820             LDR      R0,[R4, #+0]
   \       0xB0   0x6840             LDR      R0,[R0, #+4]
   \       0xB2   0x2170             MOVS     R1,#+112
   \       0xB4   0x4388             BICS     R0,R0,R1
   \       0xB6   0x6821             LDR      R1,[R4, #+0]
   \       0xB8   0x6048             STR      R0,[R1, #+4]
    222            htim->Instance->CR2 |= TIM_TRGO_OC2REF;
   \       0xBA   0x6820             LDR      R0,[R4, #+0]
   \       0xBC   0x6840             LDR      R0,[R0, #+4]
   \       0xBE   0x2150             MOVS     R1,#+80
   \       0xC0   0x4301             ORRS     R1,R1,R0
   \       0xC2   0x6820             LDR      R0,[R4, #+0]
   \       0xC4   0x6041             STR      R1,[R0, #+4]
    223          
    224            /* Initialize the TIM state*/
    225            htim->State = HAL_TIM_STATE_READY;
   \       0xC6   0x2001             MOVS     R0,#+1
   \       0xC8   0x213D             MOVS     R1,#+61
   \       0xCA   0x5460             STRB     R0,[R4, R1]
    226          
    227            return HAL_OK;
   \       0xCC   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_HallSensor_Init_1: (+1)
   \       0xCE   0xB007             ADD      SP,SP,#+28
   \       0xD0   0xBD30             POP      {R4,R5,PC}       ;; return
    228          }
    229          
    230          /**
    231            * @brief  DeInitializes the TIM Hall Sensor interface
    232            * @param  htim TIM Hall Sensor Interface handle
    233            * @retval HAL status
    234            */

   \                                 In section .text, align 2, keep-with-next
    235          HAL_StatusTypeDef HAL_TIMEx_HallSensor_DeInit(TIM_HandleTypeDef *htim)
    236          {
   \                     HAL_TIMEx_HallSensor_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    237            /* Check the parameters */
    238            assert_param(IS_TIM_INSTANCE(htim->Instance));
    239          
    240            htim->State = HAL_TIM_STATE_BUSY;
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x213D             MOVS     R1,#+61
   \        0x8   0x5460             STRB     R0,[R4, R1]
    241          
    242            /* Disable the TIM Peripheral Clock */
    243            __HAL_TIM_DISABLE(htim);
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x6A00             LDR      R0,[R0, #+32]
   \        0xE   0x....             LDR      R1,??DataTable9_1  ;; 0x1111
   \       0x10   0x4001             ANDS     R1,R1,R0
   \       0x12   0x2900             CMP      R1,#+0
   \       0x14   0xD10B             BNE      ??HAL_TIMEx_HallSensor_DeInit_0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x6A00             LDR      R0,[R0, #+32]
   \       0x1A   0x....             LDR      R1,??DataTable9_2  ;; 0x444
   \       0x1C   0x4001             ANDS     R1,R1,R0
   \       0x1E   0x2900             CMP      R1,#+0
   \       0x20   0xD105             BNE      ??HAL_TIMEx_HallSensor_DeInit_0
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x4388             BICS     R0,R0,R1
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6008             STR      R0,[R1, #+0]
    244          
    245          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
    246            if (htim->HallSensor_MspDeInitCallback == NULL)
    247            {
    248              htim->HallSensor_MspDeInitCallback = HAL_TIMEx_HallSensor_MspDeInit;
    249            }
    250            /* DeInit the low level hardware */
    251            htim->HallSensor_MspDeInitCallback(htim);
    252          #else
    253            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    254            HAL_TIMEx_HallSensor_MspDeInit(htim);
   \                     ??HAL_TIMEx_HallSensor_DeInit_0: (+1)
   \       0x2E   0x0020             MOVS     R0,R4
   \       0x30   0x....'....        BL       HAL_TIMEx_HallSensor_MspDeInit
    255          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    256          
    257            /* Change TIM state */
    258            htim->State = HAL_TIM_STATE_RESET;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x0001             MOVS     R1,R0
   \       0x38   0x223D             MOVS     R2,#+61
   \       0x3A   0x54A1             STRB     R1,[R4, R2]
    259          
    260            /* Release Lock */
    261            __HAL_UNLOCK(htim);
   \       0x3C   0x213C             MOVS     R1,#+60
   \       0x3E   0x5460             STRB     R0,[R4, R1]
    262          
    263            return HAL_OK;
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD10             POP      {R4,PC}          ;; return
    264          }
    265          
    266          /**
    267            * @brief  Initializes the TIM Hall Sensor MSP.
    268            * @param  htim TIM Hall Sensor Interface handle
    269            * @retval None
    270            */

   \                                 In section .text, align 2
    271          __weak void HAL_TIMEx_HallSensor_MspInit(TIM_HandleTypeDef *htim)
    272          {
    273            /* Prevent unused argument(s) compilation warning */
    274            UNUSED(htim);
    275          
    276            /* NOTE : This function should not be modified, when the callback is needed,
    277                      the HAL_TIMEx_HallSensor_MspInit could be implemented in the user file
    278             */
    279          }
   \                     HAL_TIMEx_HallSensor_MspInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    280          
    281          /**
    282            * @brief  DeInitializes TIM Hall Sensor MSP.
    283            * @param  htim TIM Hall Sensor Interface handle
    284            * @retval None
    285            */

   \                                 In section .text, align 2
    286          __weak void HAL_TIMEx_HallSensor_MspDeInit(TIM_HandleTypeDef *htim)
    287          {
    288            /* Prevent unused argument(s) compilation warning */
    289            UNUSED(htim);
    290          
    291            /* NOTE : This function should not be modified, when the callback is needed,
    292                      the HAL_TIMEx_HallSensor_MspDeInit could be implemented in the user file
    293             */
    294          }
   \                     HAL_TIMEx_HallSensor_MspDeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    295          
    296          /**
    297            * @brief  Starts the TIM Hall Sensor Interface.
    298            * @param  htim TIM Hall Sensor Interface handle
    299            * @retval HAL status
    300            */

   \                                 In section .text, align 2, keep-with-next
    301          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start(TIM_HandleTypeDef *htim)
    302          {
   \                     HAL_TIMEx_HallSensor_Start: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    303            uint32_t tmpsmcr;
    304          
    305            /* Check the parameters */
    306            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    307          
    308            /* Enable the Input Capture channel 1
    309              (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    310            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x....'....        BL       TIM_CCxChannelCmd
    311          
    312            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    313            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6880             LDR      R0,[R0, #+8]
   \       0x12   0x....             LDR      R1,??DataTable10  ;; 0x10007
   \       0x14   0x4001             ANDS     R1,R1,R0
    314            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x16   0x2906             CMP      R1,#+6
   \       0x18   0xD009             BEQ      ??HAL_TIMEx_HallSensor_Start_0
   \       0x1A   0x2080             MOVS     R0,#+128
   \       0x1C   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x1E   0x4281             CMP      R1,R0
   \       0x20   0xD005             BEQ      ??HAL_TIMEx_HallSensor_Start_0
    315            {
    316              __HAL_TIM_ENABLE(htim);
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x6800             LDR      R0,[R0, #+0]
   \       0x26   0x2201             MOVS     R2,#+1
   \       0x28   0x4302             ORRS     R2,R2,R0
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x6002             STR      R2,[R0, #+0]
    317            }
    318          
    319            /* Return function status */
    320            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Start_0: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBD10             POP      {R4,PC}          ;; return
    321          }
    322          
    323          /**
    324            * @brief  Stops the TIM Hall sensor Interface.
    325            * @param  htim TIM Hall Sensor Interface handle
    326            * @retval HAL status
    327            */

   \                                 In section .text, align 2, keep-with-next
    328          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop(TIM_HandleTypeDef *htim)
    329          {
   \                     HAL_TIMEx_HallSensor_Stop: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    330            /* Check the parameters */
    331            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    332          
    333            /* Disable the Input Capture channels 1, 2 and 3
    334              (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    335            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x....'....        BL       TIM_CCxChannelCmd
    336          
    337            /* Disable the Peripheral */
    338            __HAL_TIM_DISABLE(htim);
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x6A00             LDR      R0,[R0, #+32]
   \       0x12   0x....             LDR      R1,??DataTable9_1  ;; 0x1111
   \       0x14   0x4001             ANDS     R1,R1,R0
   \       0x16   0x2900             CMP      R1,#+0
   \       0x18   0xD10B             BNE      ??HAL_TIMEx_HallSensor_Stop_0
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6A00             LDR      R0,[R0, #+32]
   \       0x1E   0x....             LDR      R1,??DataTable9_2  ;; 0x444
   \       0x20   0x4001             ANDS     R1,R1,R0
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xD105             BNE      ??HAL_TIMEx_HallSensor_Stop_0
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6800             LDR      R0,[R0, #+0]
   \       0x2A   0x2101             MOVS     R1,#+1
   \       0x2C   0x4388             BICS     R0,R0,R1
   \       0x2E   0x6821             LDR      R1,[R4, #+0]
   \       0x30   0x6008             STR      R0,[R1, #+0]
    339          
    340            /* Return function status */
    341            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_0: (+1)
   \       0x32   0x2000             MOVS     R0,#+0
   \       0x34   0xBD10             POP      {R4,PC}          ;; return
    342          }
    343          
    344          /**
    345            * @brief  Starts the TIM Hall Sensor Interface in interrupt mode.
    346            * @param  htim TIM Hall Sensor Interface handle
    347            * @retval HAL status
    348            */

   \                                 In section .text, align 2, keep-with-next
    349          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_IT(TIM_HandleTypeDef *htim)
    350          {
   \                     HAL_TIMEx_HallSensor_Start_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    351            uint32_t tmpsmcr;
    352          
    353            /* Check the parameters */
    354            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    355          
    356            /* Enable the capture compare Interrupts 1 event */
    357            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x68C0             LDR      R0,[R0, #+12]
   \        0x8   0x2102             MOVS     R1,#+2
   \        0xA   0x4301             ORRS     R1,R1,R0
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x60C1             STR      R1,[R0, #+12]
    358          
    359            /* Enable the Input Capture channel 1
    360              (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    361            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \       0x10   0x2201             MOVS     R2,#+1
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x6820             LDR      R0,[R4, #+0]
   \       0x16   0x....'....        BL       TIM_CCxChannelCmd
    362          
    363            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    364            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6880             LDR      R0,[R0, #+8]
   \       0x1E   0x....             LDR      R1,??DataTable10  ;; 0x10007
   \       0x20   0x4001             ANDS     R1,R1,R0
    365            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x22   0x2906             CMP      R1,#+6
   \       0x24   0xD009             BEQ      ??HAL_TIMEx_HallSensor_Start_IT_0
   \       0x26   0x2080             MOVS     R0,#+128
   \       0x28   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x2A   0x4281             CMP      R1,R0
   \       0x2C   0xD005             BEQ      ??HAL_TIMEx_HallSensor_Start_IT_0
    366            {
    367              __HAL_TIM_ENABLE(htim);
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0x2201             MOVS     R2,#+1
   \       0x34   0x4302             ORRS     R2,R2,R0
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x6002             STR      R2,[R0, #+0]
    368            }
    369          
    370            /* Return function status */
    371            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Start_IT_0: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0xBD10             POP      {R4,PC}          ;; return
    372          }
    373          
    374          /**
    375            * @brief  Stops the TIM Hall Sensor Interface in interrupt mode.
    376            * @param  htim TIM Hall Sensor Interface handle
    377            * @retval HAL status
    378            */

   \                                 In section .text, align 2, keep-with-next
    379          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_IT(TIM_HandleTypeDef *htim)
    380          {
   \                     HAL_TIMEx_HallSensor_Stop_IT: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    381            /* Check the parameters */
    382            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    383          
    384            /* Disable the Input Capture channel 1
    385              (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    386            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x....'....        BL       TIM_CCxChannelCmd
    387          
    388            /* Disable the capture compare Interrupts event */
    389            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x68C0             LDR      R0,[R0, #+12]
   \       0x12   0x2102             MOVS     R1,#+2
   \       0x14   0x4388             BICS     R0,R0,R1
   \       0x16   0x6821             LDR      R1,[R4, #+0]
   \       0x18   0x60C8             STR      R0,[R1, #+12]
    390          
    391            /* Disable the Peripheral */
    392            __HAL_TIM_DISABLE(htim);
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6A00             LDR      R0,[R0, #+32]
   \       0x1E   0x....             LDR      R1,??DataTable9_1  ;; 0x1111
   \       0x20   0x4001             ANDS     R1,R1,R0
   \       0x22   0x2900             CMP      R1,#+0
   \       0x24   0xD10B             BNE      ??HAL_TIMEx_HallSensor_Stop_IT_0
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x6A00             LDR      R0,[R0, #+32]
   \       0x2A   0x....             LDR      R1,??DataTable9_2  ;; 0x444
   \       0x2C   0x4001             ANDS     R1,R1,R0
   \       0x2E   0x2900             CMP      R1,#+0
   \       0x30   0xD105             BNE      ??HAL_TIMEx_HallSensor_Stop_IT_0
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x2101             MOVS     R1,#+1
   \       0x38   0x4388             BICS     R0,R0,R1
   \       0x3A   0x6821             LDR      R1,[R4, #+0]
   \       0x3C   0x6008             STR      R0,[R1, #+0]
    393          
    394            /* Return function status */
    395            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_IT_0: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xBD10             POP      {R4,PC}          ;; return
    396          }
    397          
    398          /**
    399            * @brief  Starts the TIM Hall Sensor Interface in DMA mode.
    400            * @param  htim TIM Hall Sensor Interface handle
    401            * @param  pData The destination Buffer address.
    402            * @param  Length The length of data to be transferred from TIM peripheral to memory.
    403            * @retval HAL status
    404            */

   \                                 In section .text, align 2, keep-with-next
    405          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    406          {
   \                     HAL_TIMEx_HallSensor_Start_DMA: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000E             MOVS     R6,R1
   \        0x6   0x0015             MOVS     R5,R2
    407            uint32_t tmpsmcr;
    408          
    409            /* Check the parameters */
    410            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    411          
    412            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0x8   0x203D             MOVS     R0,#+61
   \        0xA   0x5C20             LDRB     R0,[R4, R0]
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD101             BNE      ??HAL_TIMEx_HallSensor_Start_DMA_0
    413            {
    414              return HAL_BUSY;
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE041             B        ??HAL_TIMEx_HallSensor_Start_DMA_1
    415            }
    416            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_0: (+1)
   \       0x14   0x203D             MOVS     R0,#+61
   \       0x16   0x5C20             LDRB     R0,[R4, R0]
   \       0x18   0x2801             CMP      R0,#+1
   \       0x1A   0xD10A             BNE      ??HAL_TIMEx_HallSensor_Start_DMA_2
    417            {
    418              if (((uint32_t)pData == 0U) && (Length > 0U))
   \       0x1C   0x2E00             CMP      R6,#+0
   \       0x1E   0xD105             BNE      ??HAL_TIMEx_HallSensor_Start_DMA_3
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0xB280             UXTH     R0,R0
   \       0x24   0x2800             CMP      R0,#+0
   \       0x26   0xD001             BEQ      ??HAL_TIMEx_HallSensor_Start_DMA_3
    419              {
    420                return HAL_ERROR;
   \       0x28   0x2001             MOVS     R0,#+1
   \       0x2A   0xE035             B        ??HAL_TIMEx_HallSensor_Start_DMA_1
    421              }
    422              else
    423              {
    424                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_3: (+1)
   \       0x2C   0x2002             MOVS     R0,#+2
   \       0x2E   0x213D             MOVS     R1,#+61
   \       0x30   0x5460             STRB     R0,[R4, R1]
    425              }
    426            }
    427            else
    428            {
    429              /* nothing to do */
    430            }
    431            /* Enable the Input Capture channel 1
    432              (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    433            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_2: (+1)
   \       0x32   0x2201             MOVS     R2,#+1
   \       0x34   0x2100             MOVS     R1,#+0
   \       0x36   0x6820             LDR      R0,[R4, #+0]
   \       0x38   0x....'....        BL       TIM_CCxChannelCmd
    434          
    435            /* Set the DMA Input Capture 1 Callbacks */
    436            htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   \       0x3C   0x....             LDR      R0,??DataTable11
   \       0x3E   0x6A61             LDR      R1,[R4, #+36]
   \       0x40   0x62C8             STR      R0,[R1, #+44]
    437            htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMACaptureHalfCplt;
   \       0x42   0x....             LDR      R0,??DataTable11_1
   \       0x44   0x6A61             LDR      R1,[R4, #+36]
   \       0x46   0x6308             STR      R0,[R1, #+48]
    438            /* Set the DMA error callback */
    439            htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x48   0x....             LDR      R0,??DataTable11_2
   \       0x4A   0x6A61             LDR      R1,[R4, #+36]
   \       0x4C   0x6348             STR      R0,[R1, #+52]
    440          
    441            /* Enable the DMA channel for Capture 1*/
    442            if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length) != HAL_OK)
   \       0x4E   0x002B             MOVS     R3,R5
   \       0x50   0xB29B             UXTH     R3,R3
   \       0x52   0x0032             MOVS     R2,R6
   \       0x54   0x6820             LDR      R0,[R4, #+0]
   \       0x56   0x0001             MOVS     R1,R0
   \       0x58   0x3134             ADDS     R1,R1,#+52
   \       0x5A   0x6A60             LDR      R0,[R4, #+36]
   \       0x5C   0x....'....        BL       HAL_DMA_Start_IT
   \       0x60   0x2800             CMP      R0,#+0
   \       0x62   0xD001             BEQ      ??HAL_TIMEx_HallSensor_Start_DMA_4
    443            {
    444              return HAL_ERROR;
   \       0x64   0x2001             MOVS     R0,#+1
   \       0x66   0xE017             B        ??HAL_TIMEx_HallSensor_Start_DMA_1
    445            }
    446            /* Enable the capture compare 1 Interrupt */
    447            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_4: (+1)
   \       0x68   0x6820             LDR      R0,[R4, #+0]
   \       0x6A   0x68C0             LDR      R0,[R0, #+12]
   \       0x6C   0x2180             MOVS     R1,#+128
   \       0x6E   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x70   0x4301             ORRS     R1,R1,R0
   \       0x72   0x6820             LDR      R0,[R4, #+0]
   \       0x74   0x60C1             STR      R1,[R0, #+12]
    448          
    449            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    450            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x76   0x6820             LDR      R0,[R4, #+0]
   \       0x78   0x6880             LDR      R0,[R0, #+8]
   \       0x7A   0x....             LDR      R1,??DataTable10  ;; 0x10007
   \       0x7C   0x4001             ANDS     R1,R1,R0
    451            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x7E   0x2906             CMP      R1,#+6
   \       0x80   0xD009             BEQ      ??HAL_TIMEx_HallSensor_Start_DMA_5
   \       0x82   0x2080             MOVS     R0,#+128
   \       0x84   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x86   0x4281             CMP      R1,R0
   \       0x88   0xD005             BEQ      ??HAL_TIMEx_HallSensor_Start_DMA_5
    452            {
    453              __HAL_TIM_ENABLE(htim);
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x6800             LDR      R0,[R0, #+0]
   \       0x8E   0x2201             MOVS     R2,#+1
   \       0x90   0x4302             ORRS     R2,R2,R0
   \       0x92   0x6820             LDR      R0,[R4, #+0]
   \       0x94   0x6002             STR      R2,[R0, #+0]
    454            }
    455          
    456            /* Return function status */
    457            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_5: (+1)
   \       0x96   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_HallSensor_Start_DMA_1: (+1)
   \       0x98   0xBD70             POP      {R4-R6,PC}       ;; return
    458          }
    459          
    460          /**
    461            * @brief  Stops the TIM Hall Sensor Interface in DMA mode.
    462            * @param  htim TIM Hall Sensor Interface handle
    463            * @retval HAL status
    464            */

   \                                 In section .text, align 2, keep-with-next
    465          HAL_StatusTypeDef HAL_TIMEx_HallSensor_Stop_DMA(TIM_HandleTypeDef *htim)
    466          {
   \                     HAL_TIMEx_HallSensor_Stop_DMA: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    467            /* Check the parameters */
    468            assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(htim->Instance));
    469          
    470            /* Disable the Input Capture channel 1
    471              (in the Hall Sensor Interface the three possible channels that can be used are TIM_CHANNEL_1, TIM_CHANNEL_2 and TIM_CHANNEL_3) */
    472            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x6820             LDR      R0,[R4, #+0]
   \        0xA   0x....'....        BL       TIM_CCxChannelCmd
    473          
    474          
    475            /* Disable the capture compare Interrupts 1 event */
    476            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x68C0             LDR      R0,[R0, #+12]
   \       0x12   0x....             LDR      R1,??DataTable11_3  ;; 0xfffffdff
   \       0x14   0x4001             ANDS     R1,R1,R0
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x60C1             STR      R1,[R0, #+12]
    477          
    478            (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x1A   0x6A60             LDR      R0,[R4, #+36]
   \       0x1C   0x....'....        BL       HAL_DMA_Abort_IT
    479            /* Disable the Peripheral */
    480            __HAL_TIM_DISABLE(htim);
   \       0x20   0x6820             LDR      R0,[R4, #+0]
   \       0x22   0x6A00             LDR      R0,[R0, #+32]
   \       0x24   0x....             LDR      R1,??DataTable9_1  ;; 0x1111
   \       0x26   0x4001             ANDS     R1,R1,R0
   \       0x28   0x2900             CMP      R1,#+0
   \       0x2A   0xD10B             BNE      ??HAL_TIMEx_HallSensor_Stop_DMA_0
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x6A00             LDR      R0,[R0, #+32]
   \       0x30   0x....             LDR      R1,??DataTable9_2  ;; 0x444
   \       0x32   0x4001             ANDS     R1,R1,R0
   \       0x34   0x2900             CMP      R1,#+0
   \       0x36   0xD105             BNE      ??HAL_TIMEx_HallSensor_Stop_DMA_0
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0x6800             LDR      R0,[R0, #+0]
   \       0x3C   0x2101             MOVS     R1,#+1
   \       0x3E   0x4388             BICS     R0,R0,R1
   \       0x40   0x6821             LDR      R1,[R4, #+0]
   \       0x42   0x6008             STR      R0,[R1, #+0]
    481          
    482            /* Return function status */
    483            return HAL_OK;
   \                     ??HAL_TIMEx_HallSensor_Stop_DMA_0: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD10             POP      {R4,PC}          ;; return
    484          }
    485          
    486          /**
    487            * @}
    488            */
    489          
    490          /** @defgroup TIMEx_Exported_Functions_Group2 Extended Timer Complementary Output Compare functions
    491            *  @brief   Timer Complementary Output Compare functions
    492            *
    493          @verbatim
    494            ==============================================================================
    495                        ##### Timer Complementary Output Compare functions #####
    496            ==============================================================================
    497            [..]
    498              This section provides functions allowing to:
    499              (+) Start the Complementary Output Compare/PWM.
    500              (+) Stop the Complementary Output Compare/PWM.
    501              (+) Start the Complementary Output Compare/PWM and enable interrupts.
    502              (+) Stop the Complementary Output Compare/PWM and disable interrupts.
    503              (+) Start the Complementary Output Compare/PWM and enable DMA transfers.
    504              (+) Stop the Complementary Output Compare/PWM and disable DMA transfers.
    505          
    506          @endverbatim
    507            * @{
    508            */
    509          
    510          /**
    511            * @brief  Starts the TIM Output Compare signal generation on the complementary
    512            *         output.
    513            * @param  htim TIM Output Compare handle
    514            * @param  Channel TIM Channel to be enabled
    515            *          This parameter can be one of the following values:
    516            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    517            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    518            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    519            * @retval HAL status
    520            */

   \                                 In section .text, align 2, keep-with-next
    521          HAL_StatusTypeDef HAL_TIMEx_OCN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    522          {
   \                     HAL_TIMEx_OCN_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    523            uint32_t tmpsmcr;
    524          
    525            /* Check the parameters */
    526            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    527          
    528            /* Enable the Capture compare channel N */
    529            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \        0x6   0x2204             MOVS     R2,#+4
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxNChannelCmd
    530          
    531            /* Enable the Main Output */
    532            __HAL_TIM_MOE_ENABLE(htim);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6C40             LDR      R0,[R0, #+68]
   \       0x14   0x2180             MOVS     R1,#+128
   \       0x16   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x18   0x4301             ORRS     R1,R1,R0
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6441             STR      R1,[R0, #+68]
    533          
    534            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    535            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6880             LDR      R0,[R0, #+8]
   \       0x22   0x....             LDR      R1,??DataTable10  ;; 0x10007
   \       0x24   0x4001             ANDS     R1,R1,R0
    536            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x26   0x2906             CMP      R1,#+6
   \       0x28   0xD009             BEQ      ??HAL_TIMEx_OCN_Start_0
   \       0x2A   0x2080             MOVS     R0,#+128
   \       0x2C   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x2E   0x4281             CMP      R1,R0
   \       0x30   0xD005             BEQ      ??HAL_TIMEx_OCN_Start_0
    537            {
    538              __HAL_TIM_ENABLE(htim);
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x2201             MOVS     R2,#+1
   \       0x38   0x4302             ORRS     R2,R2,R0
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6002             STR      R2,[R0, #+0]
    539            }
    540          
    541            /* Return function status */
    542            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Start_0: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    543          }
    544          
    545          /**
    546            * @brief  Stops the TIM Output Compare signal generation on the complementary
    547            *         output.
    548            * @param  htim TIM handle
    549            * @param  Channel TIM Channel to be disabled
    550            *          This parameter can be one of the following values:
    551            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    552            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    553            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    554            * @retval HAL status
    555            */

   \                                 In section .text, align 2, keep-with-next
    556          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    557          {
   \                     HAL_TIMEx_OCN_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    558            /* Check the parameters */
    559            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    560          
    561            /* Disable the Capture compare channel N */
    562            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxNChannelCmd
    563          
    564            /* Disable the Main Output */
    565            __HAL_TIM_MOE_DISABLE(htim);
   \       0x10   0x....             LDR      R0,??DataTable9_1  ;; 0x1111
   \       0x12   0x6821             LDR      R1,[R4, #+0]
   \       0x14   0x6A09             LDR      R1,[R1, #+32]
   \       0x16   0x4001             ANDS     R1,R1,R0
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD10B             BNE      ??HAL_TIMEx_OCN_Stop_0
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6A09             LDR      R1,[R1, #+32]
   \       0x20   0x....             LDR      R2,??DataTable9_2  ;; 0x444
   \       0x22   0x400A             ANDS     R2,R2,R1
   \       0x24   0x2A00             CMP      R2,#+0
   \       0x26   0xD105             BNE      ??HAL_TIMEx_OCN_Stop_0
   \       0x28   0x6821             LDR      R1,[R4, #+0]
   \       0x2A   0x6C49             LDR      R1,[R1, #+68]
   \       0x2C   0x....             LDR      R2,??DataTable12  ;; 0xffff7fff
   \       0x2E   0x400A             ANDS     R2,R2,R1
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x644A             STR      R2,[R1, #+68]
    566          
    567            /* Disable the Peripheral */
    568            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_0: (+1)
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x6A09             LDR      R1,[R1, #+32]
   \       0x38   0x4008             ANDS     R0,R0,R1
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD10B             BNE      ??HAL_TIMEx_OCN_Stop_1
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6A00             LDR      R0,[R0, #+32]
   \       0x42   0x....             LDR      R1,??DataTable9_2  ;; 0x444
   \       0x44   0x4001             ANDS     R1,R1,R0
   \       0x46   0x2900             CMP      R1,#+0
   \       0x48   0xD105             BNE      ??HAL_TIMEx_OCN_Stop_1
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6800             LDR      R0,[R0, #+0]
   \       0x4E   0x2101             MOVS     R1,#+1
   \       0x50   0x4388             BICS     R0,R0,R1
   \       0x52   0x6821             LDR      R1,[R4, #+0]
   \       0x54   0x6008             STR      R0,[R1, #+0]
    569          
    570            /* Return function status */
    571            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Stop_1: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    572          }
    573          
    574          /**
    575            * @brief  Starts the TIM Output Compare signal generation in interrupt mode
    576            *         on the complementary output.
    577            * @param  htim TIM OC handle
    578            * @param  Channel TIM Channel to be enabled
    579            *          This parameter can be one of the following values:
    580            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    581            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    582            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    583            * @retval HAL status
    584            */

   \                                 In section .text, align 2, keep-with-next
    585          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    586          {
   \                     HAL_TIMEx_OCN_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    587            uint32_t tmpsmcr;
    588          
    589            /* Check the parameters */
    590            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    591          
    592            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD004             BEQ      ??HAL_TIMEx_OCN_Start_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD009             BEQ      ??HAL_TIMEx_OCN_Start_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD00E             BEQ      ??HAL_TIMEx_OCN_Start_IT_2
   \       0x14   0xE014             B        ??HAL_TIMEx_OCN_Start_IT_3
    593            {
    594              case TIM_CHANNEL_1:
    595              {
    596                /* Enable the TIM Output Compare interrupt */
    597                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OCN_Start_IT_0: (+1)
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x68C0             LDR      R0,[R0, #+12]
   \       0x1A   0x2102             MOVS     R1,#+2
   \       0x1C   0x4301             ORRS     R1,R1,R0
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x60C1             STR      R1,[R0, #+12]
    598                break;
   \       0x22   0xE00D             B        ??HAL_TIMEx_OCN_Start_IT_4
    599              }
    600          
    601              case TIM_CHANNEL_2:
    602              {
    603                /* Enable the TIM Output Compare interrupt */
    604                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_OCN_Start_IT_1: (+1)
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x68C0             LDR      R0,[R0, #+12]
   \       0x28   0x2104             MOVS     R1,#+4
   \       0x2A   0x4301             ORRS     R1,R1,R0
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x60C1             STR      R1,[R0, #+12]
    605                break;
   \       0x30   0xE006             B        ??HAL_TIMEx_OCN_Start_IT_4
    606              }
    607          
    608              case TIM_CHANNEL_3:
    609              {
    610                /* Enable the TIM Output Compare interrupt */
    611                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_OCN_Start_IT_2: (+1)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x68C0             LDR      R0,[R0, #+12]
   \       0x36   0x2108             MOVS     R1,#+8
   \       0x38   0x4301             ORRS     R1,R1,R0
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x60C1             STR      R1,[R0, #+12]
    612                break;
   \       0x3E   0xE7FF             B        ??HAL_TIMEx_OCN_Start_IT_4
    613              }
    614          
    615          
    616              default:
    617                break;
    618            }
    619          
    620            /* Enable the TIM Break interrupt */
    621            __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   \                     ??HAL_TIMEx_OCN_Start_IT_3: (+1)
   \                     ??HAL_TIMEx_OCN_Start_IT_4: (+1)
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x68C0             LDR      R0,[R0, #+12]
   \       0x44   0x2180             MOVS     R1,#+128
   \       0x46   0x4301             ORRS     R1,R1,R0
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x60C1             STR      R1,[R0, #+12]
    622          
    623            /* Enable the Capture compare channel N */
    624            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \       0x4C   0x2204             MOVS     R2,#+4
   \       0x4E   0x0029             MOVS     R1,R5
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x....'....        BL       TIM_CCxNChannelCmd
    625          
    626            /* Enable the Main Output */
    627            __HAL_TIM_MOE_ENABLE(htim);
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6C40             LDR      R0,[R0, #+68]
   \       0x5A   0x2180             MOVS     R1,#+128
   \       0x5C   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x5E   0x4301             ORRS     R1,R1,R0
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6441             STR      R1,[R0, #+68]
    628          
    629            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    630            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6880             LDR      R0,[R0, #+8]
   \       0x68   0x....             LDR      R1,??DataTable10  ;; 0x10007
   \       0x6A   0x4001             ANDS     R1,R1,R0
    631            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x6C   0x2906             CMP      R1,#+6
   \       0x6E   0xD009             BEQ      ??HAL_TIMEx_OCN_Start_IT_5
   \       0x70   0x2080             MOVS     R0,#+128
   \       0x72   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x74   0x4281             CMP      R1,R0
   \       0x76   0xD005             BEQ      ??HAL_TIMEx_OCN_Start_IT_5
    632            {
    633              __HAL_TIM_ENABLE(htim);
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x6800             LDR      R0,[R0, #+0]
   \       0x7C   0x2201             MOVS     R2,#+1
   \       0x7E   0x4302             ORRS     R2,R2,R0
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6002             STR      R2,[R0, #+0]
    634            }
    635          
    636            /* Return function status */
    637            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Start_IT_5: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    638          }
    639          
    640          /**
    641            * @brief  Stops the TIM Output Compare signal generation in interrupt mode
    642            *         on the complementary output.
    643            * @param  htim TIM Output Compare handle
    644            * @param  Channel TIM Channel to be disabled
    645            *          This parameter can be one of the following values:
    646            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    647            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    648            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    649            * @retval HAL status
    650            */

   \                                 In section .text, align 2, keep-with-next
    651          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    652          {
   \                     HAL_TIMEx_OCN_Stop_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    653            uint32_t tmpccer;
    654            /* Check the parameters */
    655            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    656          
    657            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD004             BEQ      ??HAL_TIMEx_OCN_Stop_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD009             BEQ      ??HAL_TIMEx_OCN_Stop_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD00E             BEQ      ??HAL_TIMEx_OCN_Stop_IT_2
   \       0x14   0xE014             B        ??HAL_TIMEx_OCN_Stop_IT_3
    658            {
    659              case TIM_CHANNEL_1:
    660              {
    661                /* Disable the TIM Output Compare interrupt */
    662                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_OCN_Stop_IT_0: (+1)
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x68C0             LDR      R0,[R0, #+12]
   \       0x1A   0x2102             MOVS     R1,#+2
   \       0x1C   0x4388             BICS     R0,R0,R1
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x60C8             STR      R0,[R1, #+12]
    663                break;
   \       0x22   0xE00D             B        ??HAL_TIMEx_OCN_Stop_IT_4
    664              }
    665          
    666              case TIM_CHANNEL_2:
    667              {
    668                /* Disable the TIM Output Compare interrupt */
    669                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_OCN_Stop_IT_1: (+1)
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x68C0             LDR      R0,[R0, #+12]
   \       0x28   0x2104             MOVS     R1,#+4
   \       0x2A   0x4388             BICS     R0,R0,R1
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x60C8             STR      R0,[R1, #+12]
    670                break;
   \       0x30   0xE006             B        ??HAL_TIMEx_OCN_Stop_IT_4
    671              }
    672          
    673              case TIM_CHANNEL_3:
    674              {
    675                /* Disable the TIM Output Compare interrupt */
    676                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_OCN_Stop_IT_2: (+1)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x68C0             LDR      R0,[R0, #+12]
   \       0x36   0x2108             MOVS     R1,#+8
   \       0x38   0x4388             BICS     R0,R0,R1
   \       0x3A   0x6821             LDR      R1,[R4, #+0]
   \       0x3C   0x60C8             STR      R0,[R1, #+12]
    677                break;
   \       0x3E   0xE7FF             B        ??HAL_TIMEx_OCN_Stop_IT_4
    678              }
    679          
    680              default:
    681                break;
    682            }
    683          
    684            /* Disable the Capture compare channel N */
    685            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_OCN_Stop_IT_3: (+1)
   \                     ??HAL_TIMEx_OCN_Stop_IT_4: (+1)
   \       0x40   0x2200             MOVS     R2,#+0
   \       0x42   0x0029             MOVS     R1,R5
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x....'....        BL       TIM_CCxNChannelCmd
    686          
    687            /* Disable the TIM Break interrupt (only if no more channel is active) */
    688            tmpccer = htim->Instance->CCER;
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6A01             LDR      R1,[R0, #+32]
    689            if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
   \       0x4E   0x....             LDR      R0,??DataTable14  ;; 0x444
   \       0x50   0x4201             TST      R1,R0
   \       0x52   0xD105             BNE      ??HAL_TIMEx_OCN_Stop_IT_5
    690            {
    691              __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   \       0x54   0x6822             LDR      R2,[R4, #+0]
   \       0x56   0x68D2             LDR      R2,[R2, #+12]
   \       0x58   0x2380             MOVS     R3,#+128
   \       0x5A   0x439A             BICS     R2,R2,R3
   \       0x5C   0x6823             LDR      R3,[R4, #+0]
   \       0x5E   0x60DA             STR      R2,[R3, #+12]
    692            }
    693          
    694            /* Disable the Main Output */
    695            __HAL_TIM_MOE_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_IT_5: (+1)
   \       0x60   0x....             LDR      R2,??DataTable14_1  ;; 0x1111
   \       0x62   0x6823             LDR      R3,[R4, #+0]
   \       0x64   0x6A1B             LDR      R3,[R3, #+32]
   \       0x66   0x4013             ANDS     R3,R3,R2
   \       0x68   0x2B00             CMP      R3,#+0
   \       0x6A   0xD10A             BNE      ??HAL_TIMEx_OCN_Stop_IT_6
   \       0x6C   0x6823             LDR      R3,[R4, #+0]
   \       0x6E   0x6A1B             LDR      R3,[R3, #+32]
   \       0x70   0x4003             ANDS     R3,R3,R0
   \       0x72   0x2B00             CMP      R3,#+0
   \       0x74   0xD105             BNE      ??HAL_TIMEx_OCN_Stop_IT_6
   \       0x76   0x6823             LDR      R3,[R4, #+0]
   \       0x78   0x6C5B             LDR      R3,[R3, #+68]
   \       0x7A   0x....             LDR      R6,??DataTable12  ;; 0xffff7fff
   \       0x7C   0x401E             ANDS     R6,R6,R3
   \       0x7E   0x6823             LDR      R3,[R4, #+0]
   \       0x80   0x645E             STR      R6,[R3, #+68]
    696          
    697            /* Disable the Peripheral */
    698            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_IT_6: (+1)
   \       0x82   0x6823             LDR      R3,[R4, #+0]
   \       0x84   0x6A1B             LDR      R3,[R3, #+32]
   \       0x86   0x401A             ANDS     R2,R2,R3
   \       0x88   0x2A00             CMP      R2,#+0
   \       0x8A   0xD10A             BNE      ??HAL_TIMEx_OCN_Stop_IT_7
   \       0x8C   0x6822             LDR      R2,[R4, #+0]
   \       0x8E   0x6A12             LDR      R2,[R2, #+32]
   \       0x90   0x4010             ANDS     R0,R0,R2
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD105             BNE      ??HAL_TIMEx_OCN_Stop_IT_7
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x6800             LDR      R0,[R0, #+0]
   \       0x9A   0x2201             MOVS     R2,#+1
   \       0x9C   0x4390             BICS     R0,R0,R2
   \       0x9E   0x6822             LDR      R2,[R4, #+0]
   \       0xA0   0x6010             STR      R0,[R2, #+0]
    699          
    700            /* Return function status */
    701            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Stop_IT_7: (+1)
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0xBD70             POP      {R4-R6,PC}       ;; return
    702          }
    703          
    704          /**
    705            * @brief  Starts the TIM Output Compare signal generation in DMA mode
    706            *         on the complementary output.
    707            * @param  htim TIM Output Compare handle
    708            * @param  Channel TIM Channel to be enabled
    709            *          This parameter can be one of the following values:
    710            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    711            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    712            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    713            * @param  pData The source Buffer address.
    714            * @param  Length The length of data to be transferred from memory to TIM peripheral
    715            * @retval HAL status
    716            */

   \                                 In section .text, align 2, keep-with-next
    717          HAL_StatusTypeDef HAL_TIMEx_OCN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    718          {
   \                     HAL_TIMEx_OCN_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001D             MOVS     R5,R3
    719            uint32_t tmpsmcr;
    720          
    721            /* Check the parameters */
    722            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    723          
    724            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xA   0x203D             MOVS     R0,#+61
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE      ??HAL_TIMEx_OCN_Start_DMA_0
    725            {
    726              return HAL_BUSY;
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE08D             B        ??HAL_TIMEx_OCN_Start_DMA_1
    727            }
    728            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIMEx_OCN_Start_DMA_0: (+1)
   \       0x16   0x203D             MOVS     R0,#+61
   \       0x18   0x5C20             LDRB     R0,[R4, R0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD10A             BNE      ??HAL_TIMEx_OCN_Start_DMA_2
    729            {
    730              if (((uint32_t)pData == 0U) && (Length > 0U))
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD105             BNE      ??HAL_TIMEx_OCN_Start_DMA_3
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0xB280             UXTH     R0,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ      ??HAL_TIMEx_OCN_Start_DMA_3
    731              {
    732                return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE081             B        ??HAL_TIMEx_OCN_Start_DMA_1
    733              }
    734              else
    735              {
    736                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_OCN_Start_DMA_3: (+1)
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0x213D             MOVS     R1,#+61
   \       0x32   0x5460             STRB     R0,[R4, R1]
    737              }
    738            }
    739            else
    740            {
    741              /* nothing to do  */
    742            }
    743          
    744            switch (Channel)
   \                     ??HAL_TIMEx_OCN_Start_DMA_2: (+1)
   \       0x34   0x0038             MOVS     R0,R7
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD004             BEQ      ??HAL_TIMEx_OCN_Start_DMA_4
   \       0x3A   0x2804             CMP      R0,#+4
   \       0x3C   0xD020             BEQ      ??HAL_TIMEx_OCN_Start_DMA_5
   \       0x3E   0x2808             CMP      R0,#+8
   \       0x40   0xD03C             BEQ      ??HAL_TIMEx_OCN_Start_DMA_6
   \       0x42   0xE059             B        ??HAL_TIMEx_OCN_Start_DMA_7
    745            {
    746              case TIM_CHANNEL_1:
    747              {
    748                /* Set the DMA compare callbacks */
    749                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_4: (+1)
   \       0x44   0x....             LDR      R0,??DataTable16
   \       0x46   0x6A61             LDR      R1,[R4, #+36]
   \       0x48   0x62C8             STR      R0,[R1, #+44]
    750                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x4A   0x....             LDR      R0,??DataTable16_1
   \       0x4C   0x6A61             LDR      R1,[R4, #+36]
   \       0x4E   0x6308             STR      R0,[R1, #+48]
    751          
    752                /* Set the DMA error callback */
    753                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x50   0x....             LDR      R0,??DataTable16_2
   \       0x52   0x6A61             LDR      R1,[R4, #+36]
   \       0x54   0x6348             STR      R0,[R1, #+52]
    754          
    755                /* Enable the DMA channel */
    756                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   \       0x56   0x002B             MOVS     R3,R5
   \       0x58   0xB29B             UXTH     R3,R3
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x0002             MOVS     R2,R0
   \       0x5E   0x3234             ADDS     R2,R2,#+52
   \       0x60   0x0031             MOVS     R1,R6
   \       0x62   0x6A60             LDR      R0,[R4, #+36]
   \       0x64   0x....'....        BL       HAL_DMA_Start_IT
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD001             BEQ      ??HAL_TIMEx_OCN_Start_DMA_8
    757                {
    758                  return HAL_ERROR;
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xE060             B        ??HAL_TIMEx_OCN_Start_DMA_1
    759                }
    760                /* Enable the TIM Output Compare DMA request */
    761                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_OCN_Start_DMA_8: (+1)
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x68C0             LDR      R0,[R0, #+12]
   \       0x74   0x2180             MOVS     R1,#+128
   \       0x76   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x78   0x4301             ORRS     R1,R1,R0
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x60C1             STR      R1,[R0, #+12]
    762                break;
   \       0x7E   0xE03B             B        ??HAL_TIMEx_OCN_Start_DMA_9
    763              }
    764          
    765              case TIM_CHANNEL_2:
    766              {
    767                /* Set the DMA compare callbacks */
    768                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_5: (+1)
   \       0x80   0x....             LDR      R0,??DataTable16
   \       0x82   0x6AA1             LDR      R1,[R4, #+40]
   \       0x84   0x62C8             STR      R0,[R1, #+44]
    769                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x86   0x....             LDR      R0,??DataTable16_1
   \       0x88   0x6AA1             LDR      R1,[R4, #+40]
   \       0x8A   0x6308             STR      R0,[R1, #+48]
    770          
    771                /* Set the DMA error callback */
    772                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0x8C   0x....             LDR      R0,??DataTable16_2
   \       0x8E   0x6AA1             LDR      R1,[R4, #+40]
   \       0x90   0x6348             STR      R0,[R1, #+52]
    773          
    774                /* Enable the DMA channel */
    775                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   \       0x92   0x002B             MOVS     R3,R5
   \       0x94   0xB29B             UXTH     R3,R3
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x0002             MOVS     R2,R0
   \       0x9A   0x3238             ADDS     R2,R2,#+56
   \       0x9C   0x0031             MOVS     R1,R6
   \       0x9E   0x6AA0             LDR      R0,[R4, #+40]
   \       0xA0   0x....'....        BL       HAL_DMA_Start_IT
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD001             BEQ      ??HAL_TIMEx_OCN_Start_DMA_10
    776                {
    777                  return HAL_ERROR;
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0xE042             B        ??HAL_TIMEx_OCN_Start_DMA_1
    778                }
    779                /* Enable the TIM Output Compare DMA request */
    780                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_OCN_Start_DMA_10: (+1)
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x68C0             LDR      R0,[R0, #+12]
   \       0xB0   0x2180             MOVS     R1,#+128
   \       0xB2   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \       0xB4   0x4301             ORRS     R1,R1,R0
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x60C1             STR      R1,[R0, #+12]
    781                break;
   \       0xBA   0xE01D             B        ??HAL_TIMEx_OCN_Start_DMA_9
    782              }
    783          
    784              case TIM_CHANNEL_3:
    785              {
    786                /* Set the DMA compare callbacks */
    787                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_OCN_Start_DMA_6: (+1)
   \       0xBC   0x....             LDR      R0,??DataTable16
   \       0xBE   0x6AE1             LDR      R1,[R4, #+44]
   \       0xC0   0x62C8             STR      R0,[R1, #+44]
    788                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xC2   0x....             LDR      R0,??DataTable16_1
   \       0xC4   0x6AE1             LDR      R1,[R4, #+44]
   \       0xC6   0x6308             STR      R0,[R1, #+48]
    789          
    790                /* Set the DMA error callback */
    791                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \       0xC8   0x....             LDR      R0,??DataTable16_2
   \       0xCA   0x6AE1             LDR      R1,[R4, #+44]
   \       0xCC   0x6348             STR      R0,[R1, #+52]
    792          
    793                /* Enable the DMA channel */
    794                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   \       0xCE   0x002B             MOVS     R3,R5
   \       0xD0   0xB29B             UXTH     R3,R3
   \       0xD2   0x6820             LDR      R0,[R4, #+0]
   \       0xD4   0x0002             MOVS     R2,R0
   \       0xD6   0x323C             ADDS     R2,R2,#+60
   \       0xD8   0x0031             MOVS     R1,R6
   \       0xDA   0x6AE0             LDR      R0,[R4, #+44]
   \       0xDC   0x....'....        BL       HAL_DMA_Start_IT
   \       0xE0   0x2800             CMP      R0,#+0
   \       0xE2   0xD001             BEQ      ??HAL_TIMEx_OCN_Start_DMA_11
    795                {
    796                  return HAL_ERROR;
   \       0xE4   0x2001             MOVS     R0,#+1
   \       0xE6   0xE024             B        ??HAL_TIMEx_OCN_Start_DMA_1
    797                }
    798                /* Enable the TIM Output Compare DMA request */
    799                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_OCN_Start_DMA_11: (+1)
   \       0xE8   0x6820             LDR      R0,[R4, #+0]
   \       0xEA   0x68C0             LDR      R0,[R0, #+12]
   \       0xEC   0x2180             MOVS     R1,#+128
   \       0xEE   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0xF0   0x4301             ORRS     R1,R1,R0
   \       0xF2   0x6820             LDR      R0,[R4, #+0]
   \       0xF4   0x60C1             STR      R1,[R0, #+12]
    800                break;
   \       0xF6   0xE7FF             B        ??HAL_TIMEx_OCN_Start_DMA_9
    801              }
    802          
    803              default:
    804                break;
    805            }
    806          
    807            /* Enable the Capture compare channel N */
    808            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     ??HAL_TIMEx_OCN_Start_DMA_7: (+1)
   \                     ??HAL_TIMEx_OCN_Start_DMA_9: (+1)
   \       0xF8   0x2204             MOVS     R2,#+4
   \       0xFA   0x0039             MOVS     R1,R7
   \       0xFC   0x6820             LDR      R0,[R4, #+0]
   \       0xFE   0x....'....        BL       TIM_CCxNChannelCmd
    809          
    810            /* Enable the Main Output */
    811            __HAL_TIM_MOE_ENABLE(htim);
   \      0x102   0x6820             LDR      R0,[R4, #+0]
   \      0x104   0x6C40             LDR      R0,[R0, #+68]
   \      0x106   0x2180             MOVS     R1,#+128
   \      0x108   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \      0x10A   0x4301             ORRS     R1,R1,R0
   \      0x10C   0x6820             LDR      R0,[R4, #+0]
   \      0x10E   0x6441             STR      R1,[R0, #+68]
    812          
    813            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    814            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \      0x110   0x6820             LDR      R0,[R4, #+0]
   \      0x112   0x6880             LDR      R0,[R0, #+8]
   \      0x114   0x....             LDR      R1,??DataTable17  ;; 0x10007
   \      0x116   0x4001             ANDS     R1,R1,R0
    815            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \      0x118   0x2906             CMP      R1,#+6
   \      0x11A   0xD009             BEQ      ??HAL_TIMEx_OCN_Start_DMA_12
   \      0x11C   0x2080             MOVS     R0,#+128
   \      0x11E   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \      0x120   0x4281             CMP      R1,R0
   \      0x122   0xD005             BEQ      ??HAL_TIMEx_OCN_Start_DMA_12
    816            {
    817              __HAL_TIM_ENABLE(htim);
   \      0x124   0x6820             LDR      R0,[R4, #+0]
   \      0x126   0x6800             LDR      R0,[R0, #+0]
   \      0x128   0x2201             MOVS     R2,#+1
   \      0x12A   0x4302             ORRS     R2,R2,R0
   \      0x12C   0x6820             LDR      R0,[R4, #+0]
   \      0x12E   0x6002             STR      R2,[R0, #+0]
    818            }
    819          
    820            /* Return function status */
    821            return HAL_OK;
   \                     ??HAL_TIMEx_OCN_Start_DMA_12: (+1)
   \      0x130   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_OCN_Start_DMA_1: (+1)
   \      0x132   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    822          }
    823          
    824          /**
    825            * @brief  Stops the TIM Output Compare signal generation in DMA mode
    826            *         on the complementary output.
    827            * @param  htim TIM Output Compare handle
    828            * @param  Channel TIM Channel to be disabled
    829            *          This parameter can be one of the following values:
    830            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    831            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    832            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    833            * @retval HAL status
    834            */

   \                                 In section .text, align 2, keep-with-next
    835          HAL_StatusTypeDef HAL_TIMEx_OCN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    836          {
   \                     HAL_TIMEx_OCN_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    837            /* Check the parameters */
    838            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    839          
    840            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD004             BEQ      ??HAL_TIMEx_OCN_Stop_DMA_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00C             BEQ      ??HAL_TIMEx_OCN_Stop_DMA_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD014             BEQ      ??HAL_TIMEx_OCN_Stop_DMA_2
   \       0x14   0xE01D             B        ??HAL_TIMEx_OCN_Stop_DMA_3
    841            {
    842              case TIM_CHANNEL_1:
    843              {
    844                /* Disable the TIM Output Compare DMA request */
    845                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_0: (+1)
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x68C0             LDR      R0,[R0, #+12]
   \       0x1A   0x....             LDR      R1,??DataTable17_1  ;; 0xfffffdff
   \       0x1C   0x4001             ANDS     R1,R1,R0
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x60C1             STR      R1,[R0, #+12]
    846                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x22   0x6A60             LDR      R0,[R4, #+36]
   \       0x24   0x....'....        BL       HAL_DMA_Abort_IT
    847                break;
   \       0x28   0xE013             B        ??HAL_TIMEx_OCN_Stop_DMA_4
    848              }
    849          
    850              case TIM_CHANNEL_2:
    851              {
    852                /* Disable the TIM Output Compare DMA request */
    853                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_1: (+1)
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x68C0             LDR      R0,[R0, #+12]
   \       0x2E   0x....             LDR      R1,??DataTable17_2  ;; 0xfffffbff
   \       0x30   0x4001             ANDS     R1,R1,R0
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x60C1             STR      R1,[R0, #+12]
    854                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x36   0x6AA0             LDR      R0,[R4, #+40]
   \       0x38   0x....'....        BL       HAL_DMA_Abort_IT
    855                break;
   \       0x3C   0xE009             B        ??HAL_TIMEx_OCN_Stop_DMA_4
    856              }
    857          
    858              case TIM_CHANNEL_3:
    859              {
    860                /* Disable the TIM Output Compare DMA request */
    861                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_2: (+1)
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x68C0             LDR      R0,[R0, #+12]
   \       0x42   0x....             LDR      R1,??DataTable17_3  ;; 0xfffff7ff
   \       0x44   0x4001             ANDS     R1,R1,R0
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x60C1             STR      R1,[R0, #+12]
    862                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \       0x4A   0x6AE0             LDR      R0,[R4, #+44]
   \       0x4C   0x....'....        BL       HAL_DMA_Abort_IT
    863                break;
   \       0x50   0xE7FF             B        ??HAL_TIMEx_OCN_Stop_DMA_4
    864              }
    865          
    866              default:
    867                break;
    868            }
    869          
    870            /* Disable the Capture compare channel N */
    871            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_3: (+1)
   \                     ??HAL_TIMEx_OCN_Stop_DMA_4: (+1)
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x....'....        BL       TIM_CCxNChannelCmd
    872          
    873            /* Disable the Main Output */
    874            __HAL_TIM_MOE_DISABLE(htim);
   \       0x5C   0x....             LDR      R0,??DataTable14_1  ;; 0x1111
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x6A09             LDR      R1,[R1, #+32]
   \       0x62   0x4001             ANDS     R1,R1,R0
   \       0x64   0x2900             CMP      R1,#+0
   \       0x66   0xD10B             BNE      ??HAL_TIMEx_OCN_Stop_DMA_5
   \       0x68   0x6821             LDR      R1,[R4, #+0]
   \       0x6A   0x6A09             LDR      R1,[R1, #+32]
   \       0x6C   0x....             LDR      R2,??DataTable14  ;; 0x444
   \       0x6E   0x400A             ANDS     R2,R2,R1
   \       0x70   0x2A00             CMP      R2,#+0
   \       0x72   0xD105             BNE      ??HAL_TIMEx_OCN_Stop_DMA_5
   \       0x74   0x6821             LDR      R1,[R4, #+0]
   \       0x76   0x6C49             LDR      R1,[R1, #+68]
   \       0x78   0x....             LDR      R2,??DataTable17_4  ;; 0xffff7fff
   \       0x7A   0x400A             ANDS     R2,R2,R1
   \       0x7C   0x6821             LDR      R1,[R4, #+0]
   \       0x7E   0x644A             STR      R2,[R1, #+68]
    875          
    876            /* Disable the Peripheral */
    877            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OCN_Stop_DMA_5: (+1)
   \       0x80   0x6821             LDR      R1,[R4, #+0]
   \       0x82   0x6A09             LDR      R1,[R1, #+32]
   \       0x84   0x4008             ANDS     R0,R0,R1
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD10B             BNE      ??HAL_TIMEx_OCN_Stop_DMA_6
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x6A00             LDR      R0,[R0, #+32]
   \       0x8E   0x....             LDR      R1,??DataTable14  ;; 0x444
   \       0x90   0x4001             ANDS     R1,R1,R0
   \       0x92   0x2900             CMP      R1,#+0
   \       0x94   0xD105             BNE      ??HAL_TIMEx_OCN_Stop_DMA_6
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x6800             LDR      R0,[R0, #+0]
   \       0x9A   0x2101             MOVS     R1,#+1
   \       0x9C   0x4388             BICS     R0,R0,R1
   \       0x9E   0x6821             LDR      R1,[R4, #+0]
   \       0xA0   0x6008             STR      R0,[R1, #+0]
    878          
    879            /* Change the htim state */
    880            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIMEx_OCN_Stop_DMA_6: (+1)
   \       0xA2   0x2001             MOVS     R0,#+1
   \       0xA4   0x213D             MOVS     R1,#+61
   \       0xA6   0x5460             STRB     R0,[R4, R1]
    881          
    882            /* Return function status */
    883            return HAL_OK;
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    884          }
    885          
    886          /**
    887            * @}
    888            */
    889          
    890          /** @defgroup TIMEx_Exported_Functions_Group3 Extended Timer Complementary PWM functions
    891            * @brief    Timer Complementary PWM functions
    892            *
    893          @verbatim
    894            ==============================================================================
    895                           ##### Timer Complementary PWM functions #####
    896            ==============================================================================
    897            [..]
    898              This section provides functions allowing to:
    899              (+) Start the Complementary PWM.
    900              (+) Stop the Complementary PWM.
    901              (+) Start the Complementary PWM and enable interrupts.
    902              (+) Stop the Complementary PWM and disable interrupts.
    903              (+) Start the Complementary PWM and enable DMA transfers.
    904              (+) Stop the Complementary PWM and disable DMA transfers.
    905              (+) Start the Complementary Input Capture measurement.
    906              (+) Stop the Complementary Input Capture.
    907              (+) Start the Complementary Input Capture and enable interrupts.
    908              (+) Stop the Complementary Input Capture and disable interrupts.
    909              (+) Start the Complementary Input Capture and enable DMA transfers.
    910              (+) Stop the Complementary Input Capture and disable DMA transfers.
    911              (+) Start the Complementary One Pulse generation.
    912              (+) Stop the Complementary One Pulse.
    913              (+) Start the Complementary One Pulse and enable interrupts.
    914              (+) Stop the Complementary One Pulse and disable interrupts.
    915          
    916          @endverbatim
    917            * @{
    918            */
    919          
    920          /**
    921            * @brief  Starts the PWM signal generation on the complementary output.
    922            * @param  htim TIM handle
    923            * @param  Channel TIM Channel to be enabled
    924            *          This parameter can be one of the following values:
    925            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    926            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    927            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    928            * @retval HAL status
    929            */

   \                                 In section .text, align 2, keep-with-next
    930          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    931          {
   \                     HAL_TIMEx_PWMN_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    932            uint32_t tmpsmcr;
    933          
    934            /* Check the parameters */
    935            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    936          
    937            /* Enable the complementary PWM output  */
    938            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \        0x6   0x2204             MOVS     R2,#+4
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxNChannelCmd
    939          
    940            /* Enable the Main Output */
    941            __HAL_TIM_MOE_ENABLE(htim);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6C40             LDR      R0,[R0, #+68]
   \       0x14   0x2180             MOVS     R1,#+128
   \       0x16   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x18   0x4301             ORRS     R1,R1,R0
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6441             STR      R1,[R0, #+68]
    942          
    943            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
    944            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x6880             LDR      R0,[R0, #+8]
   \       0x22   0x....             LDR      R1,??DataTable17  ;; 0x10007
   \       0x24   0x4001             ANDS     R1,R1,R0
    945            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x26   0x2906             CMP      R1,#+6
   \       0x28   0xD009             BEQ      ??HAL_TIMEx_PWMN_Start_0
   \       0x2A   0x2080             MOVS     R0,#+128
   \       0x2C   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x2E   0x4281             CMP      R1,R0
   \       0x30   0xD005             BEQ      ??HAL_TIMEx_PWMN_Start_0
    946            {
    947              __HAL_TIM_ENABLE(htim);
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6800             LDR      R0,[R0, #+0]
   \       0x36   0x2201             MOVS     R2,#+1
   \       0x38   0x4302             ORRS     R2,R2,R0
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x6002             STR      R2,[R0, #+0]
    948            }
    949          
    950            /* Return function status */
    951            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Start_0: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    952          }
    953          
    954          /**
    955            * @brief  Stops the PWM signal generation on the complementary output.
    956            * @param  htim TIM handle
    957            * @param  Channel TIM Channel to be disabled
    958            *          This parameter can be one of the following values:
    959            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    960            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    961            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    962            * @retval HAL status
    963            */

   \                                 In section .text, align 2, keep-with-next
    964          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    965          {
   \                     HAL_TIMEx_PWMN_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    966            /* Check the parameters */
    967            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    968          
    969            /* Disable the complementary PWM output  */
    970            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxNChannelCmd
    971          
    972            /* Disable the Main Output */
    973            __HAL_TIM_MOE_DISABLE(htim);
   \       0x10   0x....             LDR      R0,??DataTable18  ;; 0x1111
   \       0x12   0x6821             LDR      R1,[R4, #+0]
   \       0x14   0x6A09             LDR      R1,[R1, #+32]
   \       0x16   0x4001             ANDS     R1,R1,R0
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD10B             BNE      ??HAL_TIMEx_PWMN_Stop_0
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6A09             LDR      R1,[R1, #+32]
   \       0x20   0x....             LDR      R2,??DataTable18_1  ;; 0x444
   \       0x22   0x400A             ANDS     R2,R2,R1
   \       0x24   0x2A00             CMP      R2,#+0
   \       0x26   0xD105             BNE      ??HAL_TIMEx_PWMN_Stop_0
   \       0x28   0x6821             LDR      R1,[R4, #+0]
   \       0x2A   0x6C49             LDR      R1,[R1, #+68]
   \       0x2C   0x....             LDR      R2,??DataTable17_4  ;; 0xffff7fff
   \       0x2E   0x400A             ANDS     R2,R2,R1
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x644A             STR      R2,[R1, #+68]
    974          
    975            /* Disable the Peripheral */
    976            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_0: (+1)
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x6A09             LDR      R1,[R1, #+32]
   \       0x38   0x4008             ANDS     R0,R0,R1
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD10B             BNE      ??HAL_TIMEx_PWMN_Stop_1
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6A00             LDR      R0,[R0, #+32]
   \       0x42   0x....             LDR      R1,??DataTable18_1  ;; 0x444
   \       0x44   0x4001             ANDS     R1,R1,R0
   \       0x46   0x2900             CMP      R1,#+0
   \       0x48   0xD105             BNE      ??HAL_TIMEx_PWMN_Stop_1
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6800             LDR      R0,[R0, #+0]
   \       0x4E   0x2101             MOVS     R1,#+1
   \       0x50   0x4388             BICS     R0,R0,R1
   \       0x52   0x6821             LDR      R1,[R4, #+0]
   \       0x54   0x6008             STR      R0,[R1, #+0]
    977          
    978            /* Return function status */
    979            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Stop_1: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    980          }
    981          
    982          /**
    983            * @brief  Starts the PWM signal generation in interrupt mode on the
    984            *         complementary output.
    985            * @param  htim TIM handle
    986            * @param  Channel TIM Channel to be disabled
    987            *          This parameter can be one of the following values:
    988            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    989            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    990            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    991            * @retval HAL status
    992            */

   \                                 In section .text, align 2, keep-with-next
    993          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    994          {
   \                     HAL_TIMEx_PWMN_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
    995            uint32_t tmpsmcr;
    996          
    997            /* Check the parameters */
    998            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
    999          
   1000            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD004             BEQ      ??HAL_TIMEx_PWMN_Start_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD009             BEQ      ??HAL_TIMEx_PWMN_Start_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD00E             BEQ      ??HAL_TIMEx_PWMN_Start_IT_2
   \       0x14   0xE014             B        ??HAL_TIMEx_PWMN_Start_IT_3
   1001            {
   1002              case TIM_CHANNEL_1:
   1003              {
   1004                /* Enable the TIM Capture/Compare 1 interrupt */
   1005                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_PWMN_Start_IT_0: (+1)
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x68C0             LDR      R0,[R0, #+12]
   \       0x1A   0x2102             MOVS     R1,#+2
   \       0x1C   0x4301             ORRS     R1,R1,R0
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x60C1             STR      R1,[R0, #+12]
   1006                break;
   \       0x22   0xE00D             B        ??HAL_TIMEx_PWMN_Start_IT_4
   1007              }
   1008          
   1009              case TIM_CHANNEL_2:
   1010              {
   1011                /* Enable the TIM Capture/Compare 2 interrupt */
   1012                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_PWMN_Start_IT_1: (+1)
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x68C0             LDR      R0,[R0, #+12]
   \       0x28   0x2104             MOVS     R1,#+4
   \       0x2A   0x4301             ORRS     R1,R1,R0
   \       0x2C   0x6820             LDR      R0,[R4, #+0]
   \       0x2E   0x60C1             STR      R1,[R0, #+12]
   1013                break;
   \       0x30   0xE006             B        ??HAL_TIMEx_PWMN_Start_IT_4
   1014              }
   1015          
   1016              case TIM_CHANNEL_3:
   1017              {
   1018                /* Enable the TIM Capture/Compare 3 interrupt */
   1019                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_PWMN_Start_IT_2: (+1)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x68C0             LDR      R0,[R0, #+12]
   \       0x36   0x2108             MOVS     R1,#+8
   \       0x38   0x4301             ORRS     R1,R1,R0
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x60C1             STR      R1,[R0, #+12]
   1020                break;
   \       0x3E   0xE7FF             B        ??HAL_TIMEx_PWMN_Start_IT_4
   1021              }
   1022          
   1023              default:
   1024                break;
   1025            }
   1026          
   1027            /* Enable the TIM Break interrupt */
   1028            __HAL_TIM_ENABLE_IT(htim, TIM_IT_BREAK);
   \                     ??HAL_TIMEx_PWMN_Start_IT_3: (+1)
   \                     ??HAL_TIMEx_PWMN_Start_IT_4: (+1)
   \       0x40   0x6820             LDR      R0,[R4, #+0]
   \       0x42   0x68C0             LDR      R0,[R0, #+12]
   \       0x44   0x2180             MOVS     R1,#+128
   \       0x46   0x4301             ORRS     R1,R1,R0
   \       0x48   0x6820             LDR      R0,[R4, #+0]
   \       0x4A   0x60C1             STR      R1,[R0, #+12]
   1029          
   1030            /* Enable the complementary PWM output  */
   1031            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \       0x4C   0x2204             MOVS     R2,#+4
   \       0x4E   0x0029             MOVS     R1,R5
   \       0x50   0x6820             LDR      R0,[R4, #+0]
   \       0x52   0x....'....        BL       TIM_CCxNChannelCmd
   1032          
   1033            /* Enable the Main Output */
   1034            __HAL_TIM_MOE_ENABLE(htim);
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6C40             LDR      R0,[R0, #+68]
   \       0x5A   0x2180             MOVS     R1,#+128
   \       0x5C   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x5E   0x4301             ORRS     R1,R1,R0
   \       0x60   0x6820             LDR      R0,[R4, #+0]
   \       0x62   0x6441             STR      R1,[R0, #+68]
   1035          
   1036            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1037            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \       0x64   0x6820             LDR      R0,[R4, #+0]
   \       0x66   0x6880             LDR      R0,[R0, #+8]
   \       0x68   0x....             LDR      R1,??DataTable17  ;; 0x10007
   \       0x6A   0x4001             ANDS     R1,R1,R0
   1038            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \       0x6C   0x2906             CMP      R1,#+6
   \       0x6E   0xD009             BEQ      ??HAL_TIMEx_PWMN_Start_IT_5
   \       0x70   0x2080             MOVS     R0,#+128
   \       0x72   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \       0x74   0x4281             CMP      R1,R0
   \       0x76   0xD005             BEQ      ??HAL_TIMEx_PWMN_Start_IT_5
   1039            {
   1040              __HAL_TIM_ENABLE(htim);
   \       0x78   0x6820             LDR      R0,[R4, #+0]
   \       0x7A   0x6800             LDR      R0,[R0, #+0]
   \       0x7C   0x2201             MOVS     R2,#+1
   \       0x7E   0x4302             ORRS     R2,R2,R0
   \       0x80   0x6820             LDR      R0,[R4, #+0]
   \       0x82   0x6002             STR      R2,[R0, #+0]
   1041            }
   1042          
   1043            /* Return function status */
   1044            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Start_IT_5: (+1)
   \       0x84   0x2000             MOVS     R0,#+0
   \       0x86   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1045          }
   1046          
   1047          /**
   1048            * @brief  Stops the PWM signal generation in interrupt mode on the
   1049            *         complementary output.
   1050            * @param  htim TIM handle
   1051            * @param  Channel TIM Channel to be disabled
   1052            *          This parameter can be one of the following values:
   1053            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1054            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1055            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1056            * @retval HAL status
   1057            */

   \                                 In section .text, align 2, keep-with-next
   1058          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1059          {
   \                     HAL_TIMEx_PWMN_Stop_IT: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1060            uint32_t tmpccer;
   1061          
   1062            /* Check the parameters */
   1063            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1064          
   1065            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD004             BEQ      ??HAL_TIMEx_PWMN_Stop_IT_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD009             BEQ      ??HAL_TIMEx_PWMN_Stop_IT_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD00E             BEQ      ??HAL_TIMEx_PWMN_Stop_IT_2
   \       0x14   0xE014             B        ??HAL_TIMEx_PWMN_Stop_IT_3
   1066            {
   1067              case TIM_CHANNEL_1:
   1068              {
   1069                /* Disable the TIM Capture/Compare 1 interrupt */
   1070                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_0: (+1)
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x68C0             LDR      R0,[R0, #+12]
   \       0x1A   0x2102             MOVS     R1,#+2
   \       0x1C   0x4388             BICS     R0,R0,R1
   \       0x1E   0x6821             LDR      R1,[R4, #+0]
   \       0x20   0x60C8             STR      R0,[R1, #+12]
   1071                break;
   \       0x22   0xE00D             B        ??HAL_TIMEx_PWMN_Stop_IT_4
   1072              }
   1073          
   1074              case TIM_CHANNEL_2:
   1075              {
   1076                /* Disable the TIM Capture/Compare 2 interrupt */
   1077                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_1: (+1)
   \       0x24   0x6820             LDR      R0,[R4, #+0]
   \       0x26   0x68C0             LDR      R0,[R0, #+12]
   \       0x28   0x2104             MOVS     R1,#+4
   \       0x2A   0x4388             BICS     R0,R0,R1
   \       0x2C   0x6821             LDR      R1,[R4, #+0]
   \       0x2E   0x60C8             STR      R0,[R1, #+12]
   1078                break;
   \       0x30   0xE006             B        ??HAL_TIMEx_PWMN_Stop_IT_4
   1079              }
   1080          
   1081              case TIM_CHANNEL_3:
   1082              {
   1083                /* Disable the TIM Capture/Compare 3 interrupt */
   1084                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_2: (+1)
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x68C0             LDR      R0,[R0, #+12]
   \       0x36   0x2108             MOVS     R1,#+8
   \       0x38   0x4388             BICS     R0,R0,R1
   \       0x3A   0x6821             LDR      R1,[R4, #+0]
   \       0x3C   0x60C8             STR      R0,[R1, #+12]
   1085                break;
   \       0x3E   0xE7FF             B        ??HAL_TIMEx_PWMN_Stop_IT_4
   1086              }
   1087          
   1088              default:
   1089                break;
   1090            }
   1091          
   1092            /* Disable the complementary PWM output  */
   1093            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_3: (+1)
   \                     ??HAL_TIMEx_PWMN_Stop_IT_4: (+1)
   \       0x40   0x2200             MOVS     R2,#+0
   \       0x42   0x0029             MOVS     R1,R5
   \       0x44   0x6820             LDR      R0,[R4, #+0]
   \       0x46   0x....'....        BL       TIM_CCxNChannelCmd
   1094          
   1095            /* Disable the TIM Break interrupt (only if no more channel is active) */
   1096            tmpccer = htim->Instance->CCER;
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6A01             LDR      R1,[R0, #+32]
   1097            if ((tmpccer & (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE)) == (uint32_t)RESET)
   \       0x4E   0x....             LDR      R0,??DataTable18_1  ;; 0x444
   \       0x50   0x4201             TST      R1,R0
   \       0x52   0xD105             BNE      ??HAL_TIMEx_PWMN_Stop_IT_5
   1098            {
   1099              __HAL_TIM_DISABLE_IT(htim, TIM_IT_BREAK);
   \       0x54   0x6822             LDR      R2,[R4, #+0]
   \       0x56   0x68D2             LDR      R2,[R2, #+12]
   \       0x58   0x2380             MOVS     R3,#+128
   \       0x5A   0x439A             BICS     R2,R2,R3
   \       0x5C   0x6823             LDR      R3,[R4, #+0]
   \       0x5E   0x60DA             STR      R2,[R3, #+12]
   1100            }
   1101          
   1102            /* Disable the Main Output */
   1103            __HAL_TIM_MOE_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_5: (+1)
   \       0x60   0x....             LDR      R2,??DataTable18  ;; 0x1111
   \       0x62   0x6823             LDR      R3,[R4, #+0]
   \       0x64   0x6A1B             LDR      R3,[R3, #+32]
   \       0x66   0x4013             ANDS     R3,R3,R2
   \       0x68   0x2B00             CMP      R3,#+0
   \       0x6A   0xD10A             BNE      ??HAL_TIMEx_PWMN_Stop_IT_6
   \       0x6C   0x6823             LDR      R3,[R4, #+0]
   \       0x6E   0x6A1B             LDR      R3,[R3, #+32]
   \       0x70   0x4003             ANDS     R3,R3,R0
   \       0x72   0x2B00             CMP      R3,#+0
   \       0x74   0xD105             BNE      ??HAL_TIMEx_PWMN_Stop_IT_6
   \       0x76   0x6823             LDR      R3,[R4, #+0]
   \       0x78   0x6C5B             LDR      R3,[R3, #+68]
   \       0x7A   0x....             LDR      R6,??DataTable17_4  ;; 0xffff7fff
   \       0x7C   0x401E             ANDS     R6,R6,R3
   \       0x7E   0x6823             LDR      R3,[R4, #+0]
   \       0x80   0x645E             STR      R6,[R3, #+68]
   1104          
   1105            /* Disable the Peripheral */
   1106            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_IT_6: (+1)
   \       0x82   0x6823             LDR      R3,[R4, #+0]
   \       0x84   0x6A1B             LDR      R3,[R3, #+32]
   \       0x86   0x401A             ANDS     R2,R2,R3
   \       0x88   0x2A00             CMP      R2,#+0
   \       0x8A   0xD10A             BNE      ??HAL_TIMEx_PWMN_Stop_IT_7
   \       0x8C   0x6822             LDR      R2,[R4, #+0]
   \       0x8E   0x6A12             LDR      R2,[R2, #+32]
   \       0x90   0x4010             ANDS     R0,R0,R2
   \       0x92   0x2800             CMP      R0,#+0
   \       0x94   0xD105             BNE      ??HAL_TIMEx_PWMN_Stop_IT_7
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x6800             LDR      R0,[R0, #+0]
   \       0x9A   0x2201             MOVS     R2,#+1
   \       0x9C   0x4390             BICS     R0,R0,R2
   \       0x9E   0x6822             LDR      R2,[R4, #+0]
   \       0xA0   0x6010             STR      R0,[R2, #+0]
   1107          
   1108            /* Return function status */
   1109            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Stop_IT_7: (+1)
   \       0xA2   0x2000             MOVS     R0,#+0
   \       0xA4   0xBD70             POP      {R4-R6,PC}       ;; return
   1110          }
   1111          
   1112          /**
   1113            * @brief  Starts the TIM PWM signal generation in DMA mode on the
   1114            *         complementary output
   1115            * @param  htim TIM handle
   1116            * @param  Channel TIM Channel to be enabled
   1117            *          This parameter can be one of the following values:
   1118            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1119            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1120            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1121            * @param  pData The source Buffer address.
   1122            * @param  Length The length of data to be transferred from memory to TIM peripheral
   1123            * @retval HAL status
   1124            */

   \                                 In section .text, align 2, keep-with-next
   1125          HAL_StatusTypeDef HAL_TIMEx_PWMN_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1126          {
   \                     HAL_TIMEx_PWMN_Start_DMA: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000F             MOVS     R7,R1
   \        0x6   0x0016             MOVS     R6,R2
   \        0x8   0x001D             MOVS     R5,R3
   1127            uint32_t tmpsmcr;
   1128          
   1129            /* Check the parameters */
   1130            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1131          
   1132            if (htim->State == HAL_TIM_STATE_BUSY)
   \        0xA   0x203D             MOVS     R0,#+61
   \        0xC   0x5C20             LDRB     R0,[R4, R0]
   \        0xE   0x2802             CMP      R0,#+2
   \       0x10   0xD101             BNE      ??HAL_TIMEx_PWMN_Start_DMA_0
   1133            {
   1134              return HAL_BUSY;
   \       0x12   0x2002             MOVS     R0,#+2
   \       0x14   0xE08D             B        ??HAL_TIMEx_PWMN_Start_DMA_1
   1135            }
   1136            else if (htim->State == HAL_TIM_STATE_READY)
   \                     ??HAL_TIMEx_PWMN_Start_DMA_0: (+1)
   \       0x16   0x203D             MOVS     R0,#+61
   \       0x18   0x5C20             LDRB     R0,[R4, R0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD10A             BNE      ??HAL_TIMEx_PWMN_Start_DMA_2
   1137            {
   1138              if (((uint32_t)pData == 0U) && (Length > 0U))
   \       0x1E   0x2E00             CMP      R6,#+0
   \       0x20   0xD105             BNE      ??HAL_TIMEx_PWMN_Start_DMA_3
   \       0x22   0x0028             MOVS     R0,R5
   \       0x24   0xB280             UXTH     R0,R0
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD001             BEQ      ??HAL_TIMEx_PWMN_Start_DMA_3
   1139              {
   1140                return HAL_ERROR;
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE081             B        ??HAL_TIMEx_PWMN_Start_DMA_1
   1141              }
   1142              else
   1143              {
   1144                htim->State = HAL_TIM_STATE_BUSY;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_3: (+1)
   \       0x2E   0x2002             MOVS     R0,#+2
   \       0x30   0x213D             MOVS     R1,#+61
   \       0x32   0x5460             STRB     R0,[R4, R1]
   1145              }
   1146            }
   1147            else
   1148            {
   1149              /* nothing to do */
   1150            }
   1151            switch (Channel)
   \                     ??HAL_TIMEx_PWMN_Start_DMA_2: (+1)
   \       0x34   0x0038             MOVS     R0,R7
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0xD004             BEQ      ??HAL_TIMEx_PWMN_Start_DMA_4
   \       0x3A   0x2804             CMP      R0,#+4
   \       0x3C   0xD020             BEQ      ??HAL_TIMEx_PWMN_Start_DMA_5
   \       0x3E   0x2808             CMP      R0,#+8
   \       0x40   0xD03C             BEQ      ??HAL_TIMEx_PWMN_Start_DMA_6
   \       0x42   0xE059             B        ??HAL_TIMEx_PWMN_Start_DMA_7
   1152            {
   1153              case TIM_CHANNEL_1:
   1154              {
   1155                /* Set the DMA compare callbacks */
   1156                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_4: (+1)
   \       0x44   0x....             LDR      R0,??DataTable21
   \       0x46   0x6A61             LDR      R1,[R4, #+36]
   \       0x48   0x62C8             STR      R0,[R1, #+44]
   1157                htim->hdma[TIM_DMA_ID_CC1]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x4A   0x....             LDR      R0,??DataTable21_1
   \       0x4C   0x6A61             LDR      R1,[R4, #+36]
   \       0x4E   0x6308             STR      R0,[R1, #+48]
   1158          
   1159                /* Set the DMA error callback */
   1160                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   \       0x50   0x....             LDR      R0,??DataTable21_2
   \       0x52   0x6A61             LDR      R1,[R4, #+36]
   \       0x54   0x6348             STR      R0,[R1, #+52]
   1161          
   1162                /* Enable the DMA channel */
   1163                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length) != HAL_OK)
   \       0x56   0x002B             MOVS     R3,R5
   \       0x58   0xB29B             UXTH     R3,R3
   \       0x5A   0x6820             LDR      R0,[R4, #+0]
   \       0x5C   0x0002             MOVS     R2,R0
   \       0x5E   0x3234             ADDS     R2,R2,#+52
   \       0x60   0x0031             MOVS     R1,R6
   \       0x62   0x6A60             LDR      R0,[R4, #+36]
   \       0x64   0x....'....        BL       HAL_DMA_Start_IT
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xD001             BEQ      ??HAL_TIMEx_PWMN_Start_DMA_8
   1164                {
   1165                  return HAL_ERROR;
   \       0x6C   0x2001             MOVS     R0,#+1
   \       0x6E   0xE060             B        ??HAL_TIMEx_PWMN_Start_DMA_1
   1166                }
   1167                /* Enable the TIM Capture/Compare 1 DMA request */
   1168                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_PWMN_Start_DMA_8: (+1)
   \       0x70   0x6820             LDR      R0,[R4, #+0]
   \       0x72   0x68C0             LDR      R0,[R0, #+12]
   \       0x74   0x2180             MOVS     R1,#+128
   \       0x76   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \       0x78   0x4301             ORRS     R1,R1,R0
   \       0x7A   0x6820             LDR      R0,[R4, #+0]
   \       0x7C   0x60C1             STR      R1,[R0, #+12]
   1169                break;
   \       0x7E   0xE03B             B        ??HAL_TIMEx_PWMN_Start_DMA_9
   1170              }
   1171          
   1172              case TIM_CHANNEL_2:
   1173              {
   1174                /* Set the DMA compare callbacks */
   1175                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_5: (+1)
   \       0x80   0x....             LDR      R0,??DataTable21
   \       0x82   0x6AA1             LDR      R1,[R4, #+40]
   \       0x84   0x62C8             STR      R0,[R1, #+44]
   1176                htim->hdma[TIM_DMA_ID_CC2]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0x86   0x....             LDR      R0,??DataTable21_1
   \       0x88   0x6AA1             LDR      R1,[R4, #+40]
   \       0x8A   0x6308             STR      R0,[R1, #+48]
   1177          
   1178                /* Set the DMA error callback */
   1179                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   \       0x8C   0x....             LDR      R0,??DataTable21_2
   \       0x8E   0x6AA1             LDR      R1,[R4, #+40]
   \       0x90   0x6348             STR      R0,[R1, #+52]
   1180          
   1181                /* Enable the DMA channel */
   1182                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length) != HAL_OK)
   \       0x92   0x002B             MOVS     R3,R5
   \       0x94   0xB29B             UXTH     R3,R3
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x0002             MOVS     R2,R0
   \       0x9A   0x3238             ADDS     R2,R2,#+56
   \       0x9C   0x0031             MOVS     R1,R6
   \       0x9E   0x6AA0             LDR      R0,[R4, #+40]
   \       0xA0   0x....'....        BL       HAL_DMA_Start_IT
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD001             BEQ      ??HAL_TIMEx_PWMN_Start_DMA_10
   1183                {
   1184                  return HAL_ERROR;
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0xE042             B        ??HAL_TIMEx_PWMN_Start_DMA_1
   1185                }
   1186                /* Enable the TIM Capture/Compare 2 DMA request */
   1187                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_PWMN_Start_DMA_10: (+1)
   \       0xAC   0x6820             LDR      R0,[R4, #+0]
   \       0xAE   0x68C0             LDR      R0,[R0, #+12]
   \       0xB0   0x2180             MOVS     R1,#+128
   \       0xB2   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \       0xB4   0x4301             ORRS     R1,R1,R0
   \       0xB6   0x6820             LDR      R0,[R4, #+0]
   \       0xB8   0x60C1             STR      R1,[R0, #+12]
   1188                break;
   \       0xBA   0xE01D             B        ??HAL_TIMEx_PWMN_Start_DMA_9
   1189              }
   1190          
   1191              case TIM_CHANNEL_3:
   1192              {
   1193                /* Set the DMA compare callbacks */
   1194                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_6: (+1)
   \       0xBC   0x....             LDR      R0,??DataTable21
   \       0xBE   0x6AE1             LDR      R1,[R4, #+44]
   \       0xC0   0x62C8             STR      R0,[R1, #+44]
   1195                htim->hdma[TIM_DMA_ID_CC3]->XferHalfCpltCallback = TIM_DMADelayPulseHalfCplt;
   \       0xC2   0x....             LDR      R0,??DataTable21_1
   \       0xC4   0x6AE1             LDR      R1,[R4, #+44]
   \       0xC6   0x6308             STR      R0,[R1, #+48]
   1196          
   1197                /* Set the DMA error callback */
   1198                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   \       0xC8   0x....             LDR      R0,??DataTable21_2
   \       0xCA   0x6AE1             LDR      R1,[R4, #+44]
   \       0xCC   0x6348             STR      R0,[R1, #+52]
   1199          
   1200                /* Enable the DMA channel */
   1201                if (HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3, Length) != HAL_OK)
   \       0xCE   0x002B             MOVS     R3,R5
   \       0xD0   0xB29B             UXTH     R3,R3
   \       0xD2   0x6820             LDR      R0,[R4, #+0]
   \       0xD4   0x0002             MOVS     R2,R0
   \       0xD6   0x323C             ADDS     R2,R2,#+60
   \       0xD8   0x0031             MOVS     R1,R6
   \       0xDA   0x6AE0             LDR      R0,[R4, #+44]
   \       0xDC   0x....'....        BL       HAL_DMA_Start_IT
   \       0xE0   0x2800             CMP      R0,#+0
   \       0xE2   0xD001             BEQ      ??HAL_TIMEx_PWMN_Start_DMA_11
   1202                {
   1203                  return HAL_ERROR;
   \       0xE4   0x2001             MOVS     R0,#+1
   \       0xE6   0xE024             B        ??HAL_TIMEx_PWMN_Start_DMA_1
   1204                }
   1205                /* Enable the TIM Capture/Compare 3 DMA request */
   1206                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_PWMN_Start_DMA_11: (+1)
   \       0xE8   0x6820             LDR      R0,[R4, #+0]
   \       0xEA   0x68C0             LDR      R0,[R0, #+12]
   \       0xEC   0x2180             MOVS     R1,#+128
   \       0xEE   0x0109             LSLS     R1,R1,#+4        ;; #+2048
   \       0xF0   0x4301             ORRS     R1,R1,R0
   \       0xF2   0x6820             LDR      R0,[R4, #+0]
   \       0xF4   0x60C1             STR      R1,[R0, #+12]
   1207                break;
   \       0xF6   0xE7FF             B        ??HAL_TIMEx_PWMN_Start_DMA_9
   1208              }
   1209          
   1210              default:
   1211                break;
   1212            }
   1213          
   1214            /* Enable the complementary PWM output  */
   1215            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_ENABLE);
   \                     ??HAL_TIMEx_PWMN_Start_DMA_7: (+1)
   \                     ??HAL_TIMEx_PWMN_Start_DMA_9: (+1)
   \       0xF8   0x2204             MOVS     R2,#+4
   \       0xFA   0x0039             MOVS     R1,R7
   \       0xFC   0x6820             LDR      R0,[R4, #+0]
   \       0xFE   0x....'....        BL       TIM_CCxNChannelCmd
   1216          
   1217            /* Enable the Main Output */
   1218            __HAL_TIM_MOE_ENABLE(htim);
   \      0x102   0x6820             LDR      R0,[R4, #+0]
   \      0x104   0x6C40             LDR      R0,[R0, #+68]
   \      0x106   0x2180             MOVS     R1,#+128
   \      0x108   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \      0x10A   0x4301             ORRS     R1,R1,R0
   \      0x10C   0x6820             LDR      R0,[R4, #+0]
   \      0x10E   0x6441             STR      R1,[R0, #+68]
   1219          
   1220            /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
   1221            tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
   \      0x110   0x6820             LDR      R0,[R4, #+0]
   \      0x112   0x6880             LDR      R0,[R0, #+8]
   \      0x114   0x....             LDR      R1,??DataTable23  ;; 0x10007
   \      0x116   0x4001             ANDS     R1,R1,R0
   1222            if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
   \      0x118   0x2906             CMP      R1,#+6
   \      0x11A   0xD009             BEQ      ??HAL_TIMEx_PWMN_Start_DMA_12
   \      0x11C   0x2080             MOVS     R0,#+128
   \      0x11E   0x0240             LSLS     R0,R0,#+9        ;; #+65536
   \      0x120   0x4281             CMP      R1,R0
   \      0x122   0xD005             BEQ      ??HAL_TIMEx_PWMN_Start_DMA_12
   1223            {
   1224              __HAL_TIM_ENABLE(htim);
   \      0x124   0x6820             LDR      R0,[R4, #+0]
   \      0x126   0x6800             LDR      R0,[R0, #+0]
   \      0x128   0x2201             MOVS     R2,#+1
   \      0x12A   0x4302             ORRS     R2,R2,R0
   \      0x12C   0x6820             LDR      R0,[R4, #+0]
   \      0x12E   0x6002             STR      R2,[R0, #+0]
   1225            }
   1226          
   1227            /* Return function status */
   1228            return HAL_OK;
   \                     ??HAL_TIMEx_PWMN_Start_DMA_12: (+1)
   \      0x130   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_PWMN_Start_DMA_1: (+1)
   \      0x132   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1229          }
   1230          
   1231          /**
   1232            * @brief  Stops the TIM PWM signal generation in DMA mode on the complementary
   1233            *         output
   1234            * @param  htim TIM handle
   1235            * @param  Channel TIM Channel to be disabled
   1236            *          This parameter can be one of the following values:
   1237            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1238            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1239            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1240            * @retval HAL status
   1241            */

   \                                 In section .text, align 2, keep-with-next
   1242          HAL_StatusTypeDef HAL_TIMEx_PWMN_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1243          {
   \                     HAL_TIMEx_PWMN_Stop_DMA: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1244            /* Check the parameters */
   1245            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, Channel));
   1246          
   1247            switch (Channel)
   \        0x6   0x0028             MOVS     R0,R5
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD004             BEQ      ??HAL_TIMEx_PWMN_Stop_DMA_0
   \        0xC   0x2804             CMP      R0,#+4
   \        0xE   0xD00C             BEQ      ??HAL_TIMEx_PWMN_Stop_DMA_1
   \       0x10   0x2808             CMP      R0,#+8
   \       0x12   0xD014             BEQ      ??HAL_TIMEx_PWMN_Stop_DMA_2
   \       0x14   0xE01D             B        ??HAL_TIMEx_PWMN_Stop_DMA_3
   1248            {
   1249              case TIM_CHANNEL_1:
   1250              {
   1251                /* Disable the TIM Capture/Compare 1 DMA request */
   1252                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_0: (+1)
   \       0x16   0x6820             LDR      R0,[R4, #+0]
   \       0x18   0x68C0             LDR      R0,[R0, #+12]
   \       0x1A   0x....             LDR      R1,??DataTable23_1  ;; 0xfffffdff
   \       0x1C   0x4001             ANDS     R1,R1,R0
   \       0x1E   0x6820             LDR      R0,[R4, #+0]
   \       0x20   0x60C1             STR      R1,[R0, #+12]
   1253                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC1]);
   \       0x22   0x6A60             LDR      R0,[R4, #+36]
   \       0x24   0x....'....        BL       HAL_DMA_Abort_IT
   1254                break;
   \       0x28   0xE013             B        ??HAL_TIMEx_PWMN_Stop_DMA_4
   1255              }
   1256          
   1257              case TIM_CHANNEL_2:
   1258              {
   1259                /* Disable the TIM Capture/Compare 2 DMA request */
   1260                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_1: (+1)
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x68C0             LDR      R0,[R0, #+12]
   \       0x2E   0x....             LDR      R1,??DataTable23_2  ;; 0xfffffbff
   \       0x30   0x4001             ANDS     R1,R1,R0
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x60C1             STR      R1,[R0, #+12]
   1261                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC2]);
   \       0x36   0x6AA0             LDR      R0,[R4, #+40]
   \       0x38   0x....'....        BL       HAL_DMA_Abort_IT
   1262                break;
   \       0x3C   0xE009             B        ??HAL_TIMEx_PWMN_Stop_DMA_4
   1263              }
   1264          
   1265              case TIM_CHANNEL_3:
   1266              {
   1267                /* Disable the TIM Capture/Compare 3 DMA request */
   1268                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_2: (+1)
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x68C0             LDR      R0,[R0, #+12]
   \       0x42   0x....             LDR      R1,??DataTable23_3  ;; 0xfffff7ff
   \       0x44   0x4001             ANDS     R1,R1,R0
   \       0x46   0x6820             LDR      R0,[R4, #+0]
   \       0x48   0x60C1             STR      R1,[R0, #+12]
   1269                (void)HAL_DMA_Abort_IT(htim->hdma[TIM_DMA_ID_CC3]);
   \       0x4A   0x6AE0             LDR      R0,[R4, #+44]
   \       0x4C   0x....'....        BL       HAL_DMA_Abort_IT
   1270                break;
   \       0x50   0xE7FF             B        ??HAL_TIMEx_PWMN_Stop_DMA_4
   1271              }
   1272          
   1273              default:
   1274                break;
   1275            }
   1276          
   1277            /* Disable the complementary PWM output */
   1278            TIM_CCxNChannelCmd(htim->Instance, Channel, TIM_CCxN_DISABLE);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_3: (+1)
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_4: (+1)
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x0029             MOVS     R1,R5
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x....'....        BL       TIM_CCxNChannelCmd
   1279          
   1280            /* Disable the Main Output */
   1281            __HAL_TIM_MOE_DISABLE(htim);
   \       0x5C   0x....             LDR      R0,??DataTable23_4  ;; 0x1111
   \       0x5E   0x6821             LDR      R1,[R4, #+0]
   \       0x60   0x6A09             LDR      R1,[R1, #+32]
   \       0x62   0x4001             ANDS     R1,R1,R0
   \       0x64   0x2900             CMP      R1,#+0
   \       0x66   0xD10B             BNE      ??HAL_TIMEx_PWMN_Stop_DMA_5
   \       0x68   0x6821             LDR      R1,[R4, #+0]
   \       0x6A   0x6A09             LDR      R1,[R1, #+32]
   \       0x6C   0x....             LDR      R2,??DataTable20  ;; 0x444
   \       0x6E   0x400A             ANDS     R2,R2,R1
   \       0x70   0x2A00             CMP      R2,#+0
   \       0x72   0xD105             BNE      ??HAL_TIMEx_PWMN_Stop_DMA_5
   \       0x74   0x6821             LDR      R1,[R4, #+0]
   \       0x76   0x6C49             LDR      R1,[R1, #+68]
   \       0x78   0x....             LDR      R2,??DataTable23_5  ;; 0xffff7fff
   \       0x7A   0x400A             ANDS     R2,R2,R1
   \       0x7C   0x6821             LDR      R1,[R4, #+0]
   \       0x7E   0x644A             STR      R2,[R1, #+68]
   1282          
   1283            /* Disable the Peripheral */
   1284            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_5: (+1)
   \       0x80   0x6821             LDR      R1,[R4, #+0]
   \       0x82   0x6A09             LDR      R1,[R1, #+32]
   \       0x84   0x4008             ANDS     R0,R0,R1
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD10B             BNE      ??HAL_TIMEx_PWMN_Stop_DMA_6
   \       0x8A   0x6820             LDR      R0,[R4, #+0]
   \       0x8C   0x6A00             LDR      R0,[R0, #+32]
   \       0x8E   0x....             LDR      R1,??DataTable20  ;; 0x444
   \       0x90   0x4001             ANDS     R1,R1,R0
   \       0x92   0x2900             CMP      R1,#+0
   \       0x94   0xD105             BNE      ??HAL_TIMEx_PWMN_Stop_DMA_6
   \       0x96   0x6820             LDR      R0,[R4, #+0]
   \       0x98   0x6800             LDR      R0,[R0, #+0]
   \       0x9A   0x2101             MOVS     R1,#+1
   \       0x9C   0x4388             BICS     R0,R0,R1
   \       0x9E   0x6821             LDR      R1,[R4, #+0]
   \       0xA0   0x6008             STR      R0,[R1, #+0]
   1285          
   1286            /* Change the htim state */
   1287            htim->State = HAL_TIM_STATE_READY;
   \                     ??HAL_TIMEx_PWMN_Stop_DMA_6: (+1)
   \       0xA2   0x2001             MOVS     R0,#+1
   \       0xA4   0x213D             MOVS     R1,#+61
   \       0xA6   0x5460             STRB     R0,[R4, R1]
   1288          
   1289            /* Return function status */
   1290            return HAL_OK;
   \       0xA8   0x2000             MOVS     R0,#+0
   \       0xAA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1291          }
   1292          
   1293          /**
   1294            * @}
   1295            */
   1296          
   1297          /** @defgroup TIMEx_Exported_Functions_Group4 Extended Timer Complementary One Pulse functions
   1298            * @brief    Timer Complementary One Pulse functions
   1299            *
   1300          @verbatim
   1301            ==============================================================================
   1302                          ##### Timer Complementary One Pulse functions #####
   1303            ==============================================================================
   1304            [..]
   1305              This section provides functions allowing to:
   1306              (+) Start the Complementary One Pulse generation.
   1307              (+) Stop the Complementary One Pulse.
   1308              (+) Start the Complementary One Pulse and enable interrupts.
   1309              (+) Stop the Complementary One Pulse and disable interrupts.
   1310          
   1311          @endverbatim
   1312            * @{
   1313            */
   1314          
   1315          /**
   1316            * @brief  Starts the TIM One Pulse signal generation on the complementary
   1317            *         output.
   1318            * @param  htim TIM One Pulse handle
   1319            * @param  OutputChannel TIM Channel to be enabled
   1320            *          This parameter can be one of the following values:
   1321            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1322            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1323            * @retval HAL status
   1324            */

   \                                 In section .text, align 2, keep-with-next
   1325          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1326          {
   \                     HAL_TIMEx_OnePulseN_Start: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1327            /* Check the parameters */
   1328            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1329          
   1330            /* Enable the complementary One Pulse output */
   1331            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
   \        0x6   0x2204             MOVS     R2,#+4
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxNChannelCmd
   1332          
   1333            /* Enable the Main Output */
   1334            __HAL_TIM_MOE_ENABLE(htim);
   \       0x10   0x6820             LDR      R0,[R4, #+0]
   \       0x12   0x6C40             LDR      R0,[R0, #+68]
   \       0x14   0x2180             MOVS     R1,#+128
   \       0x16   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x18   0x4301             ORRS     R1,R1,R0
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x6441             STR      R1,[R0, #+68]
   1335          
   1336            /* Return function status */
   1337            return HAL_OK;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1338          }
   1339          
   1340          /**
   1341            * @brief  Stops the TIM One Pulse signal generation on the complementary
   1342            *         output.
   1343            * @param  htim TIM One Pulse handle
   1344            * @param  OutputChannel TIM Channel to be disabled
   1345            *          This parameter can be one of the following values:
   1346            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1347            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1348            * @retval HAL status
   1349            */

   \                                 In section .text, align 2, keep-with-next
   1350          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1351          {
   \                     HAL_TIMEx_OnePulseN_Stop: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1352          
   1353            /* Check the parameters */
   1354            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1355          
   1356            /* Disable the complementary One Pulse output */
   1357            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x0029             MOVS     R1,R5
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x....'....        BL       TIM_CCxNChannelCmd
   1358          
   1359            /* Disable the Main Output */
   1360            __HAL_TIM_MOE_DISABLE(htim);
   \       0x10   0x....             LDR      R0,??DataTable23_4  ;; 0x1111
   \       0x12   0x6821             LDR      R1,[R4, #+0]
   \       0x14   0x6A09             LDR      R1,[R1, #+32]
   \       0x16   0x4001             ANDS     R1,R1,R0
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD10B             BNE      ??HAL_TIMEx_OnePulseN_Stop_0
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x6A09             LDR      R1,[R1, #+32]
   \       0x20   0x....             LDR      R2,??DataTable20  ;; 0x444
   \       0x22   0x400A             ANDS     R2,R2,R1
   \       0x24   0x2A00             CMP      R2,#+0
   \       0x26   0xD105             BNE      ??HAL_TIMEx_OnePulseN_Stop_0
   \       0x28   0x6821             LDR      R1,[R4, #+0]
   \       0x2A   0x6C49             LDR      R1,[R1, #+68]
   \       0x2C   0x....             LDR      R2,??DataTable23_5  ;; 0xffff7fff
   \       0x2E   0x400A             ANDS     R2,R2,R1
   \       0x30   0x6821             LDR      R1,[R4, #+0]
   \       0x32   0x644A             STR      R2,[R1, #+68]
   1361          
   1362            /* Disable the Peripheral */
   1363            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OnePulseN_Stop_0: (+1)
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x6A09             LDR      R1,[R1, #+32]
   \       0x38   0x4008             ANDS     R0,R0,R1
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD10B             BNE      ??HAL_TIMEx_OnePulseN_Stop_1
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x6A00             LDR      R0,[R0, #+32]
   \       0x42   0x....             LDR      R1,??DataTable20  ;; 0x444
   \       0x44   0x4001             ANDS     R1,R1,R0
   \       0x46   0x2900             CMP      R1,#+0
   \       0x48   0xD105             BNE      ??HAL_TIMEx_OnePulseN_Stop_1
   \       0x4A   0x6820             LDR      R0,[R4, #+0]
   \       0x4C   0x6800             LDR      R0,[R0, #+0]
   \       0x4E   0x2101             MOVS     R1,#+1
   \       0x50   0x4388             BICS     R0,R0,R1
   \       0x52   0x6821             LDR      R1,[R4, #+0]
   \       0x54   0x6008             STR      R0,[R1, #+0]
   1364          
   1365            /* Return function status */
   1366            return HAL_OK;
   \                     ??HAL_TIMEx_OnePulseN_Stop_1: (+1)
   \       0x56   0x2000             MOVS     R0,#+0
   \       0x58   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1367          }
   1368          
   1369          /**
   1370            * @brief  Starts the TIM One Pulse signal generation in interrupt mode on the
   1371            *         complementary channel.
   1372            * @param  htim TIM One Pulse handle
   1373            * @param  OutputChannel TIM Channel to be enabled
   1374            *          This parameter can be one of the following values:
   1375            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1376            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1377            * @retval HAL status
   1378            */

   \                                 In section .text, align 2, keep-with-next
   1379          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1380          {
   \                     HAL_TIMEx_OnePulseN_Start_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1381            /* Check the parameters */
   1382            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1383          
   1384            /* Enable the TIM Capture/Compare 1 interrupt */
   1385            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x68C0             LDR      R0,[R0, #+12]
   \        0xA   0x2102             MOVS     R1,#+2
   \        0xC   0x4301             ORRS     R1,R1,R0
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x60C1             STR      R1,[R0, #+12]
   1386          
   1387            /* Enable the TIM Capture/Compare 2 interrupt */
   1388            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x68C0             LDR      R0,[R0, #+12]
   \       0x16   0x2104             MOVS     R1,#+4
   \       0x18   0x4301             ORRS     R1,R1,R0
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x60C1             STR      R1,[R0, #+12]
   1389          
   1390            /* Enable the complementary One Pulse output */
   1391            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_ENABLE);
   \       0x1E   0x2204             MOVS     R2,#+4
   \       0x20   0x0029             MOVS     R1,R5
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x....'....        BL       TIM_CCxNChannelCmd
   1392          
   1393            /* Enable the Main Output */
   1394            __HAL_TIM_MOE_ENABLE(htim);
   \       0x28   0x6820             LDR      R0,[R4, #+0]
   \       0x2A   0x6C40             LDR      R0,[R0, #+68]
   \       0x2C   0x2180             MOVS     R1,#+128
   \       0x2E   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \       0x30   0x4301             ORRS     R1,R1,R0
   \       0x32   0x6820             LDR      R0,[R4, #+0]
   \       0x34   0x6441             STR      R1,[R0, #+68]
   1395          
   1396            /* Return function status */
   1397            return HAL_OK;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1398          }
   1399          
   1400          /**
   1401            * @brief  Stops the TIM One Pulse signal generation in interrupt mode on the
   1402            *         complementary channel.
   1403            * @param  htim TIM One Pulse handle
   1404            * @param  OutputChannel TIM Channel to be disabled
   1405            *          This parameter can be one of the following values:
   1406            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1407            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1408            * @retval HAL status
   1409            */

   \                                 In section .text, align 2, keep-with-next
   1410          HAL_StatusTypeDef HAL_TIMEx_OnePulseN_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   1411          {
   \                     HAL_TIMEx_OnePulseN_Stop_IT: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   \        0x4   0x000D             MOVS     R5,R1
   1412            /* Check the parameters */
   1413            assert_param(IS_TIM_CCXN_INSTANCE(htim->Instance, OutputChannel));
   1414          
   1415            /* Disable the TIM Capture/Compare 1 interrupt */
   1416            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   \        0x6   0x6820             LDR      R0,[R4, #+0]
   \        0x8   0x68C0             LDR      R0,[R0, #+12]
   \        0xA   0x2102             MOVS     R1,#+2
   \        0xC   0x4388             BICS     R0,R0,R1
   \        0xE   0x6821             LDR      R1,[R4, #+0]
   \       0x10   0x60C8             STR      R0,[R1, #+12]
   1417          
   1418            /* Disable the TIM Capture/Compare 2 interrupt */
   1419            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   \       0x12   0x6820             LDR      R0,[R4, #+0]
   \       0x14   0x68C0             LDR      R0,[R0, #+12]
   \       0x16   0x2104             MOVS     R1,#+4
   \       0x18   0x4388             BICS     R0,R0,R1
   \       0x1A   0x6821             LDR      R1,[R4, #+0]
   \       0x1C   0x60C8             STR      R0,[R1, #+12]
   1420          
   1421            /* Disable the complementary One Pulse output */
   1422            TIM_CCxNChannelCmd(htim->Instance, OutputChannel, TIM_CCxN_DISABLE);
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x0029             MOVS     R1,R5
   \       0x22   0x6820             LDR      R0,[R4, #+0]
   \       0x24   0x....'....        BL       TIM_CCxNChannelCmd
   1423          
   1424            /* Disable the Main Output */
   1425            __HAL_TIM_MOE_DISABLE(htim);
   \       0x28   0x....             LDR      R0,??DataTable23_4  ;; 0x1111
   \       0x2A   0x6821             LDR      R1,[R4, #+0]
   \       0x2C   0x6A09             LDR      R1,[R1, #+32]
   \       0x2E   0x4001             ANDS     R1,R1,R0
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD10B             BNE      ??HAL_TIMEx_OnePulseN_Stop_IT_0
   \       0x34   0x6821             LDR      R1,[R4, #+0]
   \       0x36   0x6A09             LDR      R1,[R1, #+32]
   \       0x38   0x....             LDR      R2,??DataTable26  ;; 0x444
   \       0x3A   0x400A             ANDS     R2,R2,R1
   \       0x3C   0x2A00             CMP      R2,#+0
   \       0x3E   0xD105             BNE      ??HAL_TIMEx_OnePulseN_Stop_IT_0
   \       0x40   0x6821             LDR      R1,[R4, #+0]
   \       0x42   0x6C49             LDR      R1,[R1, #+68]
   \       0x44   0x....             LDR      R2,??DataTable23_5  ;; 0xffff7fff
   \       0x46   0x400A             ANDS     R2,R2,R1
   \       0x48   0x6821             LDR      R1,[R4, #+0]
   \       0x4A   0x644A             STR      R2,[R1, #+68]
   1426          
   1427            /* Disable the Peripheral */
   1428            __HAL_TIM_DISABLE(htim);
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_0: (+1)
   \       0x4C   0x6821             LDR      R1,[R4, #+0]
   \       0x4E   0x6A09             LDR      R1,[R1, #+32]
   \       0x50   0x4008             ANDS     R0,R0,R1
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD10B             BNE      ??HAL_TIMEx_OnePulseN_Stop_IT_1
   \       0x56   0x6820             LDR      R0,[R4, #+0]
   \       0x58   0x6A00             LDR      R0,[R0, #+32]
   \       0x5A   0x....             LDR      R1,??DataTable26  ;; 0x444
   \       0x5C   0x4001             ANDS     R1,R1,R0
   \       0x5E   0x2900             CMP      R1,#+0
   \       0x60   0xD105             BNE      ??HAL_TIMEx_OnePulseN_Stop_IT_1
   \       0x62   0x6820             LDR      R0,[R4, #+0]
   \       0x64   0x6800             LDR      R0,[R0, #+0]
   \       0x66   0x2101             MOVS     R1,#+1
   \       0x68   0x4388             BICS     R0,R0,R1
   \       0x6A   0x6821             LDR      R1,[R4, #+0]
   \       0x6C   0x6008             STR      R0,[R1, #+0]
   1429          
   1430            /* Return function status */
   1431            return HAL_OK;
   \                     ??HAL_TIMEx_OnePulseN_Stop_IT_1: (+1)
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1432          }
   1433          
   1434          /**
   1435            * @}
   1436            */
   1437          
   1438          /** @defgroup TIMEx_Exported_Functions_Group5 Extended Peripheral Control functions
   1439            * @brief    Peripheral Control functions
   1440            *
   1441          @verbatim
   1442            ==============================================================================
   1443                              ##### Peripheral Control functions #####
   1444            ==============================================================================
   1445            [..]
   1446              This section provides functions allowing to:
   1447                (+) Configure the commutation event in case of use of the Hall sensor interface.
   1448                (+) Configure Output channels for OC and PWM mode.
   1449          
   1450                (+) Configure Complementary channels, break features and dead time.
   1451                (+) Configure Master synchronization.
   1452                (+) Configure timer remapping capabilities.
   1453                (+) Select timer input source.
   1454                (+) Enable or disable channel grouping.
   1455          
   1456          @endverbatim
   1457            * @{
   1458            */
   1459          
   1460          /**
   1461            * @brief  Configure the TIM commutation event sequence.
   1462            * @note  This function is mandatory to use the commutation event in order to
   1463            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1464            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1465            *        configured in Hall sensor interface, this interface Timer will generate the
   1466            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1467            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1468            * @param  htim TIM handle
   1469            * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1470            *          This parameter can be one of the following values:
   1471            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1472            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1473            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1474            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1475            *            @arg TIM_TS_NONE: No trigger is needed
   1476            * @param  CommutationSource the Commutation Event source
   1477            *          This parameter can be one of the following values:
   1478            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1479            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1480            * @retval HAL status
   1481            */

   \                                 In section .text, align 2, keep-with-next
   1482          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
   1483                                                        uint32_t  CommutationSource)
   1484          {
   \                     HAL_TIMEx_ConfigCommutEvent: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x0003             MOVS     R3,R0
   1485            /* Check the parameters */
   1486            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1487            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1488          
   1489            __HAL_LOCK(htim);
   \        0x4   0x203C             MOVS     R0,#+60
   \        0x6   0x5C18             LDRB     R0,[R3, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIMEx_ConfigCommutEvent_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE036             B        ??HAL_TIMEx_ConfigCommutEvent_1
   \                     ??HAL_TIMEx_ConfigCommutEvent_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x0004             MOVS     R4,R0
   \       0x14   0x253C             MOVS     R5,#+60
   \       0x16   0x555C             STRB     R4,[R3, R5]
   1490          
   1491            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1492                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD005             BEQ      ??HAL_TIMEx_ConfigCommutEvent_2
   \       0x1C   0x2910             CMP      R1,#+16
   \       0x1E   0xD003             BEQ      ??HAL_TIMEx_ConfigCommutEvent_2
   \       0x20   0x2920             CMP      R1,#+32
   \       0x22   0xD001             BEQ      ??HAL_TIMEx_ConfigCommutEvent_2
   \       0x24   0x2930             CMP      R1,#+48
   \       0x26   0xD10A             BNE      ??HAL_TIMEx_ConfigCommutEvent_3
   1493            {
   1494              /* Select the Input trigger */
   1495              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutEvent_2: (+1)
   \       0x28   0x681C             LDR      R4,[R3, #+0]
   \       0x2A   0x68A4             LDR      R4,[R4, #+8]
   \       0x2C   0x....             LDR      R5,??DataTable26_1  ;; 0xffcfff8f
   \       0x2E   0x4025             ANDS     R5,R5,R4
   \       0x30   0x681C             LDR      R4,[R3, #+0]
   \       0x32   0x60A5             STR      R5,[R4, #+8]
   1496              htim->Instance->SMCR |= InputTrigger;
   \       0x34   0x681C             LDR      R4,[R3, #+0]
   \       0x36   0x68A4             LDR      R4,[R4, #+8]
   \       0x38   0x430C             ORRS     R4,R4,R1
   \       0x3A   0x681D             LDR      R5,[R3, #+0]
   \       0x3C   0x60AC             STR      R4,[R5, #+8]
   1497            }
   1498          
   1499            /* Select the Capture Compare preload feature */
   1500            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutEvent_3: (+1)
   \       0x3E   0x681C             LDR      R4,[R3, #+0]
   \       0x40   0x6864             LDR      R4,[R4, #+4]
   \       0x42   0x4320             ORRS     R0,R0,R4
   \       0x44   0x681C             LDR      R4,[R3, #+0]
   \       0x46   0x6060             STR      R0,[R4, #+4]
   1501            /* Select the Commutation event source */
   1502            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \       0x48   0x6818             LDR      R0,[R3, #+0]
   \       0x4A   0x6840             LDR      R0,[R0, #+4]
   \       0x4C   0x2404             MOVS     R4,#+4
   \       0x4E   0x43A0             BICS     R0,R0,R4
   \       0x50   0x681C             LDR      R4,[R3, #+0]
   \       0x52   0x6060             STR      R0,[R4, #+4]
   1503            htim->Instance->CR2 |= CommutationSource;
   \       0x54   0x6818             LDR      R0,[R3, #+0]
   \       0x56   0x6840             LDR      R0,[R0, #+4]
   \       0x58   0x4310             ORRS     R0,R0,R2
   \       0x5A   0x681C             LDR      R4,[R3, #+0]
   \       0x5C   0x6060             STR      R0,[R4, #+4]
   1504          
   1505            /* Disable Commutation Interrupt */
   1506            __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
   \       0x5E   0x6818             LDR      R0,[R3, #+0]
   \       0x60   0x68C0             LDR      R0,[R0, #+12]
   \       0x62   0x2420             MOVS     R4,#+32
   \       0x64   0x43A0             BICS     R0,R0,R4
   \       0x66   0x681C             LDR      R4,[R3, #+0]
   \       0x68   0x60E0             STR      R0,[R4, #+12]
   1507          
   1508            /* Disable Commutation DMA request */
   1509            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
   \       0x6A   0x6818             LDR      R0,[R3, #+0]
   \       0x6C   0x68C0             LDR      R0,[R0, #+12]
   \       0x6E   0x....             LDR      R4,??DataTable27  ;; 0xffffdfff
   \       0x70   0x4004             ANDS     R4,R4,R0
   \       0x72   0x6818             LDR      R0,[R3, #+0]
   \       0x74   0x60C4             STR      R4,[R0, #+12]
   1510          
   1511            __HAL_UNLOCK(htim);
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x243C             MOVS     R4,#+60
   \       0x7A   0x5518             STRB     R0,[R3, R4]
   1512          
   1513            return HAL_OK;
   \       0x7C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigCommutEvent_1: (+1)
   \       0x7E   0xBD30             POP      {R4,R5,PC}       ;; return
   1514          }
   1515          
   1516          /**
   1517            * @brief  Configure the TIM commutation event sequence with interrupt.
   1518            * @note  This function is mandatory to use the commutation event in order to
   1519            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1520            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1521            *        configured in Hall sensor interface, this interface Timer will generate the
   1522            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1523            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1524            * @param  htim TIM handle
   1525            * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1526            *          This parameter can be one of the following values:
   1527            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1528            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1529            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1530            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1531            *            @arg TIM_TS_NONE: No trigger is needed
   1532            * @param  CommutationSource the Commutation Event source
   1533            *          This parameter can be one of the following values:
   1534            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1535            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1536            * @retval HAL status
   1537            */

   \                                 In section .text, align 2, keep-with-next
   1538          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_IT(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
   1539                                                           uint32_t  CommutationSource)
   1540          {
   \                     HAL_TIMEx_ConfigCommutEvent_IT: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x0003             MOVS     R3,R0
   1541            /* Check the parameters */
   1542            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1543            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1544          
   1545            __HAL_LOCK(htim);
   \        0x4   0x203C             MOVS     R0,#+60
   \        0x6   0x5C18             LDRB     R0,[R3, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIMEx_ConfigCommutEvent_IT_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE036             B        ??HAL_TIMEx_ConfigCommutEvent_IT_1
   \                     ??HAL_TIMEx_ConfigCommutEvent_IT_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x0004             MOVS     R4,R0
   \       0x14   0x253C             MOVS     R5,#+60
   \       0x16   0x555C             STRB     R4,[R3, R5]
   1546          
   1547            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1548                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD005             BEQ      ??HAL_TIMEx_ConfigCommutEvent_IT_2
   \       0x1C   0x2910             CMP      R1,#+16
   \       0x1E   0xD003             BEQ      ??HAL_TIMEx_ConfigCommutEvent_IT_2
   \       0x20   0x2920             CMP      R1,#+32
   \       0x22   0xD001             BEQ      ??HAL_TIMEx_ConfigCommutEvent_IT_2
   \       0x24   0x2930             CMP      R1,#+48
   \       0x26   0xD10A             BNE      ??HAL_TIMEx_ConfigCommutEvent_IT_3
   1549            {
   1550              /* Select the Input trigger */
   1551              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutEvent_IT_2: (+1)
   \       0x28   0x681C             LDR      R4,[R3, #+0]
   \       0x2A   0x68A4             LDR      R4,[R4, #+8]
   \       0x2C   0x....             LDR      R5,??DataTable26_1  ;; 0xffcfff8f
   \       0x2E   0x4025             ANDS     R5,R5,R4
   \       0x30   0x681C             LDR      R4,[R3, #+0]
   \       0x32   0x60A5             STR      R5,[R4, #+8]
   1552              htim->Instance->SMCR |= InputTrigger;
   \       0x34   0x681C             LDR      R4,[R3, #+0]
   \       0x36   0x68A4             LDR      R4,[R4, #+8]
   \       0x38   0x430C             ORRS     R4,R4,R1
   \       0x3A   0x681D             LDR      R5,[R3, #+0]
   \       0x3C   0x60AC             STR      R4,[R5, #+8]
   1553            }
   1554          
   1555            /* Select the Capture Compare preload feature */
   1556            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutEvent_IT_3: (+1)
   \       0x3E   0x681C             LDR      R4,[R3, #+0]
   \       0x40   0x6864             LDR      R4,[R4, #+4]
   \       0x42   0x4320             ORRS     R0,R0,R4
   \       0x44   0x681C             LDR      R4,[R3, #+0]
   \       0x46   0x6060             STR      R0,[R4, #+4]
   1557            /* Select the Commutation event source */
   1558            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \       0x48   0x6818             LDR      R0,[R3, #+0]
   \       0x4A   0x6840             LDR      R0,[R0, #+4]
   \       0x4C   0x2404             MOVS     R4,#+4
   \       0x4E   0x43A0             BICS     R0,R0,R4
   \       0x50   0x681C             LDR      R4,[R3, #+0]
   \       0x52   0x6060             STR      R0,[R4, #+4]
   1559            htim->Instance->CR2 |= CommutationSource;
   \       0x54   0x6818             LDR      R0,[R3, #+0]
   \       0x56   0x6840             LDR      R0,[R0, #+4]
   \       0x58   0x4310             ORRS     R0,R0,R2
   \       0x5A   0x681C             LDR      R4,[R3, #+0]
   \       0x5C   0x6060             STR      R0,[R4, #+4]
   1560          
   1561            /* Disable Commutation DMA request */
   1562            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_COM);
   \       0x5E   0x6818             LDR      R0,[R3, #+0]
   \       0x60   0x68C0             LDR      R0,[R0, #+12]
   \       0x62   0x....             LDR      R4,??DataTable27  ;; 0xffffdfff
   \       0x64   0x4004             ANDS     R4,R4,R0
   \       0x66   0x6818             LDR      R0,[R3, #+0]
   \       0x68   0x60C4             STR      R4,[R0, #+12]
   1563          
   1564            /* Enable the Commutation Interrupt */
   1565            __HAL_TIM_ENABLE_IT(htim, TIM_IT_COM);
   \       0x6A   0x6818             LDR      R0,[R3, #+0]
   \       0x6C   0x68C0             LDR      R0,[R0, #+12]
   \       0x6E   0x2420             MOVS     R4,#+32
   \       0x70   0x4304             ORRS     R4,R4,R0
   \       0x72   0x6818             LDR      R0,[R3, #+0]
   \       0x74   0x60C4             STR      R4,[R0, #+12]
   1566          
   1567            __HAL_UNLOCK(htim);
   \       0x76   0x2000             MOVS     R0,#+0
   \       0x78   0x243C             MOVS     R4,#+60
   \       0x7A   0x5518             STRB     R0,[R3, R4]
   1568          
   1569            return HAL_OK;
   \       0x7C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigCommutEvent_IT_1: (+1)
   \       0x7E   0xBD30             POP      {R4,R5,PC}       ;; return
   1570          }
   1571          
   1572          /**
   1573            * @brief  Configure the TIM commutation event sequence with DMA.
   1574            * @note  This function is mandatory to use the commutation event in order to
   1575            *        update the configuration at each commutation detection on the TRGI input of the Timer,
   1576            *        the typical use of this feature is with the use of another Timer(interface Timer)
   1577            *        configured in Hall sensor interface, this interface Timer will generate the
   1578            *        commutation at its TRGO output (connected to Timer used in this function) each time
   1579            *        the TI1 of the Interface Timer detect a commutation at its input TI1.
   1580            * @note  The user should configure the DMA in his own software, in This function only the COMDE bit is set
   1581            * @param  htim TIM handle
   1582            * @param  InputTrigger the Internal trigger corresponding to the Timer Interfacing with the Hall sensor
   1583            *          This parameter can be one of the following values:
   1584            *            @arg TIM_TS_ITR0: Internal trigger 0 selected
   1585            *            @arg TIM_TS_ITR1: Internal trigger 1 selected
   1586            *            @arg TIM_TS_ITR2: Internal trigger 2 selected
   1587            *            @arg TIM_TS_ITR3: Internal trigger 3 selected
   1588            *            @arg TIM_TS_NONE: No trigger is needed
   1589            * @param  CommutationSource the Commutation Event source
   1590            *          This parameter can be one of the following values:
   1591            *            @arg TIM_COMMUTATION_TRGI: Commutation source is the TRGI of the Interface Timer
   1592            *            @arg TIM_COMMUTATION_SOFTWARE:  Commutation source is set by software using the COMG bit
   1593            * @retval HAL status
   1594            */

   \                                 In section .text, align 2, keep-with-next
   1595          HAL_StatusTypeDef HAL_TIMEx_ConfigCommutEvent_DMA(TIM_HandleTypeDef *htim, uint32_t  InputTrigger,
   1596                                                            uint32_t  CommutationSource)
   1597          {
   \                     HAL_TIMEx_ConfigCommutEvent_DMA: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x0003             MOVS     R3,R0
   1598            /* Check the parameters */
   1599            assert_param(IS_TIM_COMMUTATION_EVENT_INSTANCE(htim->Instance));
   1600            assert_param(IS_TIM_INTERNAL_TRIGGEREVENT_SELECTION(InputTrigger));
   1601          
   1602            __HAL_LOCK(htim);
   \        0x4   0x203C             MOVS     R0,#+60
   \        0x6   0x5C18             LDRB     R0,[R3, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIMEx_ConfigCommutEvent_DMA_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE040             B        ??HAL_TIMEx_ConfigCommutEvent_DMA_1
   \                     ??HAL_TIMEx_ConfigCommutEvent_DMA_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x0004             MOVS     R4,R0
   \       0x14   0x253C             MOVS     R5,#+60
   \       0x16   0x555C             STRB     R4,[R3, R5]
   1603          
   1604            if ((InputTrigger == TIM_TS_ITR0) || (InputTrigger == TIM_TS_ITR1) ||
   1605                (InputTrigger == TIM_TS_ITR2) || (InputTrigger == TIM_TS_ITR3))
   \       0x18   0x2900             CMP      R1,#+0
   \       0x1A   0xD005             BEQ      ??HAL_TIMEx_ConfigCommutEvent_DMA_2
   \       0x1C   0x2910             CMP      R1,#+16
   \       0x1E   0xD003             BEQ      ??HAL_TIMEx_ConfigCommutEvent_DMA_2
   \       0x20   0x2920             CMP      R1,#+32
   \       0x22   0xD001             BEQ      ??HAL_TIMEx_ConfigCommutEvent_DMA_2
   \       0x24   0x2930             CMP      R1,#+48
   \       0x26   0xD10A             BNE      ??HAL_TIMEx_ConfigCommutEvent_DMA_3
   1606            {
   1607              /* Select the Input trigger */
   1608              htim->Instance->SMCR &= ~TIM_SMCR_TS;
   \                     ??HAL_TIMEx_ConfigCommutEvent_DMA_2: (+1)
   \       0x28   0x681C             LDR      R4,[R3, #+0]
   \       0x2A   0x68A4             LDR      R4,[R4, #+8]
   \       0x2C   0x....             LDR      R5,??DataTable26_1  ;; 0xffcfff8f
   \       0x2E   0x4025             ANDS     R5,R5,R4
   \       0x30   0x681C             LDR      R4,[R3, #+0]
   \       0x32   0x60A5             STR      R5,[R4, #+8]
   1609              htim->Instance->SMCR |= InputTrigger;
   \       0x34   0x681C             LDR      R4,[R3, #+0]
   \       0x36   0x68A4             LDR      R4,[R4, #+8]
   \       0x38   0x430C             ORRS     R4,R4,R1
   \       0x3A   0x681D             LDR      R5,[R3, #+0]
   \       0x3C   0x60AC             STR      R4,[R5, #+8]
   1610            }
   1611          
   1612            /* Select the Capture Compare preload feature */
   1613            htim->Instance->CR2 |= TIM_CR2_CCPC;
   \                     ??HAL_TIMEx_ConfigCommutEvent_DMA_3: (+1)
   \       0x3E   0x681C             LDR      R4,[R3, #+0]
   \       0x40   0x6864             LDR      R4,[R4, #+4]
   \       0x42   0x4320             ORRS     R0,R0,R4
   \       0x44   0x681C             LDR      R4,[R3, #+0]
   \       0x46   0x6060             STR      R0,[R4, #+4]
   1614            /* Select the Commutation event source */
   1615            htim->Instance->CR2 &= ~TIM_CR2_CCUS;
   \       0x48   0x6818             LDR      R0,[R3, #+0]
   \       0x4A   0x6840             LDR      R0,[R0, #+4]
   \       0x4C   0x2404             MOVS     R4,#+4
   \       0x4E   0x43A0             BICS     R0,R0,R4
   \       0x50   0x681C             LDR      R4,[R3, #+0]
   \       0x52   0x6060             STR      R0,[R4, #+4]
   1616            htim->Instance->CR2 |= CommutationSource;
   \       0x54   0x6818             LDR      R0,[R3, #+0]
   \       0x56   0x6840             LDR      R0,[R0, #+4]
   \       0x58   0x4310             ORRS     R0,R0,R2
   \       0x5A   0x681C             LDR      R4,[R3, #+0]
   \       0x5C   0x6060             STR      R0,[R4, #+4]
   1617          
   1618            /* Enable the Commutation DMA Request */
   1619            /* Set the DMA Commutation Callback */
   1620            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback = TIMEx_DMACommutationCplt;
   \       0x5E   0x....             LDR      R0,??DataTable28
   \       0x60   0x6B5C             LDR      R4,[R3, #+52]
   \       0x62   0x62E0             STR      R0,[R4, #+44]
   1621            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferHalfCpltCallback = TIMEx_DMACommutationHalfCplt;
   \       0x64   0x....             LDR      R0,??DataTable28_1
   \       0x66   0x6B5C             LDR      R4,[R3, #+52]
   \       0x68   0x6320             STR      R0,[R4, #+48]
   1622            /* Set the DMA error callback */
   1623            htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError;
   \       0x6A   0x....             LDR      R0,??DataTable29
   \       0x6C   0x6B5C             LDR      R4,[R3, #+52]
   \       0x6E   0x6360             STR      R0,[R4, #+52]
   1624          
   1625            /* Disable Commutation Interrupt */
   1626            __HAL_TIM_DISABLE_IT(htim, TIM_IT_COM);
   \       0x70   0x6818             LDR      R0,[R3, #+0]
   \       0x72   0x68C0             LDR      R0,[R0, #+12]
   \       0x74   0x2420             MOVS     R4,#+32
   \       0x76   0x43A0             BICS     R0,R0,R4
   \       0x78   0x681C             LDR      R4,[R3, #+0]
   \       0x7A   0x60E0             STR      R0,[R4, #+12]
   1627          
   1628            /* Enable the Commutation DMA Request */
   1629            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_COM);
   \       0x7C   0x6818             LDR      R0,[R3, #+0]
   \       0x7E   0x68C0             LDR      R0,[R0, #+12]
   \       0x80   0x2480             MOVS     R4,#+128
   \       0x82   0x01A4             LSLS     R4,R4,#+6        ;; #+8192
   \       0x84   0x4304             ORRS     R4,R4,R0
   \       0x86   0x6818             LDR      R0,[R3, #+0]
   \       0x88   0x60C4             STR      R4,[R0, #+12]
   1630          
   1631            __HAL_UNLOCK(htim);
   \       0x8A   0x2000             MOVS     R0,#+0
   \       0x8C   0x243C             MOVS     R4,#+60
   \       0x8E   0x5518             STRB     R0,[R3, R4]
   1632          
   1633            return HAL_OK;
   \       0x90   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigCommutEvent_DMA_1: (+1)
   \       0x92   0xBD30             POP      {R4,R5,PC}       ;; return
   1634          }
   1635          
   1636          /**
   1637            * @brief  Configures the TIM in master mode.
   1638            * @param  htim TIM handle.
   1639            * @param  sMasterConfig pointer to a TIM_MasterConfigTypeDef structure that
   1640            *         contains the selected trigger output (TRGO) and the Master/Slave
   1641            *         mode.
   1642            * @retval HAL status
   1643            */

   \                                 In section .text, align 2, keep-with-next
   1644          HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
   1645                                                                  TIM_MasterConfigTypeDef *sMasterConfig)
   1646          {
   \                     HAL_TIMEx_MasterConfigSynchronization: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0002             MOVS     R2,R0
   1647            uint32_t tmpcr2;
   1648            uint32_t tmpsmcr;
   1649          
   1650            /* Check the parameters */
   1651            assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
   1652            assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
   1653            assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
   1654          
   1655            /* Check input state */
   1656            __HAL_LOCK(htim);
   \        0x4   0x203C             MOVS     R0,#+60
   \        0x6   0x5C10             LDRB     R0,[R2, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIMEx_MasterConfigSynchronization_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE023             B        ??HAL_TIMEx_MasterConfigSynchronization_1
   \                     ??HAL_TIMEx_MasterConfigSynchronization_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x233C             MOVS     R3,#+60
   \       0x14   0x54D0             STRB     R0,[R2, R3]
   1657          
   1658            /* Change the handler state */
   1659            htim->State = HAL_TIM_STATE_BUSY;
   \       0x16   0x2302             MOVS     R3,#+2
   \       0x18   0x243D             MOVS     R4,#+61
   \       0x1A   0x5513             STRB     R3,[R2, R4]
   1660          
   1661            /* Get the TIMx CR2 register value */
   1662            tmpcr2 = htim->Instance->CR2;
   \       0x1C   0x6813             LDR      R3,[R2, #+0]
   \       0x1E   0x685B             LDR      R3,[R3, #+4]
   1663          
   1664            /* Get the TIMx SMCR register value */
   1665            tmpsmcr = htim->Instance->SMCR;
   \       0x20   0x6814             LDR      R4,[R2, #+0]
   \       0x22   0x68A4             LDR      R4,[R4, #+8]
   1666          
   1667            /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
   1668            if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
   \       0x24   0x6815             LDR      R5,[R2, #+0]
   \       0x26   0x....             LDR      R6,??DataTable29_1  ;; 0x40012c00
   \       0x28   0x42B5             CMP      R5,R6
   \       0x2A   0xD103             BNE      ??HAL_TIMEx_MasterConfigSynchronization_2
   1669            {
   1670              /* Check the parameters */
   1671              assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
   1672          
   1673              /* Clear the MMS2 bits */
   1674              tmpcr2 &= ~TIM_CR2_MMS2;
   \       0x2C   0x....             LDR      R5,??DataTable29_2  ;; 0xff0fffff
   \       0x2E   0x401D             ANDS     R5,R5,R3
   1675              /* Select the TRGO2 source*/
   1676              tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
   \       0x30   0x684B             LDR      R3,[R1, #+4]
   \       0x32   0x432B             ORRS     R3,R3,R5
   1677            }
   1678          
   1679            /* Reset the MMS Bits */
   1680            tmpcr2 &= ~TIM_CR2_MMS;
   \                     ??HAL_TIMEx_MasterConfigSynchronization_2: (+1)
   \       0x34   0x2570             MOVS     R5,#+112
   \       0x36   0x43AB             BICS     R3,R3,R5
   1681            /* Select the TRGO source */
   1682            tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
   \       0x38   0x680D             LDR      R5,[R1, #+0]
   \       0x3A   0x431D             ORRS     R5,R5,R3
   1683          
   1684            /* Reset the MSM Bit */
   1685            tmpsmcr &= ~TIM_SMCR_MSM;
   \       0x3C   0x2380             MOVS     R3,#+128
   \       0x3E   0x439C             BICS     R4,R4,R3
   1686            /* Set master mode */
   1687            tmpsmcr |= sMasterConfig->MasterSlaveMode;
   \       0x40   0x688B             LDR      R3,[R1, #+8]
   \       0x42   0x4323             ORRS     R3,R3,R4
   1688          
   1689            /* Update TIMx CR2 */
   1690            htim->Instance->CR2 = tmpcr2;
   \       0x44   0x6814             LDR      R4,[R2, #+0]
   \       0x46   0x6065             STR      R5,[R4, #+4]
   1691          
   1692            /* Update TIMx SMCR */
   1693            htim->Instance->SMCR = tmpsmcr;
   \       0x48   0x6814             LDR      R4,[R2, #+0]
   \       0x4A   0x60A3             STR      R3,[R4, #+8]
   1694          
   1695            /* Change the htim state */
   1696            htim->State = HAL_TIM_STATE_READY;
   \       0x4C   0x243D             MOVS     R4,#+61
   \       0x4E   0x5510             STRB     R0,[R2, R4]
   1697          
   1698            __HAL_UNLOCK(htim);
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0x243C             MOVS     R4,#+60
   \       0x54   0x5510             STRB     R0,[R2, R4]
   1699          
   1700            return HAL_OK;
   \       0x56   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_MasterConfigSynchronization_1: (+1)
   \       0x58   0xBD70             POP      {R4-R6,PC}       ;; return
   1701          }
   1702          
   1703          /**
   1704            * @brief  Configures the Break feature, dead time, Lock level, OSSI/OSSR State
   1705            *         and the AOE(automatic output enable).
   1706            * @param  htim TIM handle
   1707            * @param  sBreakDeadTimeConfig pointer to a TIM_ConfigBreakDeadConfigTypeDef structure that
   1708            *         contains the BDTR Register configuration  information for the TIM peripheral.
   1709            * @note   Interrupts can be generated when an active level is detected on the
   1710            *         break input, the break 2 input or the system break input. Break
   1711            *         interrupt can be enabled by calling the @ref __HAL_TIM_ENABLE_IT macro.
   1712            * @retval HAL status
   1713            */

   \                                 In section .text, align 2, keep-with-next
   1714          HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
   1715                                                          TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
   1716          {
   \                     HAL_TIMEx_ConfigBreakDeadTime: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0x0002             MOVS     R2,R0
   1717            /* Keep this variable initialized to 0 as it is used to configure BDTR register */
   1718            uint32_t tmpbdtr = 0U;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x0003             MOVS     R3,R0
   1719          
   1720            /* Check the parameters */
   1721            assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
   1722            assert_param(IS_TIM_OSSR_STATE(sBreakDeadTimeConfig->OffStateRunMode));
   1723            assert_param(IS_TIM_OSSI_STATE(sBreakDeadTimeConfig->OffStateIDLEMode));
   1724            assert_param(IS_TIM_LOCK_LEVEL(sBreakDeadTimeConfig->LockLevel));
   1725            assert_param(IS_TIM_DEADTIME(sBreakDeadTimeConfig->DeadTime));
   1726            assert_param(IS_TIM_BREAK_STATE(sBreakDeadTimeConfig->BreakState));
   1727            assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
   1728            assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
   1729            assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));
   1730          
   1731            /* Check input state */
   1732            __HAL_LOCK(htim);
   \        0x8   0x243C             MOVS     R4,#+60
   \        0xA   0x5D14             LDRB     R4,[R2, R4]
   \        0xC   0x2C01             CMP      R4,#+1
   \        0xE   0xD101             BNE      ??HAL_TIMEx_ConfigBreakDeadTime_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE047             B        ??HAL_TIMEx_ConfigBreakDeadTime_1
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_0: (+1)
   \       0x14   0x2401             MOVS     R4,#+1
   \       0x16   0x253C             MOVS     R5,#+60
   \       0x18   0x5554             STRB     R4,[R2, R5]
   1733          
   1734            /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
   1735               the OSSI State, the dead time value and the Automatic Output Enable Bit */
   1736          
   1737            /* Set the BDTR bits */
   1738            MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
   \       0x1A   0x24FF             MOVS     R4,#+255
   \       0x1C   0x43A3             BICS     R3,R3,R4
   \       0x1E   0x68CC             LDR      R4,[R1, #+12]
   \       0x20   0x431C             ORRS     R4,R4,R3
   1739            MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
   \       0x22   0x....             LDR      R5,??DataTable29_3  ;; 0xfffffcff
   \       0x24   0x4025             ANDS     R5,R5,R4
   \       0x26   0x688B             LDR      R3,[R1, #+8]
   \       0x28   0x432B             ORRS     R3,R3,R5
   1740            MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
   \       0x2A   0x....             LDR      R4,??DataTable29_4  ;; 0xfffffbff
   \       0x2C   0x401C             ANDS     R4,R4,R3
   \       0x2E   0x684B             LDR      R3,[R1, #+4]
   \       0x30   0x4323             ORRS     R3,R3,R4
   1741            MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
   \       0x32   0x....             LDR      R4,??DataTable29_5  ;; 0xfffff7ff
   \       0x34   0x401C             ANDS     R4,R4,R3
   \       0x36   0x680B             LDR      R3,[R1, #+0]
   \       0x38   0x4323             ORRS     R3,R3,R4
   1742            MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
   \       0x3A   0x....             LDR      R4,??DataTable29_6  ;; 0xffffefff
   \       0x3C   0x401C             ANDS     R4,R4,R3
   \       0x3E   0x690B             LDR      R3,[R1, #+16]
   \       0x40   0x4323             ORRS     R3,R3,R4
   1743            MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
   \       0x42   0x....             LDR      R4,??DataTable27  ;; 0xffffdfff
   \       0x44   0x401C             ANDS     R4,R4,R3
   \       0x46   0x694B             LDR      R3,[R1, #+20]
   \       0x48   0x4323             ORRS     R3,R3,R4
   1744            MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
   \       0x4A   0x....             LDR      R4,??DataTable29_7  ;; 0xffffbfff
   \       0x4C   0x401C             ANDS     R4,R4,R3
   \       0x4E   0x6B0B             LDR      R3,[R1, #+48]
   \       0x50   0x4323             ORRS     R3,R3,R4
   1745            MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
   \       0x52   0x....             LDR      R5,??DataTable29_8  ;; 0xfff0ffff
   \       0x54   0x401D             ANDS     R5,R5,R3
   \       0x56   0x698B             LDR      R3,[R1, #+24]
   \       0x58   0x041C             LSLS     R4,R3,#+16
   \       0x5A   0x432C             ORRS     R4,R4,R5
   1746          
   1747            if (IS_TIM_ADVANCED_INSTANCE(htim->Instance))
   \       0x5C   0x....             LDR      R3,??DataTable29_1  ;; 0x40012c00
   \       0x5E   0x6815             LDR      R5,[R2, #+0]
   \       0x60   0x429D             CMP      R5,R3
   \       0x62   0xD103             BNE      ??HAL_TIMEx_ConfigBreakDeadTime_2
   1748            {
   1749              /* Check the parameters */
   1750              assert_param(IS_TIM_BREAK_AFMODE(sBreakDeadTimeConfig->BreakAFMode));
   1751          
   1752              /* Set BREAK AF mode */
   1753              MODIFY_REG(tmpbdtr, TIM_BDTR_BKBID, sBreakDeadTimeConfig->BreakAFMode);
   \       0x64   0x....             LDR      R5,??DataTable29_9  ;; 0xefffffff
   \       0x66   0x4025             ANDS     R5,R5,R4
   \       0x68   0x69CC             LDR      R4,[R1, #+28]
   \       0x6A   0x432C             ORRS     R4,R4,R5
   1754            }
   1755          
   1756            if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_2: (+1)
   \       0x6C   0x6815             LDR      R5,[R2, #+0]
   \       0x6E   0x429D             CMP      R5,R3
   \       0x70   0xD113             BNE      ??HAL_TIMEx_ConfigBreakDeadTime_3
   1757            {
   1758              /* Check the parameters */
   1759              assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
   1760              assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
   1761              assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));
   1762          
   1763              /* Set the BREAK2 input related BDTR bits */
   1764              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
   \       0x72   0x....             LDR      R5,??DataTable29_2  ;; 0xff0fffff
   \       0x74   0x4025             ANDS     R5,R5,R4
   \       0x76   0x6A8C             LDR      R4,[R1, #+40]
   \       0x78   0x0524             LSLS     R4,R4,#+20
   \       0x7A   0x432C             ORRS     R4,R4,R5
   1765              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
   \       0x7C   0x....             LDR      R5,??DataTable29_10  ;; 0xfeffffff
   \       0x7E   0x4025             ANDS     R5,R5,R4
   \       0x80   0x6A0C             LDR      R4,[R1, #+32]
   \       0x82   0x432C             ORRS     R4,R4,R5
   1766              MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
   \       0x84   0x....             LDR      R5,??DataTable29_11  ;; 0xfdffffff
   \       0x86   0x4025             ANDS     R5,R5,R4
   \       0x88   0x6A4C             LDR      R4,[R1, #+36]
   \       0x8A   0x432C             ORRS     R4,R4,R5
   1767          
   1768              if (IS_TIM_ADVANCED_INSTANCE(htim->Instance))
   \       0x8C   0x6815             LDR      R5,[R2, #+0]
   \       0x8E   0x429D             CMP      R5,R3
   \       0x90   0xD103             BNE      ??HAL_TIMEx_ConfigBreakDeadTime_3
   1769              {
   1770                /* Check the parameters */
   1771                assert_param(IS_TIM_BREAK2_AFMODE(sBreakDeadTimeConfig->Break2AFMode));
   1772          
   1773                /* Set BREAK2 AF mode */
   1774                MODIFY_REG(tmpbdtr, TIM_BDTR_BK2BID, sBreakDeadTimeConfig->Break2AFMode);
   \       0x92   0x....             LDR      R3,??DataTable29_12  ;; 0xdfffffff
   \       0x94   0x4023             ANDS     R3,R3,R4
   \       0x96   0x6ACC             LDR      R4,[R1, #+44]
   \       0x98   0x431C             ORRS     R4,R4,R3
   1775              }
   1776            }
   1777          
   1778            /* Set TIMx_BDTR */
   1779            htim->Instance->BDTR = tmpbdtr;
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_3: (+1)
   \       0x9A   0x6813             LDR      R3,[R2, #+0]
   \       0x9C   0x645C             STR      R4,[R3, #+68]
   1780          
   1781            __HAL_UNLOCK(htim);
   \       0x9E   0x233C             MOVS     R3,#+60
   \       0xA0   0x54D0             STRB     R0,[R2, R3]
   1782          
   1783            return HAL_OK;
   \       0xA2   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigBreakDeadTime_1: (+1)
   \       0xA4   0xBD30             POP      {R4,R5,PC}       ;; return
   1784          }
   1785          
   1786          /**
   1787            * @brief  Configures the break input source.
   1788            * @param  htim TIM handle.
   1789            * @param  BreakInput Break input to configure
   1790            *          This parameter can be one of the following values:
   1791            *            @arg TIM_BREAKINPUT_BRK: Timer break input
   1792            *            @arg TIM_BREAKINPUT_BRK2: Timer break 2 input
   1793            * @param  sBreakInputConfig Break input source configuration
   1794            * @retval HAL status
   1795            */

   \                                 In section .text, align 2, keep-with-next
   1796          HAL_StatusTypeDef HAL_TIMEx_ConfigBreakInput(TIM_HandleTypeDef *htim,
   1797                                                       uint32_t BreakInput,
   1798                                                       TIMEx_BreakInputConfigTypeDef *sBreakInputConfig)
   1799          
   1800          {
   \                     HAL_TIMEx_ConfigBreakInput: (+1)
   \        0x0   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1801            uint32_t tmporx;
   1802            uint32_t bkin_enable_mask;
   1803            uint32_t bkin_polarity_mask;
   1804            uint32_t bkin_enable_bitpos;
   1805            uint32_t bkin_polarity_bitpos;
   1806          
   1807            /* Check the parameters */
   1808            assert_param(IS_TIM_BREAK_INSTANCE(htim->Instance));
   1809            assert_param(IS_TIM_BREAKINPUT(BreakInput));
   1810            assert_param(IS_TIM_BREAKINPUTSOURCE(sBreakInputConfig->Source));
   1811            assert_param(IS_TIM_BREAKINPUTSOURCE_STATE(sBreakInputConfig->Enable));
   1812            assert_param(IS_TIM_BREAKINPUTSOURCE_POLARITY(sBreakInputConfig->Polarity));
   1813          
   1814            /* Check input state */
   1815            __HAL_LOCK(htim);
   \        0x4   0x203C             MOVS     R0,#+60
   \        0x6   0x5C20             LDRB     R0,[R4, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIMEx_ConfigBreakInput_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE03B             B        ??HAL_TIMEx_ConfigBreakInput_1
   \                     ??HAL_TIMEx_ConfigBreakInput_0: (+1)
   \       0x10   0x2301             MOVS     R3,#+1
   \       0x12   0x0018             MOVS     R0,R3
   \       0x14   0x213C             MOVS     R1,#+60
   \       0x16   0x5460             STRB     R0,[R4, R1]
   1816          
   1817            switch (sBreakInputConfig->Source)
   \       0x18   0x6810             LDR      R0,[R2, #+0]
   \       0x1A   0x2801             CMP      R0,#+1
   \       0x1C   0xD104             BNE      ??HAL_TIMEx_ConfigBreakInput_2
   1818            {
   1819              case TIM_BREAKINPUTSOURCE_BKIN:
   1820              {
   1821                bkin_enable_mask = TIM1_AF1_BKINE;
   1822                bkin_enable_bitpos = TIM1_AF1_BKINE_Pos;
   \       0x1E   0x2600             MOVS     R6,#+0
   1823                bkin_polarity_mask = TIM1_AF1_BKINP;
   \       0x20   0x2580             MOVS     R5,#+128
   \       0x22   0x00AD             LSLS     R5,R5,#+2        ;; #+512
   1824                bkin_polarity_bitpos = TIM1_AF1_BKINP_Pos;
   \       0x24   0x2109             MOVS     R1,#+9
   1825                break;
   \       0x26   0xE003             B        ??HAL_TIMEx_ConfigBreakInput_3
   1826              }
   1827          #if defined(COMP1) && defined(COMP2)
   1828              case TIM_BREAKINPUTSOURCE_COMP1:
   1829              {
   1830                bkin_enable_mask = TIM1_AF1_BKCMP1E;
   1831                bkin_enable_bitpos = TIM1_AF1_BKCMP1E_Pos;
   1832                bkin_polarity_mask = TIM1_AF1_BKCMP1P;
   1833                bkin_polarity_bitpos = TIM1_AF1_BKCMP1P_Pos;
   1834                break;
   1835              }
   1836              case TIM_BREAKINPUTSOURCE_COMP2:
   1837              {
   1838                bkin_enable_mask = TIM1_AF1_BKCMP2E;
   1839                bkin_enable_bitpos = TIM1_AF1_BKCMP2E_Pos;
   1840                bkin_polarity_mask = TIM1_AF1_BKCMP2P;
   1841                bkin_polarity_bitpos = TIM1_AF1_BKCMP2P_Pos;
   1842                break;
   1843              }
   1844          #endif /* COMP1 && COMP2 */
   1845          
   1846              default:
   1847              {
   1848                bkin_enable_mask = 0U;
   \                     ??HAL_TIMEx_ConfigBreakInput_2: (+1)
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x000B             MOVS     R3,R1
   1849                bkin_polarity_mask = 0U;
   \       0x2C   0x000D             MOVS     R5,R1
   1850                bkin_enable_bitpos = 0U;
   \       0x2E   0x000E             MOVS     R6,R1
   1851                bkin_polarity_bitpos = 0U;
   1852                break;
   1853              }
   1854            }
   1855          
   1856            switch (BreakInput)
   \                     ??HAL_TIMEx_ConfigBreakInput_3: (+1)
   \       0x30   0x9801             LDR      R0,[SP, #+4]
   \       0x32   0x2801             CMP      R0,#+1
   \       0x34   0xD002             BEQ      ??HAL_TIMEx_ConfigBreakInput_4
   \       0x36   0x2802             CMP      R0,#+2
   \       0x38   0xD011             BEQ      ??HAL_TIMEx_ConfigBreakInput_5
   \       0x3A   0xE021             B        ??HAL_TIMEx_ConfigBreakInput_6
   1857            {
   1858              case TIM_BREAKINPUT_BRK:
   1859              {
   1860                /* Get the TIMx_AF1 register value */
   1861                tmporx = htim->Instance->AF1;
   \                     ??HAL_TIMEx_ConfigBreakInput_4: (+1)
   \       0x3C   0x6820             LDR      R0,[R4, #+0]
   \       0x3E   0x6E07             LDR      R7,[R0, #+96]
   1862          
   1863                /* Enable the break input */
   1864                tmporx &= ~bkin_enable_mask;
   \       0x40   0x439F             BICS     R7,R7,R3
   1865                tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
   \       0x42   0x6850             LDR      R0,[R2, #+4]
   \       0x44   0x40B0             LSLS     R0,R0,R6
   \       0x46   0x4018             ANDS     R0,R0,R3
   \       0x48   0x4338             ORRS     R0,R0,R7
   1866          
   1867                /* Set the break input polarity */
   1868                tmporx &= ~bkin_polarity_mask;
   \       0x4A   0x43A8             BICS     R0,R0,R5
   1869                tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
   \       0x4C   0x6897             LDR      R7,[R2, #+8]
   \       0x4E   0x408F             LSLS     R7,R7,R1
   \       0x50   0x402F             ANDS     R7,R7,R5
   \       0x52   0x4307             ORRS     R7,R7,R0
   \       0x54   0x9700             STR      R7,[SP, #+0]
   1870          
   1871                /* Set TIMx_AF1 */
   1872                htim->Instance->AF1 = tmporx;
   \       0x56   0x9800             LDR      R0,[SP, #+0]
   \       0x58   0x6827             LDR      R7,[R4, #+0]
   \       0x5A   0x6638             STR      R0,[R7, #+96]
   1873                break;
   \       0x5C   0xE010             B        ??HAL_TIMEx_ConfigBreakInput_7
   1874              }
   1875              case TIM_BREAKINPUT_BRK2:
   1876              {
   1877                /* Get the TIMx_AF2 register value */
   1878                tmporx = htim->Instance->AF2;
   \                     ??HAL_TIMEx_ConfigBreakInput_5: (+1)
   \       0x5E   0x6820             LDR      R0,[R4, #+0]
   \       0x60   0x6E47             LDR      R7,[R0, #+100]
   1879          
   1880                /* Enable the break input */
   1881                tmporx &= ~bkin_enable_mask;
   \       0x62   0x439F             BICS     R7,R7,R3
   1882                tmporx |= (sBreakInputConfig->Enable << bkin_enable_bitpos) & bkin_enable_mask;
   \       0x64   0x6850             LDR      R0,[R2, #+4]
   \       0x66   0x40B0             LSLS     R0,R0,R6
   \       0x68   0x4018             ANDS     R0,R0,R3
   \       0x6A   0x4338             ORRS     R0,R0,R7
   1883          
   1884                /* Set the break input polarity */
   1885                tmporx &= ~bkin_polarity_mask;
   \       0x6C   0x43A8             BICS     R0,R0,R5
   1886                tmporx |= (sBreakInputConfig->Polarity << bkin_polarity_bitpos) & bkin_polarity_mask;
   \       0x6E   0x6897             LDR      R7,[R2, #+8]
   \       0x70   0x408F             LSLS     R7,R7,R1
   \       0x72   0x402F             ANDS     R7,R7,R5
   \       0x74   0x4307             ORRS     R7,R7,R0
   \       0x76   0x9700             STR      R7,[SP, #+0]
   1887          
   1888                /* Set TIMx_AF2 */
   1889                htim->Instance->AF2 = tmporx;
   \       0x78   0x9800             LDR      R0,[SP, #+0]
   \       0x7A   0x6827             LDR      R7,[R4, #+0]
   \       0x7C   0x6678             STR      R0,[R7, #+100]
   1890                break;
   \       0x7E   0xE7FF             B        ??HAL_TIMEx_ConfigBreakInput_7
   1891              }
   1892              default:
   1893                break;
   1894            }
   1895          
   1896            __HAL_UNLOCK(htim);
   \                     ??HAL_TIMEx_ConfigBreakInput_6: (+1)
   \                     ??HAL_TIMEx_ConfigBreakInput_7: (+1)
   \       0x80   0x2000             MOVS     R0,#+0
   \       0x82   0x273C             MOVS     R7,#+60
   \       0x84   0x55E0             STRB     R0,[R4, R7]
   1897          
   1898            return HAL_OK;
   \       0x86   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ConfigBreakInput_1: (+1)
   \       0x88   0xBDF6             POP      {R1,R2,R4-R7,PC}  ;; return
   1899          }
   1900          
   1901          /**
   1902            * @brief  Configures the TIMx Remapping input capabilities.
   1903            * @param  htim TIM handle.
   1904            * @param  Remap specifies the TIM remapping source.
   1905            *         For TIM1, the parameter can take one of the following values:
   1906            *            @arg TIM_TIM1_ETR_GPIO:                TIM1 ETR is is connected to GPIO
   1907            @if STM32G081xx
   1908            *            @arg TIM_TIM1_ETR_COMP1:               TIM1 ETR is connected to COMP1 output
   1909            *            @arg TIM_TIM1_ETR_COMP2:               TIM1 ETR is connected to COMP2 output
   1910            @endif
   1911            *            @arg TIM_TIM1_ETR_ADC1_AWD1:           TIM1 ETR is connected to ADC1 AWD1
   1912            *            @arg TIM_TIM1_ETR_ADC1_AWD2:           TIM1 ETR is connected to ADC1 AWD2
   1913            *            @arg TIM_TIM1_ETR_ADC1_AWD3:           TIM1 ETR is connected to ADC1 AWD3
   1914            *
   1915            @if STM32G081xx
   1916            *         For TIM2, the parameter can take one of the following values:
   1917            *            @arg TIM_TIM2_ETR_GPIO:                TIM2_ETR is connected to GPIO
   1918            *            @arg TIM_TIM2_ETR_COMP1:               TIM2_ETR is connected to COMP1 output
   1919            *            @arg TIM_TIM2_ETR_COMP2:               TIM2_ETR is connected to COMP2 output
   1920            *            @arg TIM_TIM2_ETR_LSE:                 TIM2_ETR is connected to LSE
   1921            *
   1922            *         For TIM3, the parameter can take one of the following values:
   1923            *            @arg TIM_TIM3_ETR_GPIO                TIM3_ETR is connected to GPIO
   1924            *            @arg TIM_TIM3_ETR_COMP1               TIM3_ETR is connected to COMP1 output
   1925            *            @arg TIM_TIM3_ETR_COMP2               TIM3_ETR is connected to COMP2 output
   1926            @endif
   1927            *
   1928            * @retval HAL status
   1929            */

   \                                 In section .text, align 2, keep-with-next
   1930          HAL_StatusTypeDef HAL_TIMEx_RemapConfig(TIM_HandleTypeDef *htim, uint32_t Remap)
   1931          {
   \                     HAL_TIMEx_RemapConfig: (+1)
   \        0x0   0xB500             PUSH     {LR}
   \        0x2   0x0002             MOVS     R2,R0
   1932            /* Check parameters */
   1933            assert_param(IS_TIM_REMAP_INSTANCE(htim->Instance));
   1934            assert_param(IS_TIM_REMAP(Remap));
   1935          
   1936            __HAL_LOCK(htim);
   \        0x4   0x203C             MOVS     R0,#+60
   \        0x6   0x5C10             LDRB     R0,[R2, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIMEx_RemapConfig_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE00D             B        ??HAL_TIMEx_RemapConfig_1
   \                     ??HAL_TIMEx_RemapConfig_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x233C             MOVS     R3,#+60
   \       0x14   0x54D0             STRB     R0,[R2, R3]
   1937          
   1938            MODIFY_REG(htim->Instance->AF1, TIM1_AF1_ETRSEL_Msk, Remap);
   \       0x16   0x6810             LDR      R0,[R2, #+0]
   \       0x18   0x6E00             LDR      R0,[R0, #+96]
   \       0x1A   0x....             LDR      R3,??DataTable29_13  ;; 0xfffc3fff
   \       0x1C   0x4003             ANDS     R3,R3,R0
   \       0x1E   0x430B             ORRS     R3,R3,R1
   \       0x20   0x6810             LDR      R0,[R2, #+0]
   \       0x22   0x6603             STR      R3,[R0, #+96]
   1939          
   1940            __HAL_UNLOCK(htim);
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0x233C             MOVS     R3,#+60
   \       0x28   0x54D0             STRB     R0,[R2, R3]
   1941          
   1942            return HAL_OK;
   \       0x2A   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_RemapConfig_1: (+1)
   \       0x2C   0xBD00             POP      {PC}             ;; return
   1943          }
   1944          
   1945          /**
   1946            * @brief  Select the timer input source
   1947            * @param  htim TIM handle.
   1948            * @param  Channel specifies the TIM Channel
   1949            *          This parameter can be one of the following values:
   1950            *            @arg TIM_CHANNEL_1: TI1 input channel
   1951            *            @arg TIM_CHANNEL_2: TI2 input channel
   1952            * @param  TISelection specifies the timer input source
   1953            @if STM32G081xx
   1954            *         For TIM1 this parameter can be one of the following values:
   1955            *            @arg TIM_TIM1_TI1_GPIO:                TIM1 TI1 is connected to GPIO
   1956            *            @arg TIM_TIM1_TI1_COMP1:               TIM1 TI1 is connected to COMP1 output
   1957            *            @arg TIM_TIM1_TI2_GPIO:                TIM1 TI2 is connected to GPIO
   1958            *            @arg TIM_TIM1_TI2_COMP2:               TIM1 TI2 is connected to COMP2 output
   1959            *
   1960            *         For TIM2, the parameter is one of the following values:
   1961            *            @arg TIM_TIM2_TI1_GPIO:                TIM2 TI1 is connected to GPIO
   1962            *            @arg TIM_TIM2_TI1_COMP1:               TIM2 TI1 is connected to COMP1 output
   1963            *            @arg TIM_TIM2_TI2_GPIO:                TIM2 TI2 is connected to GPIO
   1964            *            @arg TIM_TIM2_TI2_COMP2:               TIM2 TI2 is connected to COMP2 output
   1965            *
   1966            *         For TIM3, the parameter is one of the following values:
   1967            *            @arg TIM_TIM3_TI1_GPIO:                TIM3 TI1 is connected to GPIO
   1968            *            @arg TIM_TIM3_TI1_COMP1:               TIM3 TI1 is connected to COMP1 output
   1969            *            @arg TIM_TIM3_TI2_GPIO:                TIM3 TI2 is connected to GPIO
   1970            *            @arg TIM_TIM3_TI2_COMP2:               TIM3 TI2 is connected to COMP2 output
   1971            @endif
   1972            *
   1973            *         For TIM14, the parameter is one of the following values:
   1974            *            @arg TIM_TIM14_TI1_GPIO:               TIM14 TI1 is connected to GPIO
   1975            *            @arg TIM_TIM14_TI1_RTC:                TIM14 TI1 is connected to RTC clock
   1976            *            @arg TIM_TIM14_TI1_HSE_32:             TIM14 TI1 is connected to HSE div 32
   1977            *            @arg TIM_TIM14_TI1_MCO:                TIM14 TI1 is connected to MCO
   1978            *
   1979            *         For TIM15, the parameter is one of the following values:
   1980            *            @arg TIM_TIM15_TI1_GPIO:              TIM15 TI1 is connected to GPIO
   1981            *            @arg TIM_TIM15_TI1_TIM2_CH1:           TIM15 TI1 is connected to TIM2 CH1
   1982            *            @arg TIM_TIM15_TI1_TIM3_CH1:           TIM15 TI1 is connected to TIM3 CH1
   1983            *            @arg TIM_TIM15_TI2_GPIO:               TIM15 TI2 is connected to GPIO
   1984            *            @arg TIM_TIM15_TI2_TIM2_CH2:           TIM15 TI2 is connected to TIM2 CH2
   1985            *            @arg TIM_TIM15_TI2_TIM3_CH2:           TIM15 TI2 is connected to TIM3 CH2
   1986            *
   1987            *         For TIM16, the parameter can have the following values:
   1988            *            @arg TIM_TIM16_TI1_GPIO:              TIM16 TI1 is connected to GPIO
   1989            *            @arg TIM_TIM16_TI1_LSI:               TIM16 TI1 is connected to LSI
   1990            *            @arg TIM_TIM16_TI1_LSE:               TIM16 TI1 is connected to LSE
   1991            *            @arg TIM_TIM16_TI1_RTC_WAKEUP:         TIM16 TI1 is connected to TRC wakeup interrupt
   1992            *
   1993            *         For TIM17, the parameter can have the following values:
   1994            *            @arg TIM_TIM17_TI1_GPIO:              TIM17 TI1 is connected to GPIO
   1995            *            @arg TIM_TIM17_TI1_HSE_32:            TIM17 TI1 is connected to HSE div 32
   1996            *            @arg TIM_TIM17_TI1_MCO:               TIM17 TI1 is connected to MCO
   1997            *
   1998            * @retval HAL status
   1999            */

   \                                 In section .text, align 2, keep-with-next
   2000          HAL_StatusTypeDef  HAL_TIMEx_TISelection(TIM_HandleTypeDef *htim, uint32_t TISelection, uint32_t Channel)
   2001          {
   \                     HAL_TIMEx_TISelection: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0003             MOVS     R3,R0
   2002            HAL_StatusTypeDef status = HAL_OK;
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x0004             MOVS     R4,R0
   2003          
   2004            /* Check parameters */
   2005            assert_param(IS_TIM_TISEL_INSTANCE(htim->Instance));
   2006            assert_param(IS_TIM_TISEL(TISelection));
   2007          
   2008            __HAL_LOCK(htim);
   \        0x8   0x253C             MOVS     R5,#+60
   \        0xA   0x5D5D             LDRB     R5,[R3, R5]
   \        0xC   0x2D01             CMP      R5,#+1
   \        0xE   0xD101             BNE      ??HAL_TIMEx_TISelection_0
   \       0x10   0x2002             MOVS     R0,#+2
   \       0x12   0xE01D             B        ??HAL_TIMEx_TISelection_1
   \                     ??HAL_TIMEx_TISelection_0: (+1)
   \       0x14   0x2501             MOVS     R5,#+1
   \       0x16   0x263C             MOVS     R6,#+60
   \       0x18   0x559D             STRB     R5,[R3, R6]
   2009          
   2010            switch (Channel)
   \       0x1A   0x0016             MOVS     R6,R2
   \       0x1C   0x2E00             CMP      R6,#+0
   \       0x1E   0xD002             BEQ      ??HAL_TIMEx_TISelection_2
   \       0x20   0x2E04             CMP      R6,#+4
   \       0x22   0xD008             BEQ      ??HAL_TIMEx_TISelection_3
   \       0x24   0xE00F             B        ??HAL_TIMEx_TISelection_4
   2011            {
   2012              case TIM_CHANNEL_1:
   2013                MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI1SEL, TISelection);
   \                     ??HAL_TIMEx_TISelection_2: (+1)
   \       0x26   0x681D             LDR      R5,[R3, #+0]
   \       0x28   0x6EAD             LDR      R5,[R5, #+104]
   \       0x2A   0x260F             MOVS     R6,#+15
   \       0x2C   0x43B5             BICS     R5,R5,R6
   \       0x2E   0x430D             ORRS     R5,R5,R1
   \       0x30   0x681E             LDR      R6,[R3, #+0]
   \       0x32   0x66B5             STR      R5,[R6, #+104]
   2014                break;
   \       0x34   0xE008             B        ??HAL_TIMEx_TISelection_5
   2015              case TIM_CHANNEL_2:
   2016                MODIFY_REG(htim->Instance->TISEL, TIM_TISEL_TI2SEL, TISelection);
   \                     ??HAL_TIMEx_TISelection_3: (+1)
   \       0x36   0x681D             LDR      R5,[R3, #+0]
   \       0x38   0x6EAD             LDR      R5,[R5, #+104]
   \       0x3A   0x....             LDR      R6,??DataTable29_14  ;; 0xfffff0ff
   \       0x3C   0x402E             ANDS     R6,R6,R5
   \       0x3E   0x430E             ORRS     R6,R6,R1
   \       0x40   0x681D             LDR      R5,[R3, #+0]
   \       0x42   0x66AE             STR      R6,[R5, #+104]
   2017                break;
   \       0x44   0xE000             B        ??HAL_TIMEx_TISelection_5
   2018              default:
   2019                status = HAL_ERROR;
   \                     ??HAL_TIMEx_TISelection_4: (+1)
   \       0x46   0x002C             MOVS     R4,R5
   2020                break;
   2021            }
   2022          
   2023            __HAL_UNLOCK(htim);
   \                     ??HAL_TIMEx_TISelection_5: (+1)
   \       0x48   0x253C             MOVS     R5,#+60
   \       0x4A   0x5558             STRB     R0,[R3, R5]
   2024          
   2025            return status;
   \       0x4C   0x0020             MOVS     R0,R4
   \       0x4E   0xB2C0             UXTB     R0,R0
   \                     ??HAL_TIMEx_TISelection_1: (+1)
   \       0x50   0xBD70             POP      {R4-R6,PC}       ;; return
   2026          }
   2027          
   2028          /**
   2029            * @brief  Group channel 5 and channel 1, 2 or 3
   2030            * @param  htim TIM handle.
   2031            * @param  Channels specifies the reference signal(s) the OC5REF is combined with.
   2032            *         This parameter can be any combination of the following values:
   2033            *         TIM_GROUPCH5_NONE: No effect of OC5REF on OC1REFC, OC2REFC and OC3REFC
   2034            *         TIM_GROUPCH5_OC1REFC: OC1REFC is the logical AND of OC1REFC and OC5REF
   2035            *         TIM_GROUPCH5_OC2REFC: OC2REFC is the logical AND of OC2REFC and OC5REF
   2036            *         TIM_GROUPCH5_OC3REFC: OC3REFC is the logical AND of OC3REFC and OC5REF
   2037            * @retval HAL status
   2038            */

   \                                 In section .text, align 2, keep-with-next
   2039          HAL_StatusTypeDef HAL_TIMEx_GroupChannel5(TIM_HandleTypeDef *htim, uint32_t Channels)
   2040          {
   \                     HAL_TIMEx_GroupChannel5: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0002             MOVS     R2,R0
   2041            /* Check parameters */
   2042            assert_param(IS_TIM_COMBINED3PHASEPWM_INSTANCE(htim->Instance));
   2043            assert_param(IS_TIM_GROUPCH5(Channels));
   2044          
   2045            /* Process Locked */
   2046            __HAL_LOCK(htim);
   \        0x4   0x203C             MOVS     R0,#+60
   \        0x6   0x5C10             LDRB     R0,[R2, R0]
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD101             BNE      ??HAL_TIMEx_GroupChannel5_0
   \        0xC   0x2002             MOVS     R0,#+2
   \        0xE   0xE016             B        ??HAL_TIMEx_GroupChannel5_1
   \                     ??HAL_TIMEx_GroupChannel5_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x233C             MOVS     R3,#+60
   \       0x14   0x54D0             STRB     R0,[R2, R3]
   2047          
   2048            htim->State = HAL_TIM_STATE_BUSY;
   \       0x16   0x2302             MOVS     R3,#+2
   \       0x18   0x243D             MOVS     R4,#+61
   \       0x1A   0x5513             STRB     R3,[R2, R4]
   2049          
   2050            /* Clear GC5Cx bit fields */
   2051            htim->Instance->CCR5 &= ~(TIM_CCR5_GC5C3 | TIM_CCR5_GC5C2 | TIM_CCR5_GC5C1);
   \       0x1C   0x6813             LDR      R3,[R2, #+0]
   \       0x1E   0x6D9B             LDR      R3,[R3, #+88]
   \       0x20   0x00DB             LSLS     R3,R3,#+3        ;; ZeroExtS R3,R3,#+3,#+3
   \       0x22   0x08DB             LSRS     R3,R3,#+3
   \       0x24   0x6814             LDR      R4,[R2, #+0]
   \       0x26   0x65A3             STR      R3,[R4, #+88]
   2052          
   2053            /* Set GC5Cx bit fields */
   2054            htim->Instance->CCR5 |= Channels;
   \       0x28   0x6813             LDR      R3,[R2, #+0]
   \       0x2A   0x6D9B             LDR      R3,[R3, #+88]
   \       0x2C   0x430B             ORRS     R3,R3,R1
   \       0x2E   0x6814             LDR      R4,[R2, #+0]
   \       0x30   0x65A3             STR      R3,[R4, #+88]
   2055          
   2056            /* Change the htim state */
   2057            htim->State = HAL_TIM_STATE_READY;
   \       0x32   0x233D             MOVS     R3,#+61
   \       0x34   0x54D0             STRB     R0,[R2, R3]
   2058          
   2059            __HAL_UNLOCK(htim);
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0x233C             MOVS     R3,#+60
   \       0x3A   0x54D0             STRB     R0,[R2, R3]
   2060          
   2061            return HAL_OK;
   \       0x3C   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_GroupChannel5_1: (+1)
   \       0x3E   0xBD10             POP      {R4,PC}          ;; return
   2062          }
   2063          
   2064          /**
   2065            * @brief  Disarm the designated break input (when it operates in bidirectional mode).
   2066            * @param  htim TIM handle.
   2067            * @param  BreakInput Break input to disarm
   2068            *          This parameter can be one of the following values:
   2069            *            @arg TIM_BREAKINPUT_BRK: Timer break input
   2070            *            @arg TIM_BREAKINPUT_BRK2: Timer break 2 input
   2071            * @note  The break input can be disarmed only when it is configured in
   2072            *        bidirectional mode and when when MOE is reset.
   2073            * @note  Purpose is to be able to have the input voltage back to high-state,
   2074            *        whatever the time constant on the output .
   2075            * @retval HAL status
   2076            */

   \                                 In section .text, align 2, keep-with-next
   2077          HAL_StatusTypeDef HAL_TIMEx_DisarmBreakInput(TIM_HandleTypeDef *htim, uint32_t BreakInput)
   2078          {
   \                     HAL_TIMEx_DisarmBreakInput: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0002             MOVS     R2,R0
   2079            uint32_t tmpbdtr;
   2080          
   2081            /* Check the parameters */
   2082            assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
   2083            assert_param(IS_TIM_BREAKINPUT(BreakInput));
   2084          
   2085            switch (BreakInput)
   \        0x4   0x0008             MOVS     R0,R1
   \        0x6   0x2801             CMP      R0,#+1
   \        0x8   0xD002             BEQ      ??HAL_TIMEx_DisarmBreakInput_0
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD011             BEQ      ??HAL_TIMEx_DisarmBreakInput_1
   \        0xE   0xE021             B        ??HAL_TIMEx_DisarmBreakInput_2
   2086            {
   2087              case TIM_BREAKINPUT_BRK:
   2088              {
   2089                /* Check initial conditions */
   2090                tmpbdtr = READ_REG(htim->Instance->BDTR);
   \                     ??HAL_TIMEx_DisarmBreakInput_0: (+1)
   \       0x10   0x6810             LDR      R0,[R2, #+0]
   \       0x12   0x6C40             LDR      R0,[R0, #+68]
   \       0x14   0x0003             MOVS     R3,R0
   2091                if ((READ_BIT(tmpbdtr, TIM_BDTR_BKBID) == TIM_BDTR_BKBID) &&
   2092                    (READ_BIT(tmpbdtr, TIM_BDTR_MOE) == 0U))
   \       0x16   0x....             LDR      R0,??DataTable29_15  ;; 0x10008000
   \       0x18   0x4018             ANDS     R0,R0,R3
   \       0x1A   0x2480             MOVS     R4,#+128
   \       0x1C   0x0564             LSLS     R4,R4,#+21       ;; #+268435456
   \       0x1E   0x42A0             CMP      R0,R4
   \       0x20   0xD106             BNE      ??HAL_TIMEx_DisarmBreakInput_3
   2093                {
   2094                  /* Break input BRK is disarmed */
   2095                  SET_BIT(htim->Instance->BDTR, TIM_BDTR_BKDSRM);
   \       0x22   0x6810             LDR      R0,[R2, #+0]
   \       0x24   0x6C40             LDR      R0,[R0, #+68]
   \       0x26   0x2480             MOVS     R4,#+128
   \       0x28   0x04E4             LSLS     R4,R4,#+19       ;; #+67108864
   \       0x2A   0x4304             ORRS     R4,R4,R0
   \       0x2C   0x6810             LDR      R0,[R2, #+0]
   \       0x2E   0x6444             STR      R4,[R0, #+68]
   2096                }
   2097                break;
   \                     ??HAL_TIMEx_DisarmBreakInput_3: (+1)
   \       0x30   0xE010             B        ??HAL_TIMEx_DisarmBreakInput_4
   2098              }
   2099          
   2100              case TIM_BREAKINPUT_BRK2:
   2101              {
   2102                /* Check initial conditions */
   2103                tmpbdtr = READ_REG(htim->Instance->BDTR);
   \                     ??HAL_TIMEx_DisarmBreakInput_1: (+1)
   \       0x32   0x6810             LDR      R0,[R2, #+0]
   \       0x34   0x6C40             LDR      R0,[R0, #+68]
   \       0x36   0x0003             MOVS     R3,R0
   2104                if ((READ_BIT(tmpbdtr, TIM_BDTR_BK2BID) == TIM_BDTR_BK2BID) &&
   2105                    (READ_BIT(tmpbdtr, TIM_BDTR_MOE) == 0U))
   \       0x38   0x....             LDR      R0,??DataTable29_16  ;; 0x20008000
   \       0x3A   0x4018             ANDS     R0,R0,R3
   \       0x3C   0x2480             MOVS     R4,#+128
   \       0x3E   0x05A4             LSLS     R4,R4,#+22       ;; #+536870912
   \       0x40   0x42A0             CMP      R0,R4
   \       0x42   0xD106             BNE      ??HAL_TIMEx_DisarmBreakInput_5
   2106                {
   2107                  /* Break input BRK is disarmed */
   2108                  SET_BIT(htim->Instance->BDTR, TIM_BDTR_BK2DSRM);
   \       0x44   0x6810             LDR      R0,[R2, #+0]
   \       0x46   0x6C40             LDR      R0,[R0, #+68]
   \       0x48   0x2480             MOVS     R4,#+128
   \       0x4A   0x0524             LSLS     R4,R4,#+20       ;; #+134217728
   \       0x4C   0x4304             ORRS     R4,R4,R0
   \       0x4E   0x6810             LDR      R0,[R2, #+0]
   \       0x50   0x6444             STR      R4,[R0, #+68]
   2109                }
   2110                break;
   \                     ??HAL_TIMEx_DisarmBreakInput_5: (+1)
   \       0x52   0xE7FF             B        ??HAL_TIMEx_DisarmBreakInput_4
   2111              }
   2112              default:
   2113                break;
   2114            }
   2115          
   2116            return HAL_OK;
   \                     ??HAL_TIMEx_DisarmBreakInput_2: (+1)
   \                     ??HAL_TIMEx_DisarmBreakInput_4: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0xBD10             POP      {R4,PC}          ;; return
   2117          }
   2118          
   2119          /**
   2120            * @brief  Arm the designated break input (when it operates in bidirectional mode).
   2121            * @param  htim TIM handle.
   2122            * @param  BreakInput Break input to arm
   2123            *          This parameter can be one of the following values:
   2124            *            @arg TIM_BREAKINPUT_BRK: Timer break input
   2125            *            @arg TIM_BREAKINPUT_BRK2: Timer break 2 input
   2126            * @note  Arming is possible at anytime, even if fault is present.
   2127            * @note  Break input is automatically armed as soon as MOE bit is set.
   2128            * @retval HAL status
   2129            */

   \                                 In section .text, align 2, keep-with-next
   2130          HAL_StatusTypeDef HAL_TIMEx_ReArmBreakInput(TIM_HandleTypeDef *htim, uint32_t BreakInput)
   2131          {
   \                     HAL_TIMEx_ReArmBreakInput: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x0005             MOVS     R5,R0
   \        0x4   0x000C             MOVS     R4,R1
   2132            uint32_t tickstart;
   2133          
   2134            /* Check the parameters */
   2135            assert_param(IS_TIM_ADVANCED_INSTANCE(htim->Instance));
   2136            assert_param(IS_TIM_BREAKINPUT(BreakInput));
   2137          
   2138            switch (BreakInput)
   \        0x6   0x0020             MOVS     R0,R4
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD002             BEQ      ??HAL_TIMEx_ReArmBreakInput_0
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD015             BEQ      ??HAL_TIMEx_ReArmBreakInput_1
   \       0x10   0xE029             B        ??HAL_TIMEx_ReArmBreakInput_2
   2139            {
   2140              case TIM_BREAKINPUT_BRK:
   2141              {
   2142                /* Check initial conditions */
   2143                if (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BKBID) == TIM_BDTR_BKBID)
   \                     ??HAL_TIMEx_ReArmBreakInput_0: (+1)
   \       0x12   0x6828             LDR      R0,[R5, #+0]
   \       0x14   0x6C40             LDR      R0,[R0, #+68]
   \       0x16   0x00C0             LSLS     R0,R0,#+3
   \       0x18   0xD50F             BPL      ??HAL_TIMEx_ReArmBreakInput_3
   2144                {
   2145                  /* Break input BRK is re-armed automatically by hardware. Poll to check whether fault condition disappeared */
   2146                  /* Init tickstart for timeout management */
   2147                  tickstart = HAL_GetTick();
   \       0x1A   0x....'....        BL       HAL_GetTick
   \       0x1E   0x0006             MOVS     R6,R0
   2148                  do
   2149                  {
   2150                    if (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BKDSRM) != TIM_BDTR_BKDSRM)
   \                     ??HAL_TIMEx_ReArmBreakInput_4: (+1)
   \       0x20   0x6828             LDR      R0,[R5, #+0]
   \       0x22   0x6C40             LDR      R0,[R0, #+68]
   \       0x24   0x0140             LSLS     R0,R0,#+5
   \       0x26   0xD401             BMI      ??HAL_TIMEx_ReArmBreakInput_5
   2151                    {
   2152                      return HAL_OK;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xE01D             B        ??HAL_TIMEx_ReArmBreakInput_6
   2153                    }
   2154                  } while ((HAL_GetTick() - tickstart) <= TIM_BREAKINPUT_REARM_TIMEOUT);
   \                     ??HAL_TIMEx_ReArmBreakInput_5: (+1)
   \       0x2C   0x....'....        BL       HAL_GetTick
   \       0x30   0x1B80             SUBS     R0,R0,R6
   \       0x32   0x2806             CMP      R0,#+6
   \       0x34   0xD3F4             BCC      ??HAL_TIMEx_ReArmBreakInput_4
   2155          
   2156                  return HAL_TIMEOUT;
   \       0x36   0x2003             MOVS     R0,#+3
   \       0x38   0xE016             B        ??HAL_TIMEx_ReArmBreakInput_6
   2157                }
   2158                break;
   \                     ??HAL_TIMEx_ReArmBreakInput_3: (+1)
   \       0x3A   0xE014             B        ??HAL_TIMEx_ReArmBreakInput_7
   2159              }
   2160          
   2161              case TIM_BREAKINPUT_BRK2:
   2162              {
   2163                /* Check initial conditions */
   2164                if (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BK2BID) == TIM_BDTR_BK2BID)
   \                     ??HAL_TIMEx_ReArmBreakInput_1: (+1)
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0x6C40             LDR      R0,[R0, #+68]
   \       0x40   0x0080             LSLS     R0,R0,#+2
   \       0x42   0xD50F             BPL      ??HAL_TIMEx_ReArmBreakInput_8
   2165                {
   2166                  /* Break input BRK2 is re-armed automatically by hardware. Poll to check whether fault condition disappeared */
   2167                  /* Init tickstart for timeout management */
   2168                  tickstart = HAL_GetTick();
   \       0x44   0x....'....        BL       HAL_GetTick
   \       0x48   0x0006             MOVS     R6,R0
   2169                  do
   2170                  {
   2171                    if (READ_BIT(htim->Instance->BDTR, TIM_BDTR_BK2DSRM) != TIM_BDTR_BK2DSRM)
   \                     ??HAL_TIMEx_ReArmBreakInput_9: (+1)
   \       0x4A   0x6828             LDR      R0,[R5, #+0]
   \       0x4C   0x6C40             LDR      R0,[R0, #+68]
   \       0x4E   0x0100             LSLS     R0,R0,#+4
   \       0x50   0xD401             BMI      ??HAL_TIMEx_ReArmBreakInput_10
   2172                    {
   2173                      return HAL_OK;
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xE008             B        ??HAL_TIMEx_ReArmBreakInput_6
   2174                    }
   2175                  } while ((HAL_GetTick() - tickstart) <= TIM_BREAKINPUT_REARM_TIMEOUT);
   \                     ??HAL_TIMEx_ReArmBreakInput_10: (+1)
   \       0x56   0x....'....        BL       HAL_GetTick
   \       0x5A   0x1B80             SUBS     R0,R0,R6
   \       0x5C   0x2806             CMP      R0,#+6
   \       0x5E   0xD3F4             BCC      ??HAL_TIMEx_ReArmBreakInput_9
   2176          
   2177                  return HAL_TIMEOUT;
   \       0x60   0x2003             MOVS     R0,#+3
   \       0x62   0xE001             B        ??HAL_TIMEx_ReArmBreakInput_6
   2178                }
   2179                break;
   \                     ??HAL_TIMEx_ReArmBreakInput_8: (+1)
   \       0x64   0xE7FF             B        ??HAL_TIMEx_ReArmBreakInput_7
   2180              }
   2181              default:
   2182                break;
   2183            }
   2184          
   2185            return HAL_OK;
   \                     ??HAL_TIMEx_ReArmBreakInput_2: (+1)
   \                     ??HAL_TIMEx_ReArmBreakInput_7: (+1)
   \       0x66   0x2000             MOVS     R0,#+0
   \                     ??HAL_TIMEx_ReArmBreakInput_6: (+1)
   \       0x68   0xBD70             POP      {R4-R6,PC}       ;; return
   2186          }
   2187          
   2188          /**
   2189            * @}
   2190            */
   2191          
   2192          /** @defgroup TIMEx_Exported_Functions_Group6 Extended Callbacks functions
   2193            * @brief    Extended Callbacks functions
   2194            *
   2195          @verbatim
   2196            ==============================================================================
   2197                              ##### Extended Callbacks functions #####
   2198            ==============================================================================
   2199            [..]
   2200              This section provides Extended TIM callback functions:
   2201              (+) Timer Commutation callback
   2202              (+) Timer Break callback
   2203          
   2204          @endverbatim
   2205            * @{
   2206            */
   2207          
   2208          /**
   2209            * @brief  Hall commutation changed callback in non-blocking mode
   2210            * @param  htim TIM handle
   2211            * @retval None
   2212            */

   \                                 In section .text, align 2
   2213          __weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
   2214          {
   2215            /* Prevent unused argument(s) compilation warning */
   2216            UNUSED(htim);
   2217          
   2218            /* NOTE : This function should not be modified, when the callback is needed,
   2219                      the HAL_TIMEx_CommutCallback could be implemented in the user file
   2220             */
   2221          }
   \                     HAL_TIMEx_CommutCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2222          /**
   2223            * @brief  Hall commutation changed half complete callback in non-blocking mode
   2224            * @param  htim TIM handle
   2225            * @retval None
   2226            */

   \                                 In section .text, align 2
   2227          __weak void HAL_TIMEx_CommutHalfCpltCallback(TIM_HandleTypeDef *htim)
   2228          {
   2229            /* Prevent unused argument(s) compilation warning */
   2230            UNUSED(htim);
   2231          
   2232            /* NOTE : This function should not be modified, when the callback is needed,
   2233                      the HAL_TIMEx_CommutHalfCpltCallback could be implemented in the user file
   2234             */
   2235          }
   \                     HAL_TIMEx_CommutHalfCpltCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2236          
   2237          /**
   2238            * @brief  Hall Break detection callback in non-blocking mode
   2239            * @param  htim TIM handle
   2240            * @retval None
   2241            */

   \                                 In section .text, align 2
   2242          __weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
   2243          {
   2244            /* Prevent unused argument(s) compilation warning */
   2245            UNUSED(htim);
   2246          
   2247            /* NOTE : This function should not be modified, when the callback is needed,
   2248                      the HAL_TIMEx_BreakCallback could be implemented in the user file
   2249             */
   2250          }
   \                     HAL_TIMEx_BreakCallback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2251          
   2252          /**
   2253            * @brief  Hall Break2 detection callback in non blocking mode
   2254            * @param  htim: TIM handle
   2255            * @retval None
   2256            */

   \                                 In section .text, align 2
   2257          __weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
   2258          {
   2259            /* Prevent unused argument(s) compilation warning */
   2260            UNUSED(htim);
   2261          
   2262            /* NOTE : This function Should not be modified, when the callback is needed,
   2263                      the HAL_TIMEx_Break2Callback could be implemented in the user file
   2264             */
   2265          }
   \                     HAL_TIMEx_Break2Callback: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2266          /**
   2267            * @}
   2268            */
   2269          
   2270          /** @defgroup TIMEx_Exported_Functions_Group7 Extended Peripheral State functions
   2271            * @brief    Extended Peripheral State functions
   2272            *
   2273          @verbatim
   2274            ==============================================================================
   2275                          ##### Extended Peripheral State functions #####
   2276            ==============================================================================
   2277            [..]
   2278              This subsection permits to get in run-time the status of the peripheral
   2279              and the data flow.
   2280          
   2281          @endverbatim
   2282            * @{
   2283            */
   2284          
   2285          /**
   2286            * @brief  Return the TIM Hall Sensor interface handle state.
   2287            * @param  htim TIM Hall Sensor handle
   2288            * @retval HAL state
   2289            */

   \                                 In section .text, align 2, keep-with-next
   2290          HAL_TIM_StateTypeDef HAL_TIMEx_HallSensor_GetState(TIM_HandleTypeDef *htim)
   2291          {
   2292            return htim->State;
   \                     HAL_TIMEx_HallSensor_GetState: (+1)
   \        0x0   0x213D             MOVS     R1,#+61
   \        0x2   0x5C40             LDRB     R0,[R0, R1]
   \        0x4   0x4770             BX       LR               ;; return
   2293          }
   2294          
   2295          /**
   2296            * @}
   2297            */
   2298          
   2299          /**
   2300            * @}
   2301            */
   2302          
   2303          /* Private functions ---------------------------------------------------------*/
   2304          /** @defgroup TIMEx_Private_Functions TIMEx Private Functions
   2305            * @{
   2306            */
   2307          
   2308          /**
   2309            * @brief  TIM DMA Commutation callback.
   2310            * @param  hdma pointer to DMA handle.
   2311            * @retval None
   2312            */

   \                                 In section .text, align 2, keep-with-next
   2313          void TIMEx_DMACommutationCplt(DMA_HandleTypeDef *hdma)
   2314          {
   \                     TIMEx_DMACommutationCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2315            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6AA5             LDR      R5,[R4, #+40]
   2316          
   2317            /* Change the htim state */
   2318            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x213D             MOVS     R1,#+61
   \        0xA   0x5468             STRB     R0,[R5, R1]
   2319          
   2320          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2321            htim->CommutationCallback(htim);
   2322          #else
   2323            HAL_TIMEx_CommutCallback(htim);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x....'....        BL       HAL_TIMEx_CommutCallback
   2324          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2325          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2326          
   2327          /**
   2328            * @brief  TIM DMA Commutation half complete callback.
   2329            * @param  hdma pointer to DMA handle.
   2330            * @retval None
   2331            */

   \                                 In section .text, align 2, keep-with-next
   2332          void TIMEx_DMACommutationHalfCplt(DMA_HandleTypeDef *hdma)
   2333          {
   \                     TIMEx_DMACommutationHalfCplt: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2334            TIM_HandleTypeDef *htim = (TIM_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
   \        0x4   0x6AA5             LDR      R5,[R4, #+40]
   2335          
   2336            /* Change the htim state */
   2337            htim->State = HAL_TIM_STATE_READY;
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x213D             MOVS     R1,#+61
   \        0xA   0x5468             STRB     R0,[R5, R1]
   2338          
   2339          #if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
   2340            htim->CommutationHalfCpltCallback(htim);
   2341          #else
   2342            HAL_TIMEx_CommutHalfCpltCallback(htim);
   \        0xC   0x0028             MOVS     R0,R5
   \        0xE   0x....'....        BL       HAL_TIMEx_CommutHalfCpltCallback
   2343          #endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
   2344          }
   \       0x12   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2345          
   2346          
   2347          /**
   2348            * @brief  Enables or disables the TIM Capture Compare Channel xN.
   2349            * @param  TIMx to select the TIM peripheral
   2350            * @param  Channel specifies the TIM Channel
   2351            *          This parameter can be one of the following values:
   2352            *            @arg TIM_CHANNEL_1: TIM Channel 1
   2353            *            @arg TIM_CHANNEL_2: TIM Channel 2
   2354            *            @arg TIM_CHANNEL_3: TIM Channel 3
   2355            * @param  ChannelNState specifies the TIM Channel CCxNE bit new state.
   2356            *          This parameter can be: TIM_CCxN_ENABLE or TIM_CCxN_Disable.
   2357            * @retval None
   2358            */

   \                                 In section .text, align 2, keep-with-next
   2359          static void TIM_CCxNChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelNState)
   2360          {
   \                     TIM_CCxNChannelCmd: (+1)
   \        0x0   0xB470             PUSH     {R4-R6}
   2361            uint32_t tmp;
   2362          
   2363            tmp = TIM_CCER_CC1NE << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
   \        0x2   0x231F             MOVS     R3,#+31
   \        0x4   0x2404             MOVS     R4,#+4
   \        0x6   0x000D             MOVS     R5,R1
   \        0x8   0x401D             ANDS     R5,R5,R3
   \        0xA   0x40AC             LSLS     R4,R4,R5
   2364          
   2365            /* Reset the CCxNE Bit */
   2366            TIMx->CCER &=  ~tmp;
   \        0xC   0x6A05             LDR      R5,[R0, #+32]
   \        0xE   0x43A5             BICS     R5,R5,R4
   \       0x10   0x6205             STR      R5,[R0, #+32]
   2367          
   2368            /* Set or reset the CCxNE Bit */
   2369            TIMx->CCER |= (uint32_t)(ChannelNState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
   \       0x12   0x6A05             LDR      R5,[R0, #+32]
   \       0x14   0x000E             MOVS     R6,R1
   \       0x16   0x4033             ANDS     R3,R3,R6
   \       0x18   0x0016             MOVS     R6,R2
   \       0x1A   0x409E             LSLS     R6,R6,R3
   \       0x1C   0x432E             ORRS     R6,R6,R5
   \       0x1E   0x6206             STR      R6,[R0, #+32]
   2370          }
   \       0x20   0xBC70             POP      {R4-R6}
   \       0x22   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \        0x0   0xFFCF'FF8F        DC32     0xffcfff8f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \        0x0   0xFFFE'FFF8        DC32     0xfffefff8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x0001'0007        DC32     0x10007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \        0x0   0x....'....        DC32     TIM_DMACaptureCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \        0x0   0x....'....        DC32     TIM_DMACaptureHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0xFFFF'7FFF        DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x0001'0007        DC32     0x10007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \        0x0   0xFFFF'F7FF        DC32     0xfffff7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \        0x0   0xFFFF'7FFF        DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \        0x0   0x....'....        DC32     TIM_DMADelayPulseHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \        0x0   0x0001'0007        DC32     0x10007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \        0x0   0xFFFF'FDFF        DC32     0xfffffdff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_2:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_3:
   \        0x0   0xFFFF'F7FF        DC32     0xfffff7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_4:
   \        0x0   0x0000'1111        DC32     0x1111

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_5:
   \        0x0   0xFFFF'7FFF        DC32     0xffff7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x0000'0444        DC32     0x444

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \        0x0   0xFFCF'FF8F        DC32     0xffcfff8f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0xFFFF'DFFF        DC32     0xffffdfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28:
   \        0x0   0x....'....        DC32     TIMEx_DMACommutationCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable28_1:
   \        0x0   0x....'....        DC32     TIMEx_DMACommutationHalfCplt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \        0x0   0x....'....        DC32     TIM_DMAError

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \        0x0   0x4001'2C00        DC32     0x40012c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_2:
   \        0x0   0xFF0F'FFFF        DC32     0xff0fffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_3:
   \        0x0   0xFFFF'FCFF        DC32     0xfffffcff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_4:
   \        0x0   0xFFFF'FBFF        DC32     0xfffffbff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_5:
   \        0x0   0xFFFF'F7FF        DC32     0xfffff7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_6:
   \        0x0   0xFFFF'EFFF        DC32     0xffffefff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_7:
   \        0x0   0xFFFF'BFFF        DC32     0xffffbfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_8:
   \        0x0   0xFFF0'FFFF        DC32     0xfff0ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_9:
   \        0x0   0xEFFF'FFFF        DC32     0xefffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_10:
   \        0x0   0xFEFF'FFFF        DC32     0xfeffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_11:
   \        0x0   0xFDFF'FFFF        DC32     0xfdffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_12:
   \        0x0   0xDFFF'FFFF        DC32     0xdfffffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_13:
   \        0x0   0xFFFC'3FFF        DC32     0xfffc3fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_14:
   \        0x0   0xFFFF'F0FF        DC32     0xfffff0ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_15:
   \        0x0   0x1000'8000        DC32     0x10008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_16:
   \        0x0   0x2000'8000        DC32     0x20008000
   2371          /**
   2372            * @}
   2373            */
   2374          
   2375          #endif /* HAL_TIM_MODULE_ENABLED */
   2376          /**
   2377            * @}
   2378            */
   2379          
   2380          /**
   2381            * @}
   2382            */
   2383          
   2384          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   HAL_TIMEx_Break2Callback
       0   HAL_TIMEx_BreakCallback
       0   HAL_TIMEx_CommutCallback
       0   HAL_TIMEx_CommutHalfCpltCallback
      12   HAL_TIMEx_ConfigBreakDeadTime
      28   HAL_TIMEx_ConfigBreakInput
      12   HAL_TIMEx_ConfigCommutEvent
      12   HAL_TIMEx_ConfigCommutEvent_DMA
      12   HAL_TIMEx_ConfigCommutEvent_IT
       8   HAL_TIMEx_DisarmBreakInput
       8   HAL_TIMEx_GroupChannel5
       8   HAL_TIMEx_HallSensor_DeInit
         8   -> HAL_TIMEx_HallSensor_MspDeInit
       0   HAL_TIMEx_HallSensor_GetState
      40   HAL_TIMEx_HallSensor_Init
        40   -> HAL_TIMEx_HallSensor_MspInit
        40   -> TIM_Base_SetConfig
        40   -> TIM_OC2_SetConfig
        40   -> TIM_TI1_SetConfig
       0   HAL_TIMEx_HallSensor_MspDeInit
       0   HAL_TIMEx_HallSensor_MspInit
       8   HAL_TIMEx_HallSensor_Start
         8   -> TIM_CCxChannelCmd
      16   HAL_TIMEx_HallSensor_Start_DMA
        16   -> HAL_DMA_Start_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Start_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Stop
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Stop_DMA
         8   -> HAL_DMA_Abort_IT
         8   -> TIM_CCxChannelCmd
       8   HAL_TIMEx_HallSensor_Stop_IT
         8   -> TIM_CCxChannelCmd
      16   HAL_TIMEx_MasterConfigSynchronization
      16   HAL_TIMEx_OCN_Start
        16   -> TIM_CCxNChannelCmd
      24   HAL_TIMEx_OCN_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Start_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Stop
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OCN_Stop_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OnePulseN_Start
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OnePulseN_Start_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OnePulseN_Stop
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_OnePulseN_Stop_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Start
        16   -> TIM_CCxNChannelCmd
      24   HAL_TIMEx_PWMN_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Start_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Stop
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Stop_DMA
        16   -> HAL_DMA_Abort_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_PWMN_Stop_IT
        16   -> TIM_CCxNChannelCmd
      16   HAL_TIMEx_ReArmBreakInput
        16   -> HAL_GetTick
       4   HAL_TIMEx_RemapConfig
      16   HAL_TIMEx_TISelection
      16   TIMEx_DMACommutationCplt
        16   -> HAL_TIMEx_CommutCallback
      16   TIMEx_DMACommutationHalfCplt
        16   -> HAL_TIMEx_CommutHalfCpltCallback
      12   TIM_CCxNChannelCmd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable12
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable23_2
       4  ??DataTable23_3
       4  ??DataTable23_4
       4  ??DataTable23_5
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable27
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_10
       4  ??DataTable29_11
       4  ??DataTable29_12
       4  ??DataTable29_13
       4  ??DataTable29_14
       4  ??DataTable29_15
       4  ??DataTable29_16
       4  ??DataTable29_2
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable29_5
       4  ??DataTable29_6
       4  ??DataTable29_7
       4  ??DataTable29_8
       4  ??DataTable29_9
       4  ??DataTable8
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       2  HAL_TIMEx_Break2Callback
       2  HAL_TIMEx_BreakCallback
       2  HAL_TIMEx_CommutCallback
       2  HAL_TIMEx_CommutHalfCpltCallback
     166  HAL_TIMEx_ConfigBreakDeadTime
     138  HAL_TIMEx_ConfigBreakInput
     128  HAL_TIMEx_ConfigCommutEvent
     148  HAL_TIMEx_ConfigCommutEvent_DMA
     128  HAL_TIMEx_ConfigCommutEvent_IT
      88  HAL_TIMEx_DisarmBreakInput
      64  HAL_TIMEx_GroupChannel5
      68  HAL_TIMEx_HallSensor_DeInit
       6  HAL_TIMEx_HallSensor_GetState
     210  HAL_TIMEx_HallSensor_Init
       2  HAL_TIMEx_HallSensor_MspDeInit
       2  HAL_TIMEx_HallSensor_MspInit
      50  HAL_TIMEx_HallSensor_Start
     154  HAL_TIMEx_HallSensor_Start_DMA
      62  HAL_TIMEx_HallSensor_Start_IT
      54  HAL_TIMEx_HallSensor_Stop
      72  HAL_TIMEx_HallSensor_Stop_DMA
      66  HAL_TIMEx_HallSensor_Stop_IT
      90  HAL_TIMEx_MasterConfigSynchronization
      66  HAL_TIMEx_OCN_Start
     308  HAL_TIMEx_OCN_Start_DMA
     136  HAL_TIMEx_OCN_Start_IT
      90  HAL_TIMEx_OCN_Stop
     172  HAL_TIMEx_OCN_Stop_DMA
     166  HAL_TIMEx_OCN_Stop_IT
      34  HAL_TIMEx_OnePulseN_Start
      58  HAL_TIMEx_OnePulseN_Start_IT
      90  HAL_TIMEx_OnePulseN_Stop
     114  HAL_TIMEx_OnePulseN_Stop_IT
      66  HAL_TIMEx_PWMN_Start
     308  HAL_TIMEx_PWMN_Start_DMA
     136  HAL_TIMEx_PWMN_Start_IT
      90  HAL_TIMEx_PWMN_Stop
     172  HAL_TIMEx_PWMN_Stop_DMA
     166  HAL_TIMEx_PWMN_Stop_IT
     106  HAL_TIMEx_ReArmBreakInput
      46  HAL_TIMEx_RemapConfig
      82  HAL_TIMEx_TISelection
      20  TIMEx_DMACommutationCplt
      20  TIMEx_DMACommutationHalfCplt
      36  TIM_CCxNChannelCmd

 
 4'402 bytes in section .text
 
 4'390 bytes of CODE memory (+ 12 bytes shared)

Errors: none
Warnings: none
